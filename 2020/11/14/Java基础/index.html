<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java基础 | Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于Java基础的一些">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://uesugier11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="关于Java基础的一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102143158061.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102145313437.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102153230843.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/1120165-20180302000448613-26394231.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031214714163.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027170918891.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031222727192.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101150109332.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105211819347.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105214703569.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105222844568.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105150937346.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151251990.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151452888.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151542928.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105153014063.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161526292.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161638781.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105162758160.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105165540835.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201118205003686.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105203849181.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201108163232784.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111131452144.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111133808047.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110220112099.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114225245322.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115160241312.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115161708654.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213911162">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213938736">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-768017317b5fab78.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-7077bdb169d4d1c3.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210518221631629.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-835b66d960e21e2e.png">
<meta property="article:published_time" content="2020-11-14T14:39:15.799Z">
<meta property="article:modified_time" content="2021-06-09T10:02:49.483Z">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102143158061.png">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-11-14T14:39:15.799Z" itemprop="datePublished">2020-11-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h1><ul>
<li><p><mark>JDK</mark></p>
<p>Java Development Kit 用作开发, 包含了JRE, 编译器和其他的工具(比如: JavaDoc，Java调试器), 可以让开发者开发、编译、执行Java应用程序.</p>
</li>
<li><p><mark>JRE</mark></p>
<p>Java 运行时环境是将要执行 Java 程序的 Java 虚拟机, （运行Java程序的用户使用的软件）可以想象成它是一个容器, JVM 是它的内容.</p>
<p>JRE = JVM + Java Packages Classes(like util, math, lang, awt,swing etc)+runtime libraries.</p>
</li>
<li><p><mark>JVM</mark></p>
<p>Java virtual machine (Java 虚拟机) 是一个可以执行 Java 编译产生的 Java class 文件 (bytecode) 的虚拟机进程, 是一个纯的运行环境.</p>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象-与-面向过程的区别"><a href="#面向对象-与-面向过程的区别" class="headerlink" title="面向对象 与 面向过程的区别"></a>面向对象 与 面向过程的区别</h2><ul>
<li><p>面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
</li>
<li><p>面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
</li>
</ul>
<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul>
<li><p><mark>封装</mark>:一个对象他所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作,封装就是把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法</p>
</li>
<li><p><mark>继承</mark>:继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使得新类能够适应新的情况。</p>
</li>
<li><p><mark>多态</mark>:多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<p>编译时多态:方法<strong>重载</strong>实现</p>
<p>运行时多态:方法<strong>重写</strong>实现</p>
</li>
<li><p><mark>抽象</mark>:声明方法的存在而不去实现它的类被叫做抽象类</p>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>由于我们程序设计追求”高内聚，低耦合”；</p>
<p>其中<strong>高内聚</strong>指的是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用；</p>
<p>而封装，就是对数据的隐藏</p>
<p>其实在后期开发中不难发现，封装往往就是体现在定义一个pojo类，其中的属性私有，设置相应的getter/setter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些public的 get set方法</span></span><br><span class="line">    <span class="comment">//get → 获得数据</span></span><br><span class="line">    <span class="comment">//set → 给数据设置值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.提高了程序安全性，保护数据</span></span><br><span class="line"><span class="comment">    2.隐藏代码的实现细节</span></span><br><span class="line"><span class="comment">    3.统一了接口</span></span><br><span class="line"><span class="comment">    4.系统可维护性增加了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>继承的本质是对某一批类的<strong>抽象</strong>，从而实现对现实世界更好的建模</li>
<li>extends 关键字是 扩展的意思，也就是子类是父类的扩展</li>
<li>Java中类只有单继承，没有多继承，因此必须慎重考虑继承的类；比如在后期我们实现多线程可以有继承和实现接口的方法，通常使用实现接口去实现，而不选择用继承；</li>
<li>继承是<strong>类与类</strong>的一种关系，除此之外，类与类之间关系还有==依赖、组合、聚合==等</li>
<li>“is - a”关系是继承的一个明显特征</li>
<li>Java中，所有的类，都默认直接或者间接继承Object类</li>
</ul>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102143158061.png" alt="image-20201102143158061"></p>
<ul>
<li>私有的东西是无法被子类继承的</li>
</ul>
<p>super需要注意的点：</p>
<ol>
<li><p>super调用父类的构造方法，必须在构造方法的第一行</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102145313437.png" alt="image-20201102145313437"></p>
</li>
<li><p>super必须只能出现在子类的<strong>方法 或 构造方法</strong>中，意思就是 如果直接在子类中直接写个super 什么用都没 会报错</p>
</li>
<li><p>super 和 this 不能同时调用构造方法</p>
</li>
</ol>
<p>super 和 this区别：</p>
<ol>
<li>代表的对象不同<ol>
<li>this：代表本身调用者这个对象</li>
<li>super：代表父类对象的引用</li>
</ol>
</li>
<li>使用的前提不同<ol>
<li>this：就算不用继承也能使用</li>
<li>super：只能在继承条件下才能使用</li>
</ol>
</li>
<li>调用构造方法不同<ol>
<li>this：调用本类的构造方法</li>
<li>super：调用父类的构造</li>
</ol>
</li>
</ol>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>重写与重载是不同的；</p>
<p><strong>重写</strong>（Override）是<strong>父类与子类之间的多态性</strong>，实质是对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，<strong>不过子类函数的访问修饰权限不能小于父类的</strong>；若子类中的方法与父类中的某一方法具有<strong>相同的方法名、返回类型和参数表</strong>，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用==<strong>super</strong>==关键字。</p>
<p><strong>重载</strong>（Overload）是让类以<strong>统一的方式</strong>处理<strong>不同类型数据</strong>的一种手段，实质表现就是多个<strong>具有不同的参数个数或者类型</strong>的<code>同名函数</code>（返回值类型可随意，<strong>不能以返回类型作为重载函数的区分标准</strong>）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时<code>通过传递不同参数个数和参数类型</code>来决定具体使用哪个方法的多态性）。</p>
<p>重写需要满足的条件</p>
<ol>
<li><p>需要是继承的关系，没有继承根本没有重写一说</p>
</li>
<li><p>方法名字必须<strong>相同</strong></p>
</li>
<li><p>参数列表必须<strong>相同</strong></p>
</li>
<li><p>子类返回值必须 <strong>小于等于</strong> 父类方法返回值</p>
</li>
<li><p>子类的权限修饰符必须 <strong>大宇等于</strong> 父类方法的权限修饰符</p>
<p>其中:<strong>public &gt; protected &gt; default(也就是什么都不写) &gt; private</strong></p>
</li>
<li><p>抛出的异常 只能被缩小，不能被扩大</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>多态：即同一方法可以根据发送对象的不同而采用多种<strong>不同的</strong>行为方式</p>
</li>
<li><p>一个对象的实际类型其实是确定的，但是<strong>指向对象的引用类型</strong>有很多（仔仔细细理解这句话的意思）</p>
<p>其实这句话是什么意思呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//这个叫对象的实际类型，根据new xxx来的 new出来是什么就其实确定了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a</span><br><span class="line">B a</span><br><span class="line"><span class="comment">//这个叫指向对象的引用类型 它就不是一定的了 可以实现父类的引用 指向 子类的类型</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>关于多态 经常听到这么一句话:</p>
<p>==成员变量、静态方法==：编译和运行看<strong>左边</strong>；==非静态方法==：编译看<strong>左边</strong>、运行看<strong>右边</strong>；</p>
<p>那到底是什么意思呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行B的非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行B的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A的非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意 这里没有用@Override 因为根本就不是重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.sTest();</span><br><span class="line">        a.test();</span><br><span class="line">        System.out.println(a.n);</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.sTest();</span><br><span class="line">        b.test();</span><br><span class="line">        System.out.println(b.n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102153230843.png" alt="image-20201102153230843"></p>
<p>不难发现：如果是==static==修饰的方法以及成员对象，我们看对象左边的类型就好，和右边没什么关系；</p>
<p>而不用==static==修饰的方法，我们就看右边的类型就行，和左边没什么关系</p>
<p>我们学习<strong>不能知其然而不知其所以然</strong>，我们来探究下为什么会这样呢？</p>
<p><code>B b = new A();</code>这行代码到底代表着什么呢?</p>
<ul>
<li><p>B b;这里声明了一个变量b 是属于B这个类的</p>
</li>
<li><p>= new A(); 建立了一个A的对象，赋值给了b 那这又代表什么呢？</p>
<p>我们现在获得了一个被A类函数<strong>覆盖后的B类对象b</strong></p>
</li>
</ul>
<p>那么问题转移了，我们只需要明白类所拥有的函数和变量到底是怎么加载的就好，就能明白为什么运行出来是这个结果了。</p>
<p>由于我们只是被覆盖了方法（非静态），成员变量还是那个成员变量，因此输出出来是各自的成员变量</p>
<p>那么静态方法呢？为什么还是各自的，没有被覆盖掉呢？</p>
<p>因为==static==修饰的函数，跟随B类的加载而加载，也就是B类的函数先于对象建立之前就存在，无法再被覆盖了。</p>
<p>还有哪些关键词修饰的方法是不能被覆盖的呢？</p>
<ol>
<li>static</li>
<li>final</li>
<li>private</li>
</ol>
<h4 id="instanceof-和-类型转换"><a href="#instanceof-和-类型转换" class="headerlink" title="instanceof 和 类型转换"></a>instanceof 和 类型转换</h4><ul>
<li><strong>instanceof是一个二元运算符 类似于 == &gt; &lt;等操作符，也是Java的一个关键字</strong></li>
<li>其作用是测试它左边的<strong>对象</strong>是否是其右边的<strong>类的实例</strong>，然后返回boolean的数据类型（true of false）</li>
</ul>
<ol>
<li><p>==obj必须为引用类型，不能是基本类型==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为null==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>关于 null 类型的描述在官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1</a> 有一些介绍。</p>
<p>一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte short int long float double char boolean,一种是引用类型，包括类，接口，数组等等。</p>
<p>而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。</p>
<p>我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的<strong>特殊符号</strong>。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2">JavaSE规范</a> 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</p>
</li>
<li><p>==obj 为 class 类的实例对象==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为class接口的实现类==</p>
<p>了解Java 集合的，我们知道集合中有个上层接口 List，其有个典型实现类 ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>或者反过来也是返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为class的直接或间接子类==</p>
<p>我们新建一个父类 Person.class，然后在创建它的一个子类 Man.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　Man.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Man m1 = <span class="keyword">new</span> Man();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);<span class="comment">//false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>　　注意第一种情况， <strong>p1 instanceof Man</strong> ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。</p>
</li>
<li><p>==问题==</p>
<p>前面我们说过<strong>编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</strong></p>
<p>看如下几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> String);<span class="comment">//编译报错</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List);<span class="comment">//false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;?&gt;);<span class="comment">//false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;Person&gt;);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<p>按照我们上面的说法，这里就存在问题了，Person 的对象 p1 很明显不能转换为 String 对象，那么自然 Person 的对象 p1 instanceof String 不能通过编译，但为什么 p1 instanceof List 却能通过编译呢？而 instanceof List<Person> 又不能通过编译了？</Person></p>
<p>根据 java SE 8：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1120165-20180302000448613-26394231.png" alt="img"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">  result = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      T temp = (T) obj; <span class="comment">// checkcast</span></span><br><span class="line">      result = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">      result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说有表达式 obj instanceof T，instanceof 运算符的 obj 操作数的类型必须是引用类型或空类型; 否则，会发生编译时错误。 </p>
<p>如果 obj 强制转换为 T 时发生编译错误，则关系表达式的 instanceof 同样会产生编译时错误。 在这种情况下，表达式实例的结果永远为false。</p>
<p>在运行时，如果 T 的值不为null，并且 obj 可以转换为 T 而不引发ClassCastException，则instanceof运算符的结果为true。 否则结果是错误的</p>
<p>简单来说就是：<strong>如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。</strong></p>
<p>所以对于上面提出的问题就很好理解了，为什么 p1 instanceof String 编译报错，因为(String)p1 是不能通过编译的，而 (List)p1 可以通过编译。</p>
</li>
</ol>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul>
<li><strong>abstract修饰符</strong>可以用来修饰方法，也可以修饰类，如果修饰方法。</li>
</ul>
<h2 id="七种设计原则"><a href="#七种设计原则" class="headerlink" title="七种设计原则"></a>七种设计原则</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031214714163.png" alt="image-20201031214714163"></p>
<p><strong>面向对象七大设计原则：</strong></p>
<p>1、 ==开闭原则（OCP：Open Closed Principle）==</p>
<p><strong>核心：对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</strong></p>
<ul>
<li>根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</li>
</ul>
<p>2、 ==里氏替换原则（LSP：Liskov Substitution Principle）==</p>
<p><strong>核心：在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）</strong></p>
<ul>
<li>1.子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</li>
<li>2.子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性</li>
<li>3.覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li>
<li>4.覆盖或实现父类的方法时输出结果可以被缩小。</li>
</ul>
<p>3、 ==单一职责原则（SRP：Single responsibility principle）==</p>
<p><strong>核心：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=解耦&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">解耦</a>和增强内聚性（高内聚，低耦合）</strong></p>
<ul>
<li>类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。</li>
</ul>
<p>4、==接口隔离原则(ISP：Interface Segregation Principle)==</p>
<p><strong>核心思想：不应该强迫客户程序依赖他们不需要使用的方法。接口分离原则的意思就是：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.</strong></p>
<ul>
<li>分离接口的两种实现方法：</li>
<li>1.使用委托分离接口。（Separation through Delegation）</li>
<li>2.使用多重继承分离接口。（Separation through Multiple Inheritance）</li>
</ul>
<p>5、==依赖倒置原则(DIP：Dependence Inversion Principle)==</p>
<p><strong>核心：要依赖于抽象，不要依赖于具体的实现</strong></p>
<ul>
<li>1.高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）</li>
<li>2.抽象不应该依赖细节（具体实现）</li>
<li>3.细节（具体实现）应该依赖抽象。<br><strong>三种实现方式:</strong></li>
<li>1.通过构造函数传递依赖对象</li>
<li>2.通过setter方法传递依赖对象</li>
<li>3.接口声明实现依赖对象</li>
</ul>
<p>6、 ==迪米特原则(最少知识原则)（LOD：Law of Demeter）==</p>
<p><strong>核心思想：一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=成都&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成都</a>降到最低，促进软件的复用</strong><br>注：</p>
<ul>
<li>1.在类的划分上，应该创建有弱耦合的类；</li>
<li>2.在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</li>
<li>3.在类的设计上，只要有可能，一个类应当设计成不变；</li>
<li>4.在对其他类的引用上，一个对象对其它对象的引用应当降到最低；</li>
<li>5.尽量降低类的访问权限；</li>
<li>6.谨慎使用序列化功能；</li>
<li>7.不要暴露类成员，而应该提供相应的访问器(属性)</li>
</ul>
<p>7、 ==组合/聚合复用原则（CRP：Composite Reuse Principle）==</p>
<p><strong>核心思想：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</strong></p>
<p>复用的种类：</p>
<ul>
<li>1.继承</li>
<li>2.合成聚合</li>
</ul>
<p><strong>注：在复用时应优先考虑使用合成聚合而不是继承</strong></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="四大数据类型"><a href="#四大数据类型" class="headerlink" title="四大数据类型"></a>四大数据类型</h2><ul>
<li><p>Java是一种强类型的语言，意味着必须给每一个变量声名一种类型</p>
</li>
<li><p>Java中一共有着八种<mark>基本类型</mark></p>
<p>包含着 4种整型（<mark>int short long byte</mark>）</p>
<p>两种浮点型（<mark>float double</mark>）</p>
<p>一种字符类型（<mark>char</mark>）</p>
<p>一种表示真值的<mark>boolean</mark>类型</p>
</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>byte(位)</td>
<td>8</td>
<td>Byte</td>
<td>0</td>
<td>-128~127</td>
<td>1字节</td>
</tr>
<tr>
<td>2</td>
<td>short(短整数)</td>
<td>16</td>
<td>Short</td>
<td>0</td>
<td>-32768~32767</td>
<td>2字节</td>
</tr>
<tr>
<td>3</td>
<td>int(整数)</td>
<td>32</td>
<td>Integer</td>
<td>0</td>
<td>-2147483648~2147483647</td>
<td>4字节</td>
</tr>
<tr>
<td>4</td>
<td>long(长整数)</td>
<td>64</td>
<td>Long</td>
<td>0</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>8字节</td>
</tr>
</tbody></table>
<ol>
<li><p><mark><strong>int与Integer的区别</strong></mark></p>
<p>Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象</p>
</li>
<li><p><mark><strong>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</strong></mark></p>
<p>对于<strong>short s1 = 1; s1 = s1 + 1;</strong>由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。</p>
<p>而<strong>short s1 = 1; s1 += 1;</strong>可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
</li>
<li></li>
</ol>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>float(单精度)</td>
<td>32</td>
<td>Float</td>
<td>0.0</td>
<td>1.4E-45~3.4028235E38</td>
<td>4字节</td>
</tr>
<tr>
<td>6</td>
<td>double(双精度)</td>
<td>64</td>
<td>Double</td>
<td>0.0</td>
<td>4.9E-324~1.7976931348623157E308</td>
<td>8字节</td>
</tr>
</tbody></table>
<ul>
<li><p>double表示这种类型的数值精度是float类型的两倍</p>
</li>
<li><p>float类型的数值有一个后缀（F或者f）没有后缀F的浮点数值（3.14）总是默认为double类型</p>
</li>
<li><p>浮点数值后面也可以加后缀（D或者d）</p>
</li>
<li><p>double 精度 大于 float 因此下用上必须强转（float f = (float) 1.23d）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027170918891.png" alt="image-20201027170918891"></p>
</li>
</ul>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>char(字符)</td>
<td>16</td>
<td>Character</td>
<td>空</td>
<td>0~65535</td>
<td>2字节</td>
</tr>
</tbody></table>
<h3 id="boolean型"><a href="#boolean型" class="headerlink" title="boolean型"></a>boolean型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>boolean</td>
<td>8</td>
<td>Boolean</td>
<td>flase</td>
<td>true或false</td>
<td>1字节</td>
</tr>
</tbody></table>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031222727192.png" alt="image-20201031222727192"></p>
<p>上图中，有6个实线箭头代表着无信息丢失的转换；另外有3个虚线箭头，代表着可能会有精度的丢失；</p>
<p>比如 123456789 是个大整数，它包含的位数比float类型所能够表达的位数要多；</p>
<p>那么我们看看 如果用float 输出 这个整数会是什么情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101150109332.png" alt="image-20201101150109332"></p>
<p>我们可以看到，虽然大小差不多，但是还是损失了一点精度；</p>
<p>当用二元运算符连接2个值的时候，要把两个操作数转为一个类型，然后在进行运算，否则：</p>
<ul>
<li><p>如果两个操作数中有一个是<strong>double</strong>类型，另一个操作数将被转换为<strong>double</strong>类型。</p>
</li>
<li><p>否则，如果其中一个操作数为<strong>float</strong>类型，另一个操作数将被转换为<strong>float</strong>类型。</p>
</li>
<li><p>否则，如果其中一个操作数为<strong>long</strong>类型，另一个操作数将被转换为<strong>long</strong>类型。</p>
</li>
<li><p>否则，两个操作数都将会被转换为<strong>int</strong>类型。</p>
</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li>检查性异常：用户错误或是问题引起的异常，是程序员无法预见的</li>
<li>运行时异常：是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略掉； </li>
<li>错误ERROR：错误不是异常，而是脱离程序员控制的问题；比如栈溢出</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><ul>
<li>Java把异常当作对象来处理，并定义了一个基类 java.lang.Throwable 作为所有异常的超类</li>
<li>Java API中定义许多异常类，其中分为两大类：<strong>Error和Exception</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105211819347.png" alt="image-20201105211819347"></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul>
<li><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</p>
</li>
<li><p>Java虚拟机运行错误（Virtual MachineError），当JVM不再由继续执行操作所需的内存资源的时候，将会出现<strong>OutOfMemoryError</strong>；这些异常发生的时候，JVM一般会选择线程终止</p>
</li>
<li><p>还有的错误发生在虚拟机试图去执行应用的时候（比如类定义错误：NoClassDefFoundError），链接错误（LinkageError）</p>
<p>这些错误不可排查，因为他们在应用程序的控制和处理能力之外</p>
</li>
</ul>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>Exception分支有一个重要子类RuntimeException（运行时异常）需要我们去掌握：</p>
<ul>
<li><pre><code class="java">ArrayIndexOutOfBoundsException <span class="comment">//数组下标越界</span>
&lt;!--code￼<span class="number">17</span>--&gt;</code></pre>
</li>
<li><pre><code class="java">ArithmeticException <span class="comment">//算术异常 比如0作为除数</span>
&lt;!--code￼<span class="number">18</span>--&gt;</code></pre>
</li>
<li><pre><code class="java">ClassNotFoundException <span class="comment">//找不到类</span>
&lt;!--code￼<span class="number">19</span>--&gt;
</code></pre>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105214703569.png" alt="image-20201105214703569"></p>
<p>其实可以理解成：catch就是平常公园里那种抓金鱼的网，try中的部分就是我们的金鱼,只有你的网的大小合适，才能抓到金鱼；finally就是我们玩抓金鱼要交的门票钱，无论抓不抓得到都得给，只不过是最后给 不是一开始给而已；</p>
<p>那我们难道只能 让程序跑的时候 抓异常，不能主动去抛出异常吗？</p>
<p>不是的，接下来还有介绍关键字<strong>throw throws</strong></p>
<p>throw ≠ throws</p>
<ul>
<li>throw<ul>
<li>作用在<strong>方法内</strong>，表示抛出具体异常，由方法体内的语句处理。</li>
<li>具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了Throw一定是抛出了某种异常。</li>
</ul>
</li>
<li>throws<ul>
<li>作用在<strong>方法上</strong>，表示如果抛出异常，则由该方法的调用者来进行异常处理。</li>
<li>主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。</li>
<li>出现异常是一种可能性，但不一定会发生异常。</li>
</ul>
</li>
</ul>
<p>例子:</p>
<p>throws E1,E2,E3只是告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常E1，E2，E3可能是该函数体产生的。 throw则是明确了这个地方要抛出这个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception1,Exception3</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">                 ......</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a!=b)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span>  Exception3(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。</p>
<p>如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理。如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！”);）。所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了</p>
<p>而Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。  </p>
<p>  throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。    throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。</p>
<p>throw是具体向外抛异常的动作，所以它是抛出一个异常实例。    throws说明你有那个可能，倾向。throw的话，那就是你把那个倾向变成真实的了。</p>
<ol>
<li>throws出现在方法函数头；而throw出现在函数体。</li>
<li>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。</li>
<li>两者都是消极处理异常的方式，只是抛出/可能抛出异常，而不会去处理异常，真正的处理异常由函数的上层调用处理</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在程序中使用自定义异常，大体可以分成下面几步：</p>
<ol>
<li>创建自定义异常类</li>
<li>在方法中通过throw关键字抛出异常对象</li>
<li>如果在当前抛出异常的方法中处理异常，可以用<strong>try-catch语句</strong>进行捕获处理；否则在方法的声明处通过<strong>throws</strong>关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>在出现一场方法的调用者中捕获并且处理异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递数字 如果数字大于0 抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString 方法 打印信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;传递进来的参数为:&quot;</span> + a);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);<span class="comment">//这里选择了抛出 而不是捕获</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyException:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105222844568.png" alt="image-20201105222844568"></p>
<h1 id="注解和反射"><a href="#注解和反射" class="headerlink" title="注解和反射"></a>注解和反射</h1><h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><p>关于注解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/9723699.html">https://www.cnblogs.com/fnlingnzb-learner/p/9723699.html</a></p>
<p>这篇文章起始也描述的也很好，把注解形容成了标签，我觉得非常生动形象</p>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li>Annotation的作用<ul>
<li>不是车舱内光绪本身，可以对程序做出解释</li>
<li>可以被其他程序（如编译器等）读取</li>
</ul>
</li>
<li>Annotation的格式<ul>
<li>注解是以==@注释名==在代码中存在的，还可以添加一些参数值，如 @SuppressWarnings(value=”unchecked”)</li>
</ul>
</li>
<li>Annotation在哪里使用<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息</li>
<li>我们可以通过反射机制编程实现对这些元数据的访问呢</li>
</ul>
</li>
</ul>
<h3 id="内置注解（基本注解）"><a href="#内置注解（基本注解）" class="headerlink" title="内置注解（基本注解）"></a>内置注解（基本注解）</h3><ul>
<li>@Override：定义在<strong>java.lang.Override</strong>中，此注解只适用于修饰方法，表示一个方法生命打算重写超类中的另一个方法声明</li>
<li>@Deprecatd：定义在<strong>java.lang.Deprecatd</strong>中，此注释可以用于修饰方法，属性，类，表示不鼓励程序员使用这样的元素（废弃了）</li>
<li>@SuppressWarning：定义在<strong>java.lang.SuppressWarnings</strong>中，用来抑制编译时的警告信息<ul>
<li>这个注解需要添加一个参数才能使用：<ul>
<li>@SuppressWarning(“all”);</li>
<li>@SuppressWarning(“unchecked”)</li>
<li>@SuppressWarning(“value={“unchecked”, “deprecation”})</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>元注解的作用就是负责注解其他的注解，Java定义了四个标准的<strong>meta-annotation类型</strong>，他们被用来提供对其他Annotation类型的作说明</p>
</li>
<li><p>这些类型和他们所支持的类在<strong>java.lang.annotation</strong>包中</p>
</li>
<li><p>四个标准的meta-annotation类型分别是</p>
<ul>
<li><p>@Target：用于描述注解的使用范围 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105150937346.png" alt="image-20201105150937346"></p>
<ul>
<li>@Target(ElementType.TYPE)  //接口、类、枚举</li>
</ul>
</li>
<li><p>@Target(ElementType.FIELD) //字段、枚举的常量</p>
<ul>
<li>@Target(ElementType.METHOD) //方法</li>
</ul>
</li>
<li><p>@Target(ElementType.PARAMETER) //方法参数</p>
<ul>
<li>@Target(ElementType.CONSTRUCTOR) //构造函数</li>
</ul>
</li>
<li><p>@Target(ElementType.LOCAL_VARIABLE)//局部变量</p>
<ul>
<li>@Target(ElementType.ANNOTATION_TYPE)//注解</li>
</ul>
</li>
<li><p>@Target(ElementType.PACKAGE) ///包 </p>
</li>
</ul>
</li>
<li><p>@Retention：表示需要在什么级别（<strong>SOURCE &lt; CLASS &lt; RUNTIME</strong>）保存该注解信息，用于描述注解的生命周期</p>
<p>话句话说 就是我们的注解在什么地方还有效</p>
<p>运行级别 是RUNTIME PentationPolicy 包含三个值:SOURCE CLASS RUNTIME</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151251990.png" alt="image-20201105151251990"></p>
<ul>
<li>@Retention(RetentionPolicy.SOURCE)  //注解仅存在于源码中，在class字节码文件中不包含</li>
<li>@Retention(RetentionPolicy.CLASS)   // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li>
<li>@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</li>
</ul>
<ul>
<li>@Document：表示是否将我们的注解生成在javadoc（java文档）中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151452888.png" alt="image-20201105151452888"></p>
<ul>
<li><p>@Inherited：说明子类可以<strong>继承</strong>父类中的该注解</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151542928.png" alt="image-20201105151542928"></p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul>
<li>使用了@interface自定义注解的时候，自动继承了<strong>java.lang.annotation.Annotation接口</strong></li>
<li>如何实现的呢？<ul>
<li>@interface用来声明一个注解，格式：@interface 注解名{内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称其实就是参数的名称</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型。或是类：Class，String，enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素的时候，经常使用空字符串，0作为默认值</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105153014063.png" alt="image-20201105153014063"></p>
<h2 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h2><h3 id="静态语言-动态语言"><a href="#静态语言-动态语言" class="headerlink" title="静态语言 动态语言"></a>静态语言 动态语言</h3><ul>
<li>静态语言：运行时结构不可变的语言就是静态语言<ul>
<li>JAVA,C,C++</li>
</ul>
</li>
<li>动态语言：是一类可以在运行的时候改变其结构的语言：例如新的函数、对象、甚至代码都可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时，代码可以根据某些条件改变自身的结构<ul>
<li>Object - C，C#，JavaScript，PHP，Python</li>
</ul>
</li>
<li>Java并不是动态语言，但Java可以被称为是准动态语言，即Java有一定的动态性，我们可以利用反射机制获取类似动态语言的特性；</li>
</ul>
<h3 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h3><ul>
<li><p><strong>反射</strong>是Java被视为动态语言的关键，反射机制允许程序在执行期借助于==Reflection API==取得任何类的内部信息，并能直接操作任意对象的内部属性和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载完类了之后，在<strong>堆内存</strong>的<strong>方法区</strong>中就产生了一个==Class==类型的对象（一个类只有一个Class对象）这个对象就包含了完整的类的结构信息；</p>
<p>我们可以通过这个对象看到类的结构；通过对象 → 看到类的结构，像在照镜子，因此叫==反射==</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161526292.png" alt="image-20201105161526292"></p>
</li>
</ul>
<h4 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161638781.png" alt="image-20201105161638781"></p>
<h4 id="Java反射优缺点"><a href="#Java反射优缺点" class="headerlink" title="Java反射优缺点"></a>Java反射优缺点</h4><ul>
<li>优点：可以实现动态创建对象和编译，体现出很大的灵活性</li>
<li>缺点：对性能有一定的影响；因为我们使用反射式一种解释操作，我们可以告诉JVM，我们希望做什么，并且它满足我们的要求，这类操作总是慢于直接执行相同的操作 （一般来说用new创建对象 但是反射用forName）</li>
</ul>
<h3 id="获取反射对象"><a href="#获取反射对象" class="headerlink" title="获取反射对象"></a>获取反射对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Reflction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c4 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个类在内存中只能有一个Class对象</span></span><br><span class="line">        <span class="comment">//类被加载后，类的整个结构会被封装在Class对象之中</span></span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pojo类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105162758160.png" alt="image-20201105162758160"></p>
<p>发现我们的hash值是一样的，代表着 一个类在内存中只会有一个Class对象；</p>
<p>此外，一个类被加载之后呢，类的整个的结构都会被封装在Class对象之中</p>
<h3 id="理解Class类并获取Class实类"><a href="#理解Class类并获取Class实类" class="headerlink" title="理解Class类并获取Class实类"></a>理解Class类并获取Class实类</h3><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>在Object类中有以下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>此方法被所有的子类继承，这个方法的返回值类型为一个Class类，而这个Class类就是Java反射的源头了；</p>
<p>换句话说，我们通过对象反射出类的名称（比如张三是个人，张三是对象，人是个类，我们通过张三就能反射出 他是个人）</p>
<p>试想一下，假如张三（对象）早上起床，去照镜子，他能看见什么呢？</p>
<ul>
<li>张三的样貌（属性）</li>
<li>张三在打哈欠（方法）</li>
<li>……</li>
</ul>
<p>反射就是如此，对象通过反射能得 某个类的属性、方法、构造器、某个类实现了哪些接口；</p>
<p>而对于每个类而言，JRE为其<strong>保留一个不变的Class类型的对象</strong>。就像是你的档案一样，包含各种信息；</p>
<p>形象点说就是，小孩子（对象）在外面走丢啦，想知道自己的父母是谁、家里在哪等等信息，可以去找公安局（Class类），让他们帮你查询信息</p>
<h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><p> 常用方法列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> getName()：返回String形式的该类的名称。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> newInstance()：根据某个Class对象产生其对应类的实例，它调用的是此类的默认构造方法(没有默认无参构造器会报错)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> getClassLoader()：返回该Class对象对应的类的类加载器。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> getSuperClass()：返回某子类所对应的直接父类所对应的Class对象</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> isArray()：判定此Class对象所对应的是否是一个数组对象</span><br><span class="line">　　</span><br><span class="line"><span class="number">6</span> getComponentType() ：如果当前类表示一个数组，则返回表示该数组组件的 Class 对象，否则返回 <span class="keyword">null</span>。</span><br><span class="line">　　</span><br><span class="line"><span class="number">7</span> getConstructor(Class[]) :返回当前 Class 对象表示的类的指定的公有构造子对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">8</span> getConstructors() :返回当前 Class 对象表示的类的所有公有构造子对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">9</span> getDeclaredConstructor(Class[]) :返回当前 Class 对象表示的类的指定已说明的一个构造子对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">10</span> getDeclaredConstructors() :返回当前 Class 对象表示的类的所有已说明的构造子对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">11</span> getDeclaredField(String) :返回当前 Class 对象表示的类或接口的指定已说明的一个域对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">12</span> getDeclaredFields() :返回当前 Class 对象表示的类或接口的所有已说明的域对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">13</span> getDeclaredMethod(String, Class[]) :返回当前 Class 对象表示的类或接口的指定已说明的一个方法对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">14</span> getDeclaredMethods() :返回 Class 对象表示的类或接口的所有已说明的方法数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">15</span> getField(String) :返回当前 Class 对象表示的类或接口的指定的公有成员域对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">16</span> getFields() :返回当前 Class 对象表示的类或接口的所有可访问的公有域对象数组。</span><br><span class="line"></span><br><span class="line"><span class="number">17</span> getInterfaces() :返回当前对象表示的类或接口实现的接口。</span><br><span class="line">　　</span><br><span class="line"><span class="number">18</span> getMethod(String, Class[]) :返回当前 Class 对象表示的类或接口的指定的公有成员方法对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">19</span> getMethods() :返回当前 Class 对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</span><br><span class="line">　　</span><br><span class="line"><span class="number">20</span> isInstance(Object) :此方法是 Java 语言 <span class="keyword">instanceof</span> 操作的动态等价方法。</span><br><span class="line">　　</span><br><span class="line"><span class="number">21</span> isInterface() :判定指定的 Class 对象是否表示一个接口类型</span><br><span class="line">　　</span><br><span class="line"><span class="number">22</span> isPrimitive() :判定指定的 Class 对象是否表示一个 Java 的基类型。</span><br><span class="line">　　</span><br><span class="line"><span class="number">23</span> newInstance() ：创建类的新实例</span><br></pre></td></tr></table></figure>

<h4 id="获取Class类实例"><a href="#获取Class类实例" class="headerlink" title="获取Class类实例"></a>获取Class类实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Reflction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方法1:已知具体的类（User），通过class属性获取</span></span><br><span class="line">        <span class="comment">//该方法最安全可靠，程序性能最高</span></span><br><span class="line">        Class c1 = User.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2:已知某个类的实例（已经创建该类的对象了）</span></span><br><span class="line">        <span class="comment">//调用实例的getClass()方法获取Class对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c2 = user.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法3:已知一个类的类名了，且知道路径（包）,可通过Class的静态方法forName()获取</span></span><br><span class="line">        <span class="comment">//有可能找不到这个类，需要抛出ClassNotFoundException</span></span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pojo类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105165540835.png" alt="image-20201105165540835"></p>
<p>获取类的方法:</p>
<ol>
<li><p>已知具体的类，通过class属性获取</p>
<p>该方法最安全可靠，程序性能最高</p>
</li>
<li><p>已知某个类的实例（已经创建该类的对象了）</p>
<p>调用实例的getClass()方法获取Class对象</p>
</li>
<li><p>已知一个类的类名了，且知道路径（包）,可通过Class的静态方法forName()获取</p>
<p>有可能找不到这个类，需要抛出<strong>ClassNotFoundException</strong></p>
</li>
<li><p>内置的<strong>基本数据类型</strong>可以直接使用类名.Type</p>
</li>
<li><p>还可以使用ClassLoader</p>
</li>
</ol>
<p>验证Class对象：</p>
<p>目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201118205003686.png" alt="image-20201118205003686"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(p == p2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(c == c2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        Class c3 = Person.class;</span><br><span class="line">        <span class="comment">// int.class;</span></span><br><span class="line">        <span class="comment">// String.class;</span></span><br><span class="line">        System.out.println(c == c3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式3</span></span><br><span class="line">        <span class="comment">// ClassNotFoundException</span></span><br><span class="line">        Class c4 = Class.forName(<span class="string">&quot;com.hpg.Test.Person&quot;</span>);<span class="comment">//true</span></span><br><span class="line">        System.out.println(c == c4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="keyword">false</span><span class="comment">//因为对象不同</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c2同属一个类</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c3同属一个类</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c4同属一个类</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>带参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;---&quot;</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, address=&quot;</span> + address</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">&quot;com.hpg.Test.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取带参构造方法对象</span></span><br><span class="line">        <span class="comment">// public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor con = c.getConstructor(String.class, <span class="keyword">int</span>.class,	String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过带参构造方法对象创建对象</span></span><br><span class="line">        <span class="comment">// public T newInstance(Object... initargs)</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">&quot;hpg&quot;</span>, <span class="number">19</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person [name=hpg, age=19, address=深圳]</span></span><br></pre></td></tr></table></figure>

<h4 id="getDeclared、getField与setAccessible-flag"><a href="#getDeclared、getField与setAccessible-flag" class="headerlink" title="getDeclared、getField与setAccessible(flag)"></a>getDeclared、getField与setAccessible(flag)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student p = <span class="keyword">new</span> Student();</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class c =Class.forName(&quot;com.hpg.Test.Person&quot;);</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">            <span class="comment">/*public java.lang.String com.hpg.Test.Student.name</span></span><br><span class="line"><span class="comment">              int com.hpg.Test.Student.id</span></span><br><span class="line"><span class="comment">              private int com.hpg.Test.Student.age*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;null&#x27;, id=0, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String name; 由于是public修饰的 因此直接用getField可以取得到</span></span><br><span class="line">        Field nameField =c.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//nameField.setAccessible(true); public 根本用不着去设true</span></span><br><span class="line">        nameField.set(p,<span class="string">&quot;hpg&quot;</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=0, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int id; 前面没有修饰 getField是取不到的 必须用getDeclaredField</span></span><br><span class="line">        <span class="comment">//Field addressField = c.getField(&quot;id&quot;);</span></span><br><span class="line">        Field idField = c.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// addressField.setAccessible(true); 前面没修饰 默认是public 因此其实也不用多此一举设置true</span></span><br><span class="line">        idField.set(p,<span class="number">100</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=100, age=0&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//private int age; 是私有的 必须用getDeclaredField取</span></span><br><span class="line">        Field ageField = c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);<span class="comment">//必须要设置这一步，因为是private</span></span><br><span class="line">        ageField.set(p,<span class="number">19</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=100, age=19&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String com.hpg.Test.Student.name</span><br><span class="line"><span class="keyword">int</span> com.hpg.Test.Student.id</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> com.hpg.Test.Student.age</span><br><span class="line">Student&#123;name=<span class="string">&#x27;null&#x27;</span>, id=<span class="number">0</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">0</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">100</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">100</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码我们可以发现：</p>
<p>假如属性是私有的，想要用class类去获取 该属性必须用：<code>getDeclaredFields</code> 这个方法可以获取类的全部字段 </p>
<p>然而<code>getFields</code> 方法只能获取public字段</p>
<p>同时，想要通过反射去设置属性的话：如果是私有变量需要先<code>xxx.setAccessible(true);</code>否则将没有权限</p>
<p>关于setAccessible原理：</p>
<p>应该是取消了Java的语言访问检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">    AccessibleObject.checkPermission();</span><br><span class="line">    <span class="keyword">if</span> (flag) checkCanSetAccessible(Reflection.getCallerClass());</span><br><span class="line">    setAccessible0(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但我觉得这会不会在某种程度上破坏了对象的封装性呢？总感觉不太好</p>
<h4 id="哪些类可以有Class对象"><a href="#哪些类可以有Class对象" class="headerlink" title="哪些类可以有Class对象"></a>哪些类可以有Class对象</h4><ul>
<li>class : 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface 接口</li>
<li>数组</li>
<li>enum 枚举</li>
<li>annotation 注解</li>
<li>primitive type 基本数据类型</li>
<li>void</li>
</ul>
<h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105203849181.png" alt="image-20201105203849181"></p>
<h4 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h4><ul>
<li>加载：将class文件字节码内容加载到内存中，并且将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程，分为三步：<strong>验证，准备，解析</strong><ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址的过程）</li>
</ul>
</li>
<li>初始化：<ul>
<li>构造类构造器<strong><clinit>()方法</clinit></strong>（这是jvm去做的）的过程，类构造器<strong><clinit>()方法</clinit></strong>是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的<ul>
<li>ps：类构造器是构造<strong>类信息</strong>的，不是构造该类对象的构造器</li>
</ul>
</li>
<li>当初始化一个类的时候，如果该类的父类还没有进行初始化，先初始化其父类</li>
<li><strong>虚拟机</strong>会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</clinit></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类无参构造初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201108163232784.png" alt="image-20201108163232784"></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。</p>
</li>
<li><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
</li>
<li><h4 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h4><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，</p>
<p>由于线程类本身就是调用的Runnable接口所以你可以继承 java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。</p>
</li>
<li><h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><p>由于Java是不支持多继承的，因此我们选择继承哪个类就显得尤为重要了。同时，Java支持调用多个接口，因此更多时候往往调用Runnable接口。</p>
</li>
<li><h4 id="线程中start-和run-的区别"><a href="#线程中start-和run-的区别" class="headerlink" title="线程中start()和run()的区别"></a>线程中start()和run()的区别</h4><p>我们根据下面的代码 以及运行结果看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiffBewteenStartAndRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread.currentThread().getName() 用于获取当前运行的线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// creating two threads for start and run method call</span></span><br><span class="line">        Thread startThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">&quot;start&quot;</span>));</span><br><span class="line">        Thread runThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">&quot;run&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        startThread.start();</span><br><span class="line">        <span class="comment">// new Thread</span></span><br><span class="line">        runThread.run();</span><br><span class="line">        <span class="comment">//current Thread</span></span><br><span class="line">        startThread.run();</span><br><span class="line">        <span class="comment">// current Thread;</span></span><br><span class="line">        runThread.start();</span><br><span class="line">        <span class="comment">// new Thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Simple Runnable implementation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String caller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String caller)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.caller = caller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caller: &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; and code on this Thread is executed by : &quot;</span></span><br><span class="line">                    + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">main</span><br><span class="line">Caller: run and code on <span class="keyword">this</span> Thread is executed by : main</span><br><span class="line">Caller: start and code on <span class="keyword">this</span> Thread is executed by : Thread-<span class="number">0</span></span><br><span class="line">Caller: start and code on <span class="keyword">this</span> Thread is executed by : main</span><br><span class="line">Caller: run and code on <span class="keyword">this</span> Thread is executed by : Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由打印结果我们发现：run方法是在主线程中main中被调用的，run方法运行在主线程main上；</p>
<p>start方法会创建新的线程，而后再调用run方法，此时的run方法是运行创建的新线程上的；</p>
</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><ul>
<li><h4 id="三种创建-启动方式"><a href="#三种创建-启动方式" class="headerlink" title="三种创建 启动方式"></a>三种创建 启动方式</h4><ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><ul>
<li><p>自定义线程类继承Thread类</p>
</li>
<li><p>重写run方法</p>
</li>
<li><p>创建线程对象，调用start()启动线程（如果是run方法是当前线程中运行方法，不会创建新的线程）</p>
</li>
<li><p>启动线程:子类对象.start();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        MyThread1 mt1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        <span class="comment">//调用start方法</span></span><br><span class="line">        mt1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><ul>
<li><p>自定义线程类实现Runnable接口</p>
</li>
<li><p>重写run方法</p>
</li>
<li><p>创建<strong>线程对象</strong>（这里一定要注意，如果只创建了实现接口的对象，是无法使用start方法的，只能用run方法），调用start()启动线程（如果是run方法是当前线程中运行方法，不会创建新的线程）</p>
</li>
<li><p>启动线程：传入目标对象 → Thread对象.start();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类的实例</span></span><br><span class="line">        MyThread2 mt2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="comment">//用该实例作为Thread的target来创建Thread对象</span></span><br><span class="line">        Thread mt = <span class="keyword">new</span> Thread(mt2);</span><br><span class="line">        <span class="comment">//调用start方法</span></span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread2 is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5></li>
</ul>
</li>
</ul>
<h2 id="Thread（Runnable-target）调用哪个run方法问题"><a href="#Thread（Runnable-target）调用哪个run方法问题" class="headerlink" title="Thread（Runnable target）调用哪个run方法问题"></a>Thread（Runnable target）调用哪个run方法问题</h2><ul>
<li><p>问题引入：</p>
<p>以下代码中有两个run方法，一个是重写了Thread中的run方法（<strong>Run of Thread</strong>），一个是传入了Runnable对象，也就是现在的Target是Runnable，由该对象去实现的run方法（<strong>Run of Runnable</strong>）；（这里有涉及<strong>匿名内部类</strong>的知识，学习后再看这里会更清楚一点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Runnable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111131452144.png" alt="image-20201111131452144"></p>
</li>
<li><p>问题扩展：</p>
<p>大体与上述代码并没有什么不同，但是在重写的代码中增加了<code>super.run();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Runnable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="comment">//这是重写的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Thread&quot;</span>);</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111133808047.png" alt="image-20201111133808047"></p>
</li>
</ul>
<p>那么为什么是这样的结果呢？</p>
<p>查看JDK中Thread源码发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">		target.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法，首先检查target是否为空，如果不为空，执行target中的run方法</p>
<p>因此，我们就不难明白上述两个运行结果是怎么来的了：</p>
<p><strong>对于第一个代码：</strong></p>
<p>重写了Thread的run()方法，同时传入了一个Runnable对象，该对象也实现了run()方法。该Thread对象调用start()方法后，会执行该对象重写的run()方法，其输出结果也就是Run of Thread，输出完后，run()方法返回，该线程对象的生命周期也就结束了。</p>
<p><strong>对于第二个代码：</strong></p>
<p>首先，该线程启动运行后，执行其重写的run()方法，输出Run of Thread。</p>
<p>接下来调用super.run()，也就是调用超类的run()方法，而该超类的run()方法，也就是JDK定义的Thread类的run()，其执行如上JDK源码 所示；显然target不为空，这时候会调用该对象的run()方法，会输出Run of Runnable.。</p>
<p>如果，上面的Thread并未重写run()方法，那么，执行的结果还是一样。首先会执行该Thread的run()方法，因为此时并未重写该方法，所以还是会调用JDK定以的run()方法，也就是上面的代码段 ，在该代码段中会判断target是否为空，显然不是，所以会调用Runnable对象实现的run()方法。</p>
<p>==总结==</p>
<p>对于形如:<code>Thread(Runnable target ...)</code>,不管传入的Target是否为空，首先都会执行Thread自己的run()方法。如果重写了该方法且该方法中没有super.run()，那么是永远不会调用Runnable实现的run()方法；</p>
<p>如果没有重写该方法，则会去判断target是否为空，以此来决定调用target实现的run()方法；</p>
<p>如果重写了该方法，且该方法中有super.run()，在执行完该语句之前的所有代码后，会判断target是否为空，以此来决定调用target实现的run()方法，执行完后，接着执行该语句之后的代码。</p>
<h2 id="普通方法调用和多线程区别"><a href="#普通方法调用和多线程区别" class="headerlink" title="普通方法调用和多线程区别"></a>普通方法调用和多线程区别</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110220112099.png" alt="image-20201110220112099"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114225245322.png" alt="image-20201114225245322"></p>
<ul>
<li><p><mark>new（创建状态）</mark></p>
<p>在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread 类的构造方法来实现，例如 “Thread thread=new Thread()”。</p>
</li>
<li><p><mark>就绪状态</mark></p>
<p>新建线程对象后，调用该线程的 start() 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件。</p>
</li>
<li><p><Mark>运行状态</Mark></p>
<p>当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 run() 方法。run() 方法定义该线程的操作和功能。</p>
</li>
<li><p><mark>阻塞状态/等待状态</mark></p>
<p>一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让 CPU 暂时中止自己的执行，进入阻塞状态。在可执行状态下，如果调用sleep(),suspend(),wait() 等方法，线程都将进入阻塞状态，发生阻塞时线程不能进入排队队列，只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p>
</li>
<li><p><mark>死亡状态</mark></p>
<p>线程调用 stop() 方法时或 run() 方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。</p>
</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li><p><strong>调整线程的优先级</strong>：学过OS的同学们可能会对这个优先级比较敏感，在Java线程中优先级高（数字大）的线程拥有更多运行机会</p>
<p>Java线程中的优先级以整数形式表达:1~10，1最小，10最大</p>
<p>Thread类有以下三个静态常量：</p>
<p><mark>static int MAX_PRIORITY</mark></p>
<p>​     线程可以具有的最高优先级，取值为10。</p>
<p><mark>tatic int MIN_PRIORITY</mark></p>
<p>​     线程可以具有的最低优先级，取值为1。</p>
<p><mark>static int NORM_PRIORITY</mark></p>
<p>​     分配给线程的默认优先级，取值为5。</p>
<p>其中，Thread类设置优先级的方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriority();</span><br></pre></td></tr></table></figure>

<p>获得优先级的方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPriority();</span><br></pre></td></tr></table></figure>

<p>需要注意的是：每个线程都有默认的优先级。主线程默认优先级是<code>static int NORM_PRIORITY</code></p>
<p>线程优先级存在继承关系，A线程中创建B线程，B与A享有相同优先级</p>
</li>
<li><p><strong>线程睡眠</strong>：<strong>Thread.sleep(long millis)方法</strong>，使线程转到<strong>阻塞状态</strong>。millis参数设定睡眠的时间，以<strong>毫秒</strong>为单位。当睡眠结束后，就转为<strong>就绪（Runnable）状态</strong>。sleep()平台移植性好。</p>
</li>
<li><p><strong>线程等待</strong>：<strong>Object类中的wait()方法</strong>，导致当前的线程等待，直到其他线程调用此对象的 <strong>notify() 方法</strong>或 <strong>notifyAll()</strong> 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>
</li>
<li><p><strong>线程让步</strong>：<strong>Thread.yield() 方法</strong>，暂停当前正在执行的线程对象，把执行机会让给<strong>相同或者更高优先级</strong>的线程。</p>
</li>
<li><p><strong>线程加入</strong>：<strong>join()方法</strong>，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
</li>
<li><p><strong>线程唤醒</strong>：<strong>Object类中的notify()方法</strong>，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>
</li>
</ul>
<h4 id="线程休眠（sleep）"><a href="#线程休眠（sleep）" class="headerlink" title="线程休眠（sleep）"></a>线程休眠（sleep）</h4><ul>
<li><p>sleep（参数）参制定了线程阻塞/等待的<strong>毫秒数</strong></p>
<p>这里当时有个疑问，欸？那我sleep(0)有啥用啊？关于这个问题，其实阅读这篇文章就可以有解答：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wl455624651/article/details/7388250">https://blog.csdn.net/wl455624651/article/details/7388250</a></p>
<p>其实简单来说就是，触发操作系统立刻重新进行一次CPU竞争，不要小看这个功能，是很有必要的</p>
</li>
<li><p>sleep存在异常<code>InterruptedException</code></p>
</li>
<li><p>sleep时间结束后，线程从阻塞/等待状态 → 就绪状态</p>
</li>
<li><p>每个对象有一个锁，而<mark><strong>sleep不会释放锁!!</strong></mark></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i + <span class="string">&quot;,日期:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">        ts1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ts2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        ts3.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ts1.start();</span><br><span class="line">        ts2.start();</span><br><span class="line">        ts3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115160241312.png" alt="image-20201115160241312"></p>
<p>通过运行结果，我们不难发现：每一组三个人名的打印顺序并不是一定的</p>
<p>这也印证了我们上面的说法：每当调用sleep函数后，线程回到了就绪队列，相当于回到了同一起跑线，需要进行新的一次CPU竞争</p>
<p>那么谁能抢到CPU呢？当然是说不定的啦，因此，打印顺序也是不一定的。</p>
<h4 id="线程礼让（yield）"><a href="#线程礼让（yield）" class="headerlink" title="线程礼让（yield）"></a>线程礼让（yield）</h4><ul>
<li>线程的礼让会使正在执行的线程<strong>暂停</strong>，但并不<strong>阻塞</strong>，也就是说该函数并<strong>不会</strong>让线程转移到<mark>等待/睡眠/阻塞</mark>状态</li>
<li>线程将会从<strong>运行态</strong> → <strong>就绪态</strong></li>
<li>之后该让哪个线程运行，由CPU进行调度，因此有可能下个运行的还是那个礼让的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;停止执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">        ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">        ty1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ty2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ty1.start();</span><br><span class="line">        ty2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115161708654.png" alt="image-20201115161708654"></p>
<h4 id="线程加入（join）"><a href="#线程加入（join）" class="headerlink" title="线程加入（join）"></a>线程加入（join）</h4><ul>
<li>Thread.join()很霸道，调用该方法的函数将会霸占处理机，等到该线程执行完成后，再执行别的线程，其他的线程在其此间为阻塞态</li>
<li>其实就是插队</li>
<li>join函数以及原理看起来简单，但是里面有很多细枝末节需要注意</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013425438/article/details/80205693">https://blog.csdn.net/u013425438/article/details/80205693</a> 这篇文章其实解释了得蛮清楚的</p>
<p>（ps：评论区也很值得一看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br><span class="line">A-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当使用了join后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>然而，假如我们把<code>t1.join()</code>放在<code>t2.start()</code>之后，我们看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>发现，又回到了交替执行的情况了，究竟是为什么呢？</p>
<p>查看join()的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);            <span class="comment">//join()等同于join(0)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);           <span class="comment">//join(0)等同于wait(0)，即wait无限时间直到被notify</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现：join()方法的底层是利用wait()方法实现的。</p>
<p>可以看出，join方法是一个同步方法，当主线程调用t1.join()方法时，主线程先获得了t1对象的锁，随后进入方法，调用了t1对象的wait()方法，使主线程进入了t1对象的等待池，</p>
<p>此时，A线程则还在执行，并且随后的t2.start()还没被执行，因此，B线程也还没开始。</p>
<p>等到A线程执行完毕之后，主线程继续执行，走到了t2.start()，B线程才会开始执行。</p>
<p><strong>其实叽里呱啦说了一大堆，就说明了一个道理:在哪个线程调用了xxx.join()方法，只会锁那个相应的线程</strong></p>
<p><strong>比如a线程调用了t1.join()，那a就会被卡住，当然了，a会不会对别的线程有影响就另当别论了</strong></p>
<p>原文中用了一个例子来验证上述这个道理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">		ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">		ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">		t2.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">		t3.start();</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现是主线程跑完了后，ABC线程交替执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t2start</span><br><span class="line">t3start</span><br><span class="line">main end</span><br><span class="line">C-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">C-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">C-<span class="number">3</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">C-<span class="number">4</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">C-<span class="number">5</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当我们使用了join函数后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t2end&quot;</span>);</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3end&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们发现，主线程在调用join函数的地方停住了，后面是AB线程交替执行</p>
<p>这里有人会说啦：哎呀 不是只会停止主线程吗，为什么不是ABC线程交替执行啊？</p>
<p>那是因为我们的C线程此时还没有在主线程上启动，C线程根本不存在，怎么执行呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t1end</span><br><span class="line">t2start</span><br><span class="line">t2end</span><br><span class="line">A-1</span><br><span class="line">B-1</span><br><span class="line">A-2</span><br><span class="line">B-2</span><br><span class="line">A-3</span><br><span class="line">B-3</span><br><span class="line">B-4</span><br><span class="line">A-4</span><br><span class="line">B-5</span><br><span class="line">A-5</span><br><span class="line">t3start</span><br><span class="line">t3end</span><br><span class="line">C-1</span><br><span class="line">main end</span><br><span class="line">C-2</span><br><span class="line">C-3</span><br><span class="line">C-4</span><br><span class="line">C-5</span><br></pre></td></tr></table></figure>

<p>如果你硬要改，让C也加入进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t2end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3end&quot;</span>);</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t1end</span><br><span class="line">t2start</span><br><span class="line">t2end</span><br><span class="line">t3start</span><br><span class="line">t3end</span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">C-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">C-<span class="number">2</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">C-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">C-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br><span class="line">C-<span class="number">5</span></span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p>即证；</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li><p><strong>并发</strong>：同一个对象被多个线程同时操作</p>
</li>
<li><p>线程同步基本思想：由于处理多线程问题的时候往往关乎到对同一个对象的访问，修改</p>
<p>因此我们需要线程同步：线程同步是一种等待机制，多个<strong>需要同时访问这个对象的线程</strong>的<strong>线程</strong>进入了<strong>这个对象</strong>的<mark>等待池</mark></p>
<p>形成了队列，等待前面的线程使用完毕之后，下一个线程再使用</p>
</li>
<li><p>同步方法：队列 + <strong>锁</strong></p>
</li>
</ul>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理模式分为两种：静态代理和动态代理</p>
<p>什么是代理呢？按照我自己的理解就是：“夹带私货”</p>
<p>什么意思呢？就是通过代理，我们可以实现我们一开始的目的，与此同时还会有一些额外的功能</p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cC-Zhou/p/9525638.html">https://www.cnblogs.com/cC-Zhou/p/9525638.html</a></p>
<p>我们买东西虽然可以从厂家那直接拿，但一般来说都是从商店那买的；</p>
<p>他们也是从厂家那拿货，然后加一点小价钱卖给我们；</p>
<p>嗯？是不是有点熟悉，像不像我们java中的接口概念：我们和商店都实现了从xxx处买东西这一接口</p>
<p>在这个小例子中，商店就是那个代理，充当中间人角色，他加了一点小价钱 就是他夹带的私活 或者说是额外扩充的功能？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213911162" alt="这里写图片描述"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是面向对象编程中比较常见的设计模式。<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213938736" alt="这里写图片描述"></p>
<p>这是常见代理模式常见的 UML 示意图。</p>
<p>需要注意的有下面几点：</p>
<ol>
<li>用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li>
<li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li>
<li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li>
<li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li>
</ol>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？</p>
<p>电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。</p>
<p>现在用代码来进行模拟。</p>
<p>首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;您正在观看电影 《肖申克的救赎》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RealMovie movie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(RealMovie movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        guanggao(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line"></span><br><span class="line">        guanggao(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guanggao</span><span class="params">(<span class="keyword">boolean</span> isStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( isStart ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RealMovie realmovie = <span class="keyword">new</span> RealMovie();</span><br><span class="line"></span><br><span class="line">        Movie movie = <span class="keyword">new</span> Cinema(realmovie);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！</span><br><span class="line">您正在观看电影 《肖申克的救赎》</span><br><span class="line">电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃</span><br><span class="line">吧！</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final的简介"><a href="#final的简介" class="headerlink" title="final的简介"></a>final的简介</h3><p>final可以修饰<strong>变量，方法和类</strong>，用于表示所修饰的内容一旦赋值之后就不会再被改变，比如String类就是一个final类型的类。即使能够知道final具体的使用方法，我想对<strong>final在多线程中存在的重排序问题</strong>也很容易忽略，希望能够一起做下探讨。</p>
<h3 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h3><p>final能够修饰变量，方法和类，也就是final使用范围基本涵盖了java每个地方，下面就分别以锁修饰的位置：变量，方法和类分别来说一说。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在java中变量，可以分为<strong>成员变量</strong>以及方法<strong>局部变量</strong>。因此也是按照这种方式依次来说，以避免漏掉任何一个死角。</p>
<h5 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h5><p>通常每个类中的成员变量可以分为<strong>类变量（static修饰的变量）以及实例变量</strong>。</p>
<ul>
<li><p>针对这两种类型的变量赋初值的时机是不同的：</p>
<ul>
<li>类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值。</li>
<li>实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。</li>
</ul>
</li>
<li><p>即：类变量有<strong>两个时机赋初值</strong>，而实例变量则可以有<strong>三个时机赋初值</strong>。</p>
</li>
</ul>
<p>当final变量未初始化时系统不会进行隐式初始化，会出现报错。这样说起来还是比较抽象，下面用具体的代码来演示。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-768017317b5fab78.png" alt="final修饰成员变量"></p>
<p>看上面的图片已经将每种情况整理出来了，这里用截图的方式也是觉得在IDE出现红色出错的标记更能清晰的说明情况。现在我们来将这几种情况归纳整理一下：</p>
<ol>
<li><strong>类变量</strong>：必须要在<strong>静态初始化块</strong>中指定初始值或者<strong>声明该类变量时</strong>指定初始值，而且只能在这<strong>两个地方</strong>之一进行指定；</li>
<li><strong>实例变量</strong>：必须要在<strong>非静态初始化块</strong>，<strong>声明该实例变量</strong>或者在<strong>构造器中</strong>指定初始值，而且只能在这<strong>三个地方</strong>进行指定。</li>
</ol>
<h5 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h5><p>final局部变量由程序员进行显式初始化，如果final局部变量已经进行了初始化则后面就不能再次进行更改，如果final变量未进行初始化，可以进行赋值，<strong>当且仅有一次</strong>赋值，一旦赋值之后再次赋值就会出错。下面用具体的代码演示final局部变量的情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-7077bdb169d4d1c3.png" alt="final修饰局部变量"></p>
<p>现在我们来换一个角度进行考虑，final修饰的是基本数据类型和引用类型有区别吗？</p>
<blockquote>
<p><strong>final基本数据类型  VS final引用数据类型</strong></p>
</blockquote>
<p>通过上面的例子我们已经看出来，如果final修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果final是引用数据类型了？这个引用的对象能够改变吗？我们同样来看一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在声明final实例成员变量时进行赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Person person = <span class="keyword">new</span> Person(<span class="number">24</span>, <span class="number">170</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对final引用数据类型person进行更改</span></span><br><span class="line">        person.age = <span class="number">22</span>;</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们对final修饰的引用数据类型变量person的属性改成22，是可以成功操作的。</p>
<p>通过这个实验我们就可以看出来：</p>
<ul>
<li><p><strong>当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。</strong></p>
</li>
<li><p><strong>而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>宏变量</strong></p>
</blockquote>
<p>利用final变量的不可更改性，在满足一下三个条件时，该变量就会成为一个“宏变量”，即是一个常量。</p>
<ol>
<li>使用final修饰符修饰；</li>
<li>在定义该final变量时就指定了初始值；</li>
<li>该初始值在编译时就能够唯一指定。</li>
</ol>
<p>注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p><strong>重写？</strong></p>
</blockquote>
<p>当父类的方法被final修饰的时候，子类不能重写父类的该方法，比如在Object中，getClass()方法就是final的，我们就不能重写该方法，但是hashCode()方法就不是被final所修饰的，我们就可以重写hashCode()方法。我们还是来写一个例子来加深一下理解：<br>先定义一个父类，里面有final修饰的方法test();</p>
<pre><code>public class FinalExampleParent &#123;
    public final void test() &#123;
    &#125;
&#125;</code></pre><p>然后FinalExample继承该父类，当重写test()方法时出现报错，如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210518221631629.png" alt="image-20210518221631629"></p>
<p>通过这个现象我们就可以看出来<strong>被final修饰的方法不能够被子类所重写</strong>。</p>
<blockquote>
<p><strong>重载？</strong></p>
</blockquote>
<pre><code>public class FinalExampleParent &#123;
    public final void test() &#123;
    &#125;

    public final void test(String str) &#123;
    &#125;
&#125;</code></pre><p>可以看出被final修饰的方法是可以重载的。经过我们的分析可以得出如下结论：</p>
<p><strong>1. 父类的final方法是不能够被子类重写的</strong></p>
<p><strong>2. final方法是可以被重载的</strong></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p><strong>当一个类被final修饰时，表名该类是不能被子类继承的</strong>。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用final修饰。还是来写一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExampleParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类会被final修饰，当子类继承该父类的时候，就会报错，如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-835b66d960e21e2e.png" alt="final类不能继承"></p>
<h3 id="final的例子"><a href="#final的例子" class="headerlink" title="final的例子"></a>final的例子</h3><p>final经常会被用作不变类上，利用final的不可更改性。我们先来看看什么是不变类。</p>
<blockquote>
<p>不变类 </p>
</blockquote>
<p>不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：</p>
<ol>
<li>使用private和final修饰符来修饰该类的成员变量</li>
<li>提供带参的构造器用于初始化类的成员变量；</li>
<li>仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；</li>
<li>如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。</li>
</ol>
<p>JDK中提供的八个包装类和String类都是不可变类，我们来看看String的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>可以看出String的value就是final修饰的，上述其他几条性质也是吻合的。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>（final关键字）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/196a4aa7f029?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/196a4aa7f029?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/" data-id="ckppikued001op0wi3xn75u4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算机网络
        
      </div>
    </a>
  
  
    <a href="/UesugiEr11.github.io/2020/10/08/%E7%AE%97%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>