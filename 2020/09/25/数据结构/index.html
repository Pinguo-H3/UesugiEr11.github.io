<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>数据结构 | Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://uesugier11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910210432530.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910211154393.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907141226830.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908134006968.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909171343270.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910151328344.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913182644224.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913211912842.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913212252808.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914214153713.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917221620390.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924161616748.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924190753703.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200925211651494.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924171609555.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924172108383.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005180356129.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/927750-20191124112314705-322764513.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004160328789.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027131924221.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029222130128.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030112007435.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030130346848.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030135230070.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031202611983.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031210034522.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031212019514.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201106182812384.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004161742293.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004172342276.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009174019820.png">
<meta property="article:published_time" content="2020-09-25T13:25:56.311Z">
<meta property="article:modified_time" content="2020-11-06T10:49:05.238Z">
<meta property="article:author" content="Erii">
<meta property="article:tag" content="数组">
<meta property="article:tag" content="链表">
<meta property="article:tag" content="栈">
<meta property="article:tag" content="队列">
<meta property="article:tag" content="树">
<meta property="article:tag" content="字符串">
<meta property="article:tag" content="图">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910210432530.png">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-09-25T13:25:56.311Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>估算程序指令的执行次数/执行时间</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul>
<li>估算程序指令所需占用的存储空间</li>
</ul>
<h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>有了时间复杂度，空间复杂度，那么究竟该用什么来表示其大小呢？我们因此衍生了一种表示方式——<strong>大O表示法</strong></p>
<p>什么是大O表示法呢？表示的是数据规模n对应的复杂度</p>
<ul>
<li>公式:T(n) = O( f(n) )<ul>
<li>n为数据规模，即是函数中变量n</li>
<li>f(n)为代码总执行次数与数据规模关系</li>
<li>T(n)为代码执行时间</li>
</ul>
</li>
</ul>
<p>判断方式:</p>
<ul>
<li><p>由于在一个程序中可能由多个函数组成，其大O是多个复杂度累计的，那么我们只需要关心最复杂的那个即可，因此我们需要去：<strong>忽略常数，系数，低阶</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量阶O(1)) &lt; 对数阶O(logn) &lt;  线性阶O(n) &lt; 线性对数阶O(nlogn) &lt; 平方阶O(n²)...立方阶O(n³)...k方阶 &lt; 指数阶O(2^n) &lt; 阶乘阶O(n!) &lt;n的n次方阶级O(n^n)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><ul>
<li>线性表是具有N个相同类型元素的有限序列（N&gt;=0）</li>
</ul>
<p>（数组，链表，栈，队列，哈希表/散列表）</p>
<h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><ul>
<li>数组是一种<strong>顺序存储</strong>的线性表，所有元素的内存地址是<strong>连续</strong>的<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910210432530.png" alt="image-20200910210432530"></li>
</ul>
<h3 id="ArrayList动态数组"><a href="#ArrayList动态数组" class="headerlink" title="ArrayList动态数组"></a>ArrayList动态数组</h3><ul>
<li>ArrayList函数接口<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910211154393.png" alt="image-20200910211154393"></li>
</ul>
<h4 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">// 缺省容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 缺省空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 元素数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 实际元素大小，默认为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 最大数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><h6 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时我们创建的ArrayList对象中的elementData长度是1，size为0，只有当第一次进行add时候，elementData变成默认长度10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h6 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h6><ul>
<li>传参构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//参数大于等于0，就用那个参数，否则抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Collection对象 构造</li>
<li>下文提到了一个概念：<strong>深拷贝和浅拷贝</strong> 关于这个的话可以看这个：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94dbef2de298">https://www.jianshu.com/p/94dbef2de298</a> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将collection对象转换成数组，然后将数组的地址的赋给elementData。</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//大于 0 则用Arrays.copy方法，把collection对象内容拷贝到elemD</span></span><br><span class="line">    <span class="comment">//ps：这里是深拷贝，意思是只复制了内容而不是地址，意思是原来的东西变化并不会影响到我复制后的</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假如size = 0 直接把空对象地址给elemD</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h6><ul>
<li><strong>带参数的add方法</strong></li>
<li><strong>不带参数的add方法</strong></li>
</ul>
<h3 id="LeetCode-数组相关"><a href="#LeetCode-数组相关" class="headerlink" title="LeetCode-数组相关"></a>LeetCode-数组相关</h3><ul>
<li>首先我们要明白用数组解题，或者题目中牵扯到数组的优势与劣势与特点</li>
<li>优势：我们是知道数组的首末索引的，可以方便我们查找遍历</li>
<li>劣势：由于数组每个位置上都有东西，我们有时候插入删除有点麻烦</li>
</ul>
<h4 id="LeetCode-88-合并两个有序数组"><a href="#LeetCode-88-合并两个有序数组" class="headerlink" title="LeetCode 88.合并两个有序数组"></a>LeetCode 88.合并两个有序数组<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907141226830.png" alt="image-20200907141226830"></h4><p>采用了双指针的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p3 = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[p3--] = nums2[p2--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[p3--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt;= nums2[p2])&#123;</span><br><span class="line">                nums1[p3--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[p3--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p1，p2各自指向数组中最后一个数据；p3指向合并后最后一个位置；</p>
<p>当p1,p2遍历完各自的数组时，结束循环。</p>
<p>当如果p1（下标）&lt;0，意味着第一个数组遍历完了，那么就p3指向的位置存放p2的数据，反之则存放p1的数据。</p>
<p>如果p1指向数据大于p2指向数据，那么p3指向位置存放p1的数据，反之则存放p2的数据。</p>
<h4 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode 75.颜色分类"></a>LeetCode 75.颜色分类<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908134006968.png" alt="image-20200908134006968"></h4><p>采用三指针解法，一个用于记录索引，一个头指针，一个尾指针<br>如果是0，则给left，如果是1则不变，如果是2则给right<br>遍历的结果保证了:left左边全是0（不包括left），right右边全是2（不包括right）;</p>
<p>当i &gt; right了，则断，否则要把刚交换得到的1，2交换回去了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i++] = nums[left];</span><br><span class="line">                nums[left++] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="comment">//换过来的right代表的数可能是0，因此i是不能++的</span></span><br><span class="line">                nums[i] = nums[right];</span><br><span class="line">                nums[right--] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977.有序数组的平方"></a>LeetCode 977.有序数组的平方</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909171343270.png" alt="image-20200909171343270"></p>
<p>本来简单点，可以直接把他们全部平方了，然后用sort直接排序，但是那样就没意思了。</p>
<p>同样使用三指针，一个记录索引，一个左指针，一个右指针。</p>
<p>由于是从小到大排序，因此索引要在最右边向左走。</p>
<p>终止条件:当left与right交错时；</p>
<p>假如左指针的数值+右指针数值&gt;0，那么代表右指针数组更大，此时这个位置应该填右指针数值的平方，反之填左指针数值的平方；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> i = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[left] + A[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans[i--] = A[right]*A[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i--] = A[left]*A[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LeeCode-面试题16-16-部分排序"><a href="#LeeCode-面试题16-16-部分排序" class="headerlink" title="LeeCode 面试题16.16. 部分排序"></a>LeeCode 面试题16.16. 部分排序</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910151328344.png" alt="image-20200910151328344"></p>
<p>首先我们看看问题 要求 n - m 尽量最小，意思是要找到符合要求的左端点中最大的，和符合要求的右端点中最小的。那么又有个问题，什么叫符合要求呢？</p>
<p>首先，对于一个数，假如其左边数都比他小，右边数都比他小，就不包含在需要排序的部分内。</p>
<p>那么符合要求即，对于<strong>左端点m</strong>来说，其右边存在一个<strong>小于他的数</strong>；反之，对于<strong>右端点n</strong>来说，其左边存在一个<strong>大于他的数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span> , -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//正向遍历一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt;= max)&#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反向遍历一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length -<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= min)&#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left , right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表（List）"><a href="#链表（List）" class="headerlink" title="链表（List）"></a>链表（List）</h2><h3 id="链表概念"><a href="#链表概念" class="headerlink" title="链表概念"></a>链表概念</h3><ul>
<li>由于动态数组有个明显缺点：可能会造成内存的大量浪费。那么有没有一种方法能做到——我们用多少空间就申请多少内存呢？当然有，就是用<strong>链表</strong>了！</li>
<li>链表是一种<strong>链式存储</strong>的线性表，其元素的内存地址不一定是连续的。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913182644224.png" alt></li>
</ul>
<h3 id="LeetCode-链表相关"><a href="#LeetCode-链表相关" class="headerlink" title="LeetCode-链表相关"></a>LeetCode-链表相关</h3><ul>
<li>首先明白链表解题的特点/优势/劣势</li>
<li>优势：链表的连接方式是通过next指针，因此我们只需要修改指向即可轻松的插入与删除</li>
<li>劣势：链表不存在索引这一说，因此我们要查找某个特定元素，只能通过遍历，不能直接找到</li>
<li>特点：我们常常会使用多指针进行操作</li>
</ul>
<h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913211912842.png" alt="image-20200913211912842"></p>
<p>采用新建一个链表的解法，可以有效解决假如头节点就是要删除的元素带来的麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newhead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        newhead.next = head;</span><br><span class="line">        ListNode tmp = newhead;</span><br><span class="line">        <span class="keyword">while</span>(tmp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.next.val == val)&#123;</span><br><span class="line">                tmp.next = tmp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86.分割链表"></a>86.分割链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913212252808.png" alt="image-20200913212252808"></p>
<p>这题比较简单，用两条链表分别保存小于x的和大于等于x部分。然后最后把两条链表一拼就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存小于x的链表</span></span><br><span class="line">        ListNode fronthead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p1 = fronthead;</span><br><span class="line">        <span class="comment">//保存大于等于x的链表</span></span><br><span class="line">        ListNode backhead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p2 = backhead;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                p1.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = backhead.next;</span><br><span class="line">        <span class="keyword">return</span> fronthead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914214153713.png" alt="image-20200914214153713"></p>
<p>这道题其实有点脑筋急转弯的味道。</p>
<p>我们想想 假如各有一个指针分别在A链表和B链表同时出发，假如他们最后能在某一点相交，那么意味着什么，是不是代表着他们行走的总路程是一样的？（因为每次只走一格，相当于速度相同，而时间又相同，那么速度X时间就是路程了）</p>
<p>假如没有相交呢？那么代表着各个指针走了一遍A又走了一遍B，最后走到了null，代表没有交点咯。</p>
<p>好了 代码如下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span>) ? headB : p1.next;</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span>) ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指Offer-24-反转链表"><a href="#剑指Offer-24-反转链表" class="headerlink" title="剑指Offer 24.反转链表"></a>剑指Offer 24.反转链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png" alt></p>
<p>所谓的单链表反转，就是把每个节点的指针域由原来的指向下一个节点变为指向其前一个节点。</p>
<p>但是单链表并没有一个指向前一个节点的指针域，因此准备一个指针pre用于存储每个节点前一个节点</p>
<p>还需要一个指针next保存当前下一个节点。</p>
<p>在遍历过程中：先保存要修改的节点的下一个节点（很关键 顺序不能错咯）然后修改当前节点的下一个指向，然后把pre指针和head指针都向后移动即可。最后返回的是pre 这也不能搞错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png" alt="image-20200915193926482"></p>
<p>这道题的解法综合性很强（在我看来）</p>
<p>整体思路:用快慢指针方法找到中间结点，然后将后半部分链表翻转过来，然后将所得的链表与原链表前半部分进行比较</p>
<p>其中快慢指针就不讲了，翻转链表怎么翻转呢？详情请看 <strong>剑指Offer 24.反转链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//偶数的话就是前者情况 奇数就是后者情况</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转后半部分链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != pre.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917221620390.png" alt="image-20200917221620390"></p>
<p>这题我的思路是先不管那个进位的事情，先单纯把对应的数加起来放在一个链表上（在这里我假设放在L1上），然后再另外写一个函数去处理那个数</p>
<p>这题其实有个好的地方，就是各链表上的数是<strong>逆序存储</strong>的，相当于加法的时候帮我们自动对齐了。太好了。</p>
<p>那么这道题我们要考虑的其实就四种情况：</p>
<ol>
<li>L1长度 &gt;= L2长度 </li>
<li>L1长度 &lt; L2长度</li>
<li>末位不需要进位（这里的末位其实是头 自己知道就好）</li>
<li>末位需要进位（这里的末位其实是头 自己知道就好）</li>
</ol>
<p>其中第一种情况其实是最好解决的，就一个末位假如大于10进位就好了。</p>
<p>第二种的方法我们可以把提前结束的地方直接接l2上，也可以解决</p>
<p>第三种末位不需要进位就不说了</p>
<p>第四种需要进位，就在新建一个头，放进位的1就ok</p>
<p>假如你问我 为什么进位肯定是1啊？你想想..最大就是9+9=18 肯定是1啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1.val += p2.val;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//l2长度大于l1 那么直接把p2接p1后面 而且因为没了 直接break</span></span><br><span class="line">            <span class="keyword">if</span>(p1.next == <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1.next = p2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        func(l1);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                head.val = head.val%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//假如是末位 大于10 那么就需要新建一个头 放1用</span></span><br><span class="line">                    head.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                head.next.val += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><h3 id="栈概念"><a href="#栈概念" class="headerlink" title="栈概念"></a>栈概念</h3><h3 id="栈源码分析"><a href="#栈源码分析" class="headerlink" title="栈源码分析"></a>栈源码分析</h3><h3 id="LeetCode-栈相关"><a href="#LeetCode-栈相关" class="headerlink" title="LeetCode-栈相关"></a>LeetCode-栈相关</h3><h4 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a>面试题 03.02. 栈的最小值</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924161616748.png" alt="image-20200924161616748"></p>
<p>这题可以用双栈的方法去解，分为主栈和副栈；</p>
<ul>
<li><p>主栈：和正常的栈一样进行<strong>push&amp;pop</strong>；</p>
</li>
<li><p>副栈：对我们<strong>push和pop的值进行特判</strong>，假如符合才进行相应操作，副栈维护着一个特殊的序列；</p>
</li>
</ul>
<p>那么对于本题，我们的副栈有着什么特殊的地方呢？</p>
<ol>
<li>我们所要<strong>push的值</strong>必须要小于/等于此时的栈顶元素</li>
<li>我们所要<strong>pop的值</strong>必须是辅助栈的栈顶元素我们才让辅助栈也pop，只有这样我们才能保证pop掉留下的元素是其次第二小，第三小…的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; MainStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; Helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        MainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(!Helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Helper.peek()&gt;=x)&#123;</span><br><span class="line">                Helper.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Helper.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = MainStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp == Helper.peek())&#123;</span><br><span class="line">            Helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  MainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Helper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924190753703.png" alt="image-20200924190753703"></p>
<p>引入概念 <strong>单调栈</strong></p>
<ul>
<li>单调递增栈：栈中数据<strong>出栈</strong>的序列为单调递增序列</li>
<li>单调递减栈：栈中数据<strong>出栈</strong>的序列为单调递减序列</li>
</ul>
<p>ps：这里不需要保证在栈中的元素要保持单调递增/递减的顺序</p>
<p>那么这题怎么用单调栈的方法来解呢？准确的说用单调递增栈的方法来解呢？</p>
<p>这题的意思就是找到每个位置离他最近的那个比他大的数，那么我们遇到比自己小的就存栈里，碰到一个大的就把自己栈顶的数据弹出来与当前的下标进行减法运算，即为差值，也就是我们需要等待的日子。</p>
<p>不要忘了，当前遍历到的这个数也有可能比之前没弹出来的数要大，所以要while（）挨个看看，而不是if（）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(T.length == <span class="number">0</span> || T.length == <span class="number">1</span> || T == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造栈</span></span><br><span class="line">        Stack&lt;Integer&gt; helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//答案数组</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; T.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//记得这里是while不是if，因为遇到了一个大的有可能比之前的没弹出来的也要大，要都判断一次;</span></span><br><span class="line">            <span class="keyword">while</span>(! helper.isEmpty() &amp;&amp; T[helper.peek()] &lt; T[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> day = helper.pop();</span><br><span class="line">                ans[day] = i - day;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            helper.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指Offer09-用两个栈实现队列"><a href="#剑指Offer09-用两个栈实现队列" class="headerlink" title="剑指Offer09.用两个栈实现队列"></a>剑指Offer09.用两个栈实现队列</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200925211651494.png" alt="image-20200925211651494"></p>
<p>这题其实比较简单，一个栈正常存，另一个用来维护成队列的特性即可；</p>
<p>在push数据的时候<strong>S1</strong>正常存，然后假如要删了把第一个栈存储数据逆序存在<strong>S2</strong>中，然后再pop<strong>S2</strong>的数据出去即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="comment">//初始化栈，一个用于正常存，一个是辅助栈;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常存</span></span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假如s2有数据</span></span><br><span class="line">        <span class="keyword">if</span>(!s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如s2没数据，s1有数据，就把s1数据存进来</span></span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty() &amp;&amp; !s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如s2没数据，s1没数据，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(s1.isEmpty() &amp;&amp; s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列概念"><a href="#队列概念" class="headerlink" title="队列概念"></a>队列概念</h3><h3 id="LeetCode-队列相关"><a href="#LeetCode-队列相关" class="headerlink" title="LeetCode-队列相关"></a>LeetCode-队列相关</h3><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924171609555.png" alt="image-20200924171609555"></p>
<p>这道题分析一下，我们的窗口随着移动，前面先进来的数要先被窗口卡在外面，那么符合先进先出，是队列；</p>
<p>我们要考虑一个区间内的最大值，又有一点栈的味道，那到底这题要用哪种呢，能不能都用呢？</p>
<p>由此，我们可不可以有一种数据结构是包含了队列的（FIFO）和栈的（FILO）的特点的呢？</p>
<p><strong>双向队列</strong>：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924172108383.png" alt="image-20200924172108383"></p>
<p>我们遍历数组，把数组放在队列中，而且我们的头要保证是每一趟中最大的，把头的值给到我们的结果数组，遍历完成后，我们的结果数组也形成了。</p>
<p>那么解决这道题，我们首先要形成题目中的”窗口”：用L和R分别表示左右边框。</p>
<ul>
<li>R=i，就是遍历的下标</li>
<li>L=i-k+1，也就是右边框减去窗口的宽再加1</li>
</ul>
<p>我们遍历途中，遇到了一个数，假如我们之前的数值都是小于该数的，那么全部弹出，并且保存该数，判断该数有没有被窗口卡住，假如此时已经形成窗口了，就把该数赋给我们的结果数组。</p>
<p>我们这有个问题：为什么我们的双向队列不直接存数呢？直接把那个数给数组不是更简单，为什么要多此一举，存下标，然后再把该下标放进数组里，把值传过去呢？</p>
<p>好问题，因为我们要判断我们的队首元素有没有被窗口卡在外面，而去判断有没有卡在外面依据，就是我们的下标与下标进行比较，只要符合了，就把该下标所在的值赋予结果数组即可；而反过来，我们存放数据的话，就要用map映射去找下标，然后比较，不是更麻烦吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//建立一个双向队列存储窗口的下标，而不是值;</span></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用i代表当前滑窗的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ; i &lt; nums.length ; i++) &#123;</span><br><span class="line">                <span class="comment">//为了保证从小到大，把之前小于现在遍历到的值的数全部弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加当前值对应的数组下标</span></span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                <span class="comment">//判断该值所在的下标是否被窗口卡在外面</span></span><br><span class="line">                <span class="keyword">if</span>(queue.peekFirst() &lt;= i - k)&#123;</span><br><span class="line">           		    queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//假如此时的窗口长度刚好成型或已经成型的时候，保存当前窗口最大值</span></span><br><span class="line">                <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    result[i - k + <span class="number">1</span>] = nums[queue.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005180356129.png" alt></p>
<p>看到这种最长上升，我下意识想到了单调栈的解法，但后来写了发现有些地方的pop很繁琐，那么我就想到了另一种方法，<strong>单调队列</strong>；</p>
<p>我们用一个数组去维护成一个单调队列，保证其是单调递增的，在遍历数组的时候，如果遇到比尾部的数字还大的，那么就肯定比队列前面已经存在的数字都要大，那么就直接插入在尾部；如果碰到了比尾部小的，我们找到前面第一个比他大的位子，替换掉；</p>
<p>这里有个巧妙地方法就是引入了二分法去找该插入的位子，关于二分的话在算法篇我们再详细讲讲左右区间选择问题和最后到底用左端点还是右端点，这里学问还是有很多的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不停更新这个数组 维护一个伪队列 保持其单调递增</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//len+1就是最长的序列了</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存放第一个数 用于后续比较</span></span><br><span class="line">        a[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，如果大于单调队列的尾部 就直接加入尾部</span></span><br><span class="line">        <span class="comment">//如果小于的话 就找到第一个比他比他大的数，把它换掉，保留了后续增长的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//如果比尾部大，直接加尾部</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; a[len]) &#123;</span><br><span class="line">                a[++len] = nums[i];</span><br><span class="line">                <span class="comment">//否则用二分找位子</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = len + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//如果这个数过大 那么就换右区间找</span></span><br><span class="line">                    <span class="keyword">if</span>(a[m] &lt; nums[i]) l = m + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//反之 换左区间</span></span><br><span class="line">                    <span class="keyword">else</span> r = m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了 退出循环 替换数字</span></span><br><span class="line">                a[r] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><p>（二叉树，AVL树，红黑树，B树，堆，Trie哈夫曼树，并查集）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/927750-20191124112314705-322764513.png" alt="img"></p>
<h2 id="LeetCode-树相关"><a href="#LeetCode-树相关" class="headerlink" title="LeetCode-树相关"></a>LeetCode-树相关</h2><ul>
<li>我们可以先不考虑整个树应该怎么解，可以考虑假如就三个结点（根 左子树 右子树）这个时候应该怎么求解，然后把这个解题思路放大 映射到整个树结构；</li>
<li>树解题一般都要用到递归的方法 那么就要明白递归最重要的三部曲</li>
<li>递归的终止条件</li>
<li>每一层递归要进行什么处理</li>
<li>每一层递归的返回值是什么</li>
</ul>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004160328789.png" alt="image-20201004160328789"></p>
<ul>
<li><p>这题要点在于，是不是把是不是子树问题转换成了是不是同树问题；</p>
<p>判断同树的方法就算：要么都为空，要么值相等，其他情况肯定都不是同树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果子树为空 肯定是主树的子树了</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果主树为空，由于此题的子树一定部位空，那么就不属于子树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断一下 此时是否是同树</span></span><br><span class="line">        <span class="keyword">if</span>(isSametree(s,t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//返回要么是左子树要么右子树，否则就都不是</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSametree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处都为空，都遍历到头了 就有可能是树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//一个未空一个不为空，肯定不是同树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//值不同，不可能为同树</span></span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断左边和右边</span></span><br><span class="line">        <span class="keyword">return</span> isSametree(s.left, t.left) &amp;&amp; isSametree(s.right, t.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027131924221.png" alt="image-20201027131924221"></p>
<p>首先要明确什么最近公共祖先的概念，不然你遍历的时候做什么处理都不清楚</p>
<ul>
<li><p><mark>最近公共祖先</mark>：<strong>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先；或者是一个结点本身就是p或者q，其左子树或右子树出现了q或者p，那么p/q本身就是最近的公共祖先</strong></p>
</li>
<li><p>递归的终止条件：比叶子结点还深的话就返回null，假如现在的root就是p/q的话就返回root，用于后续判断；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：由于要遍历整个树，因此每一层递归应该开启左右子树的递归，因此我们要把传入的参数由</p>
<p>root 改为 root.left 和 root.right</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：这个其实是这道题的困难点，我们到底该返回什么值?依据又是什么呢？</p>
<p>回到我们这题 <strong>最经公共祖先</strong> 的定义，由于我们的终止条件中可以得到我们下面的返回值，这返回值其实就是我们的判断依据</p>
<p>假如我们的左右子树都有返回值代表着什么?代表我们现在处于的这个根就是我们要找的 <strong>最近公共祖先</strong> 啦</p>
<p>假如都没有 那很可惜 只能返回NULL了</p>
<p>假如有一边不为空 那也不赖了 我们至少找到了用于判断 <strong>最近公共祖先</strong> 的一半条件了，我们就把不为空的那部分返回了，另一部分继续找就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回值就两种情况 要么就是值 要么就是空的 换句话说 假如一个根左右两边返回上来的值都不为空 那么这个跟肯定就是pq的最近公共祖先了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029222130128.png" alt="image-20201029222130128"></p>
<p>如果用递归写，那就没意思了，我们下面试试用迭代来遍历</p>
<p>首先要明白 前序遍历是怎么遍历的：<code>根节点 - 左节点 - 右节点</code></p>
<p>OK，接下来由于我们需要去把遍历出来的结果保存在数组里面返回，那么思路就出来了：</p>
<p>用一个栈去辅助遍历：</p>
<ul>
<li>当前遍历结点不为空，直接加入数组，然后压入栈中，向左子树进发</li>
<li>如果未空，返回之前保存的栈顶，然后遍历右子树（也就是遍历这个未空节点的兄弟节点）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030112007435.png" alt="image-20201030112007435"></p>
<p>同样的，我们来想想中序遍历顺序：<code>左节点 → 根节点 → 右节点</code></p>
<p>我们和前序遍历使用了相同模板，只不过里面的细节变了些:</p>
<ul>
<li>如果遍历的结点不为空，别急着把值加入数组，压入栈中，继续向左子树进发</li>
<li>如果未空，说明到了最左边啦，那首先弹出栈顶（返回上一级）然后把这个值存入数组，同时向右子树进发</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中序遍历：左 → 根 → 右</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030130346848.png" alt="image-20201030130346848"></p>
<p>后序遍历的遍历顺序：<code>左节点 → 右节点 → 根节点</code></p>
<p>看起来比较难以实现吧？那我们换一种思路:</p>
<p>我们知道先序遍历是：<code>根节点 → 左节点 → 右节点</code></p>
<p>那我们如果反过来遍历就是：<code>右节点 → 左节点 → 根节点</code></p>
<p>由于我们先便利的左节点 再遍历 右节点得到这个结果</p>
<p>那么我们假如先遍历右节点，再遍历左节点：<code>左节点 → 右节点 → 根节点</code> ，这正好是我们后序遍历结果</p>
<p>那么如何实现呢？可以使用头插法来实现第一步，而后调整遍历左右节点顺序来实现第二步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                list.addFirst(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030135230070.png" alt="image-20201030135230070"></p>
<p>这道题由于要返回一个二维数组，可以理解成每个元素里的内容是每一层的左右结点；</p>
<p>那么层次遍历是怎么遍历的呢：根结点 → 左子树A → 右子树 B→ 左子树A的左子树 → 左子树A的右子树 →右子树B的左子树 → 右子树B的右子树……</p>
<p>那就可以用队列来实现啦：</p>
<ul>
<li>先把根结点假如队列中，如果不为空 就加入数组中</li>
<li>判断该结点是否有子树（先判断左 再判断右），有的话加入队列之中</li>
<li>我们可以通过<code>queue.size()</code>得到队列的大小，也就是一层有多少个结点，通过这个就可以知道我们的子数组有几个元素了</li>
<li>在每一次的循环结束后，把我们得到的这一层的子数组都加入我们结果数组即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) queue.offer(cur);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            List&lt;Integer&gt; sublist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (curSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                sublist.add(curr.val);</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                curSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sublist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031202611983.png" alt="image-20201031202611983"></p>
<p>什么叫对称的二叉树?很简单，如果根结点为空 是对称，如果不为空，那么判断其左右子树是否==对称==，如果==对称==，那么这个树是==对称==的；</p>
<p>那么怎么知道他们的左右子树是不是==对称==的呢？很简单，左子树的左孩子与右子树的右孩子==对称==，左子树的右孩子与右子树的左孩子==对称==，那么这个树是对称的…</p>
<p>那么问题又来了…怎么知道他们的…ok，打住，看到这我们已经非常清楚递归的每一步应该干什么了吧？</p>
<ul>
<li><p>递归的终止条件：左结点为空，判断右结点是否为空；右结点为空，判断左结点是否为空；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right == <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left == <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：分别传入新的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：真值【true or false】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> left.val == right.val</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-验证二叉树"><a href="#98-验证二叉树" class="headerlink" title="98.验证二叉树"></a>98.验证二叉树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031210034522.png" alt="image-20201031210034522"></p>
<p>这道题其实让我学到了新知识：那就是二叉搜索树的中序遍历是一个递增的序列；</p>
<p>那么这道题就可以利用这个特性了，解题思路:中序遍历得到一个序列，判断是不是递增的 → 树是不是二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &gt;= list.get(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inOrder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inOrder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031212019514.png" alt="image-20201031212019514"></p>
<p>上面我们学到了怎么把搜索树转换成一个有序数组，那么接下来让我们反着来，把一个有序数组转换成二叉搜索树</p>
<p>二叉搜索树有什么特性？我们再复习一次：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>现在我们的数组是一个==有序数组==，意味着他已经是排序好了的（升序）；也就是选定一个下标，其左边的值一定小于他，其右边的值一定大于他。在其左边的部分和右边部分亦是如此。</p>
<p>那难道我们这个下标可以随便选嘛？不是的，这道题还有个条件：平衡</p>
<ul>
<li><em>平衡要求左右子树高度差的绝对值不超过1。</em></li>
</ul>
<p>那我们就得用二分法，把相对高度控制在1了</p>
<ul>
<li><p>递归的终止条件：把二分的终止条件拿来用 → left &gt; right；用于控制相对高度差为1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：首先需要计算出中值，然后创建一个新的节点，把中值交给他，同时数组左半边就是他的左子树了，同理，数组右半边就是它的右子树了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">root.left = biuldBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">root.right = biuldBST(nums, mid + <span class="number">1</span>, right);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：构建二叉树嘛，那返回值自然是结点了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        TreeNode root = biuldBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">biuldBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = biuldBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = biuldBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99.恢复二叉搜索树"></a>99.恢复二叉搜索树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201106182812384.png" alt="image-20201106182812384"></p>
<p>看到二叉搜索树，条件发生想起来：<strong>中序遍历是升序数组</strong></p>
<p>这题要恢复二搜索树，无非就是把升序数组中，影响了升序这个条件的两个值交换即可；</p>
<p>比如一个序列：<code>1、2、3、4、5</code> 他是有序的，而<code>1、3、2、4、5</code>是无序的，其中的2和3就是影响了升序的那两匹<strong>害群之马s</strong></p>
<p>由于少不了要与之前的值进行比较，因此少不了一个pre结点，用于记录上次遍历的结点</p>
<p>又由于要恢复，因此不仅仅要找到这两个值，还需要记录这两个值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上次遍历的结点</span></span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="comment">//第一个错的结点</span></span><br><span class="line">TreeNode first;</span><br><span class="line"><span class="comment">//第二个错的结点</span></span><br><span class="line">TreeNode second;</span><br></pre></td></tr></table></figure>

<p>而要整理出升序数组，需要中序遍历，当然了，在中序的时候应该进行一些操作 去找出那两个奇怪的值；</p>
<p>那么中序遍历中：</p>
<ul>
<li><p>递归的终止条件：结点为空的时候终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：正常中序遍历的同时，需要将上次遍历的结点的值与当前遍历到的结点的值进行比较</p>
<p>如果==pre.val &gt; root.val，即之前结点的值大于当前的==，就pre结点就是第一个出问题的结点</p>
<p>ok，重点来了，为什么<code>second = root</code> 没有在if条件中进行，而是单独的呢？</p>
<p>因为假如我们出问题的两个数值并不相连，比如<code>1、5、3、4、2、6、7</code>序列中出问题的是<strong>5和2</strong>；</p>
<p>first 是 5，没有问题，但假如second = root写在if中，second 就是3了；</p>
<p>因此 当下一次判断出前面的值比后面的值大了，出问题的（second的值）就不是前面那个值（比如说上述序列中的4）</p>
<p>而是后面的root代表的值（比如上面说的2）；因此second才是正确的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">   <span class="keyword">if</span>(first == <span class="keyword">null</span>) first = pre;</span><br><span class="line">   second = root;</span><br><span class="line">&#125;</span><br><span class="line">pre = root;</span><br><span class="line">inOrder(root.right);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>每一层递归的返回值是什么：由于这个函数的功能主要是用于找出结点，也不是建立什么树，因此无须返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上次遍历的结点</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="comment">//第一个错的结点</span></span><br><span class="line">    TreeNode first;</span><br><span class="line">    <span class="comment">//第二个错的结点</span></span><br><span class="line">    TreeNode second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">int</span> temp = first.val;</span><br><span class="line">        first.val = second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="keyword">null</span>) first = pre;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="串结构"><a href="#串结构" class="headerlink" title="串结构"></a>串结构</h1><h2 id="LeetCod-串相关"><a href="#LeetCod-串相关" class="headerlink" title="LeetCod-串相关"></a>LeetCod-串相关</h2><ul>
<li>串的问题一般都需要用到DP的思想去解决</li>
</ul>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004161742293.png" alt="image-20201004161742293"></p>
<p>这题一开始我想到的是用类似于异或运算的方法去解决，用一个数组去表示答案，遍历两个字符串，如果有相同的就消掉为0，最后再遍历一次数组，假如发现有不是0的 代表两个字符串并不是字母异位的。</p>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判 假如字符串长度都不同，也就没有比的必要了</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//为什么是26个呢 因为26个单词嘛 26个多一个保险点</span></span><br><span class="line">        <span class="comment">//都转成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] a1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] a2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="comment">//一个加</span></span><br><span class="line">            arr[a1[i] - <span class="number">97</span>]++;</span><br><span class="line">            <span class="comment">//一个减少</span></span><br><span class="line">            arr[a2[i] - <span class="number">97</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//有不是0的代表没消掉</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来看答案，好像有个方法可以直接排序后直接比较 学到了</p>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] a1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] a2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(a1);</span><br><span class="line">        Arrays.sort(a2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(a1, a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004172342276.png" alt="image-20201004172342276"></p>
<p>看到这种翻转题，我条件反射就想到了用栈，FILO的性质太适合了。</p>
<p>那么怎么用栈呢？整体思路就是：遇到了空格 那么前面肯定是一个单词了，把他push进栈里面；</p>
<p>整个遍历结束后，用一个字符串接受答案，一个接一个pop出来就好；</p>
<p>这题的小细节很多，比如，我们可以在尾部加一个空格方便判断是单词</p>
<p>由于题目要求，保证前面是不能有空格的，那么就得先pop一个出来，再添加后续的单词；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//倒序输出 很自然想到了栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//为了保证判断的一致性 在尾部添加一个空格</span></span><br><span class="line">        s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果遇到空格 发现是一个单词了 就把之前的push</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    stack.push(tmp.toString());</span><br><span class="line">                    <span class="comment">//别忘了重置tmp</span></span><br><span class="line">                    tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没遇到空格 就把遇到的单词拼在一起</span></span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈为空 说明就是个空串</span></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//答案字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//由于末尾的空格是不要的 那么就得先pop掉最上面的</span></span><br><span class="line">        res.append(stack.pop());</span><br><span class="line">        <span class="comment">//遍历栈 不停的加</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            res.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            res.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h1><p>（邻接矩阵，邻接表)</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表概念"><a href="#哈希表概念" class="headerlink" title="哈希表概念"></a>哈希表概念</h2><h2 id="哈希表方法"><a href="#哈希表方法" class="headerlink" title="哈希表方法"></a>哈希表方法</h2><h2 id="哈希表源码-实现"><a href="#哈希表源码-实现" class="headerlink" title="哈希表源码 实现"></a>哈希表源码 实现</h2><h2 id="LeetCode-哈希表相关"><a href="#LeetCode-哈希表相关" class="headerlink" title="LeetCode-哈希表相关"></a>LeetCode-哈希表相关</h2><h3 id="3-无重复的最长字符串"><a href="#3-无重复的最长字符串" class="headerlink" title="3.无重复的最长字符串"></a>3.无重复的最长字符串</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009174019820.png" alt="image-20201009174019820"></p>
<p>一开始看到这题有想到用数组去模拟哈希表，但是想借此机会学习一下哈希表，毕竟从来没有用过哈希表，只听过它和大概用途；</p>
<p>哈希表其实就是用于检查冲突的，然后很多功能都是基于Key和Value映射关系；我们用哈希表做题就是利用了这个特性</p>
<p>那么怎么用哈希表来解决这道题呢？</p>
<ul>
<li>思路：用哈希表存储字符串中每个字符在第几个索引中出现，边遍历边存，假如发现有重复的字符，找到该字符位置，然后<strong>窗口</strong>的左端向右平移一个单位。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果存在了这个字符 就取偏右方的那个</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a[i])) &#123;</span><br><span class="line">                <span class="comment">//map.get返回的是key的索引 为什么要+1呢 是因为假如有重复的字符了 就要向右偏移一位</span></span><br><span class="line">                left = Math.max(left, map.get(a[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//map.put方法 把 a[i]放到i的位子上</span></span><br><span class="line">            map.put(a[i], i);</span><br><span class="line">            ans = Math.max(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckppikue2000np0wicgil77u6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/UesugiEr11.github.io/2020/10/01/JavaWeb/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JavaWeb
        
      </div>
    </a>
  
  
    <a href="/UesugiEr11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>