<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>操作系统 | Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="OS知识点小小总结">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://uesugier11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="OS知识点小小总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908184220320.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909195136530.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170212997.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913173604664.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913161252525.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022162226039.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171719035.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913172420937.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170246761.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170618948.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175632848.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175227658.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171920463.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170458068.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170801720.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170850126.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172008907.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914164420048.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914170157431.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172044943.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914173409746.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161832422.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193349420.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193516137.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916192007658.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193752881.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161752742.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916194852489.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916195133485.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916203322409.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204018353.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161914285.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/31/Aryfbt.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204307618.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161938789.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151351838.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20171208095743596">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213505282.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213530758.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161725493.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005155458987.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919214807617.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215018317.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215955758.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919220556546.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222346641.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222900878.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920180827278.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920181231409.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160937233.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203323774.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203831680.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924204737502.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924205632915.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160746350.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924211536165.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153906850.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153942707.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160710930.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927175523422.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927220306063.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172546935.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154049852.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160633374.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172456487.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928160518569.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171002706.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171026404.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160532798.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171155511.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001164432414.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154151145.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928204830509.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171241240.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154232845.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171306215.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171402041.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153712342.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171447979.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171522562.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163817853.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165136258.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165807840.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171424288.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171711073.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010172704302.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010174404648.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161648794.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171611497.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171629840.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154325305.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154353653.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161600061.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171755001.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001180053003.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154628052.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154719829.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001193612876.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172035911.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172104616.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172255596.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172233221.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201003171220652.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161521827.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172349110.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154801232.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005144635558.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154819601.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151550183.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152354921.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152256817.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161258242.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160523382.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160815845.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161431904.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161437212.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005162732619.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161204191.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163718195.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163838042.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164349602.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164734068.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165031694.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165627506.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161053467.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161135651.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173524434.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173555912.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174950265.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174045837.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174549414.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174614069.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007175748653.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007180105263.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150220842.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145601465.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145627089.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145644629.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145757946.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145938524.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008152411598.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150852742.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008151221693.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153258694.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153117802.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160457079.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009145923563.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009150936475.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009151437016.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009152417463.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160437390.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009153658886.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154244423.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154702673.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009155649878.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009160734369.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221753621.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221808544.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009222819458.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160411857.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010161009559.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163137747.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160329434.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013164419312.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013165458590.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013171208992.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013172103828.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191036437.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191117077.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191223728.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013183938535.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190449917.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190842596.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160304377.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015211348937.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160222327.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155052815.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155506303.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017162252431.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163335963.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163635023.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017164819366.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165013499.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165628159.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165906305.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170134212.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170829341.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019154035820.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019155759288.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019160300060.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019161625044.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019162144683.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160151687.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019163349804.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019165134603.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019170219137.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019171609549.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019202912635.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019203053285.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160101385.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025172149372.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022154324120.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024151157653.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024152935605.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024153201118.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152405530.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024162203398.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/18464438-d40bb24f98b9fcab.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152348367.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025202529712.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152836465.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153507064.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153813924.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153804900.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025171024271.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025194631660.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025200044600.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025201533670.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026171616190.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026154027329.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026161147295.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026162123383.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026163818291.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026165005382.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015213523284.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015214304047.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215116282.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215232038.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160240209.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015220730717.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017150834371.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152832202.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152921895.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029202753739.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029162940481.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029172212611.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029195651658.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205625258.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029220042435.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205653568.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030200249404.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212923663.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212844294.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213124769.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213649586.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030184237366.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030185335274.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030191211411.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202108812.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030193731094.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202052642.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132105189.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101153719062.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101154502336.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101155052393.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101215351728.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125345951.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125517438.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125945650.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102131739128.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132004226.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194047847.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103171557320.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194753217.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195126301.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195845754.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222307176.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222534791.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222721478.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222809031.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210117983.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223441980.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223453210.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110204932034.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110205536840.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210047209.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112201410070.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201217211254729.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110211948655.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110212749873.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110213226336.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195220519.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195928484.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204211931.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213342204.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204626251.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170336498.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170652168.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113174225789.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113172110369.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113173221037.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117204230180.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117210500055.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117211041743.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117212311990.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213253389.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117214435447.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120170855920.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120172927583.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120173654373.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120174129662.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201121130707136.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124220831037.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221136257.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221532748.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124222804765.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124223414879.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211157912.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211417892.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211550210.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211631423.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125215953551.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125213642244.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125214428159.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174955785.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126173619641.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174324167.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174800002.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126205049927.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127165917726.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155825907.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155902299.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127162936159.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175628500.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128170619688.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171229955.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171832768.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128172906549.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174043814.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174540760.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175558729.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182703444.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128180104677.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182645509.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181834131.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181851581.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193846941.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128192121698.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193411250.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161756659.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220130343.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130214951871.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215834935.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215811961.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220114190.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220615924.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202131444915.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222052883.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222059739.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222106107.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222210248.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130223413367.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202130124223.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221506579.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133214862.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133541738.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202134152591.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202135117348.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202215012157.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221208007.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221809697.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202222126442.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202223154354.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161331778.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161549430.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171706471.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203164159076.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165450142.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165501947.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171351378.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180248315.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174336130.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174727508.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174925206.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175015208.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175109971.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175918544.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180225450.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165851742.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203215628038.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204160730604.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204155830464.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204162120223.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163502759.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163508555.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204164935982.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165050655.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165820255.png">
<meta property="article:published_time" content="2020-09-08T03:35:02.615Z">
<meta property="article:modified_time" content="2021-04-22T12:53:06.046Z">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908184220320.png">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-09-08T03:35:02.615Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h1><h2 id="操作系统目标及作用"><a href="#操作系统目标及作用" class="headerlink" title="操作系统目标及作用"></a>操作系统目标及作用</h2><p>现代计算机中的计算机硬件:输入设备+输出设备+存储器+运算器+控制器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908184220320.png" alt="image-20200908184220320"></p>
<ul>
<li>操作系统（Operating System，OS）：是管理计算机硬件与软件资源的系统软件，也是计算机系统的内核与基石。<ul>
<li>操作系统处理管理与配置内存</li>
<li>决定系统资源供需的优先次序</li>
<li>控制输入与输出设备</li>
<li>操作网络与管理文件系统等基本事务</li>
<li>提供一个让用户与系统交互的操作界面</li>
</ul>
</li>
</ul>
<h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的<strong>目标</strong></h3><ol>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ol>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的<strong>作用</strong></h3><ol>
<li>作为用户与计算机硬件系统之间的接口：OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909195136530.png" alt="image-20200909195136530"></li>
<li>作为计算机系统资源的管理者：管理计算机资源，这些资源包括CPU、内存、磁盘驱动器、打印机等。</li>
<li>实现了对计算机资源的抽象：为其他软件软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li>
</ol>
<h2 id="操作系统发展过程"><a href="#操作系统发展过程" class="headerlink" title="操作系统发展过程"></a>操作系统发展过程</h2><h3 id="未配置操作系统计算机系统"><a href="#未配置操作系统计算机系统" class="headerlink" title="未配置操作系统计算机系统"></a>未配置操作系统计算机系统</h3><ol>
<li>人工操作</li>
<li>脱机输入/输出（Off-Line I/O）方式<ol>
<li>脱机IO：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存；</li>
<li>联机IO：在主机的直接控制下进行输入/输出的方式，称为联机输入/输出（On-Line I/O）方式</li>
</ol>
</li>
</ol>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><ul>
<li><p>具体的工作过程是首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给作业；该作业处理完时，又把控制权交给监督程序，再由监督程序把磁带的第二个作业调入内存等等。可以看成是串行的。</p>
</li>
<li><p>优点：解决人机矛盾和CPU与IO设备速度不匹配问题，提高系统资源的利用率和系统吞吐量。</p>
</li>
<li><p>缺点：不能充分的利用系统资源，现很少使用。</p>
</li>
</ul>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li>用户所提交的作业先放在外存上，并排成一个<strong>队列（后备队列）</strong>，由作业调度程序按照一定的算法，从后备队列中选择若干个作业调入内存，使其共享CPU和系统中的各种资源。同时在内存中装入若干程序，这样可以在A程序运行时，利用其IO操作而暂停的CPU空挡时间，再调度另一道程序B运行，同样可以利用B程序在IO操作时调用CPU空档调用程序C运行，<strong>使用多道程序交替运行，始终保持CPU忙碌的状态。</strong></li>
<li><mark>优势</mark>：资源利用率高，使CPU始终处于忙碌的状态，<strong>提高内存的利用率，提高IO利用率</strong>；系统<strong>吞吐量大</strong>（CPU和其资源始终保持忙碌的状态，仅在作业完成时或者运行不下去的时候才切换，系统开销小）。</li>
<li><mark>缺点</mark>：<strong>平均周转时间长，无交互能力。</strong></li>
</ul>
<h3 id="分时系统（Time-Sharing-System"><a href="#分时系统（Time-Sharing-System" class="headerlink" title="分时系统（Time Sharing System)"></a>分时系统（Time Sharing System)</h3><h4 id="分时系统概念"><a href="#分时系统概念" class="headerlink" title="分时系统概念"></a>分时系统概念</h4><p>在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<h4 id="分时系统特征"><a href="#分时系统特征" class="headerlink" title="分时系统特征"></a>分时系统特征</h4><ol>
<li>多路性：多用户同时在各自终端上使用同一CPU。 </li>
<li>独立性：用户可彼此独立操作，互不干扰，互不混淆。 </li>
<li>及时性：用户在短时间内可得到系统的及时回答。 </li>
<li>交互性：用户与系统进行人机对话。 </li>
</ol>
<h3 id="实时系统（Real-Time-System）"><a href="#实时系统（Real-Time-System）" class="headerlink" title="实时系统（Real Time System）"></a>实时系统（Real Time System）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170212997.png" alt="image-20201219170212997"></p>
<h4 id="实时系统概念"><a href="#实时系统概念" class="headerlink" title="实时系统概念"></a>实时系统概念</h4><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<h4 id="实时系统的类型"><a href="#实时系统的类型" class="headerlink" title="实时系统的类型"></a>实时系统的类型</h4><ol>
<li>工业（武器）控制系统</li>
<li>信息查询系统</li>
<li>多媒体系统</li>
<li>嵌入式系统</li>
</ol>
<h4 id="实时任务的类型"><a href="#实时任务的类型" class="headerlink" title="实时任务的类型"></a>实时任务的类型</h4><ol>
<li>周期性实行任务和非周期性实时任务。</li>
<li>硬实时任务和软实时任务。</li>
</ol>
<h4 id="实时任务特征"><a href="#实时任务特征" class="headerlink" title="实时任务特征"></a>实时任务特征</h4><ol>
<li><strong>多任务：</strong>由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。</li>
<li><strong>抢占调度：</strong>真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级，在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。</li>
<li><strong>任务间的通讯与同步：</strong>在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。</li>
<li><strong>任务与中断之间的通信：</strong>尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要在任务级和中断级之间存在通信。</li>
</ol>
<h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913173604664.png" alt="image-20200913173604664"></p>
<h3 id="并发（Concurrence）"><a href="#并发（Concurrence）" class="headerlink" title="并发（Concurrence）"></a>并发（Concurrence）</h3><ul>
<li><p>并行：指两个或多个事件在<strong>同一时刻发生</strong>；</p>
</li>
<li><p>并发：指两个或多个事件在<strong>同一时间间隔内</strong>发生</p>
</li>
<li><p>具体地说：并发指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故在微观上这些程序是分时地交替执行。<br>若计算机系统有多个处理机，这些可以并发执行的程序便可以被分配到多个处理机上，实现并行执行。即利用每一个处理机来处理一个可并发执行的程序。</p>
</li>
<li><p>引入概念<strong>【进程】</strong>：指在系统中能独立运行 并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p>
</li>
<li><p>在一个没有引入进程的系统中，属于同一个应用程序的计算机程序和 I/O程序之间只能是顺序执行，也就是计算机程序执行告一段落后，才允许I/O程序执行；反之，在程序执行I/O操作时，计算程序也不能执行。———–为计算程序和I/O程序分别建立一个进程（Process）后，这两个程序就可以 并发执行。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913161252525.png" alt="image-20200913161252525"></p>
<h3 id="共享（Sharing）"><a href="#共享（Sharing）" class="headerlink" title="共享（Sharing）"></a>共享（Sharing）</h3><ul>
<li>在OS环境下的资源共享或称为资源复用，指的是系统中的资源可供内存中多个并发执行的进程共同使用。  ——-在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。</li>
<li>实现资源共享的两种方式<ul>
<li><strong>互斥共享方式</strong>：系统中的某些资源：如打印机、磁带机等，虽然可以提供给多个进程（线程）使用，但是应规定在一段时间内，只允许一个进程访问该资源。<pre><code>-------“临界资源”：一段时间内只允许一个进程访问的资源</code></pre></li>
<li><strong>同时共享方式</strong>：系统中还有另外一些资源，允许在一段时间内由多个进程“同时”对它们进行访问。  ——这里的“同时”也就是前面讲的在微观下交替进行的。<pre><code>典型的例子：磁盘设备！</code></pre></li>
</ul>
</li>
</ul>
<p>*<em>并发和共享是OS的两个最基本的特征！没有并发和共享就谈不上虚拟和异步； *</em></p>
<h3 id="虚拟（Virtual）"><a href="#虚拟（Virtual）" class="headerlink" title="虚拟（Virtual）"></a>虚拟（Virtual）</h3><p>虚拟和异步是依赖于并发特性的。</p>
<p>所谓虚拟（Virtual）是指通过某种技术把一个物理实体变成为若干个逻辑上的对应物。<br>物理实体是实际存在的东西，逻辑实体是虚的，它并不存在，但是用户却感觉它存在。<br>用于实现虚拟的技术称为虚拟技术，在操作系统中利用了两种方式实现虚拟技术：时分复用技术和空分复用技术。</p>
<h4 id="时分复用技术"><a href="#时分复用技术" class="headerlink" title="时分复用技术"></a>时分复用技术</h4><p>时分复用技术概念:将资源在不同的时间片内分配给各进程以使该资源被重复利用，从而提高资源的利用率。如采用时分复用的虚拟处理机，能够在不同的时间片内处理多个用户的请求，从而使得用户感觉自己独占主机，而处理机在这期间也被充分的利用。</p>
<ol>
<li><strong>虚拟处理机技术</strong>：一台处理机，通过时分复用的方法，能实现同时（宏观上）为多个用户服务，亦即，利用多道程序设计技术，可将一台物理上的处理机虚拟为多台逻辑上的处理机 —- 虚拟处理机。</li>
<li><strong>虚拟设备技术</strong>：通过时分复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备。</li>
</ol>
<ul>
<li><p>这样可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户“同时”访问的共享设备</p>
</li>
<li><p>当一种资源在时间上复用时，不同的程序或用户轮流使用它。时分复用技术通过利用处理及的空闲时间运行其他程序，提高了处理机的利用率</p>
</li>
</ul>
<h4 id="空分复用技术"><a href="#空分复用技术" class="headerlink" title="空分复用技术"></a>空分复用技术</h4><ul>
<li><p>实质上就是每次只把用户程序的一部分调入内存运行，运行完成后将该部分换出，再换入另一部分到内存中执行，通过这样的<strong>置换</strong>功能，实现了用户程序的各个部分分时地进入内存运行。</p>
</li>
<li><p>让同一个频段在不同的空间内得到重复利用。空分复用技术利用存储器的空闲空间分区域分存放和运行其他多道程序，以此来提高内存的利用率。</p>
</li>
</ul>
<p><strong>注意：采用分时复用技术，每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N，同理，采用空分复用技术，一台虚拟设备平均占用的空间必然等于或低于物理设备所拥有空间的1/N</strong></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li><p>由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“走走停停”的方式运行。</p>
<p>对于内存中的每个进程，在何时能获得处理机执行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，<strong>每道程序总共需要多少时间才能完成等等，都是不可预知的</strong>。</p>
<p>进程是以人们不可预知的速度向前推进的，此即进程的<strong>异步性</strong>。</p>
</li>
</ul>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022162226039.png" alt="image-20201022162226039"></p>
<h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><p>操作系统关于进程方面管理任务有如下几种：<strong>进程控制</strong>，<strong>进程同步</strong>，<strong>进程通信</strong>，<strong>调度</strong></p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul>
<li>为作业创建进程、撤销（终止）已结束的进程，控制进程在运行过程中的状态转换。</li>
</ul>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ul>
<li>为了使多进程同时运行时协调，有两种方式<ul>
<li><strong>进程互斥方式</strong>：进程在对临界资源进行访问时，应采用互斥方式。（<strong>临界资源加锁实现，关锁时禁止访问；锁开时允许访问。</strong>）</li>
<li><strong>进程同步方式</strong>：相互合作去完成共同任务的进程间，由同步机构对他们的执行次序加以协调。（<strong>信号量机制</strong>）</li>
</ul>
</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul>
<li>实现相互合作进程之间的信息交换。</li>
</ul>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ol>
<li><strong>作业调度</strong>：从后备队列中按照一定算法选择出若干个作业，为他们分配运行所需资源，讲作业调入内存后，分别建立与之对应的进程，使它们成为可能获得处理机的就绪进程，并将他们插入就绪队列中。</li>
<li><strong>进程调度</strong>：从进程就绪队列中按照一定算法选出一个进程，将处理机分配给他，并为他设置运行现场，使其投入执行。</li>
</ol>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>内存管理主要功能：<strong>内存分配</strong>，<strong>内存保护</strong>，<strong>地址映射</strong>，<strong>内存扩充</strong></p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ol>
<li><strong>作用</strong>：为每道程序分配内存空间；提高存储器利用率，尽量减少内存空间碎片。</li>
<li><strong>两种内存分配方式</strong>：<ol>
<li><strong>动态内存分配</strong>：每个作业所要求的基本内存空间也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。</li>
<li><strong>静态内存分配</strong>：每个作业的内存空间是在作业装入时确定的；在作业装入后的整个运行期间，不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”。</li>
</ol>
</li>
<li><strong>内存分配机制应具有的结构和功能</strong>：内存分配数据结构、内存分配功能、内存回收功能。</li>
</ol>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><ol>
<li><strong>主要作用</strong>：确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；绝不允许用户程序访问操作系统的程序和数据；也不允许用户程序转移到非共享的其它用户程序中去执行。</li>
<li><strong>内存保护机制</strong>：设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。系统对每条指令所要访问的地址进行检查，如果发生越界，产生越界中断请求，停止该程序的执行。</li>
</ol>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><ul>
<li>程序的逻辑地址通常从0开始，而物理地址不从0开始，因此需要一个映射转换过程。主要功能即为：将地址空间的逻辑地址转换为内存空间与之对应的物理地址。</li>
</ul>
<h4 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h4><ol>
<li>借助于虚拟存储技术，从逻辑上去扩充内存容量。</li>
<li>为了能在逻辑上扩充内存，系统必须具有内存扩充机制，用于实现下述各功能：<ol>
<li><strong>请求调入功能</strong>:允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向 OS 发出请求，由 OS 从磁盘中将所需部分调入内存，以便继续运行。</li>
<li><strong>置换功能</strong>：若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内存。</li>
</ol>
</li>
</ol>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><ul>
<li><strong>主要任务</strong>：<ul>
<li>完成用户进程提出的I/O请求；为用户进程分配其所需的I/O设备；</li>
<li>提高CPU和I/O设备的利用率；提高I/O速度；方便用户使用I/O设备。</li>
</ul>
</li>
<li>为此，设备管理应具有<strong>缓冲管理</strong>、<strong>设备分配</strong>和<strong>设备处理</strong>等功能。</li>
</ul>
<h4 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h4><ul>
<li>CPU运行的高速性和I/O低速性间的矛盾自计算机诞生时起便已存在。<br>如果在I/O设备和CPU之间引入缓冲，则可有效地缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量。<br>因此，在现代计算机系统中， 都毫无例外地在<strong>内存中设置了缓冲区</strong>，而且还可通过<strong>增加缓冲区容量的方法，来改善系统的性能</strong>。</li>
</ul>
<h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><ul>
<li>设备分配的基本任务，是根据用户进程的I/O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。如果在I/O设备和CPU之间，还存在着设备控制器和I/O通道时，还须为分配出去的设备分配相应的控制器和通道。</li>
</ul>
<h4 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h4><ul>
<li>设备处理程序又称为设备驱动程序。基本任务是<strong>用于实现CPU和设备控制器之间的通信</strong>，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作；反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。</li>
<li>处理过程是：设备处理程序首先检查I/O请求的合法性，了解设备状态是否是空闲的，了解有关的传递参数及设置设备的工作方式。然后向设备控制器发出I/O命令，启动I/O设备去完成指定的I/O操作。</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件管理的主要任务是对<strong>用户文件和系统文件进行管理以方便用户使用</strong>，<strong>并保证文件的安全性。</strong><br>为此，文件管理应具有对<strong>文件存储空间的管理</strong>、<strong>目录管理</strong>、<strong>文件的读/写管理</strong>以及<strong>文件的共享与保护等功能。</strong></li>
</ul>
<h4 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h4><ul>
<li>由文件系统对诸多文件及文件的存储空间，实施统一的管理。其主要任务是<strong>为每个文件分配必要的外存空间</strong>，提高外存的利用率，进而提高文件系统的存、取速度。</li>
<li>为此，系统中应设置用于记录<strong>文件存储空间使用情况的数据结构</strong>，以供分配存储空间时参考，<strong>还应具备对存储空间进行分配和回收的功能</strong>。</li>
</ul>
<h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><ul>
<li>目录管理的主要任务，是为每个文件建立一个目录项，并对众多的目录项加以有效的组织，以实现方便的按名存取。</li>
<li>通常由系统为每个文件建立一个目录项。目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。即用户只须提供文件名， 即可对该文件进行存取。</li>
</ul>
<h4 id="文件的读-写管理"><a href="#文件的读-写管理" class="headerlink" title="文件的读/写管理"></a>文件的读/写管理</h4><ul>
<li>该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。由于读和写操作不会同时进行，故可合用一个读/写指针。</li>
</ul>
<h4 id="文件的共享与保护"><a href="#文件的共享与保护" class="headerlink" title="文件的共享与保护"></a>文件的共享与保护</h4><ul>
<li>防止未经核准的用户存取文件；防止冒名顶替存取文件；防止以不正确的方式使用文件。</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li><p>引题：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171719035.png" alt="image-20200913171719035"></p>
</li>
<li><p>包含关系:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913172420937.png" alt="image-20200913172420937"></p>
</li>
</ul>
<h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><ul>
<li>为了方便用户<strong>直接/间接</strong>控制自己的作业，操作系统提供了<strong>命令接口</strong>，该接口又分为<strong>联机用户接口</strong>、<strong>脱机用户接口</strong>和<strong>图形用户接口</strong>3种</li>
</ul>
<h5 id="联机用户接口"><a href="#联机用户接口" class="headerlink" title="联机用户接口"></a>联机用户接口</h5><ul>
<li><strong>用户说一句，系统做一句。</strong>用户可通过先后键入不同命令的方式，来实现对作业的控制，直至作业完成。</li>
<li><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170246761.png" alt="image-20200913170246761"></li>
</ul>
<h5 id="脱机用户接口"><a href="#脱机用户接口" class="headerlink" title="脱机用户接口"></a>脱机用户接口</h5><ul>
<li><strong>用户说一堆，系统做一堆。</strong>该接口是为批处理<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170618948.png" alt="image-20200913170618948"></li>
</ul>
<h5 id="图形用户接口"><a href="#图形用户接口" class="headerlink" title="图形用户接口"></a>图形用户接口</h5><ul>
<li>采用图形化操作界面。</li>
</ul>
<h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><ul>
<li>由一组系统调用命令（简称系统调用，也称广义指令）组成。</li>
<li>系统调用的目的：<strong>请求系统服务</strong></li>
<li>系统调用/程序接口/程序接口 是<strong>操作系统提供给编程人员的接口</strong> 选C<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175632848.png" alt="image-20200913175632848"></li>
<li><strong>系统调用≠库函数 选A</strong><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175227658.png" alt="image-20200913175227658"></li>
</ul>
<p>注意事项:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171920463.png" alt="image-20200913171920463"></p>
<h2 id="操作系统的运行机制与结构"><a href="#操作系统的运行机制与结构" class="headerlink" title="操作系统的运行机制与结构"></a>操作系统的运行机制与结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>简单这么理解：一个程序要跑，需要调用一定的指令对吧？但是并不是所有指令都能为我们所用，有一些特定指令需要有特定的<strong>权限身份</strong></p>
<p>也就是<strong>处理机状态</strong>，比如说 我要跑一个内核程序，需要调用特权指令，那么我能在用户态下进行吗？显然不可以，需要在核心态中执行。</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>要明白操作系统的运行机制，首先需要有一个关于<strong>指令</strong>的相关知识储备</p>
<p><mark>指令</mark>要与代码区分开，一个代码可能会被翻译成多个机器语言指令</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170458068.png" alt></p>
<p>简单来说，<mark>指令</mark>是让（CPU）能识别、执行的最基本命令（比如加法指令 就是让CPU进行加法运算）</p>
<h4 id="处理机状态"><a href="#处理机状态" class="headerlink" title="处理机状态"></a>处理机状态</h4><p>由于有一些指令涉及到了内核，如果让操作计算机的用户去使用就很危险，于是我们设立了<strong>权限</strong></p>
<p>将处理机分为两种状态，让一些指令只允许特定的状态处理机调用</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170801720.png" alt="image-20201219170801720"></p>
<h4 id="程序状态"><a href="#程序状态" class="headerlink" title="程序状态"></a>程序状态</h4><p>有了两种处理机状态，相应的就有两种程序状态：</p>
<p>也就是<strong>内核程序和应用程序</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170850126.png" alt="image-20201219170850126"></p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172008907.png" alt="image-20201219172008907"></p>
<ul>
<li>操作系统内核是计算机上配置的<strong>底层软件</strong>，是操作系统<mark>最基本、最核心</mark>的部分</li>
<li>实现操作系统内核功能的那些程序我们称之为<strong>内核程序</strong></li>
</ul>
<p>一般来说操作系统的内核可分为以下几部分：</p>
<ol>
<li>时钟管理：实现计时功能</li>
<li>中断处理：实现中断机制</li>
<li>原语<ol>
<li>是一种特殊的程序</li>
<li>处于操作系统最底层，最接近硬件的部分</li>
<li>这种程序的运行具有<strong>原子性</strong>，也就是运行只能够一气呵成，不可中断</li>
<li>运行时间短，使用频繁</li>
</ol>
</li>
<li>为系统资源进行管理的功能<ol>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol>
</li>
</ol>
<h4 id="传统OS结构"><a href="#传统OS结构" class="headerlink" title="传统OS结构"></a>传统OS结构</h4><h5 id="无结构OS"><a href="#无结构OS" class="headerlink" title="无结构OS"></a>无结构OS</h5><ul>
<li>OS的各部分是以最基本的过程存在，每个过程都可随意地调用其他过程</li>
</ul>
<h5 id="模块化结构OS"><a href="#模块化结构OS" class="headerlink" title="模块化结构OS"></a>模块化结构OS</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><ul>
<li>对OS的各部分经过了划分，行程若干个具有一定独立性和大小的模块</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914164420048.png" alt="image-20200914164420048"></p>
<h6 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h6><ul>
<li>模块划分过小→降低本身复杂性，但会引起<strong>模块之间联系过多</strong>，造成系统混乱</li>
<li>模块划分过大→增加模块内部复杂性，使<strong>内部联系增加</strong></li>
<li>内聚性：指模块内部各部分间联系的亲密程度。<strong>内聚性高→模块独立性强</strong></li>
<li>耦合度：指模块间相互联系和相互影响的程度。<strong>耦合度低→模块独立性强。</strong></li>
</ul>
<h6 id="模块接口法的优缺点"><a href="#模块接口法的优缺点" class="headerlink" title="模块接口法的优缺点"></a>模块接口法的优缺点</h6><ul>
<li>优点<ul>
<li>提高OS设计的正确性、可理解性和可维护性</li>
<li>增强OS的可适应性</li>
<li>加速OS的开发过程</li>
</ul>
</li>
<li>不足/存在的问题<ul>
<li>接口规定困难</li>
<li>存在无序性</li>
</ul>
</li>
</ul>
<h5 id="分层式结构OS"><a href="#分层式结构OS" class="headerlink" title="分层式结构OS"></a>分层式结构OS</h5><h6 id="分层式结构概念"><a href="#分层式结构概念" class="headerlink" title="分层式结构概念"></a>分层式结构概念</h6><ul>
<li>目标系统An和裸机系统A0之间有许多层次软件：A1，A2，A3….An-1，使An通过这几层最终能在A0上运行。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914170157431.png" alt="image-20200914170157431"></p>
<h6 id="分层结构的优缺点"><a href="#分层结构的优缺点" class="headerlink" title="分层结构的优缺点"></a>分层结构的优缺点</h6><ul>
<li>优点<ul>
<li><strong>易保证系统的正确性</strong>：自下而上的设计方式使所有设计的决定都是有序的或者说是建立在较为可靠的基础上的，这样比较容易保证整个系统的正确性。</li>
<li><strong>具有易扩充和易维护性</strong>：在系统中增加、修改或替换一个层次中模块或整个层次时，只要不改变相应层次间接口，就不会影响其他层次，这就使得维护和扩充变得easy。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>系统效率降低</strong>：由于层次结构是分层单项依赖的，必须在每层间都建立层次间的通信机制，OS执行一个功能就得由上到下穿越多层次，就会增加系统通信开销，从而导致系统效率降低。</li>
</ul>
</li>
</ul>
<h4 id="客户端-服务端"><a href="#客户端-服务端" class="headerlink" title="客户端/服务端"></a>客户端/服务端</h4><h5 id="客户-服务器模式由来、组成和类型"><a href="#客户-服务器模式由来、组成和类型" class="headerlink" title="客户/服务器模式由来、组成和类型"></a>客户/服务器模式由来、组成和类型</h5><ul>
<li><strong>客户机</strong>：每台客户机都是一个自主计算机，具有一定处理能力，客户进程在其上运行，平时处理一些本地业务，也可以发送一个消息给服务器用以请求某项服务</li>
<li><strong>服务器</strong>：通常是一台规模较大的机器，含有网络文件系统或数据库系统，应能为网上所有用户提供一种或多种服务。</li>
<li><strong>网络系统</strong>：用于连接所有客户机和服务器，实现他们之间通信和网络资源共享的系统</li>
</ul>
<h5 id="客户-服务器之间交互"><a href="#客户-服务器之间交互" class="headerlink" title="客户/服务器之间交互"></a>客户/服务器之间交互</h5><p>一次完整的交互过程可以分成以下四步：</p>
<ol>
<li><strong>客户发送请求消息</strong></li>
<li><strong>服务器接收消息</strong></li>
<li><strong>服务器回送信息</strong></li>
<li><strong>客户机接收消息</strong></li>
</ol>
<h5 id="客户-服务器模式优点"><a href="#客户-服务器模式优点" class="headerlink" title="客户/服务器模式优点"></a>客户/服务器模式优点</h5><ol>
<li>数据的分布处理和存储</li>
<li>便于集中管理</li>
<li>灵活性和可扩充性</li>
<li>便于改编应用软件</li>
</ol>
<p>ps：经常会问到 在微内核OS中，为什么要采用客户/服务器模式？我们答客户/服务器模式的优点即可</p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>为什么要有微内核，肯定是由于<strong>大内核不够好</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172044943.png" alt="image-20201219172044943"></p>
<h5 id="微内核OS的基本概念"><a href="#微内核OS的基本概念" class="headerlink" title="微内核OS的基本概念"></a>微内核OS的基本概念</h5><p>微内核技术——把操作系统中更多的成分和功能放到更高的层次（用户模式）中去运行，而留下一个尽量小的内核，<strong>用它来完成操作系统最基本的核心功能。</strong></p>
<p>基于微内核OS结构是建立在<strong><mark>模块化和层次化</mark></strong>结构的基础上的；</p>
<ol>
<li>足够小的内核：微内核≠一个完整的OS，含有：<ol>
<li>与硬件处理紧密相关的部分</li>
<li>一些较基本的功能</li>
<li>客户和服务器之间的通信</li>
</ol>
</li>
<li>基于【<mark>客户/服务器模式</mark>】<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914173409746.png" alt="image-20200914173409746"></li>
<li>应用”机制和策略分离”原理<ol>
<li>机制：是指在实现某一功能时的具体规定或说原则</li>
<li>策略：在机制的基础上，借助某些参数和算法，用以实现该功能的优化，或达到不同的目标</li>
</ol>
</li>
<li>采用面向对象技术</li>
</ol>
<h5 id="微内核的基本功能"><a href="#微内核的基本功能" class="headerlink" title="微内核的基本功能"></a>微内核的基本功能</h5><p>基于【机制与策略分离】的原理，将机制部分以及与硬件紧密相关的部分放入微内核中。由此微内核通常具有如下几个方面功能：</p>
<ol>
<li>进程（线程）管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ol>
<h5 id="微内核操作系统的优点"><a href="#微内核操作系统的优点" class="headerlink" title="微内核操作系统的优点"></a>微内核操作系统的优点</h5><ol>
<li>提高了系统的可扩展性</li>
<li>增强了系统的可靠性</li>
<li>可移植性强</li>
<li>提供了对分布式系统的支持</li>
<li>新技术——融入了面向对象技术</li>
</ol>
<h5 id="微内核操作系统存在的问题"><a href="#微内核操作系统存在的问题" class="headerlink" title="微内核操作系统存在的问题"></a>微内核操作系统存在的问题</h5><ol>
<li>缺点:微内核操作系统的运行效率相较早期操作系统有所降低</li>
<li>改进方法:可以把一些常用的操作系统基本功能由服务器移入微内核中</li>
</ol>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><ul>
<li>前趋图(Precedence Graph)是指一个有向无循环图，可记为DAG，用于描述进程之间执行的先后顺序</li>
</ul>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><ul>
<li>特征：<ul>
<li><strong>顺序性</strong>：所谓顺序性是指，处理机严格的按照程序所规定的顺序执行，<strong>一个操作的开始必须在其前一个操作结束之后。</strong></li>
<li><strong>封闭性</strong>：所谓封闭性是指，程序在执行的时候<strong>独占全机的资源</strong>。</li>
<li><strong>可再现性</strong>：所谓可再现性是指，只要<strong>初始条件</strong>和<strong>运行环境系统</strong>相同，其<strong>运行结果</strong>一定是一样的。</li>
</ul>
</li>
</ul>
<h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><ul>
<li><p>事实上，只有不存在前趋关系的程序之间才有可能并发执行，否则无法并发执行</p>
</li>
<li><p>特征：</p>
<ul>
<li><strong>间断性</strong>：所谓间断性指的是，由于多个程序对资源的要求产生的制约性，而导致的某一个程序在运行时等待资源的情况。 比如有两个程序都需要使用打印机这个资源，如果其中的一个程序已经占用，而另一个必须等待。这样后者表现出来的就是程序运行时的间断性。</li>
<li><strong>失去封闭性</strong>：所谓失去封闭性指的是，<strong>由于多个程序并发执行会共享资源</strong>，从而导致各个程序运行环境会失去封闭性。</li>
<li><strong>不可再现性</strong>：所谓不可再现性是指相同的输入，由于资源的共享，导致最后的输出结果不同。</li>
</ul>
</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161832422.png" alt="image-20201022161832422"></p>
<h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>程序：是静态的，是一个存放在磁盘里的可执行文件，是一系列的指令集合</p>
</li>
<li><p>进程：是动态的，是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>其中，进程实体包含三部分：<strong>程序段</strong>，<strong>相关的数据段</strong>和<strong>PCB</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193349420.png" alt></p>
</li>
<li><p>程序进程关系:一个程序多次执行会对应多个进程，比如说QQ可以登录三个账号。那么既然都是QQ，那OS是怎么区分不同进程的呢？当进程被创建的时候，OS会为该进程分配一个<strong>唯一的，不重复</strong>的<strong>身份证</strong>——<strong>PID（Process ID，进程ID）</strong><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193516137.png" alt="image-20200916193516137"></p>
</li>
<li><p><strong>进程控制块（PCB）</strong>：OS需要记录进程PID，分配了哪些资源，运行情况，那么这些信息需要记录到哪里呢？答案就是进程控制块——PCB。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916192007658.png" alt="image-20200916192007658"></p>
<ul>
<li>作用：PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。下面是具体作用：<ul>
<li>作为独立运行基本单位的标志：在进程的整个生命周期中，系统总是通过PCB对进程进行控制的，亦即系统是根据 进程的PCB感知该进程的存在的，<strong>所以，PCB是进程存在的唯一标志。</strong></li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步与通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>主要由：<strong>动态性，并发性，独立性，异步性，结构性</strong>组成。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193752881.png" alt="image-20200916193752881"></p>
<h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161752742.png" alt="image-20201022161752742"></p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态有五种:<strong>创建状态，就绪状态，执行状态，阻塞状态，终止状态</strong>；其中<strong>就绪、执行、阻塞</strong>是三种基本状态。</p>
<h4 id="创建态、就绪态"><a href="#创建态、就绪态" class="headerlink" title="创建态、就绪态"></a>创建态、就绪态</h4><ul>
<li><strong>创建状态</strong>:对于处于创建态的进程，当其获得了所需的资源以及对其PCB的初始化工作完成后，便可由创建态转入就绪态</li>
<li><strong>就绪状态</strong>：进程已经处于准备好运行的状态了，只需要CPU临门一脚便可以立即执行。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916194852489.png" alt></p>
<h4 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h4><ul>
<li><strong>运行态</strong>：指进程已经获CPU，其程序正在执行的状态。在单处理机系统中，只有一个进程处于执行状态，而在多处理机系统中，有多个进程处于执行状态。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916195133485.png" alt="image-20200916195133485"></p>
<h4 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h4><ul>
<li><strong>阻塞态</strong>：指正在执行的进程由于发生某事件（I/O请求，申请缓冲区失败等）暂时无法继续执行时的状态，亦即进程的执行收到阻塞。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916203322409.png" alt="image-20200916203322409"></li>
</ul>
<h4 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h4><ul>
<li><p><strong>终止态</strong>：即一个进程达到了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204018353.png" alt="image-20200916204018353"></p>
</li>
</ul>
<h3 id="进程的转换"><a href="#进程的转换" class="headerlink" title="进程的转换"></a>进程的转换</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><ul>
<li>基本的三态模型</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161914285.png" alt="image-20201213161914285"></p>
<h4 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h4><ul>
<li>未引入挂起的五态模型:</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/03/31/Aryfbt.png" alt></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204307618.png" alt="image-20200916204307618"></p>
<p>引起进程状态转换的具体原因如下：</p>
<ul>
<li>NULL→新建态：执行一个程序，创建一个子进程。</li>
</ul>
<ul>
<li><p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
</li>
<li><p>就绪态→运行态：进程被调度</p>
</li>
<li><p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
</li>
</ul>
<ul>
<li><p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
</li>
<li><p>运行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。</p>
</li>
<li><p>阻塞态→就绪态：申请资源被分配，或等待的事件已经发生了</p>
</li>
<li><p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
</li>
</ul>
<ul>
<li>阻塞态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</li>
</ul>
<ul>
<li>终止态→NULL：完成善后操作。</li>
</ul>
<h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><p>接下来，我们引入了两个操作：挂起和激活</p>
<p>当挂起操作作用于某个进程时，该进程将被将被挂起，意味着此时该进程处于静止状态；</p>
<p>假如进程正在执行，他将暂停执行。</p>
<p>假如进程原本就处于就绪状态，则该进程此时暂不接受调度。</p>
<p>与挂起操作对应的就是激活啦。</p>
<ul>
<li>引入挂起后的进程状态转换五态模型:</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161938789.png" alt="image-20201213161938789"></p>
<ul>
<li><p>引入创建和终止——七态模型:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151351838.png" alt="image-20201005151351838"></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20171208095743596" alt="这里写图片描述"></p>
<p>引起进程状态转换的具体原因如下：</p>
<ul>
<li>等待态—→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</li>
<li>挂起等待态—→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态。</li>
<li>挂起就绪态—→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</li>
<li>就绪态—→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</li>
<li>挂起等待态—→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</li>
<li>运行态—→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 CPU，，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</li>
<li>新建态—→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</li>
</ul>
<h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><h3 id="线性方式"><a href="#线性方式" class="headerlink" title="线性方式"></a>线性方式</h3><ul>
<li>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>
</ul>
<h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><ul>
<li>系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213505282.png" alt="image-20200919213505282"></li>
</ul>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213530758.png" alt="image-20200919213530758"></li>
</ul>
<h2 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能；</p>
<p>简单来说，进程控制→实现进程状态转换。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161725493.png" alt="image-20201022161725493"></p>
<ul>
<li><p>简单的流程图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005155458987.png" alt="image-20201005155458987"></p>
</li>
</ul>
<h3 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919214807617.png" alt="image-20200919214807617"></p>
<p>与硬件紧密相关的模块、各种常用的设备的驱动程序以及运行频率较高的模块，安排在紧靠硬件的软件层次中，将它们常驻内存，通常被称为<strong>OS内核</strong>；<strong>也就是OS内核其实本质上是各个模块</strong>。</p>
<h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><ul>
<li>我们知道原语的执行具有原子性，它执行过程只能一气呵成，不允许被打断，那么为什么要一气呵成呢？下图即为解释<strong>，假如不一气呵成，就会导致操作系统某些关键的数据结构信息不统一，就会影响操作系统进行别的管理工作</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215018317.png" alt="image-20200919215018317"></li>
<li>如何实现原语的原子性呢？其实是利用了“<strong>关中断指令</strong>“和”<strong>开中断指令</strong>“;</li>
<li>CPU执行了关中断指令后，不会再check中断信号，直到遇到了开中断指令才会再去check；</li>
<li>因此关——开中断之间的指令是连续的，不可中断的，这就实现了原子性；<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215955758.png" alt="image-20200919215955758"></li>
</ul>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>创建原语：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配所需的资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ol>
<p>哪里会用到进程创建呢？</p>
<ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919220556546.png" alt="image-20200919220556546"></p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>终止/撤销原语:</p>
<ol>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若该进程正在运行，立刻剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程所拥有的所有资源还给父进程或操作系统</li>
<li>删除PCB</li>
</ol>
<p>哪里会用到进程终止呢？</p>
<ol>
<li>正常结束：进程自己请求终止</li>
<li>异常结束：非法使用特权指令</li>
<li>外界干预：用户自己选择杀某进程</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222346641.png" alt="image-20200919222346641"></p>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p>被什么事件所阻塞就会被该事件所唤醒</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222900878.png" alt="image-20200919222900878"></p>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p>切换原语:</p>
<ol>
<li>将<strong>运行环境信息</strong>存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>进程所需的运行环境</strong></li>
</ol>
<p>这里有一个地方：<strong>进程所需的运行环境</strong>是什么东西呢?</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920180827278.png" alt="image-20200920180827278"></p>
<p>首先回顾一下我们程序是如何运行的：是通过把我们的代码保存到硬盘然后转入内存，然后CPU去从内存中读取一条条指令，然后我们的程序就跑起来了。</p>
<p>那么CPU中有个东西 叫做<strong>寄存器</strong>。它们有不同的功能，<strong>比如可以存放下一条指令地址，也可以存放正在执行的指令，也可以保存暂时运算得到的结果</strong>；</p>
<p>然而我们知道寄存器并不是很专一的，他有可能会随时被其他的进程使用，那我们之前运算的结果啊，什么保存的指令啊，岂不是都不见了吗？</p>
<p><strong>这个时候就会用到我们的PCB了</strong>，它能够保持关键的一些信息，也就是运行环境，这样等我们的寄存器又空闲下来了的时候，我们就可以继续我们未完成的指令啦。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920181231409.png" alt="image-20200920181231409"></p>
<h2 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160937233.png" alt="image-20201022160937233"></p>
<h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><p>首先，我们回顾一下我们之前学的进程异步问题，由于并发执行的进程以<strong>各自独立，不可预知速度</strong>向前推进，我们所得到的结果往往也会不一样，而我们往往有时候需要控制一个事件的发生在一个事件前，那么就需要<strong>进程同步</strong>啦</p>
<p>同步也称为<strong>直接制约关系</strong>，是指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的<strong>制约关系</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203323774.png" alt="image-20200924203323774"></p>
<p>有进程同步就有进程互斥，那么进程互斥又是什么呢？</p>
<p>要明白互斥，就引入了一个概念：<strong>临界资源</strong></p>
<ul>
<li><strong>临界资源</strong>，即一个时间段内只允许一个进程使用的资源。对于该资源我们必须互斥的访问，也就是我访问，你不能访问，反之亦然；因此</li>
<li><strong>进程互斥</strong>，即指当一个进程访问某临界资源时，另一个想访问此<strong>临界资源</strong>的进程<strong>必须要等待</strong>，只有当我正在访问该资源的进程访问结束了，释放掉了，下一个进程才能去访问该资源。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203831680.png" alt="image-20200924203831680"></p>
<p>那么我们一般是如何进行对临界资源的访问的呢?<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924204737502.png" alt="image-20200924204737502"></p>
<ul>
<li>进入区：负责检查是否可以进入临界区（上锁）</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区：用于将临界区正被访问的标志恢复为未被访问的标志</li>
<li>剩余区：做其他处理</li>
</ul>
<p>ps：临界区是进程中访问临界资源的代码段；<strong>进入区</strong>和退出区是<strong>负责实现互斥</strong>的代码段；<strong>临界区</strong>也被称为”<strong>临界段</strong>“</p>
<h3 id="同步机制遵循的规则"><a href="#同步机制遵循的规则" class="headerlink" title="同步机制遵循的规则"></a>同步机制遵循的规则</h3><ul>
<li>空闲让进：多中选一</li>
<li>忙则等待：互斥访问</li>
<li>有限等待：避免死等</li>
<li>让权等待：避免忙等</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924205632915.png" alt="image-20200924205632915"></p>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>让硬件同步即为进程互斥的硬件实现方法：<strong>中断屏蔽方法，TestAndSet，Swap指令</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160746350.png" alt="image-20201022160746350"></p>
<h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><ul>
<li>在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924211536165.png" alt="image-20200924211536165"></p>
<h4 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h4><p>简称TS指令，也有称TestAndSetLock指令，或TSL指令</p>
<p>用TS指令管理临界区的时候，为每个临界资源设置一个布尔变量lock；</p>
<p>用lock的布尔值就可以判断资源是否空闲，进程能否访问。</p>
<ul>
<li>优点:实现简单；适用于多处理机的环境</li>
<li>缺点:不满足让权等待</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153906850.png" alt="image-20201005153906850"></p>
<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>有的地方称为Exchange指令，或XCHG指令；Swap指令用硬件实现，不允许被中断</p>
<p>Swap指令与TS指令在逻辑上其实差不多，但Swap需要两个参数，不需要返回值，TS需要一个共享的变量实现互斥，因此在不同的地方就要用不同的方式去进行进程互斥。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153942707.png" alt="image-20201005153942707"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160710930.png" alt="image-20201022160710930"></p>
<h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927175523422.png" alt="image-20200927175523422"></p>
<p>由于之前的措施方案无法实现进程的“让权等待”问题，因此我们引出了信号量这个概念进行解决；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927220306063.png" alt="image-20200927220306063"></p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><ul>
<li>Dijkstra把整型信号量定义为一个用于表示资源数目的整形量S，它仅能通过P\V操作进行访问。（P\V 即 wait ＆ signal）这两个操作是原子操作，是不可以在执行过程中被中断的。</li>
<li>整形信号量存在的问题:不满足让权等待原则</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172546935.png" alt="image-20201204172546935"></p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><ul>
<li><p>对于每次的<strong>wait</strong>操作，意味着进程请求一个单位的该类资源，使系统中可供分配的<strong>该类资源数减少一个</strong>，因此描述为<strong>S→value–;</strong>当<strong>S→value &lt; 0</strong>时，表 示该类<strong>资源已分配完毕</strong>，因此进程应调用<strong>block原语进行自我阻塞</strong>，放弃处理机，<strong>并插入到信号量链表S→list中</strong>；</p>
</li>
<li><p>对于每次的<strong>signal</strong>操作，意味着执行<strong>进程释放一个单位资源</strong>，使<strong>系统中可供分配的该类资源数增加一个</strong>，故<strong>S→value++操作表示资源数目+1</strong>。若+1后还是<strong>S→value &lt;= 0</strong>,表示在该信号量链表中<strong>仍有等待该资源的进程被阻塞了</strong>，故应该调用<strong>wakeup</strong>原语，将<strong>S→list链表中的第一个等待进程</strong>唤醒。(被唤醒进程从阻塞态→就绪态)</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154049852.png" alt="image-20201005154049852"></p>
</li>
</ul>
<p>ps：记录型信号量可实现进程互斥、进程同步；如果出现了P(S),V(S)的操作，除非默认说明，默认S为记录型信号量</p>
<h4 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160633374.png" alt="image-20201022160633374"></p>
<h5 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172456487.png" alt="image-20201204172456487"></p>
<ul>
<li>为使得<strong>多个进程互斥访问某临界资源</strong>【目的】，为该资源设置 <strong>互斥信号量【mutex】</strong>，初始值为1</li>
<li>将该资源置于P、V操作之间；</li>
<li>注意：利用信号量机制去实现进程互斥时必须保证我们的P\V操作是成对出现的<ul>
<li>缺少P会导致系统混乱，不能保证对临界资源互斥访问</li>
<li>缺少V将会使临界资源永远不被释放，导致临界资源永远不被释放，从而使因等待该资源的阻塞的进程不能被唤醒</li>
</ul>
</li>
</ul>
<h5 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h5><ul>
<li>进程同步：要让各并发进程按要求有序地推进</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928160518569.png" alt="image-20200928160518569"></p>
<p>现在P1,P2并发执行，由于存在异步性，二者交替推进次序无法控制，是不确定的；</p>
<p>假如我P2的代码4需要用到P1的代码1、2、3运行结果才能执行的话，我就得保证代码4是在代码3后执行；</p>
<p>此即进程同步问题：<strong>让本异步并发的进程互相配合，有序推进。</strong></p>
<p>重点：在前操作之后执行V（S），在后操作之前执行P（S）； </p>
<p><mark>技巧口诀</mark>：前P后V</p>
<p>理解：信号量S表示某种资源，一开始没有这种资源；一开始的时候P2需要使用该资源，但是没有，只能由P1来产生（释放）该资源</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171002706.png" alt="image-20201204171002706"></p>
<h5 id="实现前趋关系"><a href="#实现前趋关系" class="headerlink" title="实现前趋关系"></a>实现前趋关系</h5><p>每一对的前趋关系都是一个进程同步的问题（为了保证一前一后的操作）</p>
<p>为了实现这个目标，我们需要做的事情</p>
<ol>
<li>为每一对前趋关系各设置一个同步信号量</li>
<li>在【<strong>前操作</strong>】的之后<strong>相对应的</strong>同步信号量执行<strong>V</strong></li>
<li>在【<strong>后操作</strong>】的之前<strong>相对应的</strong>同步信号量执行<strong>P</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171026404.png" alt="image-20201204171026404"></p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160532798.png" alt="image-20201022160532798"></p>
<h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><ul>
<li>为什么要引入管程？因为信号量机制存在一定的问题:编写程序困难，容易出错（那是肯定的，这么多PV操作，想不错都难）因此我们在1973年引入管程机制进行处理；</li>
</ul>
<h4 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h4><p><strong>代表资源的数据结构</strong>以及由对该共享数据结构实施操作的一组过程<strong>所造成的资源管理程序</strong>共同构成了一个<strong>操作系统的资源管理模块</strong>——<strong>管程</strong>。</p>
<p>管程是一种特殊的软件模块，由以下部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的一组过程（就是函数）</li>
<li>对局部于管程的共享数据设置初始值的语句【对数据结构初始化的语句】</li>
<li>管程有一个名字</li>
</ol>
<p>发现了吗，管程和我们面向对象的<strong>类</strong>有点相似——可以定义一些数据，可以定义一些对这些数据操作的函数，对属性初始化的语句。</p>
<h4 id="管程的基本特征"><a href="#管程的基本特征" class="headerlink" title="管程的基本特征"></a>管程的基本特征</h4><ol>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<p>什么意思呢？通过<strong>1+2</strong>我们可以知道，假如我们要<strong>修改管程内的数据结构</strong>，我们只能够通过调用<strong>管程内封装好的方法（函数）</strong>去修改数据结构；而<strong>3则实现了进程互斥</strong>；</p>
<h4 id="管程中的条件变量"><a href="#管程中的条件变量" class="headerlink" title="管程中的条件变量"></a>管程中的条件变量</h4><p>我们使用管程实现进程同步需要用到同步工具，如wait，signal；</p>
<p>但仅仅有这两个是不够的，我们知道，每次仅能有一个进程进入管程，假如某进程在管程中被挂起或阻塞就得等很久了，那么解决这问题就引入了——<strong>条件变量 condition</strong>。</p>
<p>怎么用呢？管程中对每个条件变量以说明<strong>：condition x，y</strong>；条件变量的操作是wait，signal；</p>
<p>每个<strong>条件变量保存一个链表</strong>，用以记录因为这条件变量所阻塞的所有进程，提供2个操作：</p>
<p><strong>x.wait 和 x.signal</strong></p>
<ul>
<li>x.wait：正在调用管程的进程因为<strong>x条件需要被阻塞或者挂起</strong>，调用<strong>x.wait</strong>将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其他进程可以使用该管程——让出了入口。</li>
<li>x.signal：若正在调用管程的进程<strong>发现x条件发生了变化</strong>，则调用<strong>x.signal</strong>，<strong>重新启动一个因x条件而阻塞或挂起的进程</strong>，如果存在多个这样的进程，则选择一个，如果没有，则继续执行原进程，而不产生任何结果。<ul>
<li>注意了 这与信号量机制的signal操作不能混为一谈，信号量中的signal需要s++操作，信号量改变了。</li>
</ul>
</li>
</ul>
<h4 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h4><p>管程中设置条件变量和等待唤醒操作，以解决同步问题。（condition xxx）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171155511.png" alt="image-20201204171155511"></p>
<ol>
<li>假如两个生产者进程并发执行，依次调用insert过程的话：<ol>
<li>第一个生产者进程可以顺利执行完insert函数</li>
<li>假如在第一个生产者进程还未结束的时候，第二个生产者进程插入进来了，就会把第二个进程阻塞在insert函数后面，排队 </li>
</ol>
</li>
<li>假如两个消费者进程先执行，生产者进程后执行的话：<ol>
<li>第一个进程进来，发现count = 0，那么就执行wait操作，就等待在empty变量相关的队列中</li>
<li>同样的，第二个就排在了empty变量相关的队列中</li>
<li>此时假如有个生产者进程进来了，进行生产，把生产品放在了缓冲区当中，假如发现自己的产品是第一个产品，那么此时有可能有别的消费者进程在等待产品，就执行一个唤醒操作，唤醒一个消费者进程。</li>
<li>然后count- -，同时检查拿走前缓冲区是否是满的，假如之前是满的，那么现在取走了一个，代表着可以再放一个（再由生产者生产一个），那生产者进程需要被唤醒了，就来一个signal（full）操作。</li>
</ol>
</li>
</ol>
<h4 id="Java中类似管程的机制"><a href="#Java中类似管程的机制" class="headerlink" title="Java中类似管程的机制"></a>Java中类似管程的机制</h4><p>Java中，如果用关键字【synchronized】描述一个函数，那么这个函数同一个时间段只能被一个线程调用。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001164432414.png" alt="image-20201001164432414"></p>
<h3 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154151145.png" alt="image-20201005154151145"></p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>缓冲区未空（有产品）V→P消费者消费</li>
<li>缓冲区未满V→P生产者生产</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928204830509.png" alt="image-20200928204830509"></p>
<h5 id="问题的解法步骤"><a href="#问题的解法步骤" class="headerlink" title="问题的解法步骤"></a>问题的解法步骤</h5><ol>
<li>关系分析，找出题目中描述的各个进程，分析他们之间的同步、互斥关系</li>
<li>根据各进程的操作流程去确定P、V的大致顺序</li>
<li>设置信号量，根据题目条件设信号量初值<ol>
<li>互斥信号量初值一般为1</li>
<li>同步信号量的初值看对应的资源初值值（0/n…)</li>
</ol>
</li>
</ol>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ol>
<li>设置好信号量<ol>
<li>互斥信号量 = 1：实现对缓冲区的互斥访问</li>
<li>同步信号量<strong>empty</strong> = n：实现空闲缓冲区的数量</li>
<li>同步信号量<strong>full</strong> = 0：代表产品的数量，也即非空缓冲区的数量</li>
</ol>
</li>
<li>分别在生产者，消费者中放置P、V操作（注意顺序，以及操作的哪个信号量）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171241240.png" alt="image-20201204171241240"></p>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><ul>
<li>想一想 能不能改变相邻P、V操作的顺序呢？</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154232845.png" alt="image-20201005154232845"></p>
<p>得出结论了：<strong>实现互斥的P操作必须放在实现同步的P操作之后；</strong>由于<strong>V操作并不会导致进程阻塞，因此两个V操作顺序可以交换</strong>；</p>
<h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171306215.png" alt="image-20201204171306215"></p>
<p>注意 这里的多生产者的多 代表的不是数量 而是多个类型</p>
<h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li>互斥关系:对缓冲区(盘子)的访问要互斥的进行</li>
<li>同步关系：父亲放苹果，女儿才能取苹果；母亲放橘子，儿子才能取橘子；盘子为空时，父/母才能放水果，因此需要儿/女进行从盘子取水果；</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序<ul>
<li>实现互斥:在临界区前后分别P、V</li>
<li>实现同步:前操作后V，后操作前P</li>
</ul>
</li>
<li>设置信号量</li>
</ul>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><ul>
<li>实现互斥访问盘子:mutex = 1</li>
<li>多少个苹果 apple = 0</li>
<li>多少个橘子 orange = 0</li>
<li>盘子中还能放多少水果 plate = 1</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171402041.png" alt="image-20201204171402041"></p>
<p>以父亲和女儿举例：</p>
<p>父亲首先应该P盘子，查看是否为空，如果为空，则V苹果（苹果++)；女儿首先P苹果，查看是否准备好了，有的话就取出，V盘子（盘子++)；为了保证互斥，必须在P、V操作之中加入对互斥信号量mutex 的 P、V操作。</p>
<h5 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h5><p>可不可以不要互斥信号量mutex？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153712342.png" alt="image-20201005153712342"></p>
<p>由于缓冲区大小为1，因此orange，apple，plate三者中最多只有一个是1；这样的话最多只有一个进程的P操作不会被阻塞，可以顺利进入临界区，因此可以顺利执行；</p>
<p>那么假如缓冲区（plate）数量为2呢？</p>
<p>那么父亲和母亲都能访问盘子，有可能出现不同进程写入缓冲区的数据相互覆盖的问题；</p>
<p>得出结论:如果<strong>缓冲区的大小大于1</strong>，那么就必须<strong>专门设置一个互斥信号量mutex</strong>来保证互斥的访问缓冲区</p>
<h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171447979.png" alt="image-20201204171447979"></p>
<h5 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li>同步关系:桌上有组合1→第一个抽烟者取走；组合2→第二个抽烟者取走；组合3→第三个抽烟者取走</li>
<li>互斥关系:桌子只有一个，可以理解为容量为1的缓冲区需要互斥访问</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171522562.png" alt="image-20201204171522562"></p>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><ul>
<li>桌上组合1、2、3分别为 offer1 offer2 offer3，他们的初值都是0</li>
<li>设置一个<strong>信号量i</strong>，用于实现三个抽烟者轮流吸烟</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163817853.png" alt="image-20201010163817853"></p>
<p>以smoker1为例，首先P（offer1）检查是否有需要的组合1，有的话就拿走去抽，并且告诉供给者抽完了，然后供给者i++，p一下finish，并将下一个组合放在桌上然后v下一个组合；</p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165136258.png" alt="image-20201010165136258"></p>
<h5 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li><strong>互斥关系</strong>：<strong>写进程-写进程</strong> <strong>写进程-读进程</strong> 这两者存在互斥关系。而<strong>读进程-读进程</strong>不存在互斥</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量<ul>
<li><strong>一个互斥信号量RW</strong>：写者访问文件的前后执行PV，读者访问前后执行PV</li>
<li><strong>整型变量count</strong> 记录当前有几个读进程在访问文件</li>
<li><strong>一个互斥信号量 mutex</strong> ：保证对count变量的互斥访问</li>
<li><strong>一个互斥信号量 w</strong> ：用于实现写优先</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165807840.png" alt="image-20201010165807840"></p>
<h5 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171424288.png" alt="image-20201010171424288"></p>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171711073.png" alt="image-20201010171711073"></p>
<h5 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li><strong>互斥关系</strong>：五位哲学家与左右邻居对其中间筷子的访问是互斥的</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量<ul>
<li><strong>一个互斥信号量组chopstick[5]</strong>：用于实现对五个筷子的互斥访问。其中哲学家编号<strong>[0…4]</strong>，各哲学家i的左边筷子编号为<strong>i</strong>，右边筷子编号为<strong>（i+1）%5</strong></li>
</ul>
</li>
</ul>
<p>然而我们发现 这样子会导致死锁的现象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010172704302.png" alt="image-20201010172704302"></p>
<h5 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h5><p>按照之前的方法会发生死锁现象，那我们怎么解决呢？</p>
<p>有三种方法:</p>
<ol>
<li>最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子；偶数号哲学家相反。这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭的话，只有有其中一个可以拿起第一只筷子，而另一个因为拿不到第一个筷子就直接阻塞了。</li>
<li>仅当一个哲学家左右两只筷子都可用时才允许他抓筷子【这也是后面的<strong>破坏请求和保持条件</strong> 方法】</li>
</ol>
<p>下面以第三种方法为例，进行解决</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010174404648.png" alt="image-20201010174404648"></p>
<h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161648794.png" alt="image-20201022161648794"></p>
<h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><ul>
<li>进程通信是指进程之间的信息交换。</li>
<li>进程所拥有的内存地址空间相互独立，换而言之，进程不能直接访问另一个进程的地址空间，然而有时候有需要信息交换，那该怎么办呢？OS提供了一些方法给我们。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171611497.png" alt="image-20201204171611497"></p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p><strong>前提：两个进程对于共享空间的访问必须是互斥的。</strong></p>
<ul>
<li>基于数据结构共享：各进程公用某些数据结构，实现各进程的信息交换：如生产者-消费者问题中的有界缓冲区。是低级通信方式。</li>
<li>基于存储区共享：在内存中画一片共享存储区，数据形式和存放位置由进程控制而非OS。是高级通信方式。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171629840.png" alt="image-20201204171629840"></p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><ul>
<li>【管道 pipe文件】是指用于连接读写进程的一个共享文件，本质是内存空间中开辟的一个固定大小的缓冲区</li>
<li>管道采取半双工通信，一个时间段内只能实现单向传输；</li>
<li>进程互斥访问管道</li>
<li>管道写满时，写进程的系统调用被阻塞；管道为空时，读进程的系统调用被阻塞</li>
<li>没写满不准读，没读空不准写。</li>
<li>管道数据被读出后被抛弃，意味着读进程最多只能有一个，不然可能会读错数据。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154325305.png" alt="image-20201005154325305"></p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程通过【格式化的消息】为单位，将通信的数据封装在消息中，通过OS提供的发送接收原语，在进程间进行消息传递，完成进程的数据交换。是一种高级通信方式。</p>
<ul>
<li><p><strong>直接通信方式</strong>:发送进程利用OS提供的发送原语直接把消息发给接收进程/消息直接挂到接收方的消息队列中。</p>
</li>
<li><p><strong>间接通信方式/信箱通信方式</strong>:发送进程先发送到中间实体（信箱）中，接受进程再去接收，完成进程间的通信。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154353653.png" alt="image-20201005154353653"></p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161600061.png" alt="image-20201022161600061"></p>
<h3 id="线程的概念和特点"><a href="#线程的概念和特点" class="headerlink" title="线程的概念和特点"></a>线程的概念和特点</h3><ul>
<li>什么是线程?为什么要引入线程?</li>
</ul>
<p>假设现在有三个进程，他们所占用不同的空间内存和系统资源；假如我们要切换进程的时候，需要用保存/恢复运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销非常大，因此，人们引入了<strong>线程机制</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171755001.png" alt="image-20201204171755001"></p>
<ul>
<li>引入了线程之后，线程是<strong>CPU调度</strong>的<strong>基本单位</strong>。一个进程里面可以包含多个线程。线程之间可以并发进行。</li>
<li>但是进程依旧是<strong>资源分配</strong>的<strong>基本单位</strong>，从属一进程的各线程共享使用进程的资源。</li>
<li>同一个进程内各个线程程间并发，不需要切换进程运行环境和内存地址空间，省时省力。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001180053003.png" alt="image-20201001180053003"></p>
<h3 id="引入线程后的变化"><a href="#引入线程后的变化" class="headerlink" title="引入线程后的变化"></a>引入线程后的变化</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154628052.png" alt="image-20201005154628052"></p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154719829.png" alt="image-20201005154719829"></p>
<h3 id="线程的特性与优点"><a href="#线程的特性与优点" class="headerlink" title="线程的特性与优点"></a>线程的特性与优点</h3><ul>
<li><p>进程间并发，开销很大；线程间并发，开销很小</p>
</li>
<li><p>引入线程机制之后，并发带来的系统开销降低，系统并发性提升</p>
</li>
</ul>
<p>ps：从属于不同进程的线程间切换，也会导致进程间切换，开销也会很大。</p>
<ul>
<li>从属于同一进程的各个线程共享进程所拥有的资源。</li>
<li>进程间通信必须请求操作系统服务（CPU需要切换到核心态），开销大；同进程下线程通信，无需OS干预，开销更小；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001193612876.png" alt="image-20201001193612876"></p>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172035911.png" alt="image-20201204172035911"></p>
<ol>
<li><strong>线程的管理工作是由谁完成的？</strong><ol>
<li>答 线程的管理工作由应用程序通过线程库来完成的，不是通过OS完成的</li>
</ol>
</li>
<li><strong>线程切换是否需要CPU从用户态转换为内核态?</strong><ol>
<li>答 在用户态下，由应用程序通过线程库就可以进行线程切换了</li>
</ol>
</li>
<li><strong>OS是否能意识到用户级线程的存在?</strong><ol>
<li>答 意识不到，只有用户能意识到有多个线程</li>
</ol>
</li>
<li><strong>用户级线程有什么优点和缺点？</strong><ol>
<li>答 优点：用户级线程的切换在用户态可以完成，不需要切换到核心态，系统开销小，效率高</li>
<li>缺点：假如其中某一个线程被阻塞了，其他线程都会被阻塞，并发度不高；</li>
</ol>
</li>
</ol>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172104616.png" alt="image-20201204172104616"></p>
<ol>
<li>线程的管理工作由谁来完成?<ol>
<li>答 由OS内核完成</li>
</ol>
</li>
<li>线程切换是否需要CPU从用户态转换到内核态？<ol>
<li>答 由于线程调度、切换工作由内核负责，因此在内核级线程的线程切换时需要从用户态转换到内核态的。</li>
</ol>
</li>
<li>OS能否意识到内核级线程的存在?<ol>
<li>答 OS会为每个内核级线程建立对应TCB，然后通过TCB对线程进行管理，因此，OS能够意识到内核级线程的存在</li>
</ol>
</li>
<li>内核级线程的实现方式的优缺点？<ol>
<li>答 优点:内核级线程是<strong>处理机调度的基本单位</strong>，而进程只作<strong>为资源分配的基本单位</strong>；因此在多核CPU中，这几个线程可以被分配在多个不同cpu中并发执行，其中一个线程被阻塞了，其他的也能正常执行；</li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由OS内核完成，由于用户态到核心态的转换需要开销，因此线程管理成本高，开销大。</li>
</ol>
</li>
</ol>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li><strong>一对一模型</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172255596.png" alt="image-20201204172255596"></p>
<ul>
<li><strong>多对一模型</strong></li>
</ul>
<p>操作系统只能看的见内核级线程，因此只有内核级线程才是处理机分配的单位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172233221.png" alt="image-20201204172233221"></p>
<ul>
<li><strong>多对多模型</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201003171220652.png" alt="image-20201003171220652"></p>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161521827.png" alt="image-20201022161521827"></p>
<h3 id="调度基本概念"><a href="#调度基本概念" class="headerlink" title="调度基本概念"></a>调度基本概念</h3><ul>
<li>当有一堆任务需要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来决定<strong>处理这些任务的顺序</strong>，这就是<strong>调度</strong>所研究的问题，简单来说就是：<strong>按照某种算法选择一个进程将处理机分配给他</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172349110.png" alt="image-20201204172349110"></p>
<h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154801232.png" alt="image-20201005154801232"></p>
<ul>
<li><p><strong>高级调度/长程调度/作业调度</strong>，调度对象为作业；</p>
</li>
<li><p>高级调度主要用于多道批处理系统中，什么是多道批系统呢？虽然前面讲过了 再复习一遍吧：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005144635558.png" alt="image-20201005144635558"></p>
</li>
<li><p>高级调度根据<strong>某种算法/一定的原则</strong>从处于<strong>后备队列</strong>的作业中<strong>挑选一个/多个作业</strong>，分配内存等资源，建立PCB，使他们<strong>获得竞争处理机的权利</strong>。</p>
</li>
<li><p>高级调度是<strong>外存与内存</strong>之间的调度，每个作业只调入一次，调出一次。调入时创建相应PCB，作业调出时又撤销PCB。由于调出的时机一定是作业运行结束的时候，因此<strong>高级调度主要是解决调入的问题</strong>。</p>
</li>
</ul>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154819601.png" alt="image-20201005154819601"></p>
<ul>
<li><p><strong>中级调度/内存调度</strong>，引入这个调度的<strong>目的</strong>是为了<strong>提高内存的利用率和系统的吞吐量</strong>。</p>
</li>
<li><p>引入虚拟存储技术后，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为：<strong>就绪驻外存状态（挂起状态）</strong>，等它们已具备运行条件且内存又稍有空闲时，<strong>由中级调度决定</strong>，重新<strong>调入内存</strong>，<strong>并修改状态为就绪状态</strong>，挂在<strong>就绪队列上等待</strong>。</p>
<p>ps：PCB并不会一起被调到外存，而是常驻内存。<strong>OS</strong>通过<strong>内存中的PCB</strong>保持对各进程的<strong>监控和管理</strong>。</p>
</li>
</ul>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151550183.png" alt="image-20201005151550183"></p>
<ul>
<li><strong>低级调度/进程调度/短程调度</strong>：调度对象是<strong>进程</strong>（或内核级线程）；</li>
<li>主要功能是根据某种<strong>算法/方法/策略</strong>，决定<strong>就绪队列</strong>中哪个进程应该获得处理机，将处理机分配给它。</li>
<li>这种调度方式是OS中<strong>最基本的一种调度</strong>，在<strong>多道批、实时和分时</strong>三种类型OS中<strong>必须</strong>配置这级调度；</li>
<li>低级调度的频率很高，一般几十毫秒一次；</li>
</ul>
<h4 id="三种调度方式的联系、对比"><a href="#三种调度方式的联系、对比" class="headerlink" title="三种调度方式的联系、对比"></a>三种调度方式的联系、对比</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152354921.png" alt="image-20201005152354921">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152256817.png" alt="image-20201005152256817"></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161258242.png" alt></p>
<h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160523382.png" alt="image-20201005160523382"></p>
<ul>
<li><p>这个地方有人会说:那么进程处于临界区时，不能进行处理机调度咯? 这个说法是错的 为什么呢？</p>
<ul>
<li><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源。</li>
<li><strong>临界区</strong>：访问临界资源的那段代码</li>
<li><strong>内核程序临界区</strong>：一般是用来访问某种内核数据结构的（比如进程的就绪队列，由各就绪队列PCB租成）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160815845.png" alt="image-20201005160815845"></p>
</li>
</ul>
<h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><h5 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161431904.png" alt="image-20201005161431904"></p>
<p>在采用这种方式时，可能<strong>引起进程调度的因素</strong>归结为:</p>
<ol>
<li>正在执行的进程运行完毕，或因发生某事件而使其无法再继续执行；</li>
<li>正在执行中的进程因提出I/O请求而暂停执行；</li>
<li>在进程通信/同步过程中，执行某原语操作；</li>
</ol>
<h5 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161437212.png" alt="image-20201005161437212"></p>
<p>抢占<strong>并非是任意</strong>的，必须遵循一定原则。包括：</p>
<ol>
<li><strong>优先权原则：</strong>指允许优先级高的新进程抢占当前进程的处理机；</li>
<li><strong>短进程优先原则：</strong>指允许新的短进程可以抢占当前长进程的处理机；</li>
<li><strong>时间片原则：</strong>即各进程按时间片轮转运行时，当正在执行的进程一个时间片用完时，便停止该进程的执行而重新进行调度；</li>
</ol>
<h4 id="进程调度的切换与过程"><a href="#进程调度的切换与过程" class="headerlink" title="进程调度的切换与过程"></a>进程调度的切换与过程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005162732619.png" alt="image-20201005162732619"></p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161204191.png" alt="image-20201022161204191"></p>
<h6 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163718195.png" alt="image-20201005163718195"></p>
<h6 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163838042.png" alt="image-20201005163838042"></p>
<h6 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164349602.png" alt="image-20201005164349602"></p>
<ul>
<li><p>对于每个用户而言，都希望自己作业的周转时间短一点，然而对于OS，则向作业周转时间平均值小；那么引入了概念：带权周转时间，平均带权周转时间；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164734068.png" alt="image-20201005164734068"></p>
</li>
</ul>
<h6 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165031694.png" alt="image-20201005165031694"></p>
<h6 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165627506.png" alt="image-20201005165627506"></p>
<h4 id="调度算法种类"><a href="#调度算法种类" class="headerlink" title="调度算法种类"></a>调度算法种类</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161053467.png" alt="image-20201022161053467"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161135651.png" alt="image-20201022161135651"></p>
<h5 id="FCFS-先来先服务算法"><a href="#FCFS-先来先服务算法" class="headerlink" title="FCFS-先来先服务算法"></a>FCFS-先来先服务算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173524434.png" alt="    "></p>
<ul>
<li><p>FCFS例题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173555912.png" alt="image-20201007173555912"></p>
</li>
</ul>
<h5 id="SJF-短作业优先算法"><a href="#SJF-短作业优先算法" class="headerlink" title="SJF-短作业优先算法"></a>SJF-短作业优先算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174950265.png" alt="image-20201007174950265"></p>
<ul>
<li><p>SJF例题:</p>
<ul>
<li><p>非抢占式：</p>
<p>在0时刻，只有P1进来了，在他运行的时间7内，P2,P3,P4都进来了，在P1结束后选择运行时间最短的P3执行，后续同理；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174045837.png" alt="image-20201007174045837"></p>
</li>
<li><p>抢占式：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174549414.png" alt="image-20201007174549414">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174614069.png" alt></p>
</li>
</ul>
</li>
</ul>
<h5 id="HRRN-高相应比优先算法"><a href="#HRRN-高相应比优先算法" class="headerlink" title="HRRN-高相应比优先算法"></a>HRRN-高相应比优先算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007175748653.png" alt="image-20201007175748653"></p>
<ul>
<li>HRRN例题：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007180105263.png" alt="image-20201007180105263"></p>
<h5 id="RR时间片轮转调度算法"><a href="#RR时间片轮转调度算法" class="headerlink" title="RR时间片轮转调度算法"></a>RR时间片轮转调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150220842.png" alt="image-20201008150220842"></p>
<ul>
<li><p>RR例题</p>
<ul>
<li><p><mark>时间片大小为2情况<mark>：</mark></mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145601465.png" alt="image-20201008145601465">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145627089.png" alt="image-20201008145627089"></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145644629.png" alt="image-20201008145644629"></p>
<p>最后的运行流程图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145757946.png" alt="image-20201008145757946"></p>
<ul>
<li><p><mark>时间片大小为5情况</mark>：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145938524.png" alt="image-20201008145938524"></p>
</li>
</ul>
</li>
</ul>
<p>补充:</p>
<ul>
<li>时间片太大的影响：如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法会退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>
<li>时间片太小的影响：如果时间片太小，我们知道，进程调度、切换是有时间代价的（保存、恢复运行环境），因此这样的话会导致进程切换过于频繁，系统会花大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。</li>
<li>因此时间片的大小应该取<strong>略大于一次典型交互的时间</strong></li>
</ul>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008152411598.png" alt="image-20201008152411598"></p>
<ul>
<li><p>例题</p>
<ul>
<li><p>非抢占式的优先级调度算法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150852742.png" alt="image-20201008150852742"></p>
</li>
<li><p>抢占式的优先级调度算法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008151221693.png" alt="image-20201008151221693"></p>
</li>
</ul>
</li>
</ul>
<p><strong>extra</strong>：</p>
<ul>
<li>就绪队列未必是只有一个的，可以按照不同优先级来组织；另外也可以把优先级高的进程排在更靠近对头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种；<ul>
<li>静态优先级:创建进程时确定，之后一直不变</li>
<li>动态优先级:创建进程时有一个初始值，之后根据情况动态地调整优先级</li>
</ul>
</li>
<li>如何合理设置各进程优先级呢？通常来说<ul>
<li><strong>系统进程</strong>优先级高于<strong>用户进程</strong></li>
<li><strong>前台进程</strong>优先级高于<strong>后台进程</strong></li>
<li><strong>I/0进程</strong>优先级高于<strong>计算型进程</strong></li>
</ul>
</li>
<li>若采用动态优先级，什么时候该调整？<ul>
<li>如果某进程在<strong>就绪队列中等待</strong>了很久，适当<strong>提升</strong>优先级</li>
<li>如果某进程<strong>占用处理机运行</strong>了很久，适当<strong>降低</strong>优先级</li>
<li>如果发现一个进程<strong>频繁进行I/0操作</strong>，适当<strong>提升</strong>优先级</li>
</ul>
</li>
</ul>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153258694.png" alt="image-20201008153258694"></p>
<ul>
<li><p>例题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153117802.png" alt="image-20201008153117802"></p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160457079.png" alt="image-20201022160457079"></p>
<h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009145923563.png" alt="image-20201009145923563"></p>
<ul>
<li>简单来说，当一组进程发生死锁的情况下，这组<strong>死锁进程中的每个进程</strong>，都在<strong>等待另一个死锁进程所占有的资源</strong>，或者说每个进程所<strong>等待的事件</strong>是该组中<strong>其他进程释放所占有</strong>的<strong>资源</strong>。</li>
</ul>
<h3 id="死锁，饥饿，死循环"><a href="#死锁，饥饿，死循环" class="headerlink" title="死锁，饥饿，死循环"></a>死锁，饥饿，死循环</h3><ul>
<li><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li><strong>饥饿</strong>：由于长期得不到想要的资源，某进程无法向前推进的现象。eg.SPF算法中的如果短进程一直进来，长进程得不到处理机就会饥饿。</li>
<li><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序bug，有时候是故意写出来的。(pv操作)</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009150936475.png" alt="image-20201009150936475"></p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009151437016.png" alt="image-20201009151437016"></p>
<ol>
<li><strong>互斥条件</strong>：在一段时间内，某<strong>资源只能被一个进程所占有</strong>，若<strong>其他进程请求</strong>该资源，那就只能<strong>等待</strong>，直到占有<strong>该资源的进程用完释放</strong></li>
<li><strong>不可抢占条件</strong>：进程<strong>已获得的资源</strong>在<strong>未使用完</strong>之前<strong>不能被抢占</strong>，<strong>只能</strong>在进程使用完时<strong>由自己释放</strong></li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又<strong>提出了新的资源请求</strong>，而该<strong>资源</strong>又被<strong>其他进程占有</strong>，此时请求进程被<strong>阻塞</strong>，但又对自己已有的资源<strong>保持不放</strong>。</li>
<li><strong>循环等待条件</strong>：在发生死锁时，必然存在一个【<strong>进程-资源</strong>】的循环链，即进程集合{P0,P1,P2…..Pn}中：<strong>P0等待P1占用的资源，P1等待P2占用的资源…..Pn等待P0占用的资源</strong>；</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009152417463.png" alt="image-20201009152417463"></p>
<ul>
<li><strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></li>
</ul>
<h3 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>整体思路：破坏死锁产生的四个必要条件中的一个或几个</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160437390.png" alt="image-20201022160437390"></p>
<h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li><strong>破坏策略</strong>：把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li>
<li><strong>缺点</strong>：并不是所有的资源都可以改造成共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性。因此很多的时候是无法破坏互斥条件的。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009153658886.png" alt="image-20201009153658886"></p>
<h5 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h5><ul>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li><strong>破坏策略</strong>：<ul>
<li>当某个进程请求新的资源得不到满足的时候，必须立刻释放保持的所有资源，待以后需要时候再重新申请，即：<strong>即使某些资源尚未用完，也需要主动释放</strong>，从而破坏了不可剥夺条件。</li>
<li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，<strong>将想要的资源强行剥夺</strong>。这种方法需要考虑各进程的优先级。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>实现起来复杂</li>
<li>释放已获得的资源可能造成前一阶段的失效，因此这种方法一般只适用于容易保存和恢复状态的资源（CPU）</li>
<li>反复申请和释放资源增加系统开销，降低系统吞吐量</li>
<li>使用第一个方案，表示只要暂时得不到某资源，前面所获得资源全都得需要放弃，以后再申请。假如这种情况常发生，进程会饥饿。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154244423.png" alt="image-20201009154244423"></p>
<h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><ul>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>破坏策略</strong>：采用静态分配方法，即进程在运行前一次申请完所需要的全部资源，在它资源尚未满足前，不让它投入运行。一旦投入运行，这些资源就一直归他所有，该进程就不会再请求别的任何资源。</li>
<li><strong>缺点</strong>：有些资源可能只需要用很短时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也可能导致某些进程饥饿。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154702673.png" alt="image-20201009154702673"></p>
<p>正因为这种方法缺点太明显，因此衍生出了<strong>第二种方法</strong>:</p>
<p><strong>它允许一个进程只获得初期所需的资源后，便开始运行。在运行过程中逐步释放已分配给自己的、且用毕的全部资源，然后再请求新的所需资源。</strong></p>
<h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><ul>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求</li>
<li><strong>破坏策略</strong>：采用顺序资源分配法<ul>
<li>给系统中资源编号</li>
<li>规定每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同资源）一次申请完</li>
<li>一个进程只有占有了小编号资源才有资格申请大编号资源</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>不方便添加新设备，有可能要重新分配编号嘛</li>
<li>进程实际使用资源顺序可能与编号递增顺序不同，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦（谢谢你啊 还替我考虑那么多</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009155649878.png" alt="image-20201009155649878"></p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><ul>
<li>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
</ul>
<h5 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h5><p><strong>安全序列</strong>：是指如果<strong>系统按照这种序列分配资源</strong>，则<strong>每个进程都能顺利完成</strong>。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能会有多个</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009160734369.png" alt="image-20201009160734369"></p>
<ul>
<li><strong>不安全状态</strong>：如果分配了资源之后系统<strong>找不出任何一个安全序列</strong>，系统就进入了<strong>不安全状态</strong>。意味着之后<strong>可能</strong>所有进程都无法顺利执行下去了。为什么说是可能呢？因为<strong>假如存在进程提前归还了资源</strong>，那么系统也有可能重新<strong>回到安全状态</strong>。</li>
<li><strong>安全状态、不安全状态、死锁</strong><ul>
<li>系统处于<strong>安全状态一定不会发生死锁</strong></li>
<li>系统处于<strong>不安全状态</strong>，<strong>有可能</strong>发生了<strong>死锁</strong></li>
<li>如果发生了<strong>死锁</strong>，<strong>一定</strong>处于<strong>不安全状态</strong></li>
</ul>
</li>
</ul>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><ul>
<li><strong>核心思想</strong>：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求</li>
<li>引例：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221753621.png" alt="image-20201009221753621"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221808544.png" alt="image-20201009221808544"></p>
<p>那么对于上述这个例子，OS是怎么做的呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009222819458.png" alt="image-20201009222819458"></p>
<ul>
<li><p>准备的数据结构:</p>
<ul>
<li><strong>长度为m</strong>的<strong>一维数组Available</strong>表示还有<strong>多少可用资源</strong></li>
<li><strong>n*m矩阵Max</strong>表示各进程对资源的<strong>最大需求数</strong></li>
<li><strong>n*m矩阵Allocation</strong>表示已经给各进程<strong>分配了多少资源</strong></li>
<li><strong>Max  - Allocation = Need 矩阵</strong>表示<strong>各进程最多还需要多少资源</strong></li>
<li><strong>长度为m</strong>的<strong>一维数组Request</strong>表示<strong>进程此次申请的各种资源数</strong></li>
</ul>
</li>
<li><p>银行家算法步骤:</p>
<ul>
<li>检查此次申请是否超过之前声明的最大需求数</li>
<li>检查此次系统剩余的可用资源是否还能满足此次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ul>
</li>
<li><p>安全性算法步骤：</p>
<p>检查当前剩余的可用资源是否能够满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</p>
</li>
</ul>
<p>例题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">     Allocation　　　Max　　　Available</span><br><span class="line"> 　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> P1   ００１４　　  ０６５６　　１５２０　</span><br><span class="line"> P2　 １４３２　　  １９４２　</span><br><span class="line"> P3　 １３５４　  　１３５６</span><br><span class="line"> P4 　１０００　　  １７５０</span><br><span class="line">我们会看到一个资源分配表，要判断是否为安全状态，首先先找出它的Need，Need即Max(最多需要多少资源)减去Allocation(原本已经分配出去的资源)，计算结果如下：</span><br><span class="line"></span><br><span class="line">   NEED</span><br><span class="line"> ＡＢＣＤ</span><br><span class="line"> ０６４２　</span><br><span class="line"> ０５１０</span><br><span class="line"> ０００２</span><br><span class="line"> ０７５０</span><br><span class="line">然后加一个全都为false的字段</span><br><span class="line"></span><br><span class="line"> FINISH</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line">接下来找出need比available小的(千万不能把它当成4位数 他是4个不同的数)</span><br><span class="line"></span><br><span class="line">   NEED　　  Available</span><br><span class="line"> ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> ０６４２　　１５２０</span><br><span class="line"> ０５１０&lt;-</span><br><span class="line"> ０００２</span><br><span class="line"> ０７５０</span><br><span class="line">P2的需求小于能用的，所以配置给他再回收</span><br><span class="line"></span><br><span class="line">  NEED　　   Available</span><br><span class="line"> ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> ０６４２　　１５２０</span><br><span class="line"> ００００　＋１４３２</span><br><span class="line"> ０００２－－－－－－－</span><br><span class="line"> ０７５０　　２９５２</span><br><span class="line">此时P2 FINISH的false要改成true(己完成)</span><br><span class="line"></span><br><span class="line"> FINISH</span><br><span class="line"> false</span><br><span class="line"> true</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line">接下来继续往下找，发现P3的需求为0002，小于能用的2952，所以资源配置给他再回收</span><br><span class="line"></span><br><span class="line"> 　NEED　　    Available</span><br><span class="line"> ＡＢＣＤ　　Ａ　Ｂ　Ｃ　Ｄ</span><br><span class="line"> ０６４２　　２　９　５　２</span><br><span class="line"> ００００　＋１　３　５　４</span><br><span class="line"> ００００－－－－－－－－－－</span><br><span class="line"> ０７５０　　３　12　10　6</span><br><span class="line"></span><br><span class="line">依此类推，做完P4→P1，当全部的FINISH都变成true时，就是安全状态。</span><br></pre></td></tr></table></figure>



<h4 id="检测和解除死锁"><a href="#检测和解除死锁" class="headerlink" title="检测和解除死锁"></a>检测和解除死锁</h4><ul>
<li>允许死锁的发生，不过OS会负责检测出死锁的发生，然后采取某种措施解决死锁</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160411857.png" alt="image-20201022160411857"></p>
<h5 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010161009559.png" alt></p>
<ul>
<li>检测死锁的算法</li>
</ul>
<p>简单来说就是<strong>依次消除与不阻塞进程相连的边</strong>，<strong>直到无边可消</strong>；但你要是非说严谨的话就是下面几步</p>
<ol>
<li>在资源分配图中，找出<strong>既不阻塞又不是孤点</strong>的进程<strong>Pi</strong> （不阻塞—— 所申请的资源数量必须小于等于系统中已有空闲资源数量；不是孤点——与该进程至少有一个边相连）。然后消去它的所有<strong>请求边，分配边</strong>，使之变为孤点</li>
<li>进程Pi释放的资源，可以唤醒某些因为等待这些资源而阻塞的进程——原来<strong>阻塞进程</strong>可能变为<strong>非阻塞进程</strong>；</li>
<li>若剩下进程都能按照如上操作，消去图中所有的边，<strong>所有</strong>的进程结点都变成<strong>孤点</strong>，那称该图是 <strong>可完全简化</strong> 的；反之则称该图是 <strong>不可完全简化</strong>的</li>
</ol>
<ul>
<li>死锁定理：如果某时刻系统的资源分配图是 <strong>不可完全简化</strong>的，那么此时<strong>系统死锁</strong></li>
</ul>
<h5 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163137747.png" alt></p>
<p>解除死锁的方法：</p>
<ol>
<li><strong>资源剥夺法</strong>：挂起某些死锁进程，并抢夺它的资源，将这些资源分配给其他的死锁进程</li>
<li><strong>撤销进程法/终止进程法</strong>：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</li>
<li><strong>进程回退法</strong>：让一个或多个死锁进程回退到足以避免死锁的地步</li>
</ol>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160329434.png" alt="image-20201022160329434"></p>
<ul>
<li><p>什么是内存？内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013164419312.png" alt="image-20201013164419312"></p>
</li>
</ul>
<h3 id="进程运行原理-指令"><a href="#进程运行原理-指令" class="headerlink" title="进程运行原理-指令"></a>进程运行原理-指令</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013165458590.png" alt="image-20201013165458590"></p>
<p>由 x = x + 1这个代码为例，它被编译后为三条指令；</p>
<p>第一条指令是让CPU进行数据传送，把内存单元为<strong>01001111</strong>的数据取出来取到地址为<strong>00000011</strong>的寄存器当中</p>
<p>第二条指令是让地址为<strong>00000011</strong>的寄存器上的数据+1</p>
<p>第三条指令是让CPU进行数据传送，把地址为<strong>00000011</strong>上的数据传送到地址为<strong>01001111</strong>的地方.</p>
<p>于是实现了 x = x + 1操作</p>
<p>ps：上述指令不是严谨的二进制指令，仅供参考。</p>
<h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>由于后续的学习，经常要进行内存之间的运算，而我们的单位往往需要统一，那么接下来就讲讲单位换算</p>
<ul>
<li><p>1B=8b=2^3b</p>
</li>
<li><p>1KB=1024B=2^10B</p>
</li>
<li><p>1MB=1024KB=2^10^KB= 2^20^B</p>
</li>
<li><p>1GB=1024MB = 2^10^MB= 2^20^KB= 2^30^B</p>
</li>
<li><p>1TB=1024GB=2^10^GB= 2^20^MB= 2^30^KB= 2^40^B</p>
</li>
</ul>
<h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>上面的指令操作提到了逻辑地址，那么什么是逻辑地址呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013171208992.png" alt="image-20201013171208992"></p>
<p>eg. 0号同学入住的是房号为5（N=5）的房间，那么3（M=3）号同学入住的就是8（N+M=5+3=8）号房间；</p>
<h3 id="写程序-运行程序"><a href="#写程序-运行程序" class="headerlink" title="写程序-运行程序"></a>写程序-运行程序</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013172103828.png" alt="image-20201013172103828"></p>
<ul>
<li>编辑：程序员编辑代码</li>
<li>编译：代码编译成若干个目标模块（把<strong>高级语言</strong>翻译为<strong>机器语言</strong>）</li>
<li>链接：由链接程序把 <strong>目标模块与所需库函数</strong> 连接在一起，形成一个<strong>完整的装入模块</strong></li>
<li>装入\装载：由<strong>装入程序</strong>将<strong>装入模块装入内存</strong>运行</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><ul>
<li>装入前链接成一个完整装入模块</li>
<li>在程序执行<strong>之前</strong>，先将<strong>目标模块以及它们所需的库函数</strong>连接成一个<strong>完整的可执行文件</strong>（装入模块），之后<strong>不再拆开</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191036437.png" alt="image-20201013191036437"></p>
<h5 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h5><ul>
<li><p>运行前边装入边链接</p>
</li>
<li><p>将各目标模块装入内存时，边装入边链接的链接方式</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191117077.png" alt="image-20201013191117077"></p>
</li>
</ul>
<h5 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h5><ul>
<li>运行时需要目标模块才装入并链接</li>
<li>在程序执行中需要该目标模块时，才对它进行链接。其<strong>优点</strong>是便于<strong>修改和更新</strong>，便于实现对<strong>目标模块的共享</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191223728.png" alt="image-20201013191223728"></p>
<h4 id="装入-装载"><a href="#装入-装载" class="headerlink" title="装入\装载"></a>装入\装载</h4><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5><ul>
<li>编译时产生绝对地址</li>
<li>地址由编译器产生，而不是OS</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013183938535.png" alt="image-20201013183938535"></p>
<h5 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h5><ul>
<li>装入时逻辑地址转换为物理地址/绝对地址</li>
<li>转换过程由装入程序负责进行，装入程序是OS的一部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190449917.png" alt="image-20201013190449917"></p>
<h5 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h5><ul>
<li>运行时将逻辑地址转换为物理地址，并设置重定位寄存器</li>
<li>采用动态重定位方式装入的作业，其地址变换工作是在<strong>每执行一条指令时</strong>完成的</li>
<li>执行中允许<strong>OS有条件地</strong>将其移动</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190842596.png" alt="image-20201013190842596"></p>
<h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160304377.png" alt="image-20201022160304377"></p>
<h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><ul>
<li>OS需要负责内存空间的分配与回收<ul>
<li>记录哪些内存区域已经被分配出去了，哪些又属于空闲状态</li>
<li>当进程运行结束之后，将进程占用的内存空间回收</li>
<li>内存这么大，有很多位置可以放置内存，那么又该怎么分配内存空间？</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015211348937.png" alt="image-20201015211348937"></p>
<h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul>
<li>连续分配：指为用户进程分配的必须是一个连续的内存空间</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160222327.png" alt="image-20201022160222327"></p>
<h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><ul>
<li>在这种分法中，内存被分为系统区和用户区</li>
<li><strong>系统区</strong>：用于存放OS相关数据</li>
<li><strong>用户区</strong>：存放用户进程相关数据</li>
<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>
<li><strong>优点</strong>:实现简单，无外部碎片；</li>
<li><strong>缺点</strong>:只能用于单用户、单任务的OS中，有内部碎片，存储区利用率极低</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155052815.png" alt="image-20201017155052815"></p>
<h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><ul>
<li>固定分区<strong>目的</strong>：为了能在内存中装入多道程序，且这些程序之间又不会相互打扰</li>
<li><strong>如何实现</strong>：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</li>
<li>固定分区分配<strong>有两种方法</strong><ul>
<li>分区大小<strong>相等：</strong>缺乏灵活性，但适合用于用一台计算机控制多个相同对象的场合</li>
<li>分区大小<strong>不等：</strong>增加灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155506303.png" alt="image-20201017155506303"></p>
<p>那么固定分区分配又是如何实现的呢？</p>
<ul>
<li><p>操作系统需要建立一个数据结构 —— <strong>分区说明表</strong>，实现各个分区的分配与回收。每个表象对应一个分区，通常按照分区大小排列。每个表包含对应分区的：<strong>大小、起始地址、状态</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017162252431.png" alt="image-20201017162252431"></p>
</li>
<li><p>当某用户程序要装入内存的时候，由OS内核程序根据用户程序大小检索该表，从中找到一个能满足大小、未分配的分区。将之分配给该程序，然后修改状态为“已分配”</p>
</li>
<li><p><strong>优点</strong>：实现简单，无外部碎片</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>当用户程序太大的时候，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这会降低性能</li>
<li><strong>会产生内部碎片，内存利用率低</strong></li>
</ul>
</li>
</ul>
<h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><ul>
<li><p>动态分区分配又称为可变分区分配。</p>
</li>
<li><p>这种分配方式<strong>不会预先划分内存分区</strong>，而是在<strong>进程装入内存的时候</strong>，根据进程的大小<strong>动态地建立分区</strong>，并使分区的大小正好适合进程的需要。</p>
</li>
<li><p>系统分区的大小和数目是可变的</p>
</li>
<li><p><strong>缺点</strong>：会产生很多外部碎片，虽然可以用【紧凑】技术去处理，但紧凑的时间代价很高</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163335963.png" alt="image-20201017163335963"></p>
</li>
</ul>
<p>下面思考三个问题：</p>
<ol>
<li><p>系统要用什么样的数据结构记录内存的使用情况?</p>
<p>通常使用 <strong>空闲分区表</strong>或者是<strong>空闲分区链</strong></p>
<p><strong>空闲分区表</strong>：每个空闲分区对应一个表项</p>
<p><strong>空闲分区链</strong>：每个分区的起始部分和末尾部分分别设置前向指针和后向指针</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163635023.png" alt="image-20201017163635023"></p>
</li>
<li><p>当很多个空闲分区都能满足需求的时候，应该选择哪个分区进行分配呢？</p>
<p>把一个新作业装入内存的时候，需要按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（空闲分区链）中选出一个分区分配给该作业。</p>
</li>
<li><p>如何进行分区的分配与回收操作？</p>
<p><strong>分配:</strong></p>
<p>在上面的图示中，假如我们把一个4mb进程分配在了20MB处的话，我们只需要修改分区大小和起始地址即可</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017164819366.png" alt="image-20201017164819366"></p>
<p>假如我们分配在了4MB处的话，状态由空闲变为忙碌，则该行应该被删除，假如用空闲分区链的话，就把该节点删除</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165013499.png" alt="image-20201017165013499"></p>
<p><strong>回收</strong>：</p>
<p>假设一开始有个进程占据了14MB处（10+4），跑完了需要回收，<strong>回收区的后面/前面有一个相邻的空闲分区，那么就合并</strong></p>
</li>
</ol>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165628159.png" alt="image-20201017165628159"></p>
<p>   <strong>假如回收区的前、后各有一个相邻的空闲分区的话</strong></p>
<p>   例：在20和10mb中间有一个4mb的进程需要进行回收</p>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165906305.png" alt="image-20201017165906305"></p>
<p>   <strong>假如回收区的前后都没有相邻的空闲分区的话</strong></p>
<p>   假设有一个进程占满了14mb的地方，此进程需要被回收</p>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170134212.png" alt="image-20201017170134212"></p>
<ul>
<li><p>内部碎片，外部碎片</p>
<ul>
<li>内部碎片：位于一个<strong>操作系统分配的用于装载进程的内存区域</strong>或页面内部的空闲区域。</li>
<li>外部碎片：位于任何两个<strong>操作系统分配的用于装载进程的内存区域</strong>或页面之间的空闲区域，可以用紧凑技术进行解决</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170829341.png" alt="image-20201017170829341"></p>
</li>
</ul>
<h6 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h6><ul>
<li><strong>算法思想</strong>:每次都从低地址开始查找，找到第一个能满足大小的空闲分区</li>
<li><strong>如何实现</strong>:空闲分区以<strong>地址递增的次序排列</strong>，每次分配内存的时候顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019154035820.png" alt="image-20201019154035820"></p>
<h6 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h6><ul>
<li><strong>算法思想</strong>:动态分区分配是一种连续分配的管理方式，因此为各进程分配的空间必须也是连续的一整片区域。因此为了保证当大进程进来的时候有能连续的大片空间，可以尽可能多的留下大片空闲区，换句话说，就是大片的先不用，优先的把小空闲区给用了先。</li>
<li><strong>如何实现</strong>:空闲分区按<strong>容量递增次序链接</strong>，每次分配内存的时候顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区</li>
<li><strong>缺点</strong>：会产生很多的<strong>外部碎片</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019155759288.png" alt="image-20201019155759288"></p>
<h6 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h6><p>为了解决上述出现的 产生很多外部碎片 这个问题，我们衍生出了新的与之相对的算法：<strong>最坏适应算法</strong></p>
<ul>
<li><strong>算法思想：</strong>每次分配的时候优先使用最大的连续空闲区，使得分配后剩余的空闲区不会太小，方便使用；</li>
<li><strong>如何实现：</strong>空闲分区<strong>容量递减次序链接</strong>。每次分配内存时候按照顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</li>
<li><strong>缺点</strong>：每次都选最大的分区进行分配，会导致较大的连续空闲区被迅速消耗掉，有大进程来了，就没内存空间可以用了。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019160300060.png" alt="image-20201019160300060"></p>
<h6 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h6><p>我们每次算法讲到最后一个都是综合类的算法，结合了前面算法的特点综合的算法</p>
<p>不例外，我们这次也一样：<strong>临近适应算法</strong></p>
<ul>
<li><strong>算法思想:</strong>回想一下 ，首次适应算法是从链头开始找，低地址部分会出现小的空闲分区（外部碎片），而这些空闲分区部分我们往往用不上，因此会增加查找的开销。那么加入我们查找不从头开始，而是从上次查找结束的位置开始检索（因为后面是还没用到的部分，可以用的几率大点)，就能减少查找开销。</li>
<li><strong>如何实现</strong>：空闲分区以<strong>递增递增的顺序排列</strong>（可排成一个循环链表），每次分配内存的时候从上次查找结束的位置开始查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019161625044.png" alt="image-20201019161625044"></p>
<h6 id="四种算法总结"><a href="#四种算法总结" class="headerlink" title="四种算法总结"></a>四种算法总结</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019162144683.png" alt="image-20201019162144683"></p>
<h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160151687.png" alt="image-20201022160151687"></p>
<h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h6><ul>
<li><p>分页存储管理其实就是将<mark>一个进程</mark>的逻辑地址空间分成若干个大小相等的<strong>片</strong>；</p>
<p>这些<strong>片</strong>称为<strong>页</strong>或者<strong>页面</strong> 从零开始编号</p>
<p>相应的把内存空间分成与页面相同大小的若干个存储块 - 物理块/页框 同样 从0开始编号</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019163349804.png" alt="image-20201019163349804"></p>
<h6 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h6><p>回想我们之前所学的，进程在内存中连续存放的时候，OS是如何实现逻辑地址到物理地址的转换的呢？</p>
<p>是通过<strong>重定位寄存器</strong>去保存 装入模块存放的 <strong>起始位置</strong> + 目标内存单元相对于起始位置的<strong>偏移量</strong></p>
<p>我们就能得到该在物理地址（绝对地址）中，我们的目标存放的地址了，同理，我们把这种思想转移到了分页技术中地址的转换</p>
<p>结合之前的同学去住酒店问题，可以这么理解：</p>
<p>A同学是个傻子，只知道自己要住在离B同学X个房号的房间，这个X就是<mark>偏移量</mark>，A同学如何才能顺利的住进自己的房间呢？只需要B同学先找到自己的房间（<mark>起始位置</mark>），然后A同学就能顺藤摸瓜找到自己的房间啦。</p>
<p>以下面为例：</p>
<ul>
<li><strong>页号</strong>：逻辑地址 / 页面长度 取整 （本题中：页号=80/50 = 1</li>
<li><strong>业内偏移量</strong>：逻辑地址 % 页面长度 （本题中：页内偏移量=80 % 50 = 30</li>
<li><strong>页面在内存中的起始位置</strong>：OS用某种数据结构去进行记录的 （本题中一号页在内存中存放的起始位置=450</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019165134603.png" alt="image-20201019165134603"></p>
<p>为了方便计算页号、业内偏移量，页面大小一般取2的整数幂，那么接下来我们就来看看这种情况是什么样子的</p>
<p>红色部分前20位，表示了是第几页；（这里的<mark>前</mark>指的是从<strong>左往右</strong>数，如果严格按照二进制来说应该是后20位</p>
<p>后面12位是偏移值（这的<mark>后</mark>指的是从<strong>左往右</strong>数，如果严格按照二进制来说应该是前12位</p>
<p>加入我们知道了N号页在内存中的起始地址（假设为X），那么我就知道我们已知的逻辑地址所对应的物理地址了</p>
<ul>
<li>结论:若每个页面大小为<strong>2^K B</strong>,用二进制数表达逻辑地址，那么末尾K位是<strong>页内偏移量</strong>。其余部分代表<strong>页号</strong>；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019170219137.png" alt="image-20201019170219137"></p>
<h6 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><ul>
<li><p>分页存储管理的逻辑地质结构由：<strong>页内偏移量</strong>和<strong>页号</strong>组成</p>
</li>
<li><p>若由K位表示<strong>页内偏移量</strong>，说明系统中一个<strong>页面大小是2^K 个内存单元</strong></p>
</li>
<li><p>若由M位表示<strong>页号</strong>，说明系统中，一个<strong>进程最多允许2^M个页面</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019171609549.png" alt="image-20201019171609549"></p>
<h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><p>上述我们有个遗留问题，我们如何知道<strong>页号对应页面</strong> 在 内存中的<strong>起始地址</strong>呢？</p>
<p>其实是通过<strong>页表</strong>知道的，下面看看什么是<strong>页表</strong></p>
<p>其实页表可以结合之前的住酒店问题一起理解：</p>
<p>还是那个傻子A同学，之前说了，他只知道自己住在某同学（假设B同学）的旁边X位，他需要知道B同学住哪才能找到自己的房间。而这个页表可以帮助A同学找到那个<strong>B同学</strong>；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019202912635.png" alt="image-20201019202912635"></p>
<ol>
<li><p>一个进程对应一张页表</p>
</li>
<li><p>进程的每一页对应一个页表项</p>
</li>
<li><p>每个页表项由【<strong>页号</strong>】和【<strong>块号</strong>】组成</p>
</li>
<li><p>页表记录<strong>进程页面和实际存放的内存块之间的对应关系</strong></p>
</li>
<li><p>物理内存大小 / 页面大小 = 内存块 / 页表项（多少个 也就是能分成多少页号）</p>
</li>
<li><p>页表项 × 页表项长度 = 页表的大小（页表在内存中占用的大小）</p>
</li>
<li><p>页表的大小 /  页面大小 = 页表项个数（页框个数）</p>
</li>
<li><p>页面的数目 = 进程的大小 / 页面的大小 = 逻辑地址表示的大小 / 页面的大小 </p>
</li>
<li><p>每个页表项的长度是相同的，页号是隐含的</p>
<p>这句话是说明意思呢？意思是说 我们能够通过<strong>页表存放的起始地址</strong>和<strong>页表项长度</strong>，就可以找到各页号所对应的页表存放的位置</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019203053285.png" alt="image-20201019203053285"></p>
<p>是不是说的很绕呢？那么可以这么理解：</p>
<ul>
<li><p>页 - 一个数组</p>
<p>页的大小 表现为 2^N  这N位叫做页内偏移量 = 业内地址用N位来表示</p>
</li>
<li><p>页表项 - 构成数组的最小单位，页号相当于下标，块号相当于存的值</p>
</li>
<li><p>页表项  × 页表项大小 = 页表大小 <strong>等价于</strong></p>
<p>数组个数  ×  单个元素大小 = 整个数组大小</p>
</li>
<li><p>物理地址 / 页面大小 = 物理块的个数 → 知道了内存块号的取值范围</p>
</li>
<li><p>逻辑地址 / 页面大小 = 页面的数目 → 知道了页号的取值范围</p>
</li>
</ul>
<p>再结合那个例子理解：页面大小 决定了 页内偏移量（不是等于，因为是通过取余运算得到的），也就是距离B同学多远；而页号就是那个B同学了，B同学只需要找到自己房间号，A同学就能通过页内偏移量找到自己房间了。</p>
<h6 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160101385.png" alt="image-20201022160101385"></p>
<ul>
<li>基本地址变换机构可以借助进程的页表将<strong>逻辑地址</strong>转换为<strong>物理地址</strong></li>
<li>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong>,存放页表<strong>在内存中的起始地址F</strong>和<strong>页表长度M</strong>；</li>
<li>进程未执行的时候，<strong>页表的起始地址</strong>和<strong>页表长度</strong>放在<strong>进程控制块PCB</strong>中，当进程被<strong>调度的时候</strong>，<strong>OS内核</strong>会把他们放在<strong>页表寄存器</strong>中</li>
</ul>
<p>（页面大小为2的整数幂）</p>
<p>设页面大小为L，逻辑地址A到物理地址E的变换过程:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025172149372.png" alt="image-20201025172149372"></p>
<ol>
<li><p>计算<strong>页号P</strong>和<strong>页内偏移量W</strong>（以十进制为例：*<em>页号P = 逻辑地址A / 页面大小L ;页内偏移量W = 逻辑地址A % 页面大小L *</em> 但计算机实际运行的时候，逻辑地址结构是固定不变的，因此计算机硬件可以更快得到二进制表示的页号和页内偏移量）</p>
</li>
<li><p>比较<strong>页号P</strong>和<strong>页表长度M</strong>，如果<strong>P&gt;=M</strong>，就产生越界中断，否则继续执行 （为什么等号也会算作越界中断呢?因为页号是从0开始的，而页表长度至少是1，因此P = M也会中断哦 类似于数组越界）</p>
</li>
<li><p>页表中<strong>页表P</strong>对应的<strong>页表项地址 = 页表起始地址F + 页号P * 页表项长度</strong>；取出该<strong>页表项内容b</strong>，即为<strong>内存块号</strong>。</p>
<p>页表<strong>长度</strong>：指的是这个页表中总共有<strong>几个页表项</strong>，就是有多少页</p>
<p>页表<strong>项长度</strong>：指的是每个页表项占据了多大的<strong>存储空间</strong></p>
<p>页面<strong>大小</strong>：一个页面占多大的<strong>存储空间</strong></p>
</li>
<li><p>计算<strong>物理地址E = 内存块号b * 页面大小L + 页内偏移量W</strong> ,用得到的物理地址E去访存</p>
</li>
</ol>
<p>说了那么多，感觉是不是云里雾里的，知道了一堆名词，计算方式，但真正计算的时候仍然不会用？下面就来一道例题去实践一下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022154324120.png" alt="image-20201022154324120"></p>
<ul>
<li>页号P = 逻辑地址A / 页面大小L = 2500 / 1024 = 2 ； 页内偏移量W = 逻辑地址A % 页面大小L = 2500 % 1024 = 452</li>
<li>判断越界:页号P对应内存块号为8 没越界</li>
<li>物理地址 E = 内存块号 * 页面大小 + 页内偏移量 = 8 * 1024 + 452 = 8644 就是最后结果了</li>
</ul>
<h6 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h6><p>要去了解具有快表的地址变换机构前，首先要去理解一个概念 ： <strong>局部性原理</strong></p>
<ul>
<li><mark>局部性原理</mark><ul>
<li><mark>时间局部性</mark>：如果执行了程序中的某条指令，那么不久之后这条指令很有可能被再次执行；如果某个数据被 访问过，不久之后该数据很可能被再次访问。（程序中存在大量循环）</li>
<li><mark>空间局部性</mark>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（许多数据在内存中是连续存放的）</li>
<li>那么我们<strong>具有快表的地址变换机构</strong>与这<strong>局部性原理</strong>又有什么关系呢？我们上面介绍的<strong>基本地址变换机构</strong>中，每次要访问一个逻辑地址，都需要查询<strong>内存中的页表</strong>。而由于局部性原理，可能连续很多次查到的都是<strong>同一个页表项</strong>；当我们认识到了<strong>局部性原理</strong>之后，我们能否结合这个特性减少访问</li>
</ul>
</li>
</ul>
<p>在了解完局部性原理后，我们就可以正式开始学习<strong>快表</strong>了</p>
<ul>
<li><p><strong>快表</strong>，又称<strong>联想寄存器（TLB）</strong>,是一种访问速度比内存块很多的高速缓冲寄存器（存放在更高速存储器中）</p>
<p>用于存放当前访问的若干项页表项，以加速地址变换的过程</p>
<p>与此对应，<strong>内存中的页表</strong>常被称为<strong>慢表</strong>（存放在内存中）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024151157653.png" alt="image-20201024151157653"></p>
<p>下面我们根据上方图，仔细理顺一下 <strong>引入快表之后，地址的变换过程</strong></p>
<ol>
<li>CPU给出逻辑地址，由某硬件算出页号、页内偏移量，由地址变换机构自动地将<strong>页号P</strong>送入<strong>高速缓冲寄存器</strong>，并将此页号与<strong>高速缓冲寄存器/快表</strong>中的所有页号进行比较</li>
<li>若其中有与此相匹配的页号，说明要访问的页表项在快表中有副本，于是直接从快表中读出该页对应的<strong>内存块号/物理块号</strong>，再将内存块号与页内偏移量拼接成物理地址，然后访问该物理地址对应的<strong>内存单元</strong>。（一次）</li>
<li>若其中没有与此匹配的页号，则需要访问<strong>内存中的页表</strong>，（<strong>第一次访问内存</strong>）找到对应的页表项，得到页面存放的<strong>内存块号/物理块号</strong>，访问该物理对应的内存单元（<strong>第二次访问内存</strong>）；（找到页表项后，应同时将其存入快表的一个寄存器单元中，假如联想寄存器已经满了，OS必须找到一个老的且已经被认为是不再需要的页表项，将他换出来）</li>
<li>发现了吗？如果<strong>快表命中了，则访问某个逻辑地址只需要一次访存</strong>。如果<strong>没命中</strong>，则需要<strong>两次访存</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024152935605.png" alt="image-20201024152935605"></p>
<ul>
<li><p>有无快表的地址变换机构区别</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024153201118.png" alt="image-20201024153201118"></p>
</li>
</ul>
<h6 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152405530.png" alt="image-20201025152405530"></p>
<ul>
<li><p>我们为什么要引入新的存储管理方式呢？往往都是因为之前的多多少少存在一点问题，那么与两级页表对应的就是单级页表了，单机页表存在什么问题呢？</p>
<p>首先：页表必须连续存放，因此当页表很大的时候，需要占用多个连续页框</p>
<p>其次：没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定页面</p>
</li>
<li><p>解决方案：将页表进行分组，使每个内存块刚好放入一个<strong>分组</strong>（比如，页面大小4KB，页表项大小4B，那么可以存1K个页表项，那么把连续的1K个页表项认定为一组），把各组<strong>离散</strong>存放到各内存块中</p>
<p>然后为离散分配的页表<strong>再额外建立一张页表</strong>，我们称之为:<strong>页目录表/外层页表/顶层页表</strong></p>
</li>
</ul>
<p>我们把中间这个<strong>大页表</strong>拆分成了左边这个<strong>小页表</strong> 1024个页表项为一组</p>
<p>为什么要这么分呢？我们知道一个分页存储管理是把一个进程分成若干个页面然后存储 对吧？那么就有可能出现页号特别特别多的情况，因此我们把这些页号又再分一次，形成了一个二级页表；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024162203398.png" alt="image-20201024162203398"></p>
<p>我们现在知道了 二级页表的来由了 那么<strong>二级页表</strong>又是如何<strong>实现地址转换</strong>的呢？</p>
<ol>
<li>按照地址结构将逻辑地址拆成三个部分<ol>
<li><strong>一级页号</strong></li>
<li><strong>二级页号</strong></li>
<li><strong>页内偏移量</strong></li>
</ol>
</li>
<li>从PCB中读取<strong>页目录起始地址</strong>，根据<strong>一级页号</strong>查页目录表，找到<strong>下一级页表（二级页表）</strong>在内存中存放的位置</li>
<li>根据二级页号查表，找到最终想要访问的<strong>内存块号</strong></li>
<li>结合<strong>页内偏移量</strong>得到物理地址</li>
</ol>
<p>也就是需要3次的访存：<strong>第一次</strong>是访问<strong>内存中页目录表</strong> <strong>第二次</strong>是访问<strong>内存中二级页表</strong> <strong>第三次</strong>才是<strong>访问目标内存单元</strong></p>
<p>有点套娃的意思；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/18464438-d40bb24f98b9fcab.png" alt="img"></p>
<p>下面来一道例题来看看一些细节问题</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152348367.png" alt="image-20201025152348367"></p>
<h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025202529712.png" alt="image-20201025202529712"></p>
<h6 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h6><ul>
<li><p>进程的地址空间：按照程序<strong>自身的逻辑关系</strong>划分成了<strong>若干个段</strong>，每个段有一个<strong>段名</strong></p>
<p>编译程序会将<strong>段名</strong>转换为<strong>段号</strong></p>
<p>每段从 <strong>0</strong> 开始编制</p>
</li>
<li><p>内存分配规则：以段为单位进行分配，每个段在内存中<strong>占据连续空间</strong>，但<strong>各段之间可以不相邻</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152836465.png" alt="image-20201025152836465"></p>
<ul>
<li>分段细节</li>
</ul>
<p>分段系统的<strong>逻辑地址结构</strong>由<strong>段号</strong>和<strong>段内地址（段内偏移量）</strong>所组成</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153507064.png" alt="image-20201025153507064"></p>
<ul>
<li><p><strong>段号的位数</strong>：决定了每个进程最多可以分几个段</p>
</li>
<li><p><strong>段内地址位数</strong>：决定了每个段的最大长度是多少</p>
</li>
<li><p>以上图为例：段号与段内地址都是16位，因此每个进程最多有<strong>2^16=64K个段</strong>，每个段的最大长度是<strong>2^16=64KB</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153813924.png" alt="image-20201025153813924"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153804900.png" alt="image-20201025153804900"></p>
</li>
</ul>
<h6 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h6><p>上面我们学习了基本分页存储管理，有提到<strong>页表</strong>一概念，那么与之对应的，我们的基本分段存储管理是否也有<strong>段表</strong>一概念呢？答案是肯定的</p>
<ul>
<li>段表:程序分成多个段，直接离散地装入内存，为了保证程序可以正常运行，就必须能从物理内存中找到各<strong>逻辑段</strong>存放的位置，为此，需要为每个进程建立一张<strong>段映射表</strong>. 这个<strong>段映射表</strong>就是我们的<strong>段表</strong></li>
<li>每个<strong>段</strong>在表中占有一个<strong>表项</strong>，记录了<strong>该段在内存中的起始位置（基址）</strong>和<strong>段的长度</strong>；各表项长度是相同的</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025171024271.png" alt="image-20201025171024271"></p>
<h6 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025194631660.png" alt="image-20201025194631660"></p>
<p>根据上方流程图我们来理一下地址变换的思路，其实是与分页存储管理的地址变换差不太多的</p>
<ol>
<li>根据<strong>逻辑地址A</strong>得到<strong>段号S</strong>和<strong>段内地址W</strong></li>
<li>判断<strong>段号S</strong>是否越界，如果<strong>段号S≥段表长度M</strong>，就发生越界中断，否则继续</li>
<li>查询段表，找到对应的段表项，<strong>段表项</strong>的存放地址为<strong>段表起始地址F+段号S×段表项长度</strong></li>
<li>检查<strong>段内地址W</strong>是否超过段号所对应的<strong>段长C</strong>，如果<strong>段内地址W≥段长C</strong>，则产生越界中断，否则继续</li>
<li>计算得到<strong>物理地址 = 段基址b + 段内地址w</strong></li>
<li>访问目标内存单元</li>
</ol>
<h6 id="分段分页管理对比"><a href="#分段分页管理对比" class="headerlink" title="分段分页管理对比"></a>分段分页管理对比</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025200044600.png" alt="image-20201025200044600"></p>
<ul>
<li><p><strong>页</strong>是<mark>信息的物理单位</mark>；分页的主要目的是为了实现离散分配，提高内存利用率；</p>
<p>分页仅仅是系统管理上的需要，完全是<strong>系统行为</strong>，对于用户是<strong>不可见的</strong>；</p>
<p>分页的用户进程<strong>地址空间是一维的</strong>，程序员只需要给出一个记忆符即可表示一个地址；</p>
<p>页的<strong>大小固定</strong>，且由系统决定。</p>
</li>
<li><p><strong>段</strong>是<mark>信息的逻辑单位</mark>；分段的主要目的是更好地满足用户需求。</p>
<p>一个段通常包含着一组属于一个逻辑模块的信息。</p>
<p>分段对用户是可见的，用户编程的时候需要显示给出段名；</p>
<p>分段的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段名地址。</p>
<p>段的长度不固定，决定于用户编写的程序。</p>
</li>
<li><p>访问一个逻辑地址需要几次访问内存呢？</p>
<ul>
<li>分页（单级页表）：<strong>第一次访问内存</strong>——查询内存中的页表，<strong>第二次访问内存</strong>——访问目标内存单元</li>
<li>分段：<strong>第一次访问内存</strong>——查内存中段表，<strong>第二次访问内存</strong>——访问目标内存单元</li>
</ul>
</li>
</ul>
<h6 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h6><p>分段比分页更容易实现<strong>信息的共享和保护</strong></p>
<p>首先引入一个概念叫做纯代码，纯代码/可重入代码 是 <strong>不能被修改的代码</strong>；这种类型的代码是可以共享的，而可修改的代码是不能进行共享的（比如一个代码段有很多变量，多进程并发地同时访问会导致数据地不一致）</p>
<p>那么如果进程是分段存储管理的 几句可以很好的进行信息地共享了，因为只需要改变进程地段表项，指向同一个段即可；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025201533670.png" alt="image-20201025201533670"></p>
<h5 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026171616190.png" alt="image-20201026171616190"></p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>段页式存储，顾名思义，肯定是利用到了<strong>页式存储+段式存储</strong>，那么既然是两者结合，肯定取其精华，去其糟粕吧，那我们先复习一下段式存储和页式存储各自优缺点都有什么</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026154027329.png" alt="image-20201026154027329"></p>
<h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><ul>
<li>那么我们的段页存储管理又是如何进行的呢？究竟是先分段还是先分页呢？</li>
<li>我们的进程首先按照<strong>逻辑模块分段</strong>，再将分成的<strong>段</strong>分<strong>页</strong></li>
<li>将<strong>内存空间</strong>分为大小<strong>相同的内存块/页框/页帧/物理块</strong></li>
<li>进程将各页面分别装如个内存块中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026161147295.png" alt="image-20201026161147295"></p>
<h6 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026162123383.png" alt="image-20201026162123383"></p>
<ul>
<li>段页式系统的逻辑地址结构由<strong>段号、页号、页内地址（页内偏移量）</strong>所组成</li>
<li><strong>段号</strong>：段号的位数决定了每个进程最多可以分几个段</li>
<li><strong>页号</strong>：页号的位数决定了每个段最大有多少页</li>
<li><strong>页内偏移量</strong>：页内偏移量决定了页面大小、内存块大小是多少</li>
</ul>
<h6 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h6><p>看下面这张图是否感觉有点眼熟？感觉与二级页表类似；</p>
<p>只不过把中间的那个页表替换成了一个段表，借此机会我们再来理顺一次思路:</p>
<p>一个进程对应一个段表   一个段表对应多个页表 换而言之，进程对应了多个页表</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026163818291.png" alt="image-20201026163818291"></p>
<h6 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026165005382.png" alt="image-20201026165005382"></p>
<p>像之前的两种存储管理的地址变换过程一样 ，我们也来理一次过程：</p>
<ol>
<li>根据<strong>逻辑地址A</strong>得到<strong>段号S</strong>、<strong>页号P</strong>和<strong>页内偏移量W</strong></li>
<li>判断<strong>段号S</strong>与<strong>段表长度M</strong>关系，如果S≥M，发生越界中断，否则继续进行（第一次检查越界）</li>
<li>查询段表，进行运算：<strong>段表项 = 段表始址F + S × 段表项长度</strong> → 找到对应的<strong>段表项</strong><mark>（第一次访问内存）</mark></li>
<li>判断页号P与页表长度的关系，如果页号P≥页表长度，发生越界中断，否则继续进行（第二次检查越界）</li>
<li>根据<strong>页表存放块号和页号P</strong>计算得到查询页表，找到对应的<strong>页表项</strong><mark>（第二次访问内存）</mark></li>
<li>页表项存储着该页所在的<strong>物理块号b</strong>，再利用<strong>物理块号b</strong>和<strong>页内偏移量W</strong>构成最终的物理地址</li>
<li>最后访问目标内存单元<mark>（第三次访问内存）</mark></li>
</ol>
<h3 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h3><ul>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li>
<li>通常有三种技术：<ul>
<li>覆盖技术</li>
<li>交换技术</li>
<li>虚拟存储技术</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015213523284.png" alt="image-20201015213523284"></p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ul>
<li>OS需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li>
<li>绝对装入-编译时产生绝对地址</li>
<li>可重定位装入-装入时将逻辑地址转换为物理地址</li>
<li>动态运行时装入-运行时将逻辑地址转换为物理地址，需要设计重定位寄存器</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015214304047.png" alt="image-20201015214304047"></p>
<h3 id="内存保护-1"><a href="#内存保护-1" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存保护可采取两种办法</p>
<ul>
<li><p>方法一：在CPU种设置一对上、下限寄存器，寄存进程的上、下限地址。进程的指令要访问某个地址的时候，CPU检查是否越界</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215116282.png" alt="image-20201015215116282"></p>
</li>
<li><p>方法二：采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。其中，<strong>重定位寄存器</strong>中存放的是<strong>进程的起始物理地址</strong>，<strong>界地址寄存器</strong>中存放的是<strong>进程的最大逻辑地址</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215232038.png" alt="image-20201015215232038"></p>
<h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160240209.png" alt="image-20201022160240209"></p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul>
<li><p>覆盖是在同一个进程或程序中的</p>
</li>
<li><p>思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要的时候才调入内存</p>
<p>内存分为一个固定去和若干个覆盖区</p>
<p><strong>需要常驻内存的段</strong>放在<strong>固定区</strong>中，调入后就<strong>不再调出</strong></p>
<p><strong>不常用的段</strong>放在<strong>覆盖区</strong>，<strong>需要用</strong>的时候<strong>调入内存</strong>，<strong>用不到</strong>的时候<strong>调出内存</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015220730717.png" alt="image-20201015220730717"></p>
<ul>
<li>如下图所示，假如程序A执行需要走如下几个程序B、C….</li>
<li>B、C不能同时执行，我们就在物理内存中设置一个覆盖区 用于存放B或者C，其中其大小是B、C中较大内存决定</li>
<li>同理D、E、F也不能同时执行，因此也设立一个覆盖区用于存储</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017150834371.png" alt="image-20201017150834371"></p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li><p>交换是在不同进程(作业)之间的</p>
</li>
<li><p>设计思想：内存空间紧张的时候，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
</li>
<li><p>这种技术其实在上面的处理机调度一节层次调度中的中级调度我们也有了解过了 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152832202.png" alt="image-20201017152832202"></p>
</li>
<li><p>暂时换出外存等待的进程状态为挂起状态（挂起态）</p>
</li>
<li><p>挂起态可以细分为就绪挂起和阻塞挂起两种状态 - 复习下7态模型吧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152921895.png" alt="image-20201017152921895"></p>
</li>
</ul>
<p>下面思考三个问题</p>
<ol>
<li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p>
<p>答：具有兑换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分；</p>
<p><strong>文件区</strong>主要用于存放文件，主要<strong>追求存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong></p>
<p><strong>对换区</strong>空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区，由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要<strong>追求换入换出速度</strong>，因此通常采用<strong>连续分配方式</strong></p>
<p>对换区的I/O速度比文件区的更快</p>
</li>
<li><p>什么时候应该交换？</p>
<p>答：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生<strong>缺页</strong>，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p>
</li>
<li><p>应该换出哪些进程？</p>
<ol>
<li>可优先换出阻塞进程</li>
<li>可换出优先级低的进程</li>
<li>为了放置优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间</li>
<li>PCB会常驻内存，是不会被换出外存的</li>
</ol>
</li>
</ol>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029202753739.png" alt="image-20201029202753739"></p>
<h3 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029162940481.png" alt="image-20201029162940481"></p>
<ul>
<li><strong>一次性</strong>：是指作业必须一次性地全部装入内存后方能开始运行<ul>
<li>造成问题<ul>
<li>作业很大的时候，不能全部装入内存，导致大作业无法运行</li>
<li>当大量作业要求运行的时候，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li>
</ul>
</li>
</ul>
</li>
<li><strong>驻留性</strong>：是指作业被装入内存之后，整个作业都一直驻留在内存中，其中任何部分都不会被换出，直至作业运行结束。<ul>
<li>造成问题<ul>
<li>往往在一个时间段内，只需要访问作业的一小部分数据就可以正常运行，但偏偏会把其他不需要的部分也强行装入内存，这就导致了内存中会驻留大量、暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>而要解决传统存储管理的这些特征带来的问题，我们就引入了虚拟存储技术，而虚拟存储技术依靠【局部性原理】</p>
<p>关于局部性原理，在上述已经说过了，这里直接照搬上面的内容：</p>
<p><mark>局部性原理</mark></p>
<ul>
<li><mark>时间局部性</mark>：如果执行了程序中的某条指令，那么不久之后这条指令很有可能被再次执行；如果某个数据被 访问过，不久之后该数据很可能被再次访问。（程序中存在大量循环）</li>
<li><mark>空间局部性</mark>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（许多数据在内存中是连续存放的）</li>
</ul>
<h3 id="高速缓冲技术"><a href="#高速缓冲技术" class="headerlink" title="高速缓冲技术"></a>高速缓冲技术</h3><p>高速缓冲技术其实就算应用了局部性原理</p>
<ul>
<li><p>高速缓冲技术的思想： 将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029172212611.png" alt="image-20201029172212611"></p>
</li>
</ul>
<h3 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>虚拟内存/虚拟存储器</strong>，是指具有<mark>请求调入功能和置换功能</mark>，能从<strong>逻辑上</strong>(而不是物理上)对内存容量加以扩充的一种<marK>存储器系统。</marK></p>
<p>那么虚拟内存是如何”增大”内存的呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029195651658.png" alt="image-20201029195651658"></p>
<p>基于局部性原理，在程序<strong>装入</strong>的时候，将程序中很快会用到的部分装入内存，暂时用不到的部分就留在外存，就可以让程序开始执行；</p>
<p>在程序执行的过程中，当所访问的信息不在内存时候，由OS负责将所需的信息从<strong>外存</strong>调入<strong>内存</strong>，然后继续执行程序；</p>
<p>假如内存空间不够，由<strong>OS</strong>负责将内存中<strong>暂时用不到的信息</strong>换出到外存；</p>
<p>你看 有用的在内存中，暂时用不到的在外存，是不是在用户看来是把整个程序塞入内存里了呢？</p>
<p>注意：</p>
<ul>
<li><p>虚拟内存的<strong>最大容量</strong>由计算机的地质结构（CPU的寻址范围）确定的</p>
<p>比如某计算机地址结构为32位，按照字节编址，内存大小位512MB，外存大小为2GB；</p>
<p>则虚拟内存的<strong>最大容量</strong>  2^32^B= 4GB</p>
</li>
<li><p>虚拟内存的<strong>实际容量</strong> = min(内存和外存容量之和， CPU寻址范围)</p>
<p>依旧是上述例子</p>
<p>则虚拟内存的<strong>实际容量</strong>=min（2^32^B, 512MB + 2GB）= 2GB +512MB；</p>
</li>
</ul>
<h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul>
<li><mark>多次性</mark>：是相对于传统存储管理方式的<strong>一次性</strong>而言的，是指一个作业中程序和数据无需在作业运行的时候一次性全部装入内存，而是允许被分成多次调入内存运行。多次性是虚拟存储器最重要的特征，是任何其他的存储管理方式所不具有的。因此，虚拟存储器其实是具有多次性特征的存储器管理系统。</li>
<li><mark>对换性</mark>：是相对于传统存储管理方式的<strong>常驻性</strong>而言的，是指一个作业中的程序和数据，无须在作业运行的时候一直常驻内存，而是允许在作业的运行过程中进行换入换出。</li>
<li><mark>虚拟性</mark>：虚拟性是指能够从逻辑上扩充内存容量，使得用户所看到的内存容量远远大于实际的内存容量。虚拟性是以多次性和对换性为基础的，正是由于系统允许将作业多次调入内存，并且能把内存中暂时不允许程序、数据、进程调至外存，才有可能实现了虚拟存储器；</li>
</ul>
<h3 id="虚拟内存的实现方法"><a href="#虚拟内存的实现方法" class="headerlink" title="虚拟内存的实现方法"></a>虚拟内存的实现方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205625258.png" alt="image-20201029205625258"></p>
<p>我们知道，管理系统要实现<mark>虚拟性</mark>必须满足<mark>对换性和多次性</mark>，那么如何要满足<mark>对换性和多次性</mark>，又有什么要求呢？答案是必须建立在<strong>离散分配</strong>的内存管理方式基础上。那么现在有什么管理方式能实现虚拟存储器呢？</p>
<h4 id="分页请求系统"><a href="#分页请求系统" class="headerlink" title="分页请求系统"></a>分页请求系统</h4><ul>
<li>分页请求系统 = 分页系统的基础 + 请求调页功能 + 页面置换功能</li>
<li>用户程序装入少数页面程序和数据就能运行，之后再通过上述两个功能把即将运行<strong>页面</strong> → 内存，暂时不运行的<strong>页面</strong> → 外存</li>
<li>为了实现这两个功能，系统需要提供必要硬件支持和实现请求分页的软件<ul>
<li><strong>硬件支持</strong>：<ul>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
<li><strong>请求分页软件</strong>：<ul>
<li>在硬件支持下，将程序正在运行时所需页面 → 内存，内存中不用的页面从内存 → 磁盘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h4><ul>
<li>分页请求系统 = 分段系统的基础 + 请求调段功能 + 分段置换功能</li>
<li>用户程序装入少数段的程序和数据就能运行，之后再通过上述两个功能把即将运行的<strong>段</strong>→ 内存，暂时不运行的<strong>段</strong> → 外存</li>
<li>为了实现这两个功能，系统需要提供必要硬件支持和实现请求分段的软件<ul>
<li>硬件支持<ul>
<li>请求分段的段表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
<li>软件支持<ul>
<li>在硬件支持下，将内存中暂时不用的段从内存 → 磁盘，程序运行时所需要的段 → 内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029220042435.png" alt="image-20201029220042435"></p>
<h4 id="请求页表机制"><a href="#请求页表机制" class="headerlink" title="请求页表机制"></a>请求页表机制</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205653568.png" alt="image-20201029205653568"></p>
<table>
<thead>
<tr>
<th>页号</th>
<th>物理块号</th>
<th>状态位P</th>
<th>访问字段A</th>
<th>修改位M</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>　　状态位P：该页是否已调入内存 0 表示没有被调入 1表示被调入</p>
<p>　　访问字段A：本页在一段时间内被访问的次数，供页面置换算法使用</p>
<p>　　修改位M：标识该页在调入内存后是否被修改过</p>
<p>　　外存地址：该页在外存上的地址，供调入该页时参考</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>缺页中断机构的大致流程如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030200249404.png" alt="image-20201030200249404"></p>
<ul>
<li><p>缺页中断是因为当前指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>
</li>
<li><p>一条指令在执行期间，可能产生多次缺页中断</p>
<p>比如copy A to B，而A、B属于不同页面，那就有可能产生多次的中断：因为指令本身跨多个页面，A、B又是分别一个数据块；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212923663.png" alt="image-20201029212923663"></p>
</li>
<li><p>中断的分类如下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212844294.png" alt="image-20201029212844294"></p>
</li>
</ul>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213124769.png" alt="image-20201029213124769"></p>
<p>由于逻辑地址到物理地址映射过程写过很多次了，这里不再赘述；</p>
<p>但这里需要注意的点是：</p>
<p>快表中有的页面一定是在内存中的，如果某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面；</p>
<p>找到对应的页表项之后，假如对应页面还没有调入内存，那就产生缺页中断，之后由OS的缺页中断处理程序进行处理</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213649586.png" alt="image-20201029213649586"></p>
<p>细节补充:</p>
<ul>
<li><p>只有写指令才需要修改【修改位】，而且一般来说只需要修改快表中的数据，只有要将快表项删除的时候才需要写回内存中的慢表；</p>
<p>这样可以减少访存次数</p>
</li>
<li><p>缺页中断处理依旧需要保持CPU现场</p>
</li>
<li><p>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销</p>
</li>
<li><p>页面调入内存中，需要修改慢表，同时也需要将表项复制到快表中</p>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>请求分页管理存储与基本分页存储管理的主要区别:</p>
<p>程序执行的过程中，当所访问的信息不在内存的时候，由OS负责将所需要的信息从外存调入内存，然后继续执行</p>
<p>假如内存空间不够，就由OS负责将内存中暂时用不到的信息换出到外存</p>
<p>而由于我们的页面换入、换出需要磁盘I/O，有较大开销，因此好的页面置换算法的评价指标就是更少的缺页率</p>
<p>我们主要学习五种页面置换算法：<strong>最佳置换算法、先进先出置换算法、最近最久未使用置换算法、时钟置换算法、改进型的时钟置换算法</strong></p>
<h3 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030184237366.png" alt="image-20201030184237366"></p>
<ul>
<li>最佳置换算法：每次选择淘汰的页面将是以后永不使用，或者再最长时间内不再被访问的页面，这样可以保证最低的缺页率；</li>
<li>缺页中断未必一定会发生页面置换，假如有空闲的内存块就不用进行页面置换</li>
<li>缺页率的计算 :<strong>缺页率 = 缺页中断发生的次数 / 访问页面的总次数 × 100 ％</strong></li>
<li>最佳置换算法是理想算法，因为只有在进程执行的过程中才能知道接下来会访问什么页面，OS无法提前预判页面访问序列，因此最佳置换算法是无法实现的。</li>
</ul>
<h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030185335274.png" alt="image-20201030185335274"></p>
<ul>
<li><p>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面</p>
</li>
<li><p>如何实现的呢？先进先出，学过数据结构的朋友们都清楚，应该使用<strong>队列</strong>这种数据结构。把调入内存的页面按调入的<strong>先后顺序排成一个队列</strong>，当新来的页面需要进行页面置换的时候，<strong>poll掉头页面</strong>即可；</p>
<p>ps：队列的最长长度取决于系统为进程分配多少内存块</p>
</li>
<li><p><strong>Belady（贝莱迪）异常</strong>：  一般来说，缓存越大，命中率越高，缺页率越低。但有一个计算机学者，名字叫Belady。在1969年研究FIFO算法时，发现了一个反例，使用4个页框时的缺页次数比3个页框时的缺页多，因此这种奇怪的情况称为Belady异常。</p>
<p>这种异常的原因是对于FIFO算法来说，在同一时刻，使用4个页框时缓存中保存的页面并不完全包含使用3个页框时保存的页面，二者不是超集子集关系，造成都某些特殊的页面请求序列，4个页框命中率反而低。</p>
<p>只有FIFO算法会产生这个异常，此外，FIFO实现简单，但是有可能先进入的进程也会被经常访问，因此算法性能差。</p>
</li>
</ul>
<h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030191211411.png" alt="image-20201030191211411"></p>
<ul>
<li><p>最近最久未使用置换算法（LRU）：每次淘汰的页面是最近最久未使用的页面</p>
</li>
<li><p>实现方法：赋予每个页面对应的<strong>页表项</strong>，用访问字段记录该页面<strong>自上次被访问以来所经历的时间t</strong></p>
<p>如果需要淘汰页面，就选择现有的页面<strong>中t值最大的</strong>，即最近最久没有使用的页面</p>
</li>
<li><p>该算法需要专门的硬件支持（寄存器，栈），虽然算法性能好，但是实现也很困难，开销也很大</p>
</li>
</ul>
<h3 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202108812.png" alt="image-20201030202108812"></p>
<h4 id="简单的CLOCK算法"><a href="#简单的CLOCK算法" class="headerlink" title="简单的CLOCK算法"></a>简单的CLOCK算法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030193731094.png" alt="image-20201030193731094"></p>
<ul>
<li>时钟置换算法/最近未用算法：通过循环队列将未访问页面置换的算法</li>
<li>简单的CLOCK实现方法：为每个页面设置一个访问位——用于标志最近是否访问过（如果该进程被访问了就从0被标志为1），然后将内存中各页面通过链接指针链接成一各<strong>循环队列</strong>；当访问新页面，需要置换页面的时候，通过检查页的访问位去置换：如果是0 → 换该页面，<strong>同时指针指向下一个页面</strong>；如果是1 → 置为0，给第二次留在内存的机会。</li>
</ul>
<h4 id="改进型的CLOCK算法"><a href="#改进型的CLOCK算法" class="headerlink" title="改进型的CLOCK算法"></a>改进型的CLOCK算法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202052642.png" alt="image-20201030202052642"></p>
<ul>
<li><p>改进型CLOCK置换算法:我们将一个页面换出的时候，假如它是修改过的，那么其修改后的数据需要重新写回外存中，如果没有被修改过，就不需要拷回外存。</p>
<p>说人话就是：对于一个换出的页面，如果其被修改过，那么它换出的开销比没有被修改过的要大，那么换他出去就划不来了。</p>
</li>
<li><p>那我们以什么为指标去评判一个页面该不该被置换呢？显然易见：<mark>有没有被访问过 + 有没有被修改过</mark></p>
<ul>
<li>（访问位A， 修饰位M）</li>
<li>（A = 0，M = 0）= 最近既没被访问 + 又没被修改过 ，被置换的优先级最高</li>
<li>（A = 0，M = 1）= 最近没被访问 + 已经被修改了，并不是很好的置换选项，优先级第二</li>
<li>（A = 1，M = 0）= 最近已经被访问了 + 但没被修改过 ，那么这个页面有可能还会被访问，优先级低三</li>
<li>（A = 1，M = 1）= 最近已经被访问 + 已经被修改，被置换的优先级最低（第四）</li>
</ul>
</li>
<li><p>那这个访问位，修饰位凭什么作为依据呢？这与我们的扫描过程有关</p>
<ul>
<li>第一轮去找（0，0），不改变标志位</li>
<li>第一轮没找到，找第二轮，把扫描过的访问位置0，我们这轮找第一个（0，1）</li>
<li>第二轮没找到，找第三轮，我们找（0，0），也不改变标志位</li>
<li>第三轮没找到，我们找第四轮，找第一个（0，1）</li>
</ul>
<p>发现了吗，这与我们上面的优先级正好是吻合的，优先级低的相当于有多一次的<mark>免死金牌</mark>，多在内存里苟活一段时间；</p>
</li>
</ul>
<h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132105189.png" alt="image-20201102132105189"></p>
<h3 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h3><ul>
<li>驻留集：指请求分页存储管理中给进程分配的<strong>物理块的集合</strong>，在采用了虚拟存储技术的系统中，驻留集大小一般<strong>小于</strong>进程的总大小</li>
</ul>
<p>由上面的概念我们可以发现：</p>
<ul>
<li>如果我们的驻留集太小了，会导致缺页非常的频繁，而这会导致系统要花大量时间处理缺页，开销就很大，而且用于进程推进的时间就很少了；</li>
<li>如果我们的驻留集太大了，又会导致多道程序的并发度下降，资源的利用率就降低了</li>
</ul>
<p>因此，不难发现，选择一个合适的驻留集大小就是非常必要的了，因此我们有了两种选择驻留集大小的分配方式</p>
<ul>
<li><strong>固定分配</strong>：OS为每一个进程分配一组固定数目的物理块，在进程运行期间不再改变；<mark>即，驻留集大小不变</mark></li>
<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可以根据情况做适当的增加或减少；<mark>即，驻留集大小可变</mark></li>
</ul>
<p>置换策略：</p>
<ul>
<li><strong>局部置换</strong>：发生缺页的时候只能选择<mark>进程自己的物理块</mark>进行置换</li>
<li><strong>全局置换</strong>：可以将OS保留的空闲物理块分配给缺页进程，也可以将<mark>别的进程持有的物理块置换到外存，再分配给缺页进程</mark></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101153719062.png" alt="image-20201101153719062"></p>
<p>我们下面对三种分配置换组合进行讲解：</p>
<ol>
<li><p><mark>固定分配局部置换</mark>：系统为每个进程分配一定数量物理块，在整个运行期间都不改变；若进程在运行过程中发生缺页，只能从该进程在内存中的页面选出一页换出，然后再调入需要的页面；</p>
<p>缺点：很难在刚开始就确定应该为每个进程分配多少个物理块才合理（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101154502336.png" alt="image-20201101154502336"></p>
</li>
<li><p><mark>可变分配全局置换</mark>：刚开始会给每个进程分配一定数量物理块。OS会保持一个空闲物理块队列，当某进程发生缺页的时候，从空闲物理块取出一块分配给该进程；</p>
<p>若没有空闲物理块，就选择一个<mark>未锁定</mark>（系统会锁定一些页面，这些页面中的内容不能被置换出外存 比如，重要的内核数据就可以设置为<strong>“锁定”</strong>）的页面换出外存，再将该物理块分配给缺页的进程。使用这种策略的话，只要某个进程发生了缺页，都将获得新的物理块，仅当空闲物理块用完的时候，系统才选择一个<mark>未锁定</mark>的页面调出。被选择调出的页可能是系统中任何一个进程的页，因此这个<mark>被选中的进程</mark>所<strong>拥有的物理块</strong>会减少，<strong>缺页率</strong>也会增加。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101155052393.png" alt="image-20201101155052393"></p>
</li>
<li><p>==可变分配全局置换==：刚开始会给每个进程分配一定数量的物理块。当某进程发生缺页的时候，只允许从该进程自己的物理块选出一个换出外存。</p>
<p>缺点：如果进程在运行中频繁地缺页，系统会给该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可以适当减少分配给该进程的物理块    也就是说 这点体现出了<strong>可变分配</strong>的概念</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101215351728.png" alt="image-20201101215351728"></p>
</li>
</ol>
<p>不难发现：</p>
<ul>
<li>可变分配<strong>全局</strong>置换：只要缺页就分配新物理块</li>
<li>可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来==动态地增加或减少==进程的物理块</li>
</ul>
<h3 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h3><ol>
<li><p><strong>预调页策略</strong>：根据局部性原理（空间局部性），一次调入若干个相邻地页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将他们<strong>预先调入内存</strong>，但目前预调页的成功率仅仅只有50%；</p>
<p>故这种策略主要用于进程的首次调入（运行前调入），由程序员指出应该先调入哪些部分；</p>
</li>
<li><p><strong>请求调页策略</strong>：进程在运行期间发现缺页的时候才将所缺页面调入内存（运行时调入），由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，每次调页都需要磁盘的I/O操作，因此I/O开销大。</p>
</li>
</ol>
<h3 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h3><ol>
<li><p>系统<mark>拥有</mark>足够对换区空间：页面的调入、调出都是在<strong>内存与对换区之间</strong>进行，这样可以保证页面的调入、调出的速度<strong>很快</strong>；</p>
<p>在<strong>进程运行前</strong>，需要将进程相关的数据从<strong>文件区</strong>复制到<strong>对换区</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125345951.png" alt="image-20201102125345951"></p>
</li>
<li><p>系统<mark>缺少</mark>足够对换区空间：</p>
<p>凡是不会被修改的数据都直接从<strong>文件区</strong>调入，由于这些页面不会被修改，因此换出的时候是不必被写回磁盘的，下次需要的时候再从<strong>文件区</strong>调入即可。</p>
<p>对于可能被修改的部分，换出的时候需要写回<strong>磁盘对换区</strong>，下次需要的时候再从<strong>对换区</strong>调入。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125517438.png" alt="image-20201102125517438"></p>
</li>
<li><p>UNIX方式：<strong>运行之前</strong>进程有关的数据全部放在<strong>文件区</strong>，故<strong>未使用过的页面</strong>，都可以从<strong>文件区</strong>调入。</p>
<p>若被<strong>使用过的页面</strong>需要换出，则写回<strong>对换区</strong>，下次需要的时候从<strong>对换区</strong>调入；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125945650.png" alt="image-20201102125945650"></p>
</li>
</ol>
<h3 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>；</p>
<p>产生<strong>抖动</strong>主要原因是<strong>进程频繁访问的页面数量<mark>高于</mark>可用的物理块数</strong></p>
<p>抖动的发生与<strong>页面置换算法、页的大小和分配的内存页面数</strong>有关，与<strong>内存大小</strong>无关</p>
<p>上面我们提到了，分配的物理块太少和太多带来的影响，因此为了研究每个进程分配多少个物理块这个问题，引入新概念<strong>工作集</strong></p>
<ul>
<li>驻留集：指的是请求分页存储管理中给进程分配的内存块的集合；</li>
<li>工作集：指的是某段时间间隔内，进程<strong>实际</strong>访问页面的集合；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102131739128.png" alt="image-20201102131739128"></p>
<p>OS根据窗口尺寸来算出工作集</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132004226.png" alt="image-20201102132004226"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194047847.png" alt="image-20201103194047847"></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>一个文件应该有哪些属性呢？</li>
</ul>
<ol>
<li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li>
<li><strong>标识符</strong>：OS用于区分各个文件的一种内部名称</li>
<li><strong>文件类型</strong>：可以用不同的角度来规定文件的类型，如源文件、目标文件以及可执行文件等</li>
<li><strong>文件的位置</strong>：文件存放的路径、在外存中的地址</li>
<li><strong>文件的大小/长度</strong>：指的是文件的大小或是长度，长度单位可以是字节、字或块</li>
<li><strong>文件的的建立时间</strong>：指最后一次的修改时间等</li>
<li><strong>文件的保护信息</strong>：对文件进行保护的访问控制信息</li>
</ol>
<h3 id="文件内部数据组织"><a href="#文件内部数据组织" class="headerlink" title="文件内部数据组织"></a>文件内部数据组织</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103171557320.png" alt="image-20201103171557320"></p>
<ul>
<li>无结构文件（如文本文件： 由一些二进制或者是字符组成，又称为“流式文件”</li>
<li>有结构文件（如数据库表)：由一组相似的记录（<strong>记录</strong>是一组<strong>相关数据项</strong>的集合（<strong>数据项</strong>是文件系统中<strong>最基本的数据单位</strong>））组成，又称为”记录式文件”</li>
</ul>
<h3 id="文件是如何组织起来的"><a href="#文件是如何组织起来的" class="headerlink" title="文件是如何组织起来的"></a>文件是如何组织起来的</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194753217.png" alt="image-20201103194753217"></p>
<ul>
<li>用户可以创建一层一层的目录，各层目录中存放<strong>相应的文件</strong>，系统中的各个文件就通过一层层的目录合理有序的组织起来了</li>
<li>所谓目录 即我们熟悉的<strong>文件夹</strong>，是一种特殊的有结构文件</li>
</ul>
<h3 id="OS向上提供的功能"><a href="#OS向上提供的功能" class="headerlink" title="OS向上提供的功能"></a>OS向上提供的功能</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195126301.png" alt="image-20201103195126301"></p>
<h3 id="文件存放在外存的方法"><a href="#文件存放在外存的方法" class="headerlink" title="文件存放在外存的方法"></a>文件存放在外存的方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195845754.png" alt="image-20201103195845754"></p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>按照文件是否有结构分类，可以分为<strong>无结构文件，有结构文件</strong>两种</p>
<h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><ul>
<li><p>文件内部的数据就是一系列二进制流或是字符流组成，又称为<strong>流式文件</strong></p>
<p>如Window操作系统种的<strong>.txt文件</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222307176.png" alt="image-20201109222307176"></p>
<h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><ul>
<li><p>由一组相似的记录组成，又称为<strong>记录式文件</strong>。每条记录由若干个数据项组成</p>
<p>如：数据库表文件（一般来说每条记录有一个数据项作为关键字去识别不同记录的ID）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222534791.png" alt="image-20201109222534791"></p>
<p>根据各条记录的长度（占用的存储空间）是否相等，又可以细分为：定长记录 和 可变长记录两种</p>
<ul>
<li><p>定长记录：</p>
<p>每条记录的长度都是相同的，各数据项都处在记录中相同的位置，具有相同的顺序和长度</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222721478.png" alt="image-20201109222721478"></p>
</li>
<li><p>可变长记录:</p>
<p>由于记录的数据项的长度是不确定的，因此各记录条的长度同样也是不确定的；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222809031.png" alt="image-20201109222809031"></p>
</li>
</ul>
<h4 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210117983.png" alt="image-20201110210117983"></p>
<h5 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h5><ul>
<li><p>文件种的记录一个接一个地顺序排列（逻辑上)，记录可以是<strong>定长的或是可变长的</strong></p>
</li>
<li><p>各个记录在物理上可以是<strong>顺序存储</strong>或是<strong>链式存储</strong></p>
<ul>
<li><p>顺序存储：逻辑上相邻的记录，物理上也相邻（类似于顺序表）</p>
<p>对于<strong>可变长记录</strong>，无法实现随机存取，每次都只能从第一个记录开始依次往后找</p>
<p>对于<strong>定长记录</strong>，可以做到随机存取，若记录的长度为L（每个记录的长度模块是L）,那么第i个记录存放的相对位置就是<strong>i×L</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223441980.png" alt="image-20201109223441980"></p>
</li>
<li><p>链式存储：逻辑上相邻的记录，物理上不一定相邻（类似于链表）</p>
<p>无论是定长或是可变长记录，都是无法实现随机存取的，每次都只能从第一个记录开始依次往后找</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223453210.png" alt="image-20201109223453210"></p>
</li>
</ul>
</li>
</ul>
<h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><ul>
<li>索引表其实很像之前学习的页表，就是通过索引号去快速映射到我们需要的逻辑文件上</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110204932034.png" alt="image-20201110204932034"></p>
<h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><ul>
<li>可以把索引顺序文件这种管理方式看成前面学习的二级页表的管理方式</li>
<li>把键值那一栏看成目录，查找目录总比查找一项项内容要来得快</li>
<li>打个比方，我们都查过字典吧？我们需要查一个字，不可能直接就翻页翻到那一页，而是先翻目录，确定那个字大概在哪，然后再翻到那一部分，第二次查找，去找那个字</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110205536840.png" alt="image-20201110205536840"></p>
<p>有时候，我们只分两层还是不够，需要多级索引</p>
<p>因此衍生出来了：<strong>多级索引顺序文件</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210047209.png" alt="image-20201110210047209"></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112201410070.png" alt="image-20201112201410070"></p>
<h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201217211254729.png" alt="image-20201217211254729"></p>
<p>目录文件中的一条条记录就是一个个的<strong>文件控制块（FCB）</strong></p>
<p>同理：<strong>FCB</strong>的有序集合称为<mark>文件目录</mark>，一个<strong>FCB</strong>就是一个<mark>文件目录项</mark></p>
<p><strong>FCB</strong>实现了文件名和文件之间的映射，使得用户可以实现【按名存取】</p>
<p><strong>FCB</strong>中包含了：</p>
<ol>
<li><strong>文件的基本信息</strong><ol>
<li>文件名</li>
<li>物理地址</li>
<li>逻辑结构</li>
<li>物理结构</li>
<li>….</li>
</ol>
</li>
<li><strong>存取控制信息</strong><ol>
<li>是否可读/可写</li>
<li>禁止访问的用户名</li>
<li>…</li>
</ol>
</li>
<li><strong>实用信息</strong><ol>
<li>文件的建立时间</li>
<li>修改时间</li>
<li>…</li>
</ol>
</li>
</ol>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><ul>
<li><strong>单机文件目录</strong>其实非常好理解：就是在文件系统中只建立一张<strong>目录表</strong>，目录表存放多个文件，然后各文件各占一个目录项，目录项中又包含文件名、文件类型等等属性</li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件类型</th>
<th>文件长度</th>
</tr>
</thead>
<tbody><tr>
<td>文件名1</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>文件名2</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>文件名3</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>是简单，但仅仅只能做到<strong>按名存取</strong>，他有着三个缺点：</p>
<ul>
<li><p>查找速度慢</p>
</li>
<li><p>不允许重名</p>
</li>
<li><p>不便于实现文件共享</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110211948655.png" alt="image-20201110211948655"></p>
</li>
</ul>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110212749873.png" alt="image-20201110212749873"></p>
<h3 id="多级（树形）目录结构"><a href="#多级（树形）目录结构" class="headerlink" title="多级（树形）目录结构"></a>多级（树形）目录结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110213226336.png" alt="image-20201110213226336"></p>
<h4 id="路径名-和-当前目录"><a href="#路径名-和-当前目录" class="headerlink" title="路径名 和 当前目录"></a>路径名 和 当前目录</h4><ul>
<li><p><mark>路径名（path name）</mark>：多级目录（树形目录）中，从根目录出发，找到一项数据文件的路径是唯一的。在该路径上，从树的根开始，直到遍历到数据文件结束，途中经历的全部目录文件名和数据文件名用 <code>/</code>进行连接，就构成了数据文件唯一的路径名了</p>
</li>
<li><p><mark>当前目录（Current Directory）</mark>：由于每个文件的路径名是唯一的，那难道每次访问它都得从根开始吗？显然不可能。</p>
<p>因此衍生出<strong>当前目录</strong>这个概念帮我们解决这个问题。</p>
</li>
</ul>
<h3 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h3><ul>
<li><p>树形目录结构可以方便对文件进行分类，层次结构清晰，也能够有效的进行文件的管理和保护</p>
<p>但是，树形结构不便于实现文件的共享，为此，提出了<strong>无环图目录结构</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195220519.png" alt="image-20201112195220519"></p>
<h3 id="索引结点（FCB的改进）"><a href="#索引结点（FCB的改进）" class="headerlink" title="索引结点（FCB的改进）"></a>索引结点（FCB的改进）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195928484.png" alt="image-20201112195928484"></p>
<p>OS书上还说明了另外一个原因 阐明为什么要引入索引结点</p>
<p>当一个文件被多个文件共享的时候，假如我在其中一个目录访问该文件，并向该文件添加新内容，必须要增加相应的盘块；</p>
<p>而这些新增加的盘块只会出现在我位于的目录中，其他目录是不会相应增加的；</p>
<p>因此这新增的部分是不能被共享的，因此引入了索引结点；</p>
<p>索引结点中记录了文件的各种信息：包括文件在外存中的存放位置和其他的文件属性等信息；</p>
<p>这些信息之前是放在目录项中的，而如今放在索引结点中。</p>
<p>当任何用户对共享的文件进行修改的时候，其相应节点内容都会改变，由于是目录存储了指针，那这些变化对于所有用户都是可见的，因此可以实现共享； </p>
<ul>
<li><p>存放在外存中的索引结点我们称为<strong>磁盘索引结点</strong>，当索引结点<strong>放入内存</strong>后称为<strong>内存索引结点</strong></p>
</li>
<li><p>相比之下，内存索引结点中需要增加一些信息，比如：文件是否被修改，此时有几个进程正在访问该文件。</p>
</li>
</ul>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><h3 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h3><p>类似于我们的内存分配，磁盘（外存）中的存储单元也会被分成一个个的<strong>块/磁盘块/物理块</strong></p>
<p>而在很多操作系统中，磁盘块的大小通常与内存块、页面的大小相同</p>
<ul>
<li>内存与磁盘之间的数据交换：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204211931.png" alt="image-20201112204211931"></p>
<p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式</p>
<p>操作系统为文件分配存储空间都是以<strong>块</strong>为单位</p>
<p>而用户通过逻辑地址来操作自己的文件，操作系统负责实现<strong>从逻辑地址到物理地址的映射</strong></p>
<h3 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213342204.png" alt="image-20201117213342204"></p>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204626251.png" alt="image-20201112204626251"></p>
<p>用户通过逻辑地址来操作自己的文件；</p>
<p><strong>（逻辑块号，块内地址） → （物理块号，块内地址）</strong>，只需要转换块号即可，块内地址保持不变</p>
<p>用户给出了要访问的逻辑块号，操作系统找到该文件对应的<strong>目录项（FCB）</strong></p>
<p><mark>物理块号 = 起始块号 + 逻辑块号</mark>（逻辑块号 需要小于 长度）</p>
<p>由于可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（随机访问）</strong></p>
<ul>
<li><p><strong>连续分配方式的优点</strong>：由于读取某个磁盘块的时候，需要移动磁头；因此访问的两个磁盘块相隔越远，那么移动磁头所需要的时间就越长；而如果文件采取连续分配方式，那么文件就是连续的，因此<strong>连续分配的文件在顺序读/写时速度最快</strong></p>
</li>
<li><p><strong>连续分配方式的缺点</strong>：如果文件A需要拓展，而其后面没有相邻的空闲块，那么就需要<strong>举家迁移</strong>到一个可以放下连续磁盘块的空闲区域</p>
<p>因此，<strong>连续分配的缺点1</strong>：文件不方便拓展</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170336498.png" alt="image-20201113170336498"></p>
</li>
</ul>
<p>假如磁盘中空闲区域并不是连续的，那么就算空闲区域加起来足够放下文件，文件也不能放入磁盘中</p>
<p>因此，<strong>连续分配的缺点2</strong>：存储空间利用率低，会产生难以利用的磁盘碎片（虽然可以用紧凑处理，但耗费很大时间代价）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170652168.png" alt="image-20201113170652168"></p>
<h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113174225789.png" alt="image-20201113174225789"></p>
<p>链接分配优点：（其实和链表的优点大同小异）</p>
<ul>
<li>消除了磁盘的外部碎片，提高外存的利用率</li>
<li>对插入、删除和修改记录都非常容易</li>
<li>能适应文件的动态增长，无需事先知道文件的大小</li>
</ul>
<h5 id="隐式分配"><a href="#隐式分配" class="headerlink" title="隐式分配"></a>隐式分配</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113172110369.png" alt="image-20201113172110369"></p>
<p>采用链式分配（链表形式/隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低</p>
<p>同时，指向下一个盘块的指针也需要消耗少量的存储空间；</p>
<p>但是，采用隐式链接这个方式，可以方便的拓展文件，如果学过链表的同学就知道，我们可以使用尾插法，在这里就是修改结束块号</p>
<p>因此，所有的空闲磁盘块都可以被利用，不会有碎片问题，外村利用率提高</p>
<h5 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113173221037.png" alt="image-20201113173221037"></p>
<p>显式链接类似于数据结构中的静态链表，也就是利用数组去存储下一个块号的下标；</p>
<p>这样子的话，我们只需要知道起始块号，就能找到该文件包含的所有磁盘块了。</p>
<ul>
<li>那么如何实现逻辑块号到物理块号的转变呢？</li>
</ul>
<p>假设用户需要访问逻辑块号i，OS会找到该文件对应的<mark>目录项（FCB）</mark>，FCB中存储了很多信息，其中就包含<strong>起始块号</strong></p>
<p>接着查询<strong>内存中的文件分配表FAT</strong>，往后找i到i号逻辑块对应的物理块号。（相当于查询数组下标了）</p>
<p>这里需要注意，逻辑块号转换到物理块号这一过程是不需要读磁盘操作的</p>
<p>链式分配（显示链接）的文件，支持顺序访问和随机访问，由于块号转换过程不需要访问磁盘，因此相比于隐式链接，访问速度要快很多</p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117204230180.png" alt="image-20201117204230180"></p>
<ul>
<li>索引分配允许文件离散分配在各磁盘块之中，系统会为每个文件建立一张<mark>索引表</mark></li>
<li><mark>索引表</mark>记录了文件的各个<mark>逻辑块</mark>对应的<mark>物理块</mark><ul>
<li>索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页面之间的映射关系</li>
</ul>
</li>
<li><mark>索引表</mark>存放的磁盘块称为<mark>索引块</mark></li>
<li>文件数据存放的磁盘称为<mark>数据块</mark></li>
<li>区别于<strong>显式链接</strong>，索引分配的表是一个文件一张，而<strong>显式链接</strong>中是一个磁盘对应一张（磁盘中包含多个文件，也就是说可能磁盘采取索引分配的话，可能会有多张索引表）</li>
<li>索引分配方式支持<strong>随机访问</strong>，文件拓展也容易实现（给文件分配一个空闲块，再加一个索引表项即可）</li>
<li>但是索引表需要占用一定的<strong>存储空间</strong></li>
</ul>
<h5 id="索引分配方案"><a href="#索引分配方案" class="headerlink" title="索引分配方案"></a>索引分配方案</h5><p>想一想，假如一个文件太大了，一个单独的磁盘块（索引块）装不下文件的整张索引表，那该怎么办呢？</p>
<p>我们有三种解决方案：<strong>链接方案、多层索引、混合索引</strong></p>
<ul>
<li><h4 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117210500055.png" alt="image-20201117210500055"></p>
<p>其实其基本思想与数据结构中的链表无二，就是将块离散的 存储，而后通过链接的方式串起来</p>
<p>但这个方式也与链表的弊端一样，就是我们的查找非常的麻烦，极端一点想，我们只想访问文件最后一个索引块</p>
<p>就不得不遍历整个索引块，十分麻烦且低效</p>
<p>而且中小型文件，本身就不大了，还得为他分配索引块，可见，小文件采用这种方式，索引块利用率很低；</p>
</li>
<li><h4 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117211041743.png" alt="image-20201117211041743"></p>
<p>为解决上述问题，我们类如了类似于多级页表的<strong>多层索引</strong>；</p>
<p>也就是用顶级索引表去查次级索引表，以此类推</p>
<p>其访问方式是：用逻辑块号÷表项数 得到次级表是哪一块，用逻辑块号%表项数得到偏移地址</p>
<p><strong>采用K层索引结构，且顶级索引表未调入内存的时候，访问一个数据块需要 ==k+1==次读磁盘操作</strong></p>
<p>这种方式的优点是：大大加快了对大型文件的查找速度</p>
<p>缺点是：假如文件很小，但其所在的索引技术很大，我访问这个盘块的时候依旧得按照这种方式，太麻烦了；</p>
</li>
<li><h4 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117212311990.png" alt="image-20201117212311990"></p>
<p>我们知道OS最喜欢干的事情就是把各种方法的优点结合起来，然后美名其曰叫“混合xxxx“ 呵呵</p>
<p>混合索引就是既采用了<strong>直接地址索引</strong>，又采用了<strong>多层索引</strong></p>
<p>这样的话，小文件用直接地址索引；大文件用多层索引；十分方便</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213253389.png" alt="image-20201117213253389"></p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117214435447.png" alt="image-20201117214435447"></p>
<h3 id="存储空间管理方法"><a href="#存储空间管理方法" class="headerlink" title="存储空间管理方法"></a>存储空间管理方法</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p>空闲表法 属于 <mark>连续分配方式</mark></p>
<p>与内存的动态方式差不太多，为每个内存分配一块<strong>连续的存储空间</strong></p>
<p>同时为外存上的所有空闲区建立一张空闲表：</p>
<p>每个空闲区对应一个空闲表项——空闲表项又包括：<strong>表项序号</strong>、<strong>该空闲区第一个盘块号</strong>、<strong>该区的空闲盘块数</strong></p>
<p>而文件分配在哪个区间的方法与内存分区（动态）分配方式类似:</p>
<p>采用：<mark>首次适应、最佳适应、最坏适应等算法</mark></p>
<p>对于文件系统来说，文件较小（盘块1-4个时），采用<strong>连续分配方式</strong>，为文件分配相邻接的几个盘块；</p>
<p>当文件较大的时候，采用<strong>离散分配方式</strong>；此外，对于<strong>多媒体文件</strong>，为减少磁头寻道时间，采用<strong>连续分配方式</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120170855920.png" alt="image-20201120170855920"></p>
<h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p>空闲链表法中，形成链表的结点有两种组成形式:<strong>盘块和盘区</strong></p>
<ul>
<li>盘区：每个盘区可包含若干个盘块</li>
<li>空闲链表法：把空闲的结点串在一起，当有文件申请N个盘块的时候，从链表头开始检索，之后的分配方式根据结点是盘块还是盘区决定</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120172927583.png" alt="image-20201120172927583"></p>
<h5 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h5><ul>
<li>OS保存链头链尾指针</li>
<li><mark>分配方式</mark>：从链头开始，边遍历边分配指针</li>
<li><mark>回收方式</mark>：将回收的盘块依次使用尾插法</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120173654373.png" alt></p>
<h5 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h5><ul>
<li><p>OS保存链头、链尾指针</p>
</li>
<li><p><mark>分配方式</mark>：与上一种方式不同，不会边遍历边分配，而是依旧不同算法规则找到一个<strong>合适</strong>的盘区分配给文件</p>
<p>若是不存在这种盘区，则将不同盘区的盘块摘取同时分配给一个文件</p>
</li>
<li><p><mark>回收方式</mark>：若回收区与某空闲盘相邻，则合并到空闲盘区中；若不相邻，则作为单独结点（盘区）使用尾插法</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120174129662.png" alt="image-20201120174129662"></p>
<h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>位示图使用0/1其中一位表示对应盘块空闲，另一位表示已分配</p>
<p>位示图形如二维数组，那么行列肯定有其代表的意义</p>
<ul>
<li>行：字号</li>
<li>列：位号</li>
<li>map[m,n]表示盘块号</li>
</ul>
<p>若盘块号、字号、位号由0开始：</p>
<ul>
<li>字号（行号）i，位号（列号）j的二进制位对应的<strong>盘块号b = n（一个字的字长）× i + j</strong></li>
<li>b盘块号对应的<strong>字号i = b / n</strong>，</li>
</ul>
<p>若从1开始：</p>
<ul>
<li>字号（行号）i，位号（列号）j的二进制位对应的<strong>盘块号b = n（一个字的字长）× （i - 1） + j</strong></li>
<li><mark>分配方式</mark>：若文件需要K个块<ul>
<li>顺序扫描位示图，找到K个相邻或不相邻的0（这里0表示空闲，有可能在另外一种表达方式里1代表空闲）</li>
<li>根据字号、位号(行、列)计算出对应盘块号，将相应盘块分配给文件</li>
<li>将相应位设置为“1”</li>
</ul>
</li>
<li><mark>回收方式</mark>：根据回收的盘块号计算出对应字号位号，设置为0</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201121130707136.png" alt="image-20201121130707136"></p>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124220831037.png" alt="image-20201124220831037"></p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221136257.png" alt="image-20201124221136257"></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221532748.png" alt="image-20201124221532748"></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124222804765.png" alt="image-20201124222804765"></p>
<p>通常来说，打开文件表又分为两种：系统的打开文件表和用户进程的打开文件表</p>
<p>用户进程的打开文件表包含:读写指针 用于 记录该进程对文件的读/写操作进行到的位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124223414879.png" alt="image-20201124223414879"></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211157912.png" alt="image-20201125211157912"></p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211417892.png" alt="image-20201125211417892"></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211550210.png" alt="image-20201125211550210"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211631423.png" alt="image-20201125211631423"></p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125215953551.png" alt="image-20201125215953551"></p>
<p>文件共享的意义:让多个用户共享地使用同一个文件</p>
<p>ps：多个用户共享同一个文件，表示系统中只有一份文件数据，只要某一用户修改该文件数据，其他用户也可以看到文件数据的变化</p>
<p>而假如多个用户复制同一份文件，在各自复制的文件上修改，是对其他用户的文件数据无影响的</p>
<p>文件共享分为两种方式</p>
<ul>
<li>基于索引结点的共享方式 - 硬链接</li>
<li>基于符号链的共享方式 - 软链接</li>
</ul>
<h3 id="基于索引结点的共享方式-硬链接"><a href="#基于索引结点的共享方式-硬链接" class="headerlink" title="基于索引结点的共享方式 - 硬链接"></a>基于索引结点的共享方式 - 硬链接</h3><p>将文件的物理地址以及其他的文件属性等信息 不再放在目录项之中，而是放在索引结点中；</p>
<p>这样的话，文件目录就只会包含：文件名 和 指向索引结点的指针（二级目录？</p>
<p>用户对于文件的修改，是改变了结点内容的改变，而没影响到指针的指向，因此实现了用户的文件共享功能</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125213642244.png" alt="image-20201125213642244"></p>
<h3 id="基于符号链的共享方式-软链接"><a href="#基于符号链的共享方式-软链接" class="headerlink" title="基于符号链的共享方式 - 软链接"></a>基于符号链的共享方式 - 软链接</h3><p>利用符号链实现文件共享的基本思想是：是允许一个文件或子目录有多个父目录，但其中仅有一个作为<strong>主父目录</strong></p>
<p>其他的父目录是通过<strong>符号链接方式</strong>与该文件进行链接</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125214428159.png" alt="image-20201125214428159"></p>
<p>比如说快捷方式，就是一种软链接</p>
<p>当我们启动快捷方式的时候，一层层检索目录结构，最后运行实质上的真正程序。</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>文件保护有三种方式：口令保护、加密保护、访问控制</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174955785.png" alt="image-20201126174955785"></p>
<h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p><strong>基本思想</strong>：为文件设置一个口令（密匙？）用户请求访问该文件时需要提供该口令</p>
<p><strong>口令存储位置</strong>：一般来说存放在文件对应的<strong>FCB</strong>(文件控制块，包含了文件各种信息)或者<strong>索引结点</strong>中。用户访问文件之前输入口令，OS根据用户所输入的口令与FCB中口令进行对比；若正确，则允许该用户访问文件</p>
<p><strong>优点</strong>：保存口令的空间开销不多，验证口令的时间开销也小</p>
<p><strong>缺点</strong>：正确的口令存放在系统内部，不够安全</p>
<h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>加密保护的实质是运用了加密算法，对原始数据进行处理，使之成为新数据；</p>
<p>只有使用对应的解密算法才能把数据还原成原始数据；</p>
<p>比如下例用的是异或运算（相同为0，不一样为1）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126173619641.png" alt="image-20201126173619641"></p>
<p>优点：保密性强，不需要在系统中存储密码</p>
<p>缺点：编码/译码，加密/解密 需要一定时间</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在文件的FBC或索引结点中 + 一个访问控制列表（玩权限）</p>
<p>记录各用户能对该文件进行的操作</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174324167.png" alt="image-20201126174324167"></p>
<p>精简访问列表:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174800002.png" alt="image-20201126174800002"></p>
<h2 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h2><p>文件系统层次结构由上至下分别为:</p>
<p><mark>用户接口→文件目录系统→存取控制模块→逻辑文件系统与文件系统缓冲区→物理文件系统→（辅助分配模块/设备管理模块→设备）</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126205049927.png" alt="image-20201126205049927"></p>
<p><strong>用户接口</strong>：文件系统需要向上层的用户提供一些简单易用的功能接口；这层就是用于处理用户发出的<strong>系统调用请求（Read、Write、Open、Close等系统调用）</strong></p>
<p><strong>文件目录系统</strong>：用户是通过文件路径来访问文件的，==因此这一层需要根据用户给出的文件路径找到相应的==<strong>FCB</strong>或者<strong>索引结点</strong></p>
<p>所有的目录、目录项相关的管理工作都在本层完成。如：管理活跃的文件目录表、管理打开文件表等。</p>
<p><strong>存取控制模块</strong>：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了<strong>文件保护相关功能</strong></p>
<p><strong>逻辑文件系统与文件信息缓冲区</strong>：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址。</p>
<p><strong>物理文件系统</strong>：这一层需要把上一层提供的文件逻辑地址→实际的物理地址</p>
<p><strong>辅助分配模块</strong>：负责文件存储空间的管理，即负责分配和回收存储空间</p>
<p><strong>设备管理模块</strong>：直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等。</p>
<p>用一个例子进行记忆的话：</p>
<p>假设某用户需要删除<mark>D:/工作目录/学生信息.xlsx的<strong>最后100条记录</strong></mark></p>
<p>则：</p>
<ol>
<li>用户需要通过OS提供的接口发出上述请求 —— <strong>用户接口</strong></li>
<li>由于用户提供的是文件的存放路径，因此需要OS一层层查找目录，找到对应的目录项 —— <strong>文件目录系统</strong></li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限 —— <strong>存取控制模块（存取控制验证层）</strong></li>
<li>验证了用户的访问权限之后，需要把用户提供的”记录号”转变为对应的逻辑地址 —— <strong>逻辑文件系统与文件信息缓冲区</strong></li>
<li>知道了目录记录对应的逻辑地址之后，需要转换成实际的物理地址 —— <strong>物理文件系统</strong></li>
<li>要删除记录，需要与磁盘设备发出请求 —— <strong>设备管理程序模块</strong></li>
<li>删除记录后，那么就会有一些盘块变为空闲状态，因此要将空闲盘块进行回收 —— <strong>辅助分配模块</strong></li>
</ol>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127165917726.png" alt="image-20201127165917726"></p>
<h4 id="磁盘-磁道-扇区"><a href="#磁盘-磁道-扇区" class="headerlink" title="磁盘 磁道 扇区"></a>磁盘 磁道 扇区</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155825907.png" alt="image-20201127155825907"></p>
<ul>
<li><p><strong>磁盘</strong>：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
</li>
<li><p><strong>磁道</strong>：磁盘的盘面呗划分成一个个磁道，一个圈（环）就是一个磁道。</p>
<p>磁道类似跑道，可以这样记忆。</p>
</li>
<li><p><strong>扇区</strong>：一个磁道又被划分成一个个扇区，每个扇区就是一个<strong>磁盘块</strong>。各个扇区存放的数据量相同</p>
</li>
</ul>
<h4 id="如何读写数据"><a href="#如何读写数据" class="headerlink" title="如何读写数据"></a>如何读写数据</h4><p>内部结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155902299.png" alt="image-20201127155902299"></p>
<p>读取数据的过程是这样的：</p>
<p>首先把磁头移动到想要读/写扇区的所在的<strong>磁道</strong>上。然后转动磁盘，目标扇区从磁头下划过的时候，就完成了对扇区的读/写操作了。</p>
<p>有点类似于留声机?</p>
<h4 id="盘面、柱面"><a href="#盘面、柱面" class="headerlink" title="盘面、柱面"></a>盘面、柱面</h4><ul>
<li><p><strong>盘面</strong>：一个盘片可能有2各盘面</p>
</li>
<li><p><strong>柱面</strong>：所有盘面中相对位置相同的<strong>磁道</strong>组成柱面</p>
<p>什么意思呢？想象一下空间内有一个盘面（圆）从内到外分成很多个圆环。这些圆环各向垂直于面的方向延申，形成了一个个圆柱面</p>
<p>这就是柱面</p>
</li>
</ul>
<h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127162936159.png" alt="image-20201127162936159"></p>
<p>上述我们提到了柱面、扇面、扇区</p>
<p>那就有对应的柱面号，扇面号和扇区号了。磁盘块的物理地址就是靠这三个属性进行定位</p>
<p>定位过程:</p>
<ol>
<li>首先磁臂内外移动 —— 定位柱面</li>
<li>激活相应的磁头 —— 定位扇面</li>
<li>旋转磁盘，扇区从磁头下划过 —— 定位扇区号</li>
</ol>
<h4 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h4><ul>
<li>按照磁头可不可以移动来分<ul>
<li>磁头可移动：活动头磁盘，磁臂可以来回伸缩带动磁头定位磁道</li>
<li>磁头不可移动：固定头磁盘，磁盘中每个磁道都有一个磁头</li>
</ul>
</li>
<li>按照盘片可不可以更换来分<ul>
<li>盘片可以更换：可换片磁盘</li>
<li>盘片不可更换：固定盘磁盘</li>
</ul>
</li>
</ul>
<h3 id="磁盘调度算法（重点"><a href="#磁盘调度算法（重点" class="headerlink" title="磁盘调度算法（重点)"></a>磁盘调度算法（重点)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175628500.png" alt="image-20201128175628500"></p>
<h4 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读/写操作需要的时间"></a>一次磁盘读/写操作需要的时间</h4><p>要明白算法的调优方式，必须先明白读写的时间开销在哪，才能对症下药</p>
<p><strong>总花费时间  = 寻找时间/寻道时间 + 延迟时间 + 传输时间</strong></p>
<ul>
<li><mark>寻道时间</mark>：磁头定位磁道所花时间</li>
<li><mark>延迟时间</mark>：旋转转盘，磁头定位到扇区所花时间</li>
<li><mark>传输时间</mark>：从磁盘读出/向磁盘写入数据所花时间</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128170619688.png" alt="image-20201128170619688"></p>
<h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><p>这种算法就是按照进程的请求到达顺序，磁头依次移动；</p>
<ul>
<li>优点：公平，假如请求访问的磁道较为集中，算法性能不算太差</li>
<li>缺点：若有大量进程竞争使用磁盘，请求访问磁道分散，则磁头需要移动的磁道数将会很大，此算法性能就会很差。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171229955.png" alt="image-20201128171229955"></p>
<h4 id="最短寻找时间优先算法（SSTF）"><a href="#最短寻找时间优先算法（SSTF）" class="headerlink" title="最短寻找时间优先算法（SSTF）"></a>最短寻找时间优先算法（SSTF）</h4><p>这个算法只会着眼于眼前的最近磁道（贪心算法），保证单次寻道时间最短。</p>
<ul>
<li><p>优点:性能好，平均寻道时间短</p>
</li>
<li><p>缺点:可能造成【饥饿】现象</p>
<p>什么意思呢？假如处理某处磁道的访问请求时，本来应该处理下一个磁道请求了，但来了一个更近的，就不得不先处理更近的了。这种情况一旦多了，就会导致一些磁道访问请求迟迟得不到处理，造成了饥饿现象。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171832768.png" alt="image-20201128171832768"></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 磁盘调度算法;</span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//最短寻道时间优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSTF</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> visit[];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nearIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sstf(<span class="keyword">int</span> queue[],<span class="keyword">int</span> start)&#123;</span><br><span class="line">		<span class="keyword">int</span> nearNum=<span class="number">9999</span>;</span><br><span class="line">		visit=<span class="keyword">new</span> <span class="keyword">int</span>[queue.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queue.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queue.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(queue[j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			visit[i]=nearNum;</span><br><span class="line">			queue[nearIndex]=-<span class="number">1</span>;</span><br><span class="line">			start=nearNum;</span><br><span class="line">			nearNum=<span class="number">9999</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> visit;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> visit[],<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">		System.out.print(<span class="string">&quot;访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;visit.length;i++)&#123;</span><br><span class="line">			System.out.print(visit[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			sum=Math.abs(visit[i]-start)+sum;</span><br><span class="line">			start=visit[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;经过的磁道总数：&quot;</span>+sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均寻道长度：&quot;</span>+sum/visit.length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求序列长度：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] queue=<span class="keyword">new</span> <span class="keyword">int</span>[a];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">			queue[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		SSTF sstf=<span class="keyword">new</span> SSTF();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入读写头起始位置：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> start=sc.nextInt();</span><br><span class="line">		sstf.print(sstf.sstf(queue, start),start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h4><p>扫描算法是用于解决SSTF算法产生的饥饿问题的。</p>
<p>SSTF算法的饥饿问题是由于磁头有可能仅在一个小区域内移动，因此，扫描算法规定了扫描的方式：</p>
<p><strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能向外移动</strong></p>
<ul>
<li><p>优点：性能较好，平均寻道时间短，不会产生饥饿现象(不会发生磁头只在一个小区域内移动的问题)</p>
</li>
<li><p>缺点：只有到达最边上的磁道时才能改变磁道移动方向（有时候外侧磁道是没有请求的，因此移动是无意义的）</p>
<p>SCAN算法对各位置磁道的<strong>相应频率</strong>不平均，有一些磁道刚被从左往右移动磁头访问了，没过多久就又会被从右往左返回的磁头再次访问，而有一些磁道就得等很久才能被再次访问。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128172906549.png" alt="image-20201128172906549"></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 磁盘调度算法<span class="number">2</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SCAN</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> visit[];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nearIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] scan(<span class="keyword">int</span> queue[],<span class="keyword">int</span> start,<span class="keyword">int</span> direction)&#123;</span><br><span class="line">		<span class="keyword">int</span> nearNum=<span class="number">9999</span>;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		visit=<span class="keyword">new</span> <span class="keyword">int</span>[queue.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queue.length;i++)&#123;</span><br><span class="line">			index=-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queue.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(queue[j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>((direction==<span class="number">1</span>)&amp;&amp;(queue[j]&gt;start)&amp;&amp;(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start)))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">						index=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>((direction==<span class="number">0</span>)&amp;&amp;(queue[j]&lt;start)&amp;&amp;(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start)))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">						index=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((direction==<span class="number">1</span>)&amp;&amp;(index==-<span class="number">1</span>))&#123;</span><br><span class="line">				direction=<span class="number">0</span>;</span><br><span class="line">				i=i-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((direction==<span class="number">0</span>)&amp;&amp;(index==-<span class="number">1</span>))&#123;</span><br><span class="line">				direction=<span class="number">1</span>;</span><br><span class="line">				i=i-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">				visit[i]=nearNum;</span><br><span class="line">				queue[nearIndex]=-<span class="number">1</span>;</span><br><span class="line">				start=nearNum;</span><br><span class="line">				nearNum=<span class="number">9999</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> visit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> visit[],<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">		System.out.print(<span class="string">&quot;访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;visit.length;i++)&#123;</span><br><span class="line">			System.out.print(visit[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			sum=Math.abs(visit[i]-start)+sum;</span><br><span class="line">			start=visit[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;经过的磁道总数：&quot;</span>+sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均寻道长度：&quot;</span>+sum/visit.length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求序列长度：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] queue=<span class="keyword">new</span> <span class="keyword">int</span>[a];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">			queue[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		SCAN scan=<span class="keyword">new</span> SCAN();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入读写头起始位置：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> start=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;磁道增加的方向：（0向磁道号减少的方向移动,1向磁道号增加的方向移动）&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> direction=sc.nextInt();</span><br><span class="line">		scan.print(scan.scan(queue, start,direction),start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h4><p>扫描算法虽然解决了饥饿问题，但是出现了有一些没必要的移动问题。</p>
<p>那么LOOK算法就是解决这个问题的：</p>
<p>若磁头行进路径方向上没有其他请求了，就立刻改变磁头移动方向，减少了无意义的移动。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174043814.png" alt="image-20201128174043814"></p>
<h4 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h4><p>扫描算法还有一个问题，就是各个位置磁道的响应频率不平均</p>
<p>循环扫描算法就是解决这一问题：</p>
<p>它规定了一个方向，只有沿着这个方向移动的磁头才会对磁道访问请求进行处理，而反方向时只快速移动，而不做任何处理</p>
<ul>
<li>优点：各个位置磁道的响应频率很平均</li>
<li>缺点：还是老问题，它到达最边上磁道才会反向移动，多了无意义的移动。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174540760.png" alt="image-20201128174540760"></p>
<h4 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h4><p>回想一下之前的LOOK算法，假如磁头行进路径方向上没有其他请求了，就立刻返回。</p>
<p>那么C-LOOK算法也是如此，而且它加上了循环扫描算法的特点：它规定了一个方向，只有沿着这个方向移动的磁头才会对磁道访问请求进行处理，而反方向时只快速移动，而不做任何处理</p>
<p><strong>也就是 C-SCAN算法 + LOOK算法 = C-LOOK算法</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175558729.png" alt="image-20201128175558729"></p>
<h3 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182703444.png" alt="image-20201128182703444"></p>
<ul>
<li>延迟时间：将目标扇区转到磁头下面所花的时间</li>
</ul>
<p>由于磁头读入扇区数据后需要一定时间处理，而在这时间段内，磁盘并不会因此而停下，而是接着旋转。</p>
<p>因此逻辑相邻的扇区恰好在物理上也相邻，那么想处理连续逻辑扇区的时候，就不得不等磁盘转到下一个扇区，因此有可能需要很长的延迟时间。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128180104677.png" alt="image-20201128180104677"></p>
<p>解决方案1:</p>
<p>可以采取交替编号策略，使得逻辑上相邻的扇区在物理上不一定要相邻，而是有一定的间隔，这样的话，有可能磁头在转到下一个扇区的时候，上一个扇区的数据已经读取完毕，准备好读下一个了。</p>
<p>解决方案2：</p>
<p>采取错位命名的策略，使得相邻盘面的相对位置相同的扇区编号不同；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182645509.png" alt="image-20201128182645509"></p>
<h3 id="磁盘地址结构设计"><a href="#磁盘地址结构设计" class="headerlink" title="磁盘地址结构设计"></a>磁盘地址结构设计</h3><p>思考一个问题，为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而非（盘面号，柱面号，扇区号）呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181834131.png" alt="image-20201128181834131"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181851581.png" alt="image-20201128181851581"></p>
<p>根据之前的学习，我们知道磁头臂之所以要移动是为了切换柱面，也就是切换磁道号；</p>
<p>盘面号，柱面号，扇区号 ：这种记录方式，需要移动磁头臂</p>
<p>柱面号，盘面号，扇区号：这种记录方式只需要激活不同盘面的磁头，不需要移动磁头臂</p>
<p>而上一节我们也知道了，移动磁头笔的时间我们称为寻道时间，</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193846941.png" alt="image-20201128193846941"></p>
<h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><p>磁盘初始化分为三步：低级格式化 磁盘分区 逻辑格式化</p>
<ul>
<li><p><mark>低级格式化/物理格式化</mark>：将磁盘各磁道划分为扇区，扇区包含三个区域—— 头、数据区域、尾三部分</p>
<p>其中，头尾用于存储管理扇区的数据结构（如扇区校验码）</p>
</li>
<li><p><mark>分区</mark>：第一步分好了扇区，第二部则是用若干柱面将扇区填充好（磁盘分盘：C盘、D盘、E盘）</p>
</li>
<li><p><mark>逻辑格式化</mark>：创建文件系统 —— 创建文件系统的根目录、初始化存储管理空间所用的数据结构</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128192121698.png" alt="image-20201128192121698"></p>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>ROM：初始化程序可以放在ROM（只读存储器）中。ROM中的数据在厂的时候就写入了，并且之后不能再修改</p>
<p>ROM一般是出厂的时候，就集成在主板上</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193411250.png" alt="image-20201128193411250"></p>
<h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><p>坏块：即坏了，无法使用的扇区；属于硬件故障，OS无法修复，针对坏块能做的只有标记坏块，避免使用到。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161756659.png" alt></p>
<h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="IO设备概念和分类"><a href="#IO设备概念和分类" class="headerlink" title="IO设备概念和分类"></a>IO设备概念和分类</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220130343.png" alt="image-20201130220130343"></p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>什么是IO设备?</li>
</ul>
<p>IO设备就是可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备，是计算机中的硬件部件</p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p>
<p>比如:Write操作——向外部设备写出数据；Read操作:从外部设备读入数据</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130214951871.png" alt="image-20201130214951871"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按照<mark>使用特性</mark>分类：<ul>
<li>人机交互类外部设备：数据传输速度慢</li>
<li>存储设备：数据传输速度快</li>
<li>网络通信设备：数据传输速度介于两者之间</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215834935.png" alt="image-20201130215834935"></p>
<hr>
<ul>
<li>按照<mark>传输速率</mark>分类：<ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215811961.png" alt="image-20201130215811961"></p>
<hr>
<ul>
<li>按照<mark>信息交换的单位</mark>分类<ul>
<li>块设备：传输速率较高，可寻址，对它可以随机地读/写任一块</li>
<li>字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220114190.png" alt="image-20201130220114190"></p>
<h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I-O控制器"></a>I-O控制器</h2><ul>
<li>I/O设备分为两部分：机械部件和电子部件（I/O控制器、设备控制器）</li>
</ul>
<h3 id="机械部件"><a href="#机械部件" class="headerlink" title="机械部件"></a>机械部件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220615924.png" alt="image-20201130220615924"></p>
<h3 id="电子部件（I-O控制器）"><a href="#电子部件（I-O控制器）" class="headerlink" title="电子部件（I/O控制器）"></a>电子部件（I/O控制器）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202131444915.png" alt="image-20201202131444915"></p>
<p>由于CPU无法直接控制I/O设备地机械部件，解决这种问题 经典方案：<mark>加一层</mark></p>
<p>让<strong>电子部件</strong>充当CPU和I/O设备机械部件之间的中介，用于实现CPU对设备地控制</p>
<p>这个<strong>电子部件</strong>就是<mark>I/O控制器</mark>，又称为<mark>设备控制器</mark>，CPU可以控制这个I/O控制器，由这个来控制设备的机械部件</p>
<h4 id="I-O控制器功能"><a href="#I-O控制器功能" class="headerlink" title="I/O控制器功能"></a>I/O控制器功能</h4><ul>
<li><p><strong>接受和识别CPU发出的命令</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222052883.png" alt="image-20201130222052883"></p>
</li>
<li><p><strong>向CPU报告设备的状态</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222059739.png" alt="image-20201130222059739"></p>
</li>
<li><p><strong>数据交换</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222106107.png" alt="image-20201130222106107"></p>
</li>
<li><p><strong>地址识别</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222210248.png" alt="image-20201130222210248"></p>
</li>
<li><p><strong>数据缓冲</strong></p>
<p>I/O设备的速率较低，而CPU和内存速率很高，因此在控制器中要设置一个缓冲区。（好像就是数据寄存器？）</p>
</li>
<li><p><strong>差错控制</strong></p>
<p>对于I/O设备传过来的数据，设备管理器还需要进行差错检测。如果有错误，就需要将差错检测码置位，并向CPU报告，CPU会把这次传过来的数据作废，并重新进行一次传送，以保证数据输入的正确性。</p>
</li>
</ul>
<h4 id="I-O控制器组成"><a href="#I-O控制器组成" class="headerlink" title="I/O控制器组成"></a>I/O控制器组成</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130223413367.png" alt="image-20201130223413367"></p>
<ol>
<li>一个I/O控制器可能会对应多个设备</li>
<li>数据寄存器、控制寄存器、状态寄存器可能会有多个（如：每个控制/状态寄存器会对应一个具体的设备），且这些寄存器都需要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<mark>内存映像I/O</mark>；另一些计算机则采用I/O专用地址，即<mark>寄存器独立编址</mark>。</li>
</ol>
<h3 id="内存映像I-O-寄存器独立编址"><a href="#内存映像I-O-寄存器独立编址" class="headerlink" title="内存映像I/O | 寄存器独立编址"></a>内存映像I/O | 寄存器独立编址</h3><p>左图是内存映像（映射）I/O ，右图采用寄存器独立编址；</p>
<ul>
<li><p><strong>内存映射I/O</strong>：编址上不再区分内存单元和设备控制器中的寄存器地址，都用N记录；</p>
<p>当地址处于0 ~ (N - 1) 范围 被认为是内存地址，大于等于N时候，认为是某控制器的寄存器地址</p>
</li>
<li><p><strong>寄存器独立编址</strong>：这种方法采用特定的I/O指令:</p>
<ul>
<li><code>cpu-reg</code>是CPU某个寄存器 <code>dev-no</code>是指定设备，即控制器地址；<code>dev-reg</code>指定控制器中的寄存器</li>
<li>CPU寄存器中的内容复制到控制寄存器中指令:<code>io-store cpu-reg, dev-no,dev-reg</code></li>
<li>CPU寄存器中内容存入内存某单元指令:<code>Store cpu-reg,k</code></li>
</ul>
<p>这种方法的主要缺点就是：访问内存和访问设备需要两种不同指令。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202130124223.png" alt="image-20201202130124223"></p>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221506579.png" alt="image-20201202221506579"></p>
<ul>
<li>I/O控制方式分为:<strong>程序直接控制方式、中断驱动方式、DMA方式、通道控制方式</strong></li>
</ul>
<h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133214862.png" alt="image-20201202133214862"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133541738.png" alt="image-20201202133541738"></p>
<ul>
<li>CPU干预的频率：非常频繁，I/O操作开始之前、完成之后需要CPU接收，并且在等待I/O完成的过程中CPU需要不停地轮询检查</li>
<li>数据传送的单位：每次读/写<strong>一个字</strong></li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备 → CPU（CPU的寄存器） → 内存</li>
<li>写操作（数据输出）：内存 → CPU（CPU的寄存器）→ I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可</li>
<li>缺点：CPU和I/O只能串行工作（也就是不能并行工作）；CPU需要已知轮询检查，长期处于<strong>忙等</strong>状态,CPU利用率低。</li>
</ul>
</li>
</ul>
<h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202134152591.png" alt="image-20201202134152591"></p>
<ul>
<li>CPU干预的频率：每次I/O操作开始之前、完成之后需要CPU介入；等待I/O完成的过程中CPU可以切换到别的进程执行。</li>
<li>数据传送的单位：每次读/写<strong>一个字</strong></li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备 → CPU（CPU的寄存器） → 内存</li>
<li>写操作（数据输出）：内存 → CPU（CPU的寄存器）→ I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：与<strong>程序直接控制方式</strong>相比，在<strong>中断驱动方式</strong>中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停轮询</li>
<li>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li>
</ul>
</li>
</ul>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202135117348.png" alt="image-20201202135117348"></p>
<h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>DMA控制器包含以下部分:</p>
<ul>
<li><mark>DR（Data Register ， 数据寄存器）</mark>：暂存从设备到内存，或从内存到设备的数据。</li>
<li><mark>MAR（Memory Address Register，内存地址寄存器）</mark>：在输入时，MAR表示数据应放在内存中的什么位置；输出的时候，MAR表示要输出的数据放在内存中的上面位置</li>
<li><mark>DC（Data Counter， 数据计数器）</mark>：表示剩余要读/写的字节数</li>
<li><mark>CR（Command Register，命令/状态寄存器）</mark>：用于存放CPU发来的I/O命令，或设备的状态信息。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202215012157.png" alt="image-20201202215012157"></p>
<ul>
<li>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
<li>数据传送的单位：每次读/写<strong>一个或多个块</strong>（ps：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li>
<li>数据的流向（不需要流经CPU）<ul>
<li>读操作（数据输入）：I/O设备 → 内存</li>
<li>写操作（数据输出）：内存 → I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：数据传输以<strong>块</strong>为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的<strong>并行性</strong>得到提升。</li>
<li>缺点：CPU每发出一条指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</li>
</ul>
</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221208007.png" alt="image-20201202221208007"></p>
<ul>
<li>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU的干预</li>
<li>数据传送的单位：每次读/写<strong>一组数据块</strong></li>
<li>数据的流向（在通道的控制下进行）<ul>
<li>读操作（数据输入）：I/O设备 → 内存</li>
<li>写操作（数据输出）：内存 → I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：CPU、通道、I/O设备可并行工作，资源利用率很高。</li>
<li>缺点：实现复杂，需要专门的通道硬件支持</li>
</ul>
</li>
</ul>
<h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I/O软件层次结构"></a>I/O软件层次结构</h2><p>大体从上至下分为:用户层软件，设备独立性软件，设备驱动程序，中断处理程序和硬件</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221809697.png" alt="image-20201202221809697"></p>
<h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202222126442.png" alt="image-20201202222126442"></p>
<h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><p>设备独立性软件（又称为设备无关性软件）。与设备硬件特性无关的功能几乎都在这一层实现</p>
<p>它所主要实现的功能如下：</p>
<ol>
<li><p>向上层<strong>提供统一的调用接口</strong>（如read/write系统调用）</p>
</li>
<li><p><strong>设备的保护</strong>：原理类似于文件保护。设备被看作是一种特殊的文件，不同用户对于各文件的访问权限也是不同的。同理，对设备的访问权限也不一样。</p>
</li>
<li><p><strong>差错处理</strong>：设备独立性软件需要对一些设备的错误进行处理</p>
</li>
<li><p><strong>设备的分配与回收</strong>：很多设备是临界资源，不能同时分配给多个进程，需要回收。</p>
</li>
<li><p><strong>数据缓冲区管理</strong>：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li><p><strong>建立<mark>逻辑设备名</mark>到<mark>物理设备名</mark>的映射关系</strong>；根据设备类型选择调用相应的驱动程序。（打印店打印的时候，一台电脑可以对应多个打印机（打印机1，打印机2…，这些就是<strong>逻辑设备名</strong>）</p>
<p>设备独立性软件需要通过<strong>逻辑设备表（LUT,Logical Unit Table）</strong>来确定逻辑设备对应的物理设备；并找到该设备对应的<strong>设备驱动程序</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202223154354.png" alt="image-20201202223154354"></p>
</li>
</ol>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>由于不同的I/O设备有不同的硬件特性，因此需要根据设备不同硬件特性提供相应的驱动程序。</p>
<p>这些驱动程序将上层传达下来的命令<mark>翻译</mark>成下层特定设备能听得懂的操作。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161331778.png" alt="image-20201203161331778"></p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161549430.png" alt="image-20201203161549430"></p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>执行I/O操作，由机械部件、电子部件组成。</li>
</ul>
<h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I/O核心子系统"></a>I/O核心子系统</h2><p>I/O核心子系统属于操作系统的内核部分；</p>
<h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h3><ul>
<li><p>I/O调度:用某种算法确定一个好的顺序来处理各个I/O请求。</p>
</li>
<li><p>如:磁盘调度(先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法)。当多个磁盘I/O请求到来时,用某种调度算法确定满足I/O请求的顺序。<br>冋理,打卬机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序。</p>
</li>
</ul>
<h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p>操作系统需要实现文件保护功能,不同的用户对各个文件有不同的访问权限(如:只读、读和写等在UNIX系统中,设备被看做是一种特殊的文件,每个设备也会有对应的FCB。当用户请求访问某个设备时,系统根据FCB中记录的信息来判断该用户是否有相应的访问权限,以此实现“设备保护”的功能。(参考“文件保护”小节)</p>
<h3 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171706471.png" alt="image-20201203171706471"></p>
<p>要知道什么是假脱机技术，就得先了解脱机技术：</p>
<ul>
<li>脱机IO技术：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围控制机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203164159076.png" alt="image-20201203164159076"></p>
<p>那么假脱机技术又是什么呢?</p>
<p>在脱机技术中，用户程序和数据是预先存在了磁带中，进而通过控制机来输入和输出数据，</p>
<p>因此假脱机技术就是仿造这种方式：</p>
<ul>
<li><p>用 输入进程 <strong>模拟</strong> 脱机输入时的外围控制机</p>
</li>
<li><p>用 输出进程 <strong>模拟</strong> 脱机输出时的外围控制机</p>
</li>
<li><p>用 输入井 <strong>模拟</strong> 脱机输入时的磁带，用于收容I/O设备输入的数据</p>
</li>
<li><p>用 输出井 <strong>模拟</strong> 脱机输出时的磁带，用于收容用户进程输出的数据</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165450142.png" alt="image-20201203165450142"></p>
<p>在内存中不仅仅有输入和输出进程，还有输入缓冲区和输出缓冲区</p>
<p>缓冲区相当于一个中转站，给数据传输的进行喘一口气</p>
<ul>
<li>输入缓冲区：暂存从输入设备输入的数据，之后转存到输入井中</li>
<li>输出缓冲区：暂存从输出井送进来的数据，之后再传送到输出设备上</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165501947.png" alt="image-20201203165501947"></p>
<h4 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h4><ul>
<li>独占式设备一一只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求</li>
<li>共享设备一一允许多个进程“同时”使用的设备(宏观上同时使用,微观上可能是交替使用)。可以同时满足多个进程的使用请求。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171351378.png" alt="image-20201203171351378"></p>
<p>通过这种方式，虽然系统中只有一台打印机，但每个进程提出打印请求的时候，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使得每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p>SPOOLing技术把一台物理设备<strong>虚拟</strong>成了逻辑上的多台设备，可将独占式设备改造成了共享设备。</p>
<h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180248315.png" alt="image-20201203180248315"></p>
<h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><p>考虑因素分三大因素:设备的固有属性、设备分配算法、设备分配中的安全性</p>
<h4 id="设备固有属性因素"><a href="#设备固有属性因素" class="headerlink" title="设备固有属性因素"></a>设备固有属性因素</h4><p>设备的固有属性可分为三种：<strong>独占设备、共享设备、虚拟设备</strong></p>
<p>独占式设备：一个时间段只能分配给一个进程<br>共享式设备：可同时分配给多个进程使用，各个进程往往是宏观上同时共享使用设备，微观上交替使用。<br>虚拟设备：采用假脱机技术将独占式设备改造成虚拟共享设备，可同时分配给多个进程使用。（如采用SPOOLing技术实现的共享打印机）</p>
<h4 id="设备分配算法因素"><a href="#设备分配算法因素" class="headerlink" title="设备分配算法因素"></a>设备分配算法因素</h4><p>先来先服务算法、短作业优先算法，优先级高优先算法等。</p>
<h4 id="设备分配安全性因素"><a href="#设备分配安全性因素" class="headerlink" title="设备分配安全性因素"></a>设备分配安全性因素</h4><p>从进程运行的安全性上考虑，设备分配有两种方式：</p>
<ul>
<li><mark>安全分配方式</mark>：为进程分配一个设备后就将进程阻塞，本次IO完成后才将这个进程唤醒。(打印机例子)<ul>
<li>优点：这种方式是安全的破坏了“请求和保持条件”，不会发生死锁。</li>
<li>缺点：但是对于一个进程来说，CPU和IO设备只能串行工作。系统资源利用率低，进程执行效率低。</li>
</ul>
</li>
<li><mark>不安全分配方式</mark>：进程发出IO请求后，系统为其分配IO设备，进程可以继续执行，之后还可以发出新的IO请求。只有某个IO请求得不到满足的情况下才将进程阻塞。<ul>
<li>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</li>
<li>缺点：有可能发生死锁（就需要：死锁避免、死锁的检测和解除）</li>
</ul>
</li>
</ul>
<h3 id="设备分配方式"><a href="#设备分配方式" class="headerlink" title="设备分配方式"></a>设备分配方式</h3><p>分为：静态分配和动态分配 两种分配方式</p>
<ul>
<li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了<mark>请求和保持</mark>条件，不会发生死锁）</li>
<li>动态分配：进程运行过程中动态申请设备资源</li>
</ul>
<h3 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h3><p>设备与控制器通道之间的关系。<br>一个通道可以有多个控制器，一个控制器又能控制多台设备。所以他们三者之间是一对多的关系，也就可以用树状结构来描述。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174336130.png" alt="image-20201203174336130"></p>
<h4 id="设备控制表DCT"><a href="#设备控制表DCT" class="headerlink" title="设备控制表DCT"></a>设备控制表DCT</h4><ul>
<li><strong>设备控制表 - <mark>D</mark>evice <mark>C</mark>ontrol <mark>T</mark>able - DCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174727508.png" alt="image-20201203174727508"></p>
<h4 id="控制器控制表COCT"><a href="#控制器控制表COCT" class="headerlink" title="控制器控制表COCT"></a>控制器控制表COCT</h4><ul>
<li><strong>控制器控制表 - <mark>Co</mark>ntroller <mark>C</mark>ontrol <mark>T</mark>able - COCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174925206.png" alt="image-20201203174925206"></p>
<h4 id="通道控制表CHCT"><a href="#通道控制表CHCT" class="headerlink" title="通道控制表CHCT"></a>通道控制表CHCT</h4><ul>
<li><strong>通道控制表 - <mark>Ch</mark>annel <mark>C</mark>ontrol <mark>T</mark>able - CHCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175015208.png" alt="image-20201203175015208"></p>
<h4 id="系统设备表SDT"><a href="#系统设备表SDT" class="headerlink" title="系统设备表SDT"></a>系统设备表SDT</h4><ul>
<li><strong>系统设备表 - <mark>S</mark>ystem <mark>D</mark>evice <mark>T</mark>able - SDT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175109971.png" alt="image-20201203175109971"></p>
<h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><ul>
<li>自下到上的查表，分配</li>
</ul>
<ol>
<li>按照进程请求的物理设备名查找<strong>SDT（系统设备表）</strong></li>
<li>根据系统设备表找到<strong>DCT（设备控制表）</strong>，若设备忙碌则将进程挂到设备等待队列中，不忙碌则将设备分配给进程。</li>
<li>根据设备控制表找到<strong>COCT（控制器控制表）</strong>，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据<strong>COCT（控制器控制表）</strong>找到<strong>CHCT（通道控制表）</strong>，若通道忙碌则将PCB挂到通达等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<p><strong>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可以启动IO设备进行数据传送</strong></p>
<p>缺点：</p>
<ol>
<li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法执行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ol>
<h3 id="设备分配的改进方式"><a href="#设备分配的改进方式" class="headerlink" title="设备分配的改进方式"></a>设备分配的改进方式</h3><p>改进思想：通过建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名就可以找到物理设备名。</p>
<p>①根据进程请求的逻辑设备名查找SDT（<strong>注：用户编程时提供的逻辑设备名其实就是“设备类型”</strong>）<br>②查找SDT，找到用户进程<strong>指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</strong><br>③根据DCT找到COCT，若控制器忙碌，则将PCB挂到控制器等待队列中；不忙碌，则将控制器分配给进程。<br>④根据COCT找到CHCT，若通道忙碌，则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</p>
<p>上述步骤提到了一个<mark>逻辑设备表LUT</mark>。那么什么是LUT呢？</p>
<p>还记得改进思想吗？建立映射，这个LUT就是用来<strong>建立映射</strong>（将逻辑设备名映射为物理设备名）的。</p>
<p>用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射。<strong>LUT（逻辑设备表）</strong><br><code>如果整个系统只有一张LUT：各个用户所用的逻辑设备名不能重复，如果每个用户一张LUT：各个用户的逻辑设备名可以重复。</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175918544.png" alt="image-20201203175918544"></p>
<p>上面步骤是第一次通过逻辑设备名申请使用一个设备，假如之后进程再以相同的逻辑设备名来请求使用设备的话:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180225450.png" alt="image-20201203180225450"></p>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165851742.png" alt="image-20201204165851742"></p>
<h3 id="缓冲区概述"><a href="#缓冲区概述" class="headerlink" title="缓冲区概述"></a>缓冲区概述</h3><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<p>使用<mark>硬件</mark>作为缓冲区的成本较高，容量小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的<strong>联想寄存器</strong>，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况，更多是利用<mark>内存</mark>作为缓冲区，<strong>设备独立性软件</strong>的缓冲区管理就是要组织管理好这些缓冲区。</p>
<h3 id="缓冲区作用"><a href="#缓冲区作用" class="headerlink" title="缓冲区作用"></a>缓冲区作用</h3><p>缓冲区有什么作用呢？</p>
<ol>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203215628038.png" alt="image-20201203215628038"></p>
<h3 id="缓冲区管理策略"><a href="#缓冲区管理策略" class="headerlink" title="缓冲区管理策略"></a>缓冲区管理策略</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>背景/什么时候需要用到缓冲：假设某用户进程请求某种块设备读入若干块的数据</p>
<p>此时若采用单缓冲的策略：操作系统会在<strong>主存</strong>中为其分配一个缓冲区</p>
<p>其中要注意:</p>
<ol>
<li>当缓冲区数据<strong>非空（满）</strong>时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</li>
<li>当缓冲区<strong>为空</strong>时，可以往缓冲区冲入输入，但必须把缓冲区充满之后，才能从缓冲区当数据传出</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204160730604.png" alt="image-20201204160730604"></p>
<p>假设输入数据的时间为<strong>T</strong>，CPU处理数据的时间为<strong>C</strong>，缓冲区传送数据到工作区的时间为<strong>M</strong></p>
<p>若<mark>T&gt;C（输入数据时间比CPU处理时间开销长）</mark>：由<strong>限制2</strong>我们可以知道CPU处理完数据后并不能将下一块数据从缓冲区传送到工作区，必须等缓冲区中冲满数据才可以进行下一组数据的处理</p>
<p>若<mark>T&lt;C（CPU处理时间比输入数据时间开销长）</mark>：由<strong>限制1</strong>我们可以知道当缓冲区的数据被冲满后，并不能继续冲入下一块数据，必须等待CPU处理结束后，才能将数据从缓冲区传送到工作区。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204155830464.png" alt="image-20201204155830464"></p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>背景/什么时候需要用到缓冲：假设某用户进程请求某种块设备读入若干块的数据</p>
<p>此时若采用单缓冲的策略：操作系统会在<strong>主存</strong>中为其分配两个缓冲区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204162120223.png" alt="image-20201204162120223"></p>
<p>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</p>
<p>假设输入数据的时间为<strong>T</strong>，CPU处理数据的时间为<strong>C</strong>，缓冲区传送数据到工作区的时间为<strong>M</strong></p>
<ul>
<li><p>若<mark>T &gt; C + M（数据输入时间大于CPU处理时间加上缓冲区传送数据时间）</mark></p>
<p>首先满缓冲区开始传送数据到工作区，交由CPU处理；传送数据开始的时候，设备向空缓冲区冲入数据；新的满缓冲区向工作区传送数据，交由CPU处理；同理，另一个空缓冲区也同步冲入数据；由此反复…</p>
</li>
</ul>
<p>处理一块数据的平均用时为 T</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163502759.png" alt="image-20201204163502759"></p>
<ul>
<li><p>若<mark>T &lt; C + M（数据输入时间小于CPU处理时间加上缓冲区传送数据时间）</mark></p>
<p>设备向空缓冲区输入数据和满缓冲区向工作区传数据同步进行，当然了，后者进行完后CPU会接力完成数据处理；</p>
<p>我们知道，由于<strong>限制1</strong>的约束，有可能做不到2T = 2M + C，也就是说，一个缓冲区是满的，另一个还有点参与数据没取完，就必须等待另一个M的进行。</p>
</li>
</ul>
<p>处理一块数据的平均用时为 C + M</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163508555.png" alt="image-20201204163508555"></p>
<p>综合来说：采用双缓冲策略，处理一个数据块的平均耗时为Max (T, C+M)</p>
<h4 id="使用单-双缓冲在通信时的区别"><a href="#使用单-双缓冲在通信时的区别" class="headerlink" title="使用单/双缓冲在通信时的区别"></a>使用单/双缓冲在通信时的区别</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204164935982.png" alt="image-20201204164935982"></p>
<h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165050655.png" alt="image-20201204165050655"></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：</p>
<ul>
<li>用于收容输入数据的<mark>工作缓冲区（hin）</mark></li>
<li>用于提取输入数据的<mark>工作缓冲区（sin）</mark></li>
<li>用于收容输出数据的<mark>工作缓冲区（hout）</mark></li>
<li>用于提取输出数据的<mark>工作缓冲区（sout）</mark></li>
</ul>
<p>操作系统根据不同的进程请求，将不同队列中的缓冲区提取一块出来 作为上述四种工作缓冲区的一种；</p>
<p>然后将其交付给程用于执行，缓冲区的状态将会进行一定的改变，之后会挂回到对应状态的队列队尾；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165820255.png" alt="image-20201204165820255"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckppikufa004kp0wi58msgmo3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/UesugiEr11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>