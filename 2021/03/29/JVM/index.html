<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JVM | Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于JVM的一些">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://uesugier11.github.io/2021/03/29/JVM/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="关于JVM的一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150422.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327170325065.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327171507549.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327172341180.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327175412940.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327180817345.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327181945387.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212734640.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212704950.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220740850.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220755869.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131631397.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131624431.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132108123.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132146310.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/v2-7c34658ce6ef846c31593d479db89a94_hd.jpg">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329140851007.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143315393.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145942295.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145612278.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151426081.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151456843.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151617194.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329153609323.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329210714606.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329212803232.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220051576.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220606611.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220707797.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200718171257640.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200718171302947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210331222026374.png">
<meta property="og:image" content="https://www.pianshen.com/images/752/e1021c66ff23345c1b990f6edae93b10.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401155032539.png">
<meta property="og:image" content="https://www.pianshen.com/images/766/fa8aecd7819647645d2f83ee72d3db5e.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161651540.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161711251.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163229697.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163240449.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401170801241.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401172719840.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401181412932.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211909934.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401213735454.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401182820987.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401183107197.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211654862.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401220030117.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401221929519.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164402777.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164522414.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150939.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150946.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150955.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151002.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402215216638.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220116879.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220402831.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220907130.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402222723556.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405180124566.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201052497.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404145418336.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103523827.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103529454.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404152959054.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154222616.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154248333.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154955660.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103534693.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151109.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165247574.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165320293.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165454440.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165830879.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170011836.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170927035.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151211.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151222.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201808678.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405202602146.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405203350365.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406201628119.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406202510383.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204514100.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204617979.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205720096.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205841685.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205930635.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210522604.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210616293.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406212905766.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213536911.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213701389.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214624098.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214735588.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214755269.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215006674.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151432.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151441.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215628748.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215649658.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151508.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151523.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151547.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163256206.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163623604.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163636859.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163904424.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163939850.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409164137353.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410174849844.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410181127638.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210412150411190.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-e5c0fc9fdbca7174.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-aa2a7c61bcc2c67f.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-d4af5df076ca1a8b46a275d62c9d919f_hd.jpg">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415212558624.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415211657918.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415220215431.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/Ij2UZf.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.jpg">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163733386.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163939413.png">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/368583-20180711114821287-381545002.png">
<meta property="article:published_time" content="2021-03-29T07:51:18.960Z">
<meta property="article:modified_time" content="2021-06-08T08:54:19.852Z">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150422.png">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/29/JVM/" class="article-date">
  <time datetime="2021-03-29T07:51:18.960Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JVM
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>大的来说：Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<p>细的来说：JVM是运行在操作系统之上的，它与硬件没有直接的交互。Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS）</p>
<p>说了那么多，究竟JVM的核心特性是什么呢？是使用相同的字节码，它们都会给出相同的结果。</p>
<p>FYI，达到的核心目的：<mark>实现了跨平台</mark></p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>一次编写，到处运行（java跨平台的原因）</li>
<li>自动内存管理，<strong>垃圾回收机制</strong></li>
<li>数组<strong>下标越界</strong>检查</li>
<li>多态</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>JVM JRE JDK</strong>的区别（一层封装接一层封装 JVM是最里面的 与OS打交道）</p>
<ul>
<li><p><mark>JDK</mark></p>
<p>Java Development Kit 用作开发, 包含了JRE, 编译器和其他的工具(比如: JavaDoc，Java调试器), 可以让开发者开发、编译、执行Java应用程序.</p>
</li>
<li><p><mark>JRE</mark></p>
<p>Java 运行时环境是将要执行 Java 程序的 Java 虚拟机, （运行Java程序的用户使用的软件）可以想象成它是一个容器, JVM 是它的内容.</p>
<p>JRE = JVM + Java Packages Classes(like util, math, lang, awt,swing etc)+runtime libraries.</p>
</li>
<li><p><mark>JVM</mark></p>
<p>Java virtual machine (Java 虚拟机) 是一个可以执行 Java 编译产生的 Java class 文件 (bytecode) 的虚拟机进程, 是一个纯的运行环境.</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150422.png" alt="img"></p>
<h2 id="常见JVM"><a href="#常见JVM" class="headerlink" title="常见JVM"></a>常见JVM</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327170325065.png" alt="image-20210327170325065"></p>
<h1 id="内存结构-运行时数据区域"><a href="#内存结构-运行时数据区域" class="headerlink" title="内存结构 - 运行时数据区域"></a>内存结构 - 运行时数据区域</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327171507549.png" alt="image-20210327171507549"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul>
<li>程序计数器 - Program Counter Register</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>程序计数器是一块较小的<strong>内存空间</strong>，给<mark>字节码解释器</mark>服务。是当前线程锁执行的字节码的<strong>行号指示器</strong></li>
</ul>
<p>读完上面这段文字，是不是感觉很抽象？我们结合下面的这幅图理解</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327172341180.png" alt="image-20210327172341180"></p>
<p>右侧是java的代码，左边是二进制字节码，代表着一些jvm指令；</p>
<p>然而左侧指令能交由CPU直接执行么？答案是否定的，需要经由：指令 → 【解释器】 → 机器码 → CPU</p>
<p>这个解释器是怎么工作的呢？是通过改变<strong>程序计数器</strong>的值来选取下一跳需要执行的字节码指令！</p>
<p>还记得程序计数器的作用么？是的，它记住了下一条jvm指令的执行地址，因此就可以配合解释器去进行程序流程控制了</p>
<p>在物理上，这个程序计数器是通过<strong>寄存器</strong>实现的</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>线程私有</p>
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码（也就是一个确定的时刻，一个处理器都只会去执行一条线程中的指令）</li>
<li>为了线程 恢复正确的执行位置：<strong>每条线程需要有一个<mark>独立的程序计数器</mark></strong></li>
<li>各线程之间计数器互不影响，独立存储，称这类内存区域为：<strong>线程私有的内存</strong></li>
</ul>
<p>可以结合我们的寄存器与PCB之间的关系去理解</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CPU中有个东西</span> <span class="string">叫做寄存器。它们有不同的功能，比如可以存放下一条指令地址，也可以存放正在执行的指令，也可以保存暂时运算得到的结果；</span></span><br><span class="line"></span><br><span class="line"><span class="string">然而我们知道寄存器并不是很专一的，他有可能会随时被其他的进程使用，那我们之前运算的结果啊，什么保存的指令啊，岂不是都不见了吗？</span></span><br><span class="line"></span><br><span class="line"><span class="string">这个时候就会用到我们的PCB了，它能够保持关键的一些信息，也就是运行环境，这样等我们的寄存器又空闲下来了的时候，我们就可以继续我们未完成的指令啦。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不会存在内存溢出：是<code>唯一一个</code>在《Java虚拟机规范》中没有规定任何<strong>OutOfMemoryError（内存溢出）</strong>情况的区域</p>
</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>Java虚拟机栈 - Java Virtual Machine Stack</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成（存储局部变量表、操作数栈、动态连接、方法出口等信息），对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>。</li>
<li>每一个方法被调用直至执行完毕的过程，就对应着一个<strong>栈帧</strong>在<strong>虚拟机栈</strong>中入栈到出栈的过程</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327175412940.png" alt="image-20210327175412940"></p>
<p>ps：虚拟机栈是线程私有的，没有线程安全问题。</p>
<h3 id="代码流程演示"><a href="#代码流程演示" class="headerlink" title="代码流程演示"></a>代码流程演示</h3><ul>
<li><p>Code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p>main先进栈 然后是method1进栈 最后method2进栈</p>
<p>而释放（出栈）则是反过来。</p>
<p>在顶部活动的栈帧，称之为：<strong>活动栈帧</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327180817345.png" alt="image-20210327180817345"></p>
</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>垃圾回收是否涉及栈内存？</p>
<ul>
<li><p><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧（一次次的方法调用）组成的，在方法执行完毕后，对应的栈帧就会被自动的被弹出栈，被自动回收掉；</p>
<p>因此无需通过垃圾回收机制去回收内存。</p>
</li>
</ul>
</li>
<li><p>栈内存的分配越大越好吗？</p>
<ul>
<li><p>首先需要明白栈内存是运行代码时通过虚拟机参数指定</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327181945387.png" alt="image-20210327181945387"></p>
</li>
<li><p>线程是存放在物理内存中的，假如栈内存分配过大，线程就会过大，一个物理内存能够承载的线程数量就会减少；</p>
<p>栈内存的分配大了，导致的是支持更多的<strong>递归调用</strong>，然而可以执行的线程数量却不会增多，反而减少。</p>
</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212734640.png" alt="image-20210327212734640"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212704950.png" alt="image-20210327212704950"></p>
<p>下面分析三段代码，你是否能判断出各段代码是否是线程安全的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：只有m1是安全的，m2、m3都不是安全的；</p>
<p>为什么呢？m1中的sb为线程中局部变量，是线程私有的，其他线程无法访问；</p>
<p>m2中的sb虽然作为局部变量，但是最后会<code>return sb;</code> 导致别的线程可以得到这个变量，因此也不是线程私有的；</p>
<p>m3中的sb作为的是方法的参数，意味着别的可能可以访问到，因此不是线程私有的（想要安全，就应该改成String</p>
<p>Buffer）</p>
<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h3 id="栈内存异常"><a href="#栈内存异常" class="headerlink" title="栈内存异常"></a>栈内存异常</h3><h4 id="StackOverFlow"><a href="#StackOverFlow" class="headerlink" title="StackOverFlow"></a>StackOverFlow</h4><ul>
<li>栈内存溢出StackOverFlow：假如线程请求的栈深度大于虚拟机所允许的深度，则会抛出该异常；</li>
</ul>
<p>导致的原因：</p>
<ol>
<li><p>栈帧过多导致栈内存溢出（无限递归）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220740850.png" alt="image-20210327220740850"></p>
</li>
<li><p>栈帧过大导致栈内存溢出</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220755869.png" alt="image-20210327220755869"></p>
</li>
</ol>
<h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><ul>
<li><p>内存溢出OutOfMemoryError如果Java虚拟机栈容量可以<strong>动态扩展</strong>，而当栈扩展到<strong>W伏案申请到足够内存</strong>的时候抛出</p>
<p>ps：一个线程java栈的大小由-Xss设置决定</p>
</li>
<li><p>HotSpot虚拟机栈是无法动态扩展的</p>
</li>
</ul>
<h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><h4 id="CPU占用过高"><a href="#CPU占用过高" class="headerlink" title="CPU占用过高"></a>CPU占用过高</h4><ul>
<li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><strong>ps H -eo pid, tid</strong>（线程id）, <strong>%cpu | grep</strong> 去定位刚才通过top查到的进程号，再通过ps命令进一步查看是哪个线程占用CPU过高</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>进制需要转换</strong></li>
</ul>
<p>比如 62665进程 对应的 7f99进程</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131631397.png" alt="image-20210329131631397"></p>
<p>第8行：一个while true循环导致进程占用过高</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131624431.png" alt="image-20210329131624431"></p>
</li>
</ul>
<h4 id="程序运行长时间得不到结果"><a href="#程序运行长时间得不到结果" class="headerlink" title="程序运行长时间得不到结果"></a>程序运行长时间得不到结果</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132108123.png" alt="image-20210329132108123"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132146310.png" alt="image-20210329132146310"></p>
<p>分析一下这段代码：</p>
<p>现在有a b两个对象，第一个线程锁住了对象a，然后休眠2000ms（2s），醒过来后尝试去锁对象b；而在第一个线程休眠的过程中，有一个新的线程创建了，它锁住了对象b，并尝试去锁对象a，而对象a此时已经被第一个线程锁住了，因此就必须等待第一个线程释放a对象。接着第一个线程休眠时间到了，醒过来后尝试去获得b对象的锁，然而b对象早已被第二个线程锁住了，因此不可得。这样的结果就导致第一个线程等待第二个线程去释放b的锁，第二个线程等待第一个线程释放a的锁 ——死锁了；</p>
<h2 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h2><ul>
<li>本地方法区（本地方法栈）：Native Method Stacks</li>
</ul>
<p>与虚拟机栈作用相似，区别在于：</p>
<p>虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈是为虚拟机使用到的本地（Native）方法服务</p>
<p>简单来说：指的是被native修饰的方法，即非Java代码。</p>
<p>下图中getClass（）没有方法体，是由Java的底层的C/C++来实现的。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/v2-7c34658ce6ef846c31593d479db89a94_hd.jpg" alt="img"></p>
<p>ps：本地方法栈也是由线程独享的，没有线程安全问题。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>堆Heap：是存放对象实例的区域，是垃圾收集器管理的内存区域（因此一些资料中称之为GC【Garbage Collected】堆）</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存，java世界中“几乎”所有的<strong>对象实例</strong>都在这里分配<strong>内存</strong></p>
<p>（为什么说是几乎？由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致了一些微妙的变化悄然发生了，因此说Java对象实例都分配在堆上也渐渐变得不是那么绝对了 —— 《深入理解JVM虚拟机》）</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有<mark>(重点）垃圾回收机制</mark></li>
</ul>
<h3 id="堆分配"><a href="#堆分配" class="headerlink" title="堆分配"></a>堆分配</h3><p>如果从分配内存的角度这去看，所有线程共享的<strong>Java堆</strong>是可以划分出多个<strong>线程私有的</strong><mark>分配缓冲区（Thread Local Allocation Buffer，TLAB）</mark>的，用以提升对象分配时的效率；</p>
<p>然而无论用什么角度，无论怎么划分，Java堆都只能存储<strong>对象的实例</strong>，堆划分目的是为了：更好回收内存or更快分配内存</p>
<p>同时，根据《Java虚拟机规范》规定，Java堆是可以处于<strong>物理上不连续</strong>的内存空间中的，但是在逻辑上应被视为<strong>连续</strong>，但对于大对象（如 数组对象），为了存储高效、实现简单，往往要求连续的内存空间（类似于磁盘吧？）</p>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><ul>
<li>虽然说堆中存在<mark>垃圾回收机制</mark>，但是回收的对象是我们认定为<strong>垃圾</strong>的数据，也就是不再使用的对象，但假如一直有对象在创建，且一直有被使用的情况，那堆内存肯定不够用，就会导致<strong>堆内存溢出</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示堆内存溢出 java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * -Xmx8m 使用Xmx进行堆空间大小的控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a); <span class="comment">// hello, hellohello, hellohellohellohello ...</span></span><br><span class="line">                a = a + a;  <span class="comment">// hellohellohellohello</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329140851007.png" alt="image-20210329140851007"></p>
<h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><p>诊断工具：</p>
<ul>
<li><p>jps工具</p>
<p>命令行形式，查看当前系统中有哪些java进程</p>
</li>
<li><p>jmap工具</p>
<p>命令行形式，查看堆内存占用情况</p>
</li>
<li><p>jconsole工具</p>
<p>图形界面形式，多功能的检测工具，可以进行连续监测</p>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>图中的常量池为【运行时常量池】</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143315393.png" alt="image-20210329143315393"></p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>方法区Method Area：与Java堆一样，是<mark>各线程共享的内存区域</mark>。用于存储<strong>已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。《Java虚拟机规范》将方法区描述为堆的一个逻辑部分，但方法区还有一个别名叫<strong>非堆（Non-Heap）</strong>,用于与Java堆区分开（说人话就是方法区只是一个逻辑上概念，具体怎么实现是可以不同处理的）</li>
</ul>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><ul>
<li>在JDK 8之前，许多Java程序员习惯在<strong>HotSpot</strong>虚拟机上开发、部署程序，许多人去把<strong>方法区</strong>称为<strong>永久代</strong>，然而这两者并不是等价的；<ul>
<li>那为什么要这么称呼呢？是因为当时的<strong>HotSpot</strong>虚拟机设计团队把<strong>收集器的分代设计</strong>扩展到了<mark>方法区</mark>，或者说使用<strong>永久代</strong>去实现了<mark>方法区</mark>。</li>
<li>那好处是什么呢？使得垃圾收集器能够像管理Java堆一样去管理这部分的内存了，省去了专门为方法区编写内存管理代码的工作了</li>
</ul>
</li>
<li>然而对于其他虚拟机，不一定有着<strong>永久代</strong>这个概念；</li>
<li>JDK 6的时候，<strong>HotSpot</strong>开发团队就有放弃<strong>永久代</strong>，逐步改为采用<strong>本地内存</strong>去实现方法区的计划</li>
<li>JDK 7的时候，就把原本放在<strong>永久代</strong>的<strong>字符串常量池、静态变量</strong>移出</li>
<li>JDK 8的时候，完全废除了永久代，改用了在本地内存中实现的<mark>元空间Meta-Space</mark>去代替，并把JDK 7中<strong>永久代</strong>剩余的内容（主要是类型信息）全部移到了<strong>元空间</strong>中</li>
</ul>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul>
<li>类创建过多，导致方法区内存溢出，想一想我们什么场景会遇到？</li>
<li>没错，我们的Spring Mybatis中有着许许多多的代理对象创建，bean注入等情况，少不了类的创建，那就十分有可能出现这个问题</li>
</ul>
<h4 id="永久代-内存溢出"><a href="#永久代-内存溢出" class="headerlink" title="永久代 - 内存溢出"></a>永久代 - 内存溢出</h4><ul>
<li>使用JDK 1.6</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示永久代内存溢出  java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment"> * -XX:MaxPermSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo1_8 test = <span class="keyword">new</span> Demo1_8();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++, j++) &#123;</span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145942295.png" alt="image-20210329145942295"></p>
<h4 id="元空间-内存溢出"><a href="#元空间-内存溢出" class="headerlink" title="元空间 - 内存溢出"></a>元空间 - 内存溢出</h4><ul>
<li>使用JDK 1.8</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; <span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo1_8 test = <span class="keyword">new</span> Demo1_8();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145612278.png" alt="image-20210329145612278"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>为了学习运行时常量池，必须先明白什么是常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制字节码（类基本信息，常量池，类方法定义 - 包含了虚拟机指令）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述代码来说，其字节码包含的信息会保存在常量池中；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151426081.png" alt="image-20210329151426081"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151456843.png" alt="image-20210329151456843"></p>
<p>根据常量池查表，最后可以翻译出指令：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151617194.png" alt="image-20210329151617194"></p>
<p>因此简单来说，常量池就是一张表，虚拟机指令根据这张长凉飙去找到要执行的类名、方法名、参数类型和字面量、等信息（或者说用于存放编译期生成的各种字面量与符号引用）</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li><p>运行时常量池 Runtime Constant Pool 是方法去的一部分。Class文件中除了类基本信息:版本号， public， 类名, 包名, 父类， 接口</p>
<p>还有方法等描述信息外，还有一项就是我们上述学习的<strong>常量池表</strong>，这部分的内容会在类加载后存放到方法区的<strong>运行时常量池</strong>中</p>
<p>（说那么多，其实运行时常量池就是常量池在程序运行时的称呼啦）</p>
</li>
<li><p>运行时常量池具有动态性。也就是在方法区中的运行时常量池是可以发生变化的。</p>
<p>（也就是说，并非预置入Class文件中常量池的内容才能进入方法区<strong>运行时常量池</strong>，在运行其间也可以将新的常量放入池中。String类的<mark>intern()</mark>方法便利用了这一个特性）</p>
<p>而常量池就不行，它是静态的，当编译生成字节码文件直接就不变了。</p>
</li>
</ul>
<h4 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h4><p>StringTable一些特性：</p>
<ol>
<li>常量池中的字符串是<strong>符号</strong>，不是<strong>对象</strong>，只有第一次使用到的时候才是<strong>对象</strong></li>
<li>可以利用串池的机制，避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是 <mark>StringBuilder</mark>(1.8)</li>
<li>字符串常量拼接的原理是<strong>编译期优化</strong></li>
<li>可以使用<mark>intern方法</mark>，主动的去将串池中还没有的<strong>字符串对象</strong>放入串池</li>
</ol>
<h5 id="StringTable-常量池与串池关系"><a href="#StringTable-常量池与串池关系" class="headerlink" title="StringTable - 常量池与串池关系"></a>StringTable - 常量池与串池关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串串池：StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_22</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span></span><br><span class="line">    <span class="comment">// 等到真正执行了指令才会转成对象，如下：</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;] </span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329153609323.png" alt="image-20210329153609323"></p>
<p>下图的意思表示：</p>
<p>到常量池 #2号位置 加载一个信息（在这里是字符串对象a），接着把这个对象加载到局部变量表的一号Slot中，以此类推后续操作…</p>
<ul>
<li>ps:字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</li>
</ul>
<h5 id="StringTable-字符串变量拼接"><a href="#StringTable-字符串变量拼接" class="headerlink" title="StringTable - 字符串变量拼接"></a>StringTable - 字符串变量拼接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>; </span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//这段代码执行过后，字符串常量池中会有 a b 但不会有ab</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	 Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: return</span><br></pre></td></tr></table></figure>

<p>根据反编译的指令，我们可以看出来字符串被创建的过程：</p>
<p><code>StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code></p>
<p>首先初始化了StringBuilder 然后添加字符串a，添加字符串b，最后调用toString()方法。之后使用astore 4，也就是放入局部变量表中的4号slot中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329210714606.png" alt="image-20210329210714606"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 懒惰的</span><br><span class="line">    String s2 &#x3D; &quot;b&quot;;</span><br><span class="line">    &#x2F;&#x2F;ab字符串</span><br><span class="line">    String s3 &#x3D; &quot;ab&quot;;</span><br><span class="line">    &#x2F;&#x2F;拼接后的字符串</span><br><span class="line">    String s4 &#x3D; s1 + s2; </span><br><span class="line">    </span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这段代码打印结果是什么呢？答案是：false</p>
<p>根据上面的分析，我们知道了s4的构建过程，是由字符串a b拼接而成，最终通过toString()方法锁返回的一个对象，既然是对象就存在于<strong>堆内存中</strong></p>
<p>而s3本身就是一个”ab“完整的字符串，存在于串池之中；</p>
<p>因此字符串的<strong>值</strong>相同，但却是完全不同（地址不同/内存位置不同）的两个字符串，而 <code>==</code> 恰好比较的就是内存位置，故为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 懒惰的</span><br><span class="line">    String s2 &#x3D; &quot;b&quot;;</span><br><span class="line">    String s3 &#x3D; &quot;ab&quot;;</span><br><span class="line">    String s4 &#x3D; s1 + s2; &#x2F;&#x2F; new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br><span class="line">    String s5 &#x3D; &quot;a&quot; + &quot;b&quot;;  &#x2F;&#x2F; javac 在编译期间的优化，结果已经在编译期确定为ab</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们修改一下，不使用s1 + s2将变量拼接在一起的写法了，直接将常量拼接在一起，答案还会是false吗？</p>
<p>我们看看反编译后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 	  Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;6, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        &#x2F;&#x2F;ab3初始化时直接从串池中获取字符串</span><br><span class="line">        29: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">        31: astore        5</span><br><span class="line">        33: return</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329212803232.png" alt="image-20210329212803232"></p>
<p>我们根据运行流程：在第6行指令中，程序进行到这想去串池中寻找<strong>ab对象</strong>，发现没有这对象，就根据ab符号创建了一个ab对象，放入串池，程序继续执行，直到29行指令，依旧想去串池寻找<strong>ab对象</strong>，而此时这个对象是存在的，因此不会创建一个新的，故这两个对象是同一个对象</p>
<p>因此答案是 true</p>
<p>其本质是javac 在编译期间的一个优化，由于我们的“a”和“b”是两个常量，因此在编译期间的时候就可以写死，确定结果为”ab“了</p>
<p>然而s4不是这样，s4是变量的拼接，变量的值是有可能修改的，因此其结果只能在运行期间用<mark>StringBuilder</mark>动态的去确定结果</p>
<p>（这也可以解释为什么答案是true：因为前面创建ab的时候（s3）在<strong>串池</strong>中放入了“ab”这个对象了，因此我们的s5可以直接从串池获取结果，故s5 = s3，为true）；</p>
<h5 id="intern方法-JDK-8"><a href="#intern方法-JDK-8" class="headerlink" title="intern方法(JDK 8)"></a>intern方法(JDK 8)</h5><p>技术参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/be66e22f5fc8">https://www.jianshu.com/p/be66e22f5fc8</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiullan/article/details/65936959">https://blog.csdn.net/qiullan/article/details/65936959</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lcsy000/article/details/82782864">https://blog.csdn.net/lcsy000/article/details/82782864</a></p>
<p><code>public native String intern();</code></p>
<p>作用：将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池；</p>
<p>而无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><mark>FYI</mark>:此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p>使用场景：</p>
<p>现在我们<code>Sting str1 = new String(&quot;ABC&quot;);</code>，根据之前学习我们知道这个<strong>str1</strong>的实例保存于<strong>堆</strong>中，假如我们创建一个字符串</p>
<p><code>String str2 = &quot;ABC&quot;</code>,JVM会在字符串常量池/串池中创建这个<strong>String</strong>的实例，再将池中的实例的引用返回给<strong>str2</strong>。</p>
<p>那么假如想让第一个new出来的String也保存在字符串常量池中，该怎么办呢？可以使用<mark>String.intern()</mark>,将字符串<strong>放到常量池</strong>中，返回在常量池中的引用；</p>
<p>关于这个intern方法有个细节，在jdk1.7之后，假如我们的字符串在字符串常量池中<strong>没有出现过</strong>，那么就会在字符串常量池中保存一个<strong>引用</strong>，指向谁呢？指向<strong>堆</strong>中这个字符串的实例。而假如字符串在常量池中出现过了，就直接返回常量池中的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    String s2 = s.intern(); </span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面来逐行分析一下每一行代码所带来的影响：</p>
<ol>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>  将字符串”a“和”b“放入串池中，现在串池中状态为：[“a”, “b”]s存在于堆中；</li>
<li><code>String s2 = s.intern();</code>  由于串池中没有ab，因此会把“ab”串放入串池（此时的串池状态为[“a”, “b”, “ab”]），再返回这个“ab”在串池中的引用</li>
<li><code>System.out.println(s2 == &quot;ab&quot;);</code> s2是“ab”这个串在池中的引用，因此与池中的“ab”为同一个ab 答案为true</li>
<li><code>System.out.println(s == &quot;ab&quot;);</code>s在堆内存中，与串池中“ab”为同一个ab，答案为true</li>
<li><code>System.out.println(s == s2);</code> s2是“ab”串在池中引用，与堆内存中的s（ab）为同一个对象</li>
</ol>
<p>下面我们改动一些地方，结果却是不一样的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);   </span><br><span class="line">    String s2 = s.intern(); <span class="comment">// 这里由于串池有了“ab”串，因此不会放入串池，返回的s2是串池中的ab，而s依旧不变，为堆中ab</span></span><br><span class="line">    </span><br><span class="line">     System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">     System.out.println( s2 == x);<span class="comment">//true</span></span><br><span class="line">     System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//false</span></span><br><span class="line">     System.out.println( s == x );<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><code>String x = &quot;ab&quot;;</code>首先存放一个“ab”串到串池中，现在串池为[“ab”]</li>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 将“a” 和 “b”放入串池。同时创建出“ab”对象，这个对象存在于堆中，不是串池中,s指向的是”ab“的对象引用，与串池中的不是同一个ab。这步过后，串池情况： [“ab”, “a”, “b”]</li>
<li><code>String s2 = s.intern();</code>由于串池有了“ab”串，因此不会放入串池，返回的s2是串池中的ab，而s依旧不变，为堆中ab</li>
<li><code>System.out.println(s2 == &quot;ab&quot;);</code>：s2是串池中的ab，故为true</li>
<li><code>System.out.println( s2 == x);</code>:同上</li>
<li><code>System.out.println(s == &quot;ab&quot;);</code>:s是堆中的“ab”，不是串池中的ab，答案为false</li>
<li><code>System.out.println( s == x );</code>:同上</li>
</ol>
<h5 id="intern方法-JDK-6"><a href="#intern方法-JDK-6" class="headerlink" title="intern方法(JDK 6)"></a>intern方法(JDK 6)</h5><p>作用：调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><MARK>FYI:此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></MARK></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">String s2 = s.intern(); </span><br><span class="line">String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println( s2 == x);<span class="comment">//true</span></span><br><span class="line">System.out.println( s == x );<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p>分析：</p>
<ol>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>将“a” 和 “b”放入串池。同时创建出“ab”对象，这个对象存在于堆中。这步过后，串池情况： [“a”, “b”]</li>
<li><code>String s2 = s.intern();</code>由于串池没有”ab“，因此尝试将”ab“放入串池的同时，拷贝了一份放入串池，而拷贝的这个”ab“与堆中的”ab“并不是相同的对象。之后返回结果，s2是串池中的”ab“</li>
<li><code>String x = &quot;ab&quot;;</code>由于串池中有了”ab“了，不会创建新的字符串放入串池，而是直接沿用串池的”ab“</li>
<li><code>System.out.println( s2 == x);</code> s2与x都是串池中的“ab”，因此结果是true</li>
<li><code>System.out.println( s == x );</code>s是堆中的“ab”，而x是串池中”ab“，结果为false</li>
</ol>
<p>这段代码放在JDK 8运行结果为：true true；原因是放入串池的字符串对象不是拷贝出来的对象，而是自己这个字符串的引用，为相同对象。因此结果为true；</p>
<h5 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h5><ul>
<li>1.6中 StringTable位于方法区中</li>
<li>1.8中 StringTable位于堆中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220051576.png" alt="image-20210330220051576"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span><br><span class="line">* 在jdk6下设置 -XX:MaxPermSize&#x3D;10m</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOutPositionOfStringTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在jdk 6 中出现问题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220606611.png" alt="image-20210330220606611"></p>
<p>在jdk 8中出现问题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220707797.png" alt="image-20210330220707797"></p>
<h5 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h5><ul>
<li>StringTable的底层实现是使用<strong>HashTable</strong></li>
</ul>
<p>字符串存在于<strong>堆内存</strong>中，只有当内存紧张的时候，才会触发垃圾回收；</p>
<p><code>-Xmx10m -XX+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx10m</td>
<td>堆空间大小</td>
</tr>
<tr>
<td>-XX+PrintStringTableStatistics</td>
<td>打印串池统计信息</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC日志详情</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>打印GC日志</td>
</tr>
</tbody></table>
<p>首先进行一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 1388K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 67% used [0x00000007bfd00000,0x00000007bfe5b100,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 2927K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 319K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 &#x3D;    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     11756 &#x3D;    282144 bytes, avg  24.000</span><br><span class="line">Number of literals      :     11756 &#x3D;    455312 bytes, avg  38.730</span><br><span class="line">Total footprint         :           &#x3D;    897544 bytes</span><br><span class="line">Average bucket size     :     0.587</span><br><span class="line">Variance of bucket size :     0.587</span><br><span class="line">Std. dev. of bucket size:     0.766</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :       831 &#x3D;     19944 bytes, avg  24.000</span><br><span class="line">Number of literals      :       831 &#x3D;     56304 bytes, avg  67.755</span><br><span class="line">Total footprint         :           &#x3D;    556352 bytes</span><br><span class="line">Average bucket size     :     0.014</span><br><span class="line">Variance of bucket size :     0.014</span><br><span class="line">Std. dev. of bucket size:     0.118</span><br><span class="line">Maximum bucket size     :         2</span><br></pre></td></tr></table></figure>

<p>我们查看我们关心的<mark>StringTable</mark>信息：</p>
<p>我们的串池本质结构是HashTable，它的本质是一个Map，其中的存储结构使用的是数组的方式，每一个bucket为一个数组结构，数字代表其中存储的字符串个数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :       831 &#x3D;     19944 bytes, avg  24.000</span><br><span class="line">Number of literals      :       831 &#x3D;     56304 bytes, avg  67.755</span><br></pre></td></tr></table></figure>



<p>下面写入10万个字符，来强制触发GC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100000</span>;j++)&#123;</span><br><span class="line">             String.valueOf(j).intern();</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;504K(9728K), 0.0015310 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2544K-&gt;512K(2560K)] 2552K-&gt;528K(9728K), 0.0010023 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2560K-&gt;480K(2560K)] 2576K-&gt;520K(9728K), 0.0013527 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">100000</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 1295K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 39% used [0x00000007bfd00000,0x00000007bfdcbc60,0x00000007bff00000)</span><br><span class="line">  from space 512K, 93% used [0x00000007bff00000,0x00000007bff78020,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 7168K, used 40K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf60a000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3095K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 &#x3D;    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     12129 &#x3D;    291096 bytes, avg  24.000</span><br><span class="line">Number of literals      :     12129 &#x3D;    467440 bytes, avg  38.539</span><br><span class="line">Total footprint         :           &#x3D;    918624 bytes</span><br><span class="line">Average bucket size     :     0.606</span><br><span class="line">Variance of bucket size :     0.606</span><br><span class="line">Std. dev. of bucket size:     0.778</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :     15285 &#x3D;    366840 bytes, avg  24.000</span><br><span class="line">Number of literals      :     15285 &#x3D;    866120 bytes, avg  56.665</span><br><span class="line">Total footprint         :           &#x3D;   1713064 bytes</span><br><span class="line">Average bucket size     :     0.255</span><br><span class="line">Variance of bucket size :     0.267</span><br><span class="line">Std. dev. of bucket size:     0.516</span><br><span class="line">Maximum bucket size     :         4</span><br></pre></td></tr></table></figure>

<p>我们发现日志显示发生了三次Yong gc（新生代GC），Number of entries 是15285，没有达到10万，说明了我们的串池是会发生GC的。</p>
<h5 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h5><p>由于<strong>StringTable</strong>的本质是一个<strong>HashTable</strong>,那我们调优的思路就是：减少hash碰撞，加快查找速度；</p>
<ul>
<li><p>减少hash碰撞的方法，就是通过<strong>增加HashTable桶的个数</strong>去减少字符串放入串池所需时间</p>
<p>方法参数：<code>-XX:StringTableSize=xxxx</code></p>
</li>
<li><p>另一种调优思路，由于有许多字符串是重复的，并不是都要放入串池中，因此可以通过<mark>intern()</mark>方法去减少重复入池</p>
</li>
</ul>
<h3 id="方法区-堆-JV栈间关系"><a href="#方法区-堆-JV栈间关系" class="headerlink" title="方法区 堆 JV栈间关系"></a>方法区 堆 JV栈间关系</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200718171257640.jpg" alt="img"></p>
<p>如上图一条Java新建对象实例语句：</p>
<ol>
<li>第一个Person是<strong>变量类型</strong>，所以存放在方法区（变量的类型，类的信息，等等）中</li>
<li>第二个person是<strong>局部变量引用</strong>，在一个方法中写的，所以放在JVM栈中</li>
<li>第三个new Person()；是一个<strong>实例化对象</strong>，所以放在Java堆中</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200718171302947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>JVM栈中为局部变量的引用，实际上是指向Java堆中的对象实例，然后对象实例又指向方法区中的对象类型。</strong></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li><p>直接内存（Direct Memory）并<strong>不是</strong>运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，属于操作系统直接管理</p>
</li>
<li><p>JDK 1.4中引入了NIO类（New Input/Output）类，引入了一种基于<strong>通道</strong>与<strong>缓冲区（Buffer）</strong>的IO方式，可以使用<strong>Native函数库</strong>直接的去分配<strong>堆外内存</strong>，接着通过一个存储在<strong>Java堆</strong>中的<code>DirectByteBuffer</code>对象去作为<strong>这块内存（也就是所分配的堆外内存）</strong>的引用进行操作。这样在一些场景中就能显著的提高性能，为什么呢？因为避免了在<strong>Java堆</strong>和<strong>Native堆</strong>中来回复制数据</p>
<p>（我们可以结合下面的文件读写部分进行理解）</p>
</li>
</ul>
<h3 id="文件读写的流程"><a href="#文件读写的流程" class="headerlink" title="文件读写的流程"></a>文件读写的流程</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210331222026374.png" alt="image-20210331222026374"></p>
<p>Java语言本身并没有读写磁盘文件的能力，想要去读写文件需要依靠<strong>操作系统</strong>为我们提供的函数。因此需要用户态切换到内核态</p>
<p><img src="https://www.pianshen.com/images/752/e1021c66ff23345c1b990f6edae93b10.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>在内核态时，需要内存如上两个图所示。也就是先把磁盘文件读到系统内存中的<strong>系统缓冲区</strong>，再读到Java堆内存中的<strong>java缓冲区byte[]</strong>。</p>
<p>使用IO，这里需要两份内存存储重复数据，效率低；</p>
</li>
</ul>
<p>而是用了<code>DirectByteBuffer</code>后呢？</p>
<p>我们多出来一块：<strong>direct memory（直接内存）</strong>，使得磁盘文件可和java内存都可以直接读到这里面，省了一次缓冲区的复制操作，这样子的特性适合大文件的读写操作。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401155032539.png" alt="image-20210401155032539"></p>
<p><img src="https://www.pianshen.com/images/766/fa8aecd7819647645d2f83ee72d3db5e.png" alt="在这里插入图片描述"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p> 虽然本机<strong>直接内存</strong>的分配并不会受到<strong>Java堆</strong>的大小限制。However，既然是内存肯定就会受到<strong>本机的总内存（物理内存、SWAP分区or分页文件</strong>的大小以及<strong>处理器寻址空间</strong>的限制！</p>
<p>有时候我们管理实际内存去设置<code>-Xmx</code>等参数信息，却往往省略掉了去管理直接内存，这就会导致：各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<strong><mark>OutOfMemoryError</mark></strong>异常</p>
<h3 id="直接内存释放"><a href="#直接内存释放" class="headerlink" title="直接内存释放"></a>直接内存释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -XX:+DisableExplicitGC 显式的 让显示的垃圾回收无效（小tips）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕...&quot;</span>);</span><br><span class="line">        System.in.read();<span class="comment">//控制台随便摁一下 模拟一个空隙</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放...&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 显式的垃圾回收，Full GC</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行后，我们能看到进程分配了1个G内存</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161651540.png" alt="image-20210401161651540"></p>
<p>接着byteBuffer指空，被回收</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161711251.png" alt="image-20210401161711251"></p>
<p>那我们可不可以理解成是使用了<code>System.gc()</code>导致直接内存被回收了呢？但垃圾回收是JVM的内容，JVM不是不会管理直接内存么？</p>
<p>其实他是使用了<code>unsafe.freeMemory();</code>进行释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放前：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163229697.png" alt="image-20210401163229697"></p>
<p>释放后：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163240449.png" alt="image-20210401163240449"></p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>我们点进<code>allocateDirect</code>这个方法，它内部是使用了<code>DirectByteBuffer(capacity)</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectByteBuffer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，我们发现它底层调用的其实就是<code>unsafe</code>类</p>
<p>同时需要留意一行代码：<code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code></p>
<p>解读：Cleaner是虚引用类型，特点：关联的对象被回收时，会调用Cleaner的clean方法（在这里的this → DirectByteBuffer)</p>
<p>下面就来看看clean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的thunk指的是任务对象，执行其run方法，去真正的进行内存释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;<span class="comment">//任务对象 在这里指的是：new Deallocator(base, size, cap) </span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质执行的就是下面这段代码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用了<strong>Unsafe</strong>类来完成直接内存的分配回收，回收需要主动调用<strong>freeMemory</strong>方法</li>
<li>ByteBuffer的实现内部使用了<strong>Cleaner（虚引用）</strong>来检测<strong>ByteBuffer</strong>。一旦<strong>ByteBuffer</strong>被垃圾回收，那么会由<strong>ReferenceHandler</strong>来调用<strong>Cleaner</strong>的<mark>clean</mark>方法调用<mark>freeMemory</mark>来释放内存</li>
</ul>
<h1 id="※垃圾回收※"><a href="#※垃圾回收※" class="headerlink" title="※垃圾回收※"></a>※垃圾回收※</h1><p>引言：Java与C++之间有一堵由内存动态分配和垃圾收集技术所围起的高墙，墙外的人想进去，墙里的人却想出来</p>
<h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><p>大致思路：由于堆中存放着Java世界中几乎所有的<strong>对象实例</strong>，垃圾收集器在对堆进行回收前，首先要判断哪些是“垃圾”，怎么定义“垃圾”呢？那就是通过判断对象的“死活”，也就是判断哪些对象还<mark>存活</mark>着，而哪些已经<mark>死去</mark>了（死去：即不可能再被任何途径使用的对象）</p>
<p>AKA，我们能够判断哪些对象死去了，就能够判断该对象是否能被回收了，下面介绍几种能达到这效果的算法。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>思路：在<strong>对象</strong>中添加一个<strong>引用计数器</strong>，每当有一个地方引用它的时候，<strong>计数器值+1</strong>；而当引用失效的时候，<strong>计数器值-1</strong>；任何时刻<strong>计数器值 = 0</strong>的对象就代表着是不可能再被使用的。</li>
</ul>
<p>这种算法看似简单，但需要大量额外处理才能保证正确地工作，譬如简简单单一个<strong>引用计数法</strong>就很难解决对象之间的<mark>循环引用问题</mark></p>
<p>如下图：对象<strong>objA</strong>和对象<strong>objB</strong>间有字段<code>instance</code>，我们下面进行赋值</p>
<p>令：<code>objA.instance = objB</code>和<code>objB.instan = objA</code></p>
<p>同时，这两个对象没有别的引用了，按照定义来说，这两个对象是不可能被访问的了，但由于他们互相引用对方，导致了他们的<strong>引用计数器值</strong>不为0，而我们也就无法按照引用计数算法去回收他们；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401170801241.png" alt="image-20210401170801241"></p>
<h3 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h3><ul>
<li><p>思路：通过一系列称为<mark>GC Roots</mark>的根对象作为<strong>起始字节集</strong>，从这些节点开始，根据<strong>引用关系</strong>去向下搜索，搜索过程中我们走过的路径称之为：<strong>引用链（Reference Chain）</strong>，如果某个对象到<mark>GC Roots</mark>间没有任何的<strong>引用链</strong>相连，用图论的话就是：从<mark>GC Roots</mark>到这个对象是<strong>不可达</strong>的时候，就证明这个对象是不可能再被使用的；</p>
<p>（其实就是当时学数据结构说的图，然后判断可达性的算法啦）</p>
</li>
</ul>
<p>eg：下图</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401172719840.png" alt="image-20210401172719840"></p>
<h4 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h4><p>通过上面对于可达性算法的学习，确定<mark>GC Roots</mark>根对象就显得尤为重要了，那么哪些类可以作为根对象呢？</p>
<ol>
<li><p>在虚拟机栈（栈帧中的本地变量表）中<strong>引用的对象</strong>，神神叨叨的，什么意思呢？其实就是各线程被调用的<strong>方法堆栈</strong>中使用到的<strong>参数、局部变量、临时变量等</strong></p>
</li>
<li><p>在方法区中<strong>类静态属性</strong>所引用的对象，such as：Java类的引用类型静态变量</p>
</li>
<li><p>在方法区中<strong>常量</strong>引用的对象，such as：字符串常量池中的引用</p>
</li>
<li><p>在本地方法栈中<strong>JNI（也就是,NATIVE方法）</strong>引用的对象</p>
</li>
<li><p>在<strong>Java虚拟机内部</strong>的引用，such as：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointException，OutOfMemoryError）等，以及系统类加载器</p>
</li>
<li><p>所有被<strong>同步锁（synchronized关键字）</strong>持有的对象</p>
</li>
<li><p>反应Java虚拟机内部情况的<strong>JMXBean、JVMTI</strong>中注册的回调、本地代码缓存等</p>
</li>
<li><p>根据<strong>垃圾收集器和当前回收区域</strong>的不同，还可能临时加入其它GC Roots。</p>
<p>比如：分代收集和局部回收，这个区域的对象完全可能被其他区域对象所引用，例如老年代的对象引用与年轻代的对象实例。</p>
<p><strong>在新生代建立一个全局数据结构“记忆集”。这个结构把老年代划分为若干小块，标识出哪一块会出现跨代引用。此后发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入GC Roots进行扫描。该方法需要在对象改变引用关系时维护记录数据的正确性。</strong></p>
</li>
</ol>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>可达性算法的两个要求：根对象 + 引用，上面讲完了根对象，接下来来学习<strong>引用</strong></p>
<ul>
<li>Java中对于引用的概念：如果<code>reference</code>类型的数据中<strong>存储的数值</strong>代表的是<strong>另一块内存的起始地址</strong>，就称该<code>reference</code>数据是代表<strong>某块内存、某个对象</strong>的<mark>对象</mark>（其实就是指针的概念吧？)</li>
</ul>
<h5 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h5><p>然而如果我们对于一个对象只定义：被引用了、未被引用。那我们就无法描述一些留在内存中有点没必要，但丢了又有点浪费（食之无味，弃之可惜？）的对象了不是吗？因此，就对引用的概念进行扩充，将引用分为：<strong>强引用、软引用、弱引用和虚引用</strong></p>
<p>（下图中，实线代表强引用，虚线代表软、弱、虚）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401181412932.png" alt="image-20210401181412932"></p>
<p>概述：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211909934.png" alt="image-20210401211909934"></p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><ul>
<li>强引用（Strongly Reference）</li>
</ul>
<p>其实就是最传统的关于<code>引用</code>的定义，指的是代码中普遍存在的<strong>引用赋值</strong>，即：<code>Object obj = new Object();</code></p>
<p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><ul>
<li>软引用（Soft Reference）</li>
</ul>
<p>描述一些还有用，但不是必须的对象</p>
<p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<ul>
<li><p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
</li>
<li><p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">		<span class="comment">//list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line">        <span class="comment">//list对SoftReference为强引用，而SoftReference对byte[]则是弱引用</span></span><br><span class="line">        <span class="comment">//list先引用软引用对象 再间接引用byte数组</span></span><br><span class="line">		List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过软引用对象创建数组</span></span><br><span class="line">		SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref= <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4M]);</span><br><span class="line">        <span class="comment">//将该软引用对象加入list中</span></span><br><span class="line">        list.add(ref);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而软引用本身也要占有一部分内存（虽然很小），如果想把这部分清除掉，需要配合<strong>引用队列</strong>去清理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同样 构建list --&gt; SoftReference --&gt; byte[]三者关系</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构建了引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//模拟存储5个 4MB的byte[]数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//构建SoftReference软引用对象</span></span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            <span class="comment">//加入list</span></span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="comment">//遍历引用队列 直到不为空</span></span><br><span class="line">        <span class="keyword">while</span>( poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//移除</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">//移动到队列中的下个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401213735454.png" alt="image-20210401213735454"></p>
</li>
</ul>
<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><ul>
<li>弱引用（Weak Reference）</li>
</ul>
<p>描述非必须对象，且强度比软引用更弱一些。</p>
<p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<ul>
<li><p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  list --&gt; WeakReference --&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; w : list) &#123;</span><br><span class="line">                System.out.print(w.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体上来说和软引用差不多，只是将<strong>SoftReference 换为了 WeakReference</strong></p>
</li>
</ul>
<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401182820987.png" alt="image-20210401182820987"></p>
<p>上面我们其实在学习直接内存的内存管理部分有接触过虚引用（Cleaner就是个虚引用）</p>
<p>使用场景：假如有一个ByteBuffer被垃圾回收后，留下来的直接内存是不会被回收掉的，因此就需要使用到虚引用，由于虚引用指向直接内存的地址，则可以通过unsafe.freeMemory去释放直接内存。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401183107197.png" alt="image-20210401183107197"></p>
<h6 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h6><ul>
<li>终结器引用（FinalReference）</li>
</ul>
<p>我们知道，所有的类都继承自<strong>Object类</strong>，<strong>Object类</strong>有一个<mark>finalize</mark>方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的<mark>finalize</mark>方法。调用以后，下一次GC时，该对象的内存就可以被回收掉了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211654862.png" alt="image-20210401211654862"></p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>上面讲述了如何判断对象是不是垃圾，接下来章节就要学习如何进行垃圾回收了。</p>
<p>垃圾回收算法可划分为两大部分：<strong>引用计数式垃圾收集（Reference CountingGC）</strong>和<strong>追踪式垃圾收集（Tracing GC）</strong>两大类，这两类也分别被称为：<strong>直接垃圾收集</strong>和<strong>间接垃圾收集</strong></p>
<p>下面所介绍的算法均属于：<strong>追踪式垃圾收集（间接垃圾收集）</strong>范畴</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><ul>
<li><p>标记 - 清除（Mark-Sweep）：这是最早也是最基础的垃圾回收算法，顾名思义，该算法分为<strong>【标记】</strong>和<strong>【清除】</strong>两个阶段</p>
<ul>
<li>首先标记<strong>所有</strong>需要回收的对象</li>
<li>在标记完成之后，统一回收到<strong>所有</strong>被标记的对象</li>
</ul>
<p>也可以反过来操作</p>
<ul>
<li>首先标记<strong>存活的对象</strong></li>
<li>统一回收没有被标记的对象</li>
</ul>
<p>标记的过程即判断对象是否为垃圾的过程；</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401220030117.png" alt="image-20210401220030117"></p>
<p>需要注意的是，清除并不是将内存中的字节清零，而是记录了内存的起始结束地址，在下次分配内存的时候，如果该块内存大小合适，则直接覆盖；</p>
<p>这部分的内容和操作系统中的内存管理很像，只不过这里好像不合并空闲的内存块，进而会产生内部碎片，产生内部碎片了，就无法满足大对象的内存分配啦，那jvm就不得不进行垃圾回收，那程序就不得不暂停，应用就不得不变慢</p>
<p>操作系统中关于内存管理部分笔记：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D</a> </p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><ul>
<li>标记 - 整理（Mark - Compact）算法：标记过程与<strong>标记 - 清除算法</strong>是相同的，而后续步骤就有些不一样了。</li>
</ul>
<p>我们知道，标记 - 清除算法有可能会产生大量的内部碎片，因此，标记 - 整理算法就是在这一点对标记 - 清除算法进行了优化。</p>
<p>它是怎么做的呢？它让所有存活的对象都向内存空间的一端进行移动，然后直接清除掉边界以外的内存。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401221929519.png" alt="image-20210401221929519"></p>
<p>那难道这个算法就是完美的了吗？显然不是。</p>
<p>移动存活的对象，尤其是在<strong>老年代</strong>这种每次回收都有大量对象存活的区域，移动存活对象并且更新所有引用这些对象的地方将会是一种极为繁琐的操作。而且，对象在移动的时候，用户应用程序是必须暂停的（ps：这种停顿被最初的虚拟机设计者称为：“Stop The World” ）</p>
<p>然而，结合OS的学习我们知道，我们完全可以不移动和整理存活对象的内存。可以依靠<strong>内存分配器和内存访问器</strong></p>
<p>such as：使用<strong>分区空闲分配链表</strong>，关于这部分的内容，我的博客有记载：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95</a></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h3><ul>
<li>标记 - 复制算法被简称为<strong>复制算法</strong>。它的本质是利用了【半区复制】：将可用的内存按照容量划分成了<strong>大小相等的两块</strong>，每次只去使用其中的一块。当这一块内存用完了，就把还存活着的对象复制到另一块上面，再将已经使用过的内存空间一次清理。</li>
<li>优点：虽然说如果内存中多数对象是存活的时候，需要产生大量的内存间复制的开销；但如果大多数对象都是可以回收的话，算法需要复制的就是这部分少数的存活对象了。且这种算法无需考虑有空间碎片的复杂情况，只需要移动<strong>堆顶指针</strong>，按照顺序去分配就好了</li>
<li>缺点：这种算法会将可用的内存变为原来的一半（一半真实投入利用，一半等着放入存活对象）</li>
</ul>
<p>首先标记垃圾，然后将存活的对象复制到另一块上</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></p>
<p>接着清空垃圾</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164402777.png" alt="image-20210402164402777"></p>
<p>接着交换两块的位置，FROM→TO，TO→FROM</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164522414.png" alt="image-20210402164522414"></p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><h3 id="分代垃圾回收理论"><a href="#分代垃圾回收理论" class="headerlink" title="分代垃圾回收理论"></a>分代垃圾回收理论</h3><p> 当前大多数商业虚拟机的GC，大都遵循“分代收集”设计。</p>
<p>它建立在了两个分代假说之上</p>
<ol>
<li>弱分代假说（Weak Generatjional Hypothesis）：绝大多数的对象都是<strong>朝生夕死</strong>的</li>
<li>强分代假说（Strong Generatjional Hypothesis）：熬过越多次垃圾回收过程的对象就<strong>越难以消亡</strong></li>
</ol>
<p>基于这两个假说，垃圾收集器的设计就有了原则：垃圾收集器应该将<strong>Java堆</strong>划分出不同的区域，然后将回收对象按照<strong>年龄</strong>（对象熬过垃圾回收过程的次数）为依据，分配到不同的区域的存储；</p>
<p>这样做有什么好处呢？好处在于，各分区内的对象具有的特点很明显，虚拟机就能依据其特点去回收了，能提高效率；</p>
<p><strong>Java堆</strong>划分出不同区域后，垃圾收集器才能每次只回收其中某一个/某一些区域，因此也才衍生了：<mark>Minor GC、Major GC、Full GC</mark>这样的回收类型划分，进而，也才能够针对<strong>不同的区域</strong>安排与<strong>里面所存储的对象的特征</strong>相匹配的GC算法 —— 上面提到的那些算法。</p>
<p>一般来说，会把<strong>Java堆</strong>划分为：<mark>新生代（Young Generation）</mark>和<mark>老年代（Old Generation）</mark>.</p>
<ul>
<li>新生代：特点在于每次垃圾收集时都有大量的对象死去</li>
<li>老年代：从每次回收中存活下来的对象都存储在这</li>
</ul>
<h3 id="分代垃圾回收过程"><a href="#分代垃圾回收过程" class="headerlink" title="分代垃圾回收过程"></a>分代垃圾回收过程</h3><p>首先要明确，新对象会在伊甸园中产生。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150939.png" alt="img"></p>
<p>此时，伊甸园已满，没有办法存储新的对象，则触发了一次GC</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150946.png" alt="img"></p>
<p>会将存活的对象复制到<strong>幸存区TO</strong>中，由于捱过了一次垃圾回收，因此寿命+1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150955.png" alt="img"></p>
<p>同时白板FROM与幸存区TO交换内存</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151002.png" alt="img"></p>
<p>此时假如伊甸园满了，而恰巧又创建了个新对象，那此时会再次触发<strong>Minor GC</strong>，这次会把<strong>伊甸园中</strong>和<strong>幸存区</strong>中的垃圾都回收了，除此之外，其他操作和上述基本相同；</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402215216638.png" alt="image-20210402215216638"></p>
<p>我们注意到，我们的老年代一直是空着的，那难道他是没有用处的嘛？还记得我们说的关于老年代的特点吗？他是存储经历了多次<strong>Minor GC</strong>但仍存活下来的对象的。那我们怎么判断一个对象存活的次数够不够多呢？通常来说就会设置一个<strong>阈值（最大为15,4bit）</strong>，达到了，就会放入老年代中。（当然，如果内存实在是紧张有时候不会去管那个阈值，直接将对象移入老年代）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220116879.png" alt="image-20210402220116879"></p>
<p>假如，我们的老年代也放满了，那<strong>Minor GC</strong>就无法达到内存回收了，此时就会触发<strong>Full GC</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220402831.png" alt="image-20210402220402831"></p>
<h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220907130.png" alt="image-20210402220907130"></p>
<h3 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h3><p>正常来说，当新的对象创建，进行GC，放入伊甸园，走一个这样完整的流程；</p>
<p>但如果我们创建的对象过于大，导致新生代无法容纳，那么就会把这个对象直接放入老年代；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402222723556.png" alt="image-20210402222723556"></p>
<ul>
<li>线程内存溢出问题</li>
</ul>
<p>假如某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h2 id="HotSpot算法细节-概念辨析"><a href="#HotSpot算法细节-概念辨析" class="headerlink" title="HotSpot算法细节 - 概念辨析"></a>HotSpot算法细节 - 概念辨析</h2><p>由于我们接下来会引用到一些专用名词：三色标记法、增量更新、记忆集、卡表等，因此我们需要对这几个名词的出现场景以概念进行一定的理解；</p>
<h3 id="分代收集理论扩展"><a href="#分代收集理论扩展" class="headerlink" title="分代收集理论扩展"></a>分代收集理论扩展</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>记不记得我们的<strong>分代垃圾回收理论</strong>部分立下了2条假说/法则？</p>
<ol>
<li>弱分代假说（Weak Generatjional Hypothesis）：绝大多数的对象都是<strong>朝生夕死</strong>的</li>
<li>强分代假说（Strong Generatjional Hypothesis）：熬过越多次垃圾回收过程的对象就<strong>越难以消亡</strong></li>
</ol>
<p>现在我们引入了第三条法则：</p>
<ul>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>有什么用呢？别急，下面来进行解释：</p>
<p>首先需要明白在分代收集部分并非只是简单划分一下内存区域那么简单的，它存在一个明显的困难：对象之间并不是孤立的，对象之间会存在<strong>跨代引用</strong>，什么意思呢？</p>
<p>假如现在进行一次只局限于新生代区域内的收集（即Minor GC），但是新生代的对象有没有可能被老年代所引用呢？完全有这个可能。而为了找出该区域中的存活对象，就不得不在固定的<strong>GC Roots</strong>之外，额外去遍历整个<strong>老年代中</strong>所有对象去确保可达性分析结果的正确性（翻译大白话就是：找出新生代中对象被哪些老年代引用了），这种方案会为内存的回收带来极大的性能负担，因此就需要我们的第三条法则了。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>这个理论的本质，或者说我们该怎么去理解呢？</p>
<ul>
<li>存在相互引用关系的两个对象，是倾向于同时生存或者同时消亡的。</li>
</ul>
<p>eg：一个新生代对象存在跨代引用（一个老年代对象引用了该对象），由于老年代对象难以消亡，这份引用（羁绊）会使得新生代对象在GC的时候得以存活，这样时间久了，新生代会晋升到老年代中，此时就不存在<strong>跨代引用</strong>了</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>根据这条假说，既然这种跨代引用为少数情况，则我们不该为了这少量的跨代引用去扫描<strong>整个老年代</strong>，也不必去浪费空间去专门记录每一个对象是否存在哪些跨代引用了，就只需要在新生代上建立一个全局的数据结构（即<strong>记忆集</strong>），该结构将<strong>老年代</strong>划分成若干小块，并且标识出了老年代中哪块内存会存在<strong>跨代引用</strong>。</p>
<p>这样之后发生Minor GC的时候，只有这部分的小块内存中对象才会被加入到<mark>GC Roots</mark>进行扫描。Although，这种方法需要在对象改变引用关系（或将自己或某个属性赋值）时，维护记录数据的正确性，增加了一些运行的开销，但比起之前说的扫描整个老年代来说肯定是划算不少了。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h4><p>上面提到了记忆集这个数据结构，下面就来详解一下：</p>
<ul>
<li><p>记忆集是一种用于记录从<strong>非收集区域</strong>指向<strong>收集区域</strong>的<strong>指针集合</strong>的<strong>抽象数据结构</strong>，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构(下列代码为用对象指针去实现的记忆集)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class RememberedSet &#123;Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节</p>
<p>那设计者在实现记忆集的时候，便可以选择更为“粗犷”的<strong>记录粒度</strong>来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范围以外的的记录精度</p>
<ol>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ol>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>上述的卡精度的具体实现，是使用了一种叫<strong>卡表（Card Table）</strong>的方式去实现的记忆集，也是目前最常用的一种记忆集的实现形式（一些资料中甚至直接把它和记忆集混为一谈）</p>
<p>怎么理解卡表呢？记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。（用HashMap和Map的关系去理解吧）</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>卡表最简单的形式可以只是一个字节数组（之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是最小按字节寻址的， 没有直接存储一个bit的指令，所以要用bit的话就不得不多消耗几条shift+mask指令。）</p>
<p>即：<code>CARD_TABLE [this address &gt;&gt; 9] = 0</code> 表示的是HotSpot默认的卡表标记逻辑</p>
<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个 内存块被称作<mark>“卡页”（Card Page）</mark>。</p>
<p>一般来说，卡页大小都是以<strong>2的N次幂的字节数</strong>，通过上面代码可 以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如 果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了 地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块，如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405180124566.png" alt="image-20210405180124566"></p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，<strong>称为这个元素变脏（Dirty，脏表</strong>），没有则标识为0。</p>
<p>在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入<mark>GC Roots</mark>中一并扫描。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>我们可以顺便来梳理一下：分代收集理论存在跨代引用问题 → 使用记忆集卡表进行解决 → 卡表何时变脏？谁来把他们变脏？</p>
<p>这留下来了两个疑问。有问题就得解决</p>
<ol>
<li>卡表元素何时变脏？有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻</li>
<li>如何变脏，即如何在对象赋值的那一刻去更新维护卡表？假如是<strong>解释执行的字节码</strong>，那相对好处理，虚拟 机负责每条字节码指令的执行，有充分的介入空间；但在<strong>编译执行</strong>的场景中呢？经过即时编译后的代 码已经是纯粹的机器指令流了，这就必须找到一个在<mark>机器码层面</mark>的手段，把维护卡表的动作放到每一 个赋值操作之中。 </li>
</ol>
<h4 id="写屏障-1"><a href="#写屏障-1" class="headerlink" title="写屏障"></a>写屏障</h4><p>下面就对第二个问题进行更深一步理解：</p>
<p>在HotSpot虚拟机里是通过<mark>写屏障（Write Barrier）技术</mark>维护卡表状态的。</p>
<ul>
<li>ps：写屏障（Write Barrier）≠ 内存屏障（Memory Barrier），后者的目的是为了指令不因编译优化、CPU执行优化等原因 而导致乱序执行，它也是可以细分为仅确保读操作顺序正确性和仅确保写操作顺序正确性的内存屏障 的</li>
</ul>
<p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的<strong>AOP切面</strong>（有没有觉得很熟悉？没错，就是Spring中的那个），在引用对象赋值时会产生一个<strong>环形（Around）通知</strong>，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。</p>
<p>在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值 后的则叫作写后屏障（Post-Write Barrier）。</p>
<p>下面是一段写后屏障更新卡表的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 引用字段赋值操作</span></span><br><span class="line">*field = new_value;</span><br><span class="line"><span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">post_write_barrier(field, new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然应用这种技术后，只要对引用更新，就会产生额外的开销，但这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
<p>除了开销外还有一个问题：卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</p>
<p>伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != <span class="number">0</span>)</span><br><span class="line">CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>我们可以使用一个新的参数<code>+UseCondCardMark</code>，去决定是否开启卡表更新的条件判断，开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡</p>
<h3 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h3><p>使用三色标记：</p>
<ul>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201052497.png" alt="image-20210405201052497"></p>
<p>在上图中，最后一种情况会发生“对象消失”的问题，即原本应该是黑色的对象被标注为白色，导致被误认为是垃圾回收掉了</p>
<p>本质上来说，当且仅当以下两个条件同时满足时，这种情况会发生：</p>
<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
<p>因此衍生了</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="总概述"><a href="#总概述" class="headerlink" title="总概述"></a>总概述</h3><p>垃圾回收算法是内存回收的方法论，垃圾回收器则为内存回收的实践者。（下图为HotSpot虚拟机的垃圾回收器，连线表示可以搭配使用）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404145418336.png" alt="image-20210404145418336"></p>
<p>那么我们如何评判一个垃圾回收器好不好呢？需要什么指标呢？</p>
<p>一般来说我们从这三个方面入手去评判</p>
<ol>
<li><p><mark>吞吐量</mark>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
</li>
<li><p><mark>暂停时间</mark>：STW发生的时间</p>
</li>
<li><p><mark>内存占用</mark>：Java堆区所占的内存大小</p>
<p>注重吞吐量（做的事多），每次STW时间长，总时长短</p>
<p>注重低延迟（用户交互性好，不卡），每次STW间隔短，总时长长</p>
</li>
</ol>
<p><strong>现在的垃圾回收器标准：在满足最大吞吐量优先的情况下，降低停顿时间。</strong></p>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li>串行垃圾回收器适用场景<ul>
<li>单线程</li>
<li>内存小，多用于个人电脑（CPU核数较少）</li>
</ul>
</li>
</ul>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul>
<li>Serial（串行），从名字看出来这是一个单线程工作收集器，其潜在意义是：在进行GC的时候，会强制暂停其他所有的工作进程。</li>
<li>参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103523827.png" alt="在这里插入图片描述"></p>
<ul>
<li>特点<ul>
<li>简单而高效：Serial收集器没有线程交互的开销，专心做GC回收，因此可以获得最高的单线程收集效率</li>
<li>额外内存消耗较小</li>
</ul>
</li>
</ul>
<p>基于以上特点，Serial收集器适用于运行在客户端模式下的虚拟机</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul>
<li>ParNew收集器：本质是<strong>Serial收集器</strong>的多线程并行版本</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103529454.png" alt="在这里插入图片描述"></p>
<ul>
<li>特点<ul>
<li>支持多线程并行收集</li>
<li>只有这个收集器能够和<strong>CMS收集器</strong>配合工作（CMS收集器是HotSpot虚拟机中第一款支持并发的垃圾收集器，首次实现了让垃圾收集线程和用户线程（基本上）同时工作。</li>
<li>ParNew收集器较Serial在多核cpu上效率更高。</li>
</ul>
</li>
<li>并发与并行区别<ul>
<li><strong>并发</strong>：并发描述的是垃圾收集器线程和用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程序都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量会受到一定影响。</li>
<li><strong>并行</strong>：并行描述的是多条垃圾收集器之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程处于等待状态</li>
</ul>
</li>
</ul>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul>
<li>吞吐量优先垃圾回收器适用场景<ul>
<li>多线程</li>
<li>堆的内存较大，多核CPU</li>
</ul>
</li>
<li>特点<ul>
<li>在单位的时间内，STW的时间最短</li>
<li>是<strong>JDK 1.8</strong>默认使用的垃圾回收器</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404152959054.png" alt="image-20210404152959054"></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scanvenge收集器：是一款新生代收集器，同样基于<strong>标记-复制算法</strong>，能够实现并行收集。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png" alt="image-20210404154734362"></p>
<ul>
<li><p>特点：MDS等收集器的关注点是在于尽可能缩短<strong>STW</strong>时间，而这款收集器注重于达到一个<strong>可控制的吞吐量</strong></p>
</li>
<li><p>由于该款收集器注重于控制吞吐量，因此我们需要留意这 2个参数</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154222616.png" alt="image-20210404154222616"></p>
</li>
<li><p>GC自使用调节策略（与ParNew收集器最重要的一个区别）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154248333.png" alt="image-20210404154248333"></p>
</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><ul>
<li>Parallel Old收集器：是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，是基于标记 - 整理算法实现的</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png" alt></p>
<ul>
<li>特点：在注重吞吐量，或者处理器资源较为稀缺的场合，优先考虑<strong>Parallel Scavenge收集器 + Parallel Old收集器</strong>这个组合</li>
</ul>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154955660.png" alt="image-20210404154955660"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ul>
<li>CMS收集器（Concurrent Mark Sweep）：一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</li>
</ul>
<p>使用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<ul>
<li><p>特点</p>
<ul>
<li>基于<strong>标记-清除算法</strong>实现。</li>
<li>从总体来说，内存回收过程能与用户线程一起并发执行</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p><strong>处理器资源敏感</strong>。特别是核心数少的处理器，因为GC占用线程，所以总吞吐量降低。</p>
</li>
<li><p><strong>难以应对“浮动垃圾”（即在标记完成后出现的新垃圾）</strong>，因为有并发标记的阶段，所以这阶段产生的垃圾不会被标记，这些垃圾只能等到下一次垃圾收集时清理。</p>
<p> 同时，CMS不能等到老年代几乎填满后再启动，因为他必须留下足够的内存，在垃圾收集的同时给用户线程使用。预留过多会造成内存浪费以及回收频繁；预留过少会造成“并发失败”，并发失败发生后虚拟机会调用Serial Old重新收集，会使性能下降。</p>
</li>
<li><p>由于标记-清除算法，而产生的<strong>空间碎片化</strong>问题，甚至可能会进行一次Full GC。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103534693.png" alt="在这里插入图片描述"></p>
<ul>
<li>运作过程：<ul>
<li>初始标记（initial mark）：仅标记一下<strong>GC Roots</strong>能直接关联到的<strong>对象</strong>，追求时间效率，避免用户久等。</li>
<li>并发标记（cocurrent mark）：从<strong>GC Roots直接关联对象开始遍历整个对象图（所有的可达的对象）</strong>，这个过程耗时长但不需要<strong>停顿用户线程</strong>，此过程可以与<strong>垃圾回收线程</strong>一起<mark>并发</mark>运行</li>
<li>重新标记（remark）：为了修正<strong>并发标记</strong>期间，用户程序继续运作而导致标记变动的那部分对象的<strong>标记记录</strong>（这是在并发可达性分析中，增量更新部分的内容），此阶段的停顿时间通常比<strong>初始标记阶段</strong>时间长一点，但也远比<strong>并发标记</strong>阶段时间短</li>
<li>并发清除（concurrent sweep）：清除删除掉<strong>标记阶段</strong>中判断出来的已经死亡的对象，此阶段可以与用户线程<strong>同时并发</strong></li>
</ul>
</li>
</ul>
<h3 id="G1-Garabage-First-收集器"><a href="#G1-Garabage-First-收集器" class="headerlink" title="G1(Garabage First)收集器"></a>G1(Garabage First)收集器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>之前的收集器是以分代为衡量标准进行GC，而G1是面向<strong>堆内存任何部分组成回收集</strong>，衡量标注是哪块内存中存放的垃圾数量最多，则回收受益最大。</p>
<ul>
<li><p><strong>Region</strong>： G1在组建回收集时，不再根据新生代老年代衡量。而是把java堆划分为多个大小相等的<strong>Region</strong>，每个Region根据需要可以扮演<strong>新生代的Eden、Survivor存活区域或老年代区域</strong>。</p>
</li>
<li><p><strong>特点</strong>：既兼顾低延迟，也针对大吞吐量。</p>
</li>
<li><p><strong>Humongous区域</strong>：收集器再对不同Region采用不同策略进行收集。Humongous区域专门用来存放大对象（即超过Region一半大小的对象）。对于超过整个Region的对象，用多个连续Humongous存储。G1大多数行为将其视为<strong>老年代</strong>。</p>
</li>
<li><p><strong>注意点</strong>：G1仍保有新生代老年代概念，是一系列区域（不需要为连续的）的<mark>动态集合</mark>。G1将<strong>Region</strong>作为最小回收单元，因此停顿时间可预测（即每次手机的内存空间为<strong>Region</strong>大小整数倍，可以有计划的避免在这个Java堆尽心全区域的垃圾回收）</p>
<ul>
<li>具体实现：通过跟踪每个Region的回收价值大小（即回收所获得空间和回收所需时间的经验值），并<strong>维护一个优先级列表</strong>。回收时根据用户设定允许的回收停顿时间，优先处理价值高的Region。（这也是为什么说停顿时间是可预测的原因）</li>
</ul>
</li>
<li><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
</li>
</ul>
<h4 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151109.png" alt="img"></p>
<p>总的一个流程：</p>
<p>新生代伊甸园垃圾回收（Young Collection）—–&gt;内存不足，新生代回收+并发标记（Young Collection + Concurrent Mark）—–&gt;回收新生代伊甸园、幸存区、老年代内存（Mixed Collection）——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h5 id="Young-Collection-Minor-GC"><a href="#Young-Collection-Minor-GC" class="headerlink" title="Young Collection/Minor GC"></a>Young Collection/Minor GC</h5><p>即新生代收集：目标只是新生代的垃圾收集</p>
<ul>
<li>E：伊甸园</li>
<li>S：幸存区</li>
<li>O：老年代</li>
</ul>
<p>这个回收会发生：STW</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165247574.png" alt="image-20210405165247574"></p>
<p>新生代回收会将幸存对象以<strong>拷贝算法</strong>放入幸存区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165320293.png" alt="image-20210405165320293"></p>
<p>接着，当幸存区中对象过多，或者是年龄达到了<strong>阈值</strong>，则这部分对象会晋升到<strong>老年代</strong>，不够年龄的则拷贝到别处幸存区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165454440.png" alt="image-20210405165454440"></p>
<h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p><strong>CM并发标记</strong>：从<strong>GC Roots直接关联对象开始遍历整个对象图（所有的可达的对象）</strong></p>
<ul>
<li><p>在 <mark>Young GC</mark> 时会<strong>对 GC Root 进行初始标记</strong></p>
</li>
<li><p>在老年代<strong>占用堆内存的比例</strong>达到<strong>阈值</strong>时，对进行并发标记（不会STW），阈值可以根据参数：<code>-XX:InitiatingHeapOccupancyPercent=percent (默认45%)</code>去决定</p>
</li>
<li><p>E：伊甸园</p>
</li>
<li><p>S：幸存区</p>
</li>
<li><p>O：老年代</p>
</li>
</ul>
<p>如下图，当老年代（O，橙色部分）占用堆 空间比例达到我们设置的阈值的时候，会进行<strong>并发标记</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165830879.png" alt="image-20210405165830879"></p>
<h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>混合收集：目标是收集整个新生代以及<strong>部分</strong>老年代的垃圾收集（目前只有G1收集器会有该行为）</p>
<p>在该阶段，会对E S O（具体含义看以下解释）进行全面的垃圾回收</p>
<ul>
<li>E：伊甸园</li>
<li>S：幸存区</li>
<li>O：老年代</li>
</ul>
<p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p>
<ul>
<li><p>回收过程：</p>
<ul>
<li><p>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的SATB记录</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）：负责更新<strong>Region</strong>的统计数据，对各个Region的回收价值和成本进行排序（其实就是维护一个优先级列表啦），然后结合用户设置的停顿时间去制定一个回收计划，可自由的选择任意多个Region去构成一个<strong>回收集</strong>，然后把决定回收的那一部分Region的存活对象复制到空的Region，然后直接清理整个旧Region的全部空间。</p>
<p>由于这部分的操作设计到了存活对象的移动，因此是<strong>必须暂停用户线程的</strong>，由多条收集器线程<strong>并行完成</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170011836.png" alt="image-20210405170011836"></p>
<p>我们观察上图，发现并不是所有的老年代区域（O）都被复制到了新的老年代区域，是因为G1是根据我们上面的参数 —— 最大暂停时间，<strong>有选择</strong>的进行回收。也就是一开始我们的<mark>注意点</mark>部分中的：维护一个优先级列表，从列表中优先回收价值最高的区域。</p>
<p>从这个阶段，也能够体现出<strong>Garbage First</strong>的含义了。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ol>
<li>Full GC（整堆收集）：收集整个Java堆和方法区的垃圾收集</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170927035.png" alt="image-20210405170927035"></p>
<p>对于G1算法来说，它老年代内存不足时需要分类讨论：</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h4 id="Young-Collection跨代引用"><a href="#Young-Collection跨代引用" class="headerlink" title="Young Collection跨代引用"></a>Young Collection跨代引用</h4><ul>
<li>这部分内容在HotSpot算法细节 - 概念辨析部分中有具体理解。</li>
</ul>
<p>跨代引用：老年代引用新生代</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151211.png" alt="img"></p>
<p>主要是通过了记忆集卡表去进行问题的解决。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151222.png" alt="img"></p>
<ul>
<li>在引用变更时通过post-write barried（写屏障） + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set（记忆集）</li>
</ul>
<h4 id="Remark-重新标记"><a href="#Remark-重新标记" class="headerlink" title="Remark - 重新标记"></a>Remark - 重新标记</h4><p>这部分内容使用到了<strong>三色标记</strong>，具体可以查看并发可达性分析部分的内容</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></p>
<p>这是一个GC Roots的图</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201808678.png" alt="image-20210405201808678"></p>
<p>考虑这么个情况：假如C被判断成一个无引用的（白色）过后，A又去引用了C，那C应该是有引用的，那就不应该被回收掉，但是A又是黑色的，是已经检查过的元素，那在整个并发标记的过程结束后，我们仍然判断C为白色（应该被回收的对象），那这样就不对的了；</p>
<p>因此就需要对引用的对象进行二次检查，即重新标记Remark</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405202602146.png" alt="image-20210405202602146"></p>
<p>具体实现：</p>
<p>当对象的引用发生改变时，引用关系的插入与删除会通过写屏障去实现。</p>
<p>比如本例中，A引用C，则会把C加入到一个队列中，并改变其为灰色（没有被处理完），等整个并发标记阶段结束后，进入重新标记阶段，发生STW，将该队列中的对象拿出来重新进行检查，若是有引用的，则置为黑色，就不会被回收掉了</p>
<h4 id="G1-字符串去重"><a href="#G1-字符串去重" class="headerlink" title="G1-字符串去重"></a>G1-字符串去重</h4><ul>
<li>JDK 8U20 字符串去重</li>
</ul>
<p>提到字符串去重，除了之前提到的String方法中的<code>intern</code>方法外，G1还提供了另外一种方法</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>优点：节省了大量内存</li>
<li>缺点：新生代回收时间略微增加，导致略微多占用CPU</li>
<li>与String.intern()区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h4 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h4><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<p><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认开启</p>
<h4 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h4><ul>
<li><p>一个对象大于region的一半时，就称为巨型对象</p>
</li>
<li><p>G1不会对巨型对象进行<strong>拷贝</strong>（因为代价太高了）</p>
</li>
<li><p>回收时被优先考虑</p>
</li>
<li><p>G1会跟踪老年代所有<strong>incoming</strong>引用（卡表），如果老年代<strong>incoming</strong>引用为0（卡表为0）的巨型对象就可以在新生代垃圾回收时处理掉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405203350365.png" alt="image-20210405203350365"></p>
</li>
</ul>
<h4 id="JDK-9并发标记起始时间调整"><a href="#JDK-9并发标记起始时间调整" class="headerlink" title="JDK 9并发标记起始时间调整"></a>JDK 9并发标记起始时间调整</h4><ul>
<li><p>并发标记必须在<strong>堆</strong>空间占满之前完成，否则退化为 FullGC</p>
</li>
<li><p>JDK 9之前需要使用<code>-XX:InitiatingHeapOccupancyPercent</code></p>
</li>
<li><p>JDK 9之后可动态调整</p>
<ul>
<li><code>-XX:InitatingHeapOccupancyPercent</code>去设置初始值</li>
<li>进行数据采样并且动态调整</li>
<li>会添加一个安全的空档空间</li>
</ul>
<h2 id="GC-垃圾回收-调优"><a href="#GC-垃圾回收-调优" class="headerlink" title="GC(垃圾回收)调优"></a>GC(垃圾回收)调优</h2></li>
</ul>
<p>关于这部分内容，感觉是项大工程，之后系统的学习一下，不能囫囵吞枣，先把后续部分学了；</p>
<h1 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><ul>
<li><p>类字节码文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>类文件的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 			   magic;&#x2F;&#x2F;魔数</span><br><span class="line">    u2             minor_version;&#x2F;&#x2F;小版本号</span><br><span class="line">    u2             major_version;&#x2F;&#x2F;主版本号   </span><br><span class="line">    u2             constant_pool_count;&#x2F;&#x2F;常量池信息</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池信息</span><br><span class="line">    u2             access_flags;&#x2F;&#x2F;访问标志：返回一些信息（是类还是接口啊，是公共还是私有等)   </span><br><span class="line">    u2             this_class;&#x2F;&#x2F;类包名    </span><br><span class="line">    u2             super_class;&#x2F;&#x2F;父类信息   </span><br><span class="line">    u2             interfaces_count;&#x2F;&#x2F;接口信息    </span><br><span class="line">    u2             interfaces[interfaces_count];&#x2F;&#x2F;接口信息   </span><br><span class="line">    u2             fields_count;&#x2F;&#x2F;变量信息    </span><br><span class="line">    field_info     fields[fields_count];&#x2F;&#x2F;变量信息   </span><br><span class="line">    u2             methods_count;&#x2F;&#x2F;方法信息    </span><br><span class="line">    method_info    methods[methods_count];&#x2F;&#x2F;方法信息    </span><br><span class="line">    u2             attributes_count;&#x2F;&#x2F;附加属性信息   </span><br><span class="line">    attribute_info attributes[attributes_count];&#x2F;&#x2F;附加属性信息 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个Class文件的头4个字节被称为<strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。</p>
<p>如：0000000 <mark>ca fe ba be</mark> 00 00 00 34 00 23 0a 00 06 00 15 09 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic;&#x2F;&#x2F;魔数</span><br></pre></td></tr></table></figure>

<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>紧接着魔数的4个字节存储的是<strong>Class文件的版本号</strong>：第5和第6个字节是<strong>次版本号（Minor Version）</strong>第7和第8个字节是<strong>主版本号（Major Version）</strong></p>
<p>如：0000000 ca fe ba be <mark>00 00 00 34</mark> 00 23 0a 00 06 00 15 09 </p>
<p>此处的00 34中的34表示的是十六进制，即十进制的52：表示的是java8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;&#x2F;&#x2F;小版本号</span><br><span class="line">u2             major_version;&#x2F;&#x2F;主版本号   </span><br></pre></td></tr></table></figure>



<h3 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主、次版本号之后的是<strong>常量池</strong>入口，常量池可以比喻为Class文件里的<strong>资源仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;&#x2F;&#x2F;常量池信息</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池信息</span><br></pre></td></tr></table></figure>

<p>如：0000000 ca fe ba be 00 00 00 34 <mark>00 23 0a 00 06 00 15 09</mark></p>
<p>mark标记的是完整的常量池信息，我们通常拆分成小段去理解：</p>
<ul>
<li><p>0000000 ca fe ba be 00 00 00 34 <mark>00 23</mark> 0a 00 06 00 15 09 ：表示常量池的长度，00 23（35），表示常量池有#1~#34项，容量计数 从1而不是从0开始；空出来的原因：如果后面某些指向常量池的索引值的数据在特定情况下需要表达：”不引用任何一个常量池项目”的含义，就可以把索引值设置成0；</p>
</li>
<li><p>0000000 ca fe ba be 00 00 00 34 00 23 <mark>0a 00 06 00 15</mark> 09：<strong>0a（十进制中的10）</strong>表示一个方法引用，<strong>00 06</strong>和<strong>00 15（21）</strong>表示引用了常量池中#6和#21项来获得这个方法的【所属类】和【方法名】</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406201628119.png" alt="image-20210406201628119"></p>
</li>
</ul>
<p>后续部分以此类推，可阅读《深入理解JVM虚拟机》一书进行学习。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><ul>
<li>用于识别一些类或 者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;&#x2F;&#x2F;访问标志：返回一些信息（是类还是接口啊，是公共还是私有等)   </span><br></pre></td></tr></table></figure>

<p>具体的标志位以及其对应的含义见下表：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406202510383.png" alt="image-20210406202510383"></p>
<h3 id="类索引、福类索引与接口索引集合"><a href="#类索引、福类索引与接口索引集合" class="headerlink" title="类索引、福类索引与接口索引集合"></a>类索引、福类索引与接口索引集合</h3><p><strong>类索引（this_class）</strong>和<strong>父类索引（super_class）</strong>都是一个<strong>u2</strong>类型的数据，而<strong>接口索引集合 （interfaces）</strong>是一组u2类型的数据的<strong>集合</strong>，Class文件中由这三项数据来确定该类型的继承关系。类索 引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;&#x2F;&#x2F;类包名    </span><br><span class="line">u2             super_class;&#x2F;&#x2F;父类信息   </span><br><span class="line">u2             interfaces_count;&#x2F;&#x2F;接口信息    </span><br><span class="line">u2             interfaces[interfaces_count];&#x2F;&#x2F;接口信息  </span><br></pre></td></tr></table></figure>



<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;&#x2F;&#x2F;变量信息    </span><br><span class="line">field_info     fields[fields_count];&#x2F;&#x2F;变量信息  </span><br></pre></td></tr></table></figure>

<ul>
<li>字段<ul>
<li>包括：括类级变量以及实例级变量</li>
<li>不包括：在方法内部声明的局部变量</li>
</ul>
</li>
</ul>
<p>在Java中，我们常见的描述字段的信息：</p>
<ol>
<li>字段的作用域（public、private、protected修饰 符）</li>
<li>实例变量还是类变量（static修饰符）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile修饰符，是否 强制从主内存读写）</li>
<li>可否被序列化（transient修饰符）</li>
<li>字段数据类型（基本类型、对象、数组）</li>
<li>字段名称</li>
</ol>
<p>上述这些信息，其修饰符是以<strong>布尔值</strong>形式存在，即：要么有，要么没有，适合使用标志位去表示；</p>
<p>而字段的名字，字段的数据类型都是不可以确定的，或者说不能用01去表示，因此就只能引用常量池中的常量去描述</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204514100.png" alt="image-20210406204514100"> <strong>字段修饰符</strong>放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如下图所示（可以看到我们熟悉的public private protected等）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204617979.png" alt="image-20210406204617979"></p>
<p>name_index和descriptor_index是两项索引值，表示对常量池项的引用</p>
<ul>
<li><p>name_index：字段的简单名称</p>
</li>
<li><p>descriptor_index：字段和方法的描述符</p>
</li>
<li><p><strong>“简单名称” “描述符”“全限定名”</strong>这三种特殊字符串的概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.clazz;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全限定名：<mark>org/fenixsoft/clazz/TestClass”</mark>是这个类的全限定名，仅仅是把类全名中的<strong>“.”</strong>替换成了<strong>“/”</strong>而已，为了使连续的多个全限定名之间不产生混 淆，在使用时最后一般会加入一个<strong>“；”</strong>号表示全限定名结束。</p>
</li>
<li><p>简单名称:简单名称则就是指没有类型和参数修饰 的方法或者字段名称，这个类中的<strong>inc()方法和m字段</strong>的<mark>简单名称</mark>分别就是<strong>“inc”</strong>和<strong>“m”</strong>。</p>
</li>
<li><p>描述符：是用来描述字段 的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205720096.png" alt="image-20210406205720096"></p>
</li>
</ul>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括</p>
<ol>
<li><p>访问标志（access_flags）</p>
</li>
<li><p>名称索引（name_index）</p>
</li>
<li><p>描述符索引（descriptor_index）</p>
</li>
<li><p>属性表集合（attributes）</p>
<p> u2             methods_count;//方法信息<br> method_info    methods[methods_count];//方法信息<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205841685.png" alt="image-20210406205841685"></p>
</li>
</ol>
<p>对于方法表，其标志位与取值可参考下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205930635.png" alt="image-20210406205930635"></p>
<p>我们需要注意的是，方法可以通过访问标志、名称索引、描述符索引来表达。但方法中的代码，会经过Javac编译器编译成字节码指令之 后，存放在<strong>方法属性表集合</strong>中一个名为<mark>Code</mark>的属性里面,属性表在下节进行讲解。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul>
<li><p>属性表（attribute_info）：Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息</p>
<p>  u2             attributes_count;//附加属性信息<br>  attribute_info attributes[attributes_count];//附加属性信息<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210522604.png" alt="image-20210406210522604"></p>
</li>
</ul>
<p>我们下面主要讲解一下Code属性：</p>
<p>我们上面说到：Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 </p>
<p>而Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如<strong>接口或者抽象类</strong>中的方法就不存在Code属性</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210616293.png" alt="image-20210406210616293"></p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>相关指令对应的含义可参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></li>
</ul>
<p>Java虚拟机的指令由<strong>一个字节长度</strong>的、代表着<strong>某种特定操作含义</strong>的<mark>数字</mark>（称为<strong>操作码，Opcode</strong>） 以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数，Operand</strong>）构成。</p>
<p>而Java虚拟机中大多数指令都不包含操作数，只有一个操作码，指令参数存放在操作数栈中；</p>
<h3 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示 字节码指令 和 操作数栈 常量池的关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;        </span><br><span class="line">		<span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="keyword">int</span> c = a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>常量池载入运行时常量池</p>
<p>ps：运行时常量池属于方法区的一部分</p>
<p>Class文件常量池中的数据存储在运行时常量池，将来找方法引用等信息等就从这去找。</p>
<p>32768：是<code>Short.MAX_VALUE + 1</code>的结果，通常来说一些小的数字并不存储在常量池中，而是与方法字节码存储在一起，而较大一些的则放在常量池中。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406212905766.png" alt="image-20210406212905766"></p>
</li>
<li><p>方法字节码载入方法区</p>
<p>接着会将方法的字节码放入方法区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213536911.png" alt="image-20210406213536911"></p>
</li>
<li><p>main线程开始运行，分配栈帧内存</p>
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213701389.png" alt="image-20210406213701389"></p>
</li>
<li><p>执行引擎开始执行字节码</p>
<ol>
<li><p>bipush 10 ：将一个 byte 压入操作数栈（其长度会补齐 4 个字节）</p>
<ul>
<li>下面是类似的指令：<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
</ul>
</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214624098.png" alt="image-20210406214624098"></p>
</li>
<li><p>istore 1（1代表的是1号槽位）</p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214735588.png" alt="image-20210406214735588"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214755269.png" alt="image-20210406214755269"></p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>ldc #3</p>
<p>从常量池加载#3数据到操作数栈中</p>
<p>32768的计算是在<strong>编译期间</strong>计算好的（不是运行时期间）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215006674.png" alt="image-20210406215006674"></p>
</li>
<li><p>istore 2</p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151432.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151441.png" alt="img"></p>
</li>
<li><p>iload 1</p>
<p>由于 a + b操作是不能在局部变量表中执行，而是得在操作数栈中进行，因此 <strong>iload</strong>就是进行变量的读取操作</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215628748.png" alt="image-20210406215628748"></p>
</li>
<li><p>iload 2</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215649658.png" alt="image-20210406215649658"></p>
</li>
<li><p>iadd</p>
<p>操作数栈有a 和 b两个数据了，就要进行加法操作：将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151508.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151523.png" alt="img"></p>
</li>
<li><p>istore 3</p>
<p>将操作数栈中的32778取出来放入局部变量表三号槽位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151547.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163256206.png" alt="image-20210409163256206"></p>
</li>
<li><p>getstatic #4</p>
<p>在运行时常量池中找到成员变量的引用，此处的#4指向的是存放在堆中的System.out对象</p>
<p>注意，此处并不会把<strong>该对象</strong>放入操作数栈中，而是将<strong>其引用</strong>放入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163623604.png" alt="image-20210409163623604"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163636859.png" alt="image-20210409163636859"></p>
</li>
<li><p>iload 3</p>
<p>将局部变量表中3号槽位的元素压入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163904424.png" alt="image-20210409163904424"></p>
</li>
<li><p>invokevirtual #5</p>
<p>找到运行时常量池 #5 项，接着定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>虚拟机分配新的栈帧（分配 locals、stack等）</p>
<p>接着执行：传递参数，执行新栈帧中的字节码</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163939850.png" alt="image-20210409163939850"></p>
<p>执行完毕，弹出栈帧</p>
<p>清除main操作数栈的内容</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409164137353.png" alt="image-20210409164137353"></p>
</li>
<li><p>return</p>
<p>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
</li>
</ol>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>我们首先认识一下什么是类加载机制：</p>
<ul>
<li>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<strong>类加载机制</strong></li>
</ul>
<p>我们可以对这句话进行拆分：</p>
<p>描述类的数据是移动单位，出发点是Class文件，目的地是内存。在移动其间对该单位进行了三步：</p>
<ol>
<li>检验</li>
<li>转换解析</li>
<li>初始化</li>
</ol>
<p>移动的目的是为了能形成一个能被虚拟机直接使用的java类型（意思是一开始不行）</p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>一个类的生命周期从大的来说是从：被加载到虚拟机内存中开始，到卸载出内存为止</p>
<p>细分的话，在这个生命周期内会经历：</p>
<p>加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段</p>
<p>验证、准备、解析 这三个部分我们统称为：为连接（Linking）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410174849844.png" alt="image-20210410174849844"></p>
<p>值得注意的是：</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的（解析的顺序不确定）</p>
<p>因为解析阶段在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>
<p>这个过程表示的是按顺序开始，不是所谓的第一步、第二步、第三步的关系，而往往是交叉混合进行，在一个阶段中可能调用或者激活另一个过程。因此这个图只是一个大致的运行流程图罢了，不是一个真正的时序图。</p>
<p>是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行<strong>“初始化”</strong>（而加载、验证、准备自然需要在此之前开始，因为这五个阶段的顺序是确定的）</p>
<ol>
<li>遇到<strong>new、getstatic、putstatic或invokestatic</strong>这四条，<mark>字节码指令</mark>时，如果类型没有进行过初始 化，则需要先触发其初始化阶段，从<mark>Java代码</mark>的场景来说的话分为：<ol>
<li>使用<strong>new</strong>关键字实例化对象的时候。</li>
<li><strong>读取或设置</strong>一个类型的<strong>静态字段</strong>（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。</li>
<li><strong>调用</strong>一个类型的<strong>静态方法</strong>的时候</li>
</ol>
</li>
<li>使用java.lang.reflect包的方法对类型进行<strong>反射调用</strong>的时候，如果类型没有进行过初始化，则需 要先触发其初始化</li>
<li>当初始化类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其<strong>父类的初始化</strong>。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>（包含<strong>main()方法的那个类</strong>），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.<strong>MethodHandle</strong>实例最后的解 析结果为<strong>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</strong>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被<strong>default关键字修饰的接口方法</strong>）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>综上这六类场景中的行为我们称之为对一个类型进行<strong>主动引用</strong>（言外之意就是所有引用类型的方式都是不会触发初始化的，我们称之为<strong>被动引用</strong>）</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只会输出“SuperClass init！123”，而不会输出“SubClass init！</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410181127638.png" alt="image-20210410181127638"></p>
<p>原因是：对于静态字段（static），只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化，因此子类的静态字段是没有被初始化的。</p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>加载（Loading）阶段</strong>是整个<mark>类加载（Class Loading）</mark>过程中的一个阶段</p>
<p>在此阶段，Java虚拟机完成了以下三件事</p>
<ol>
<li>通过一个类的<strong>全限定名</strong>来获取定义此类的<mark>二进制字节流</mark>。（实现这个动作的代码我们称之为：<strong>类加载器（Class Loader），这部分内容将在后面着重学习</strong>）</li>
<li>将这个<mark>字节流</mark>所代表的<strong>静态存储结构</strong>转化为<strong>方法区</strong>的<mark>运行时数据结构</mark></li>
<li>在<strong>堆内存</strong>中生成一个代表这个类的<mark>java.lang.Class对象</mark>，作为<strong>方法区</strong>这个类的<strong>各种数据</strong>的<mark>访问入口（外部接口）</mark>。</li>
</ol>
<p>第一条这个规则比较宽松，因此衍生了许多java技术（这个规则的实践）</p>
<ul>
<li>从ZIP压缩包中读取</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用 了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件</li>
<li>…</li>
</ul>
<p>值得注意的是：</p>
<p><mark>加载阶段与连接阶段</mark>的部分动作（如一部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，<strong>加载</strong>阶段尚未完成，<strong>连接</strong>阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部 分，这两个阶段的开始时间仍然保持着固定的先后顺序</p>
<p>(也就是大体上依旧保持着先后顺序，只是连接部分中的几步可能穿插在加载阶段)</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li><mark>验证阶段</mark>是连接阶段的第一步</li>
</ul>
<p>这一步的目的：从字面我们也能看出来，主要是进行Class文件的字节流中包含的信息的验证，确认符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p>
<p><em>文件格式验证</em>：验证字节流是否符合Class文件格式的规范并 验证其版本是否能被当前的jvm版本所处理。ok没问题后，字节流就可以进入内存的方法区进行保存了。后面的3个校验都是在方法区进行的。</p>
<p><em>元数据验证</em>：对字节码描述的信息进行语义化分析，保证其描述的内容符合java语言的语法规范。</p>
<p><em>字节码检验</em>：最复杂，对方法体的内容进行检验，保证其在运行时不会作出什么出格的事来。</p>
<p><em>符号引用验证</em>：来验证一些引用的真实性与可行性，比如代码里面引了其他类，这里就要去检测一下那些来究竟是否存在；或者说代码中访问了其他类的一些属性，这里就对那些属性的可以访问行进行了检验。（这一步将为后面的解析工作打下基础）</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li><mark>准备阶段</mark>是正式为类中定义的<strong>变量</strong>（即静态变量，被static修饰的变量）<strong>分配内存</strong>并<strong>设置类变量初始值（0 或者 null）</strong>的阶段</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>在准备阶段进行内存分配的仅包括<strong>类变量</strong>，而不包括<strong>实例变量</strong>，<strong>实例变量</strong>将会在<strong>对象实例化</strong>时随着对象一起分配在<strong>Java堆</strong>中</p>
<p>（实例变量就是对象变量，即没加static的变量。对应的 类变量，即静态变量，也就是变量前加了static的变量）</p>
</li>
<li><p>初始值“通常情况”下是数据类型的零值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>静态变量value在准备阶段后的初始值是0而不是123.（初始化阶段才会赋值）</p>
</li>
</ol>
<p>   但也有特殊情况，那就是加上了final关键字</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>   那么准备阶段 value 的值就被赋值为 123</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210412150411190.png" alt="image-20210412150411190"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>解析阶段是Java虚拟机将<strong>常量池</strong>内的<mark><strong>符号引用</strong></mark>替换为<mark><strong>直接引用</strong></mark>的过程</li>
</ul>
<p>符号引用，形如：CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局<strong>无关</strong>，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接<strong>相关</strong>的，同一个<strong>符号引用</strong>在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li>
</ul>
<p>举个例子来说的话：</p>
<p>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的<strong>偏移量</strong>就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>一句话来说：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>类的初始化阶段是类加载过程的最后一个步骤，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，只有在初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码（字节码），将主导权移交给应用程序</li>
<li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,值得注意的是，<code>&lt;clinit&gt;()</code>方法并不是程序员在Java代码中直接编写的方法，是<strong>Javac编译器的自动生成物</strong></li>
</ul>
<p>类初始化条件：要对类进行<strong>初始化</strong>，代码上可以理解为<u><strong>‘为要初始化的类中的所有静态成员都赋予初始值、对类中所有静态块都执行一次，并且是按代码编写顺序执行’</strong></u>。</p>
<p><code>如下代码：输出的是‘1’。如果①和②顺序调换，则输出的是‘123’。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(Super.i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">  <span class="comment">//①</span></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i = <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//②</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">		System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类加载原理图解"><a href="#类加载原理图解" class="headerlink" title="类加载原理图解"></a>类加载原理图解</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-e5c0fc9fdbca7174.png" alt="img"></p>
<p><clinit>方法代码理解：</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">static</span>&#123;                            </span><br><span class="line"> A=<span class="number">2</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ---相当于----&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"> &lt;clinit&gt;()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">     A=<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>接口和类初始化过程的区别：</li>
</ul>
<ol>
<li>对于类，会生成<clinit>(){……}方法体：去包含静态变量的赋值和静态块代码</clinit></li>
<li>而对于接口，也会生成<clinit>(){……}方法体：去初始化接口中的成员变量</clinit></li>
</ol>
<p>类的初始化执行之前要求父类全部都初始化完成了，但接口的初始化貌似对父接口的初始化不怎么感冒，也就是说，子接口初始化的时候并不要求其父接口也完成初始化，只有在真正使用到父接口的时候它才会被初始化（比如引用接口上的常量的时候啦）</p>
<h3 id="代码体验"><a href="#代码体验" class="headerlink" title="代码体验"></a>代码体验</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第二句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是main方法，我输出Super的类变量i：&quot;</span>+Sub.i);</span><br><span class="line">      Sub sub  = <span class="keyword">new</span> Sub();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Super</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//第四句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super成员块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第六句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">int</span> j = <span class="number">123</span>;</span><br><span class="line">      <span class="comment">//第五句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super成员块中的变量j：&quot;</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      <span class="comment">//第一句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super静态块&quot;</span>);</span><br><span class="line">      i = <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">extends</span> <span class="title">Super</span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      <span class="comment">//第三句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub静态块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第八句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//第七句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub成员块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-aa2a7c61bcc2c67f.png" alt="img"></p>
<p>说明：</p>
<ol>
<li><strong>对于同一个类：</strong>静态代码块和静态变量的赋值 是<strong>先于</strong>main方法的调用执行的。</li>
<li><strong>对于同一个类：</strong>静态代码块和静态变量的赋值是按顺序执行的。</li>
<li>子类调用父类的类变量成员，是不会触发子类本身的初始化操作的【所以我们调用 <code>Sub.i</code> ，<code>Sub.class</code>并没有被初始化和加载】。</li>
<li>使用new方式创建子类，对于类加载而言，是先加载父类、再加载子类（注意：此时由于父类已经在前面初始化了一次，所以，这一步，就只有子类初始化，父类不会再进行初始化）</li>
<li>不论成员块放在哪个位置，它都 <strong>先于</strong>类构造方法执行</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p><strong>类加载器就是根据一个全限定名加载class生成二进制流并转换为一个java.lang.Class对象实例</strong></p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<mark>唯一性</mark>，每 一个类加载器，都拥有一个独立的类名称空间/命名空间，因此，一旦一个类被加载如JVM中，同一个类就不会被再次载入了。</p>
<p>可以这么理解：</p>
<ul>
<li><strong>Java</strong>中，一个类用其全限定类名（包括包名和类名）作为标识</li>
<li><strong>JVM</strong>中，一个类用其全限定类名和其类加载器作为其唯一标识</li>
</ul>
<p>因此，这两个<strong>类</strong>来源于同一个 <strong>Class文件</strong>，被同一个<strong>Java虚拟机</strong>加载，但加载它们的<strong>类加载器</strong><mark>不同</mark>，那这两个类就必定<mark>不相等</mark></p>
<p>这里所指的“相等”，包括类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，也包括使用<code>instanceof()</code>关键字对做对象所属关系判定等情况</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>-从jvm的角度来讲，只存在以下两种不同的类加载器：  </p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分；</li>
<li>所有其他类的加载器，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ul>
<p>-从Java开发人员的角度看，类加载器可以划分成三大类：</p>
<ul>
<li><mark>启动类加载器（Bootstrap ClassLoader）</mark>： 此类加载器负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。<ul>
<li>启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</li>
</ul>
</li>
<li><mark>扩展类加载器（Extension ClassLoader）</mark> ： 这个类加载器是由<code>ExtClassLoader（sun.misc.Launcher$ExtClassLoader）</code>实现的。它负责将<code>&lt;Java_Home&gt;/lib/ext</code>或者被 <code>java.ext.dir</code>系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li><Mark>应用程序类加载器（Application ClassLoader） ： 这个类加载器是由 <code>AppClassLoader（sun.misc.Launcher$AppClassLoader）</code>实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，因此一般称为系统类加载器。<ul>
<li>它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</Mark></li>
</ul>
<p>类加载器的关系：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d4af5df076ca1a8b46a275d62c9d919f_hd.jpg" alt="v2-d4af5df076ca1a8b46a275d62c9d919f_hd.jpg"></p>
<p>分层理解的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415212558624.png" alt="image-20210415212558624"></p>
<p>上图展示的类加载器之间的层次关系，称为类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过<strong>组合（Composition）关系</strong>来实现，而不是通过<strong>继承（Inheritance）</strong>的关系实现。</p>
<ul>
<li>组合关系(has-a关系）：把该类当成另一个类的<strong>组合成分</strong>，从而允许新类直接复用该类的public方法</li>
</ul>
<h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当需要使用该类时，才会将它的class文件加载到内存生成class对象（按需加载），加载时，使用的是<strong>双亲委派模式</strong>：</p>
<ul>
<li><p>如果一个类加载器收到了类请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给【父加载器/上级加载器】去完成，每一层都是如此，因此所有类加载的请求最终都会传到启动类加载器，只有当父加载器无法完成该请求时，子加载器才去自己加载。（父加载器、子加载器：非继承关系，而是用<strong>组合模式</strong>来复用父加载器代码）</p>
</li>
<li><p>双亲委派的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 首先，检查请求的类是否已经被加载过了，加载了就直接返回</span></span><br><span class="line">	Class c = findLoadedClass(name);</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前类加载器的父加载器不为空，则委托父加载器去加载该类</span></span><br><span class="line">		<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">			c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">			c = findBootstrapClassOrNull(name);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">			<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">			<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">			c = findClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">		resolveClass(c);</span><br><span class="line">	&#125;<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码也看得来双亲委派的逻辑：</p>
<ol>
<li>先检查请求加载的类型是否已经被加载过<ol>
<li>若没有则调用父加载器的 <code>loadClass()</code>方法</li>
<li>若父加载器为空（找到顶了）则默认使用启动类加载器作为父加载器</li>
</ol>
</li>
<li>假如父类加载器加载失败， 抛出<code>ClassNotFoundException</code>异常的话，才调用自己的<code>findClass()</code>方法尝试进行加载</li>
</ol>
</li>
</ul>
<p>举个例子来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大家所熟知的Object类，直接告诉大家，Object默认情况下是启动类加载器进行加载的。假设我也自定义一个Object，并且制定加载器为自定义加载器。现在你会发现自定义的Object可以正常编译，但是永远无法被加载运行。</span><br><span class="line">这是因为申请自定义Object加载时，总是启动类加载器，而不是自定义加载器，也不会是其他的加载器。</span><br></pre></td></tr></table></figure>



<p>这样做有什么好处呢？</p>
<ol>
<li>避免类的重复加载。一旦一个类被父类加载器加载之后，就不会再被委派给子类进行加载。</li>
<li>保护程序安全，可以防止核心API被随意篡改</li>
</ol>
<ul>
<li><strong>沙箱安全机制</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang; <span class="comment">// 包命名为java.lang</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行main函数，需要加载Start，根据双亲委派机制，加载请求会被向上委派到引导类加载器（记住第1小节的工作原理图）；</p>
<p>引导类加载器一看，包是java.lang，所以是由它来进行加载。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415211657918.png" alt="image-20210415211657918"></p>
<p>但这个lang包已经在base包中被加载过了，因此会直接报错.</p>
<p>从这点我们体现出了沙箱安全机制作用：保护核心类，防止打破双亲委派机制，防篡改，如果重名的话就报异常，这里的重名指包名加类名都重复</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><h5 id="重写loadClass-方法破坏双亲委派模型"><a href="#重写loadClass-方法破坏双亲委派模型" class="headerlink" title="重写loadClass()方法破坏双亲委派模型"></a>重写loadClass()方法破坏双亲委派模型</h5><p>现在有个类 A</p>
<p>我们希望通过自定义加载器 直接从某个路径下读取A.class . 而不是说 通过自定义加载器 委托给 AppClassLoader ——&gt; ExtClassLoader —-&gt; BootClassLoader 这么走一遍，都没有的话，才让自定义加载器去加载 A.class . 这么一来 还是 双亲委派。</p>
<p>我们期望的是 A.class 及时在 AppClassLoader 中存在，也不要从<code>AppClassLoader</code> 去加载。</p>
<p>说白了，就是 直接让自定义加载器去直接加载A.class 而不让它取委托父加载器去加载，不要去走双亲委派那一套。</p>
<p>我们知道 双亲委派的机制是在<code>ClassLoader # loadClass</code>方法中实现的，打破双亲委派，那我们是不是可以考虑从这个地方下手呢？</p>
<p>因此我们就知道了，打破双亲委派方法是通过 —— 重写<code>ClassLoader # loadClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="comment">//自己的类路径下的对象走我自己的classLoader</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;com.xxx.xxx.Test&quot;</span>.equals(name)) &#123;</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 交由父加载器去加载</span></span><br><span class="line">                    c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h5><ul>
<li>这个类加载器能够通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。</li>
</ul>
<p>JNDI服务（是Java的标准服务）使用这个线程上下文类加载器去加载所需的SPI服务（即接口，Service Provider Interface，SPI）代码，这是一种父类加载器去请求子类加载器完成类加载的行为。按照之前所学的，这肯定是违背双亲委派模型的一般性原则。（留了个后门）</p>
<ul>
<li>应用</li>
</ul>
<p>在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，解决SPI的加载问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统加载方式 1</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统加载方式 2</span></span><br><span class="line">System.setProperty(<span class="string">&quot;jdbc.drivers&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPI加载方式</span></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>SPI加载机制中，不需要手动设置驱动为com.mysql.jdbc.Driver。</p>
<p>spi服务的模式原本过程</p>
<ol>
<li>从META-INF/services/java.sql.Driver文件中获取具体的实现类名：”com.mysql.jdbc.Driver”</li>
<li>加载这个类（使用<code>class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415220215431.png" alt="image-20210415220215431"></p>
<p>使用了这个线程上下文后，mysql的驱动加载过程：</p>
<ol>
<li>从META-INF/services/java.sql.Driver文件中获取具体的实现类名：”com.mysql.jdbc.Driver”</li>
<li>加载这个类（使用<code>class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></li>
<li>使用线程上下文类加载器去加载Driver类，使得父级加载器可以加载子级类加载器路径中的类</li>
</ol>
<h1 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h1><p>Java技术中的编译器有多个过程：</p>
<ol>
<li>前端编译器（叫“编译器的前端”更准确一些）把<em>.java文件转变成</em>.class文件的过程</li>
<li>指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程</li>
<li>使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程 序编译成与目标机器指令集相关的二进制代码的过程</li>
</ol>
<p>对应这三类编译过程的三类比较有代表性的编译产品分别为：</p>
<ol>
<li><mark>前端编译器</mark>：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
<li><mark>即时编译器</mark>：HotSpot虚拟机的C1、C2编译器，Graal编译器</li>
<li><mark>提前编译器</mark>：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ol>
<h3 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h3><h4 id="编译期处理-语法糖"><a href="#编译期处理-语法糖" class="headerlink" title="编译期处理 - 语法糖"></a>编译期处理 - 语法糖</h4><h5 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>编译成class后的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123; </span><br><span class="line">	<span class="comment">// 这个无参构造是编译器帮助我们加上的 </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V </span></span><br><span class="line">		&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h5><p>基本类型和其包装类型的相互转换过程，称为<strong>拆装箱</strong></p>
<p>在<strong>JDK 5</strong>以后，它们的转换可以在编译期自动完成（也就是说第一段代码在JDK 5前无法编译通过，而第二段可以）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Integer x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实质的转换过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以明显看出来第二段代码比第一段代码麻烦很多，因此JVM提供了这么个糖给我们吃，省去不少麻烦</p>
<h5 id="【泛型-泛型擦除】"><a href="#【泛型-泛型擦除】" class="headerlink" title="【泛型  - 泛型擦除】"></a>【泛型  - 泛型擦除】</h5><ul>
<li>重点</li>
</ul>
<p>Java选择的泛型实现方式叫作<mark>“类型擦除式泛型”（Type Erasure Generics）</mark>,与之对应的是c#的<mark>是“具现化式泛型”（Reified Generics）</mark></p>
<p>（具现化和特化、偏特化这些名词最初都是源于C++模版语 法中的概念）</p>
<p>区别：</p>
<ol>
<li><p>道C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，<strong>List&lt; int &gt;与 List&lt; string &gt;</strong>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换 为原来的<strong>裸类型（Raw Type，</strong>稍后我们会讲解裸类型具体是什么）了，并且在相应的地方插入了<strong>强制转型代码</strong>。due to that,对于处在运行期的Java语言来说的话，<strong>List&lt; int &gt;与 List&lt; string &gt;</strong>其实是同一个类型的。</p>
<p>这也是 类型擦除中的擦除的含义</p>
</li>
</ol>
<p>上面都是一些概念类型的知识，下面用实例代码来体验一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  	List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"> 	  list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e) </span></span><br><span class="line"> 	  Integer x = list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index); </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> cn.itcast.jvm.t3.candy.Candy();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/itcast/jvm/t3/candy/Candy3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; </span><br><span class="line">	descriptor: ([Ljava/lang/String;)V </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC </span><br><span class="line">  Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span> </span><br><span class="line">       -------<span class="keyword">new</span> ArrayList对象----------         </span><br><span class="line">       0: new #2   // class java/util/ArrayList </span><br><span class="line">       <span class="number">3</span>: dup </span><br><span class="line">       4: invokespecial #3 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">       <span class="number">7</span>: astore_1 </span><br><span class="line">                </span><br><span class="line">       <span class="number">8</span>: aload_1 </span><br><span class="line">       <span class="number">9</span>: bipush <span class="number">10</span> </span><br><span class="line">       11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; </span><br><span class="line">       <span class="comment">//add方法的参数类型实际是Object类型</span></span><br><span class="line">       14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z </span><br><span class="line">       <span class="number">19</span>: pop </span><br><span class="line">       <span class="number">20</span>: aload_1 </span><br><span class="line">       <span class="number">21</span>: iconst_0 </span><br><span class="line">       <span class="comment">//get方法的参数类型实际是Object类型</span></span><br><span class="line">       22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; </span><br><span class="line">       <span class="comment">//	强制类型转换         </span></span><br><span class="line">       27: checkcast #7 // class java/lang/Integer </span><br><span class="line">       <span class="number">30</span>: astore_2 </span><br><span class="line">       <span class="number">31</span>: <span class="keyword">return</span> </span><br><span class="line">       LineNumberTable:</span><br><span class="line">					line <span class="number">8</span>: <span class="number">0</span> </span><br><span class="line">          line <span class="number">9</span>: <span class="number">8</span> </span><br><span class="line">          line <span class="number">10</span>: <span class="number">20</span> </span><br><span class="line">          line <span class="number">11</span>: <span class="number">31</span> </span><br><span class="line">       LocalVariableTable:</span><br><span class="line">			  	Start Length Slot Name    Signature</span><br><span class="line">              <span class="number">0</span>   <span class="number">32</span>    <span class="number">0</span>   args      [Ljava/lang/String; </span><br><span class="line">              <span class="number">8</span>   <span class="number">24</span>    <span class="number">1</span>   list      Ljava/util/List;</span><br><span class="line">       LocalVariableTypeTable:</span><br><span class="line">					Start Length  Slot   Signature</span><br><span class="line">					    <span class="number">8</span>   <span class="number">24</span>     <span class="number">1</span>      Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>list.add 和 get 方法在bycecode层面上的参数类型都是Object类型，最后会执行checkcast指令进行类型转换为真实类型</li>
</ul>
<p>上面我们提及了，泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p>
<p>既然现在是Object类型的，而我们想去的值为Integer类型，就必须进行一次类型转换操作（在编译器真正生成字节码的过程中进行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer </span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>若x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作 </span></span><br><span class="line"><span class="keyword">int</span> x = ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure>



<ul>
<li><p>类型擦除把字节码上泛型信息（方法体内泛型信息）擦除了，但在<strong>LocalVariableTypeTable（局部变量类型表）</strong>保留了方法参数泛型信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  LocalVariableTypeTable:</span><br><span class="line">Start Length  Slot   Signature</span><br><span class="line">    <span class="number">8</span>   <span class="number">24</span>     <span class="number">1</span>      Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>虽然这个信息被保留了，但无法通过反射去获得</p>
<p>只有方法参数和返回值上带泛型信息，才能通过反射获取泛型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Method test = Candy3.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">        Type[] types = test.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="comment">//判断是不是参数化泛型类型</span></span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">                <span class="comment">//getActualTypeArguments()获取到的是&lt;&gt;中的参数</span></span><br><span class="line">                Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始类型 - interface java.util.List </span><br><span class="line">泛型参数[0] - class java.lang.String </span><br><span class="line">原始类型 - interface java.util.Map </span><br><span class="line">泛型参数[0] - class java.lang.Integer </span><br><span class="line">泛型参数[1] - class java.lang.Object</span><br></pre></td></tr></table></figure>



<h5 id="可变参数（变长参数）"><a href="#可变参数（变长参数）" class="headerlink" title="可变参数（变长参数）"></a>可变参数（变长参数）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String str : args)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>print(String... strs)</code> 中的 … 表示参数个数是可以不定的</p>
<p>上述代码 本质：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Varargs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="keyword">int</span> var2 = args.length;</span><br><span class="line">        <span class="comment">//增强for循环的数组实现方式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            String str = var1[var3];</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//变长参数转换为数组</span></span><br><span class="line">        print(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述代码来说，编译器会帮助我们转换为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是集合去使用了foreach的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其本质就是使用了<strong>迭代器Iterator</strong></p>
<p>因此，能够使用foreach去遍历的集合一定是实现了<strong>Iterator</strong>接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">//获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器实质进行的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Demo6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//通过字符串的hashCode+value来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">//hello的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">//再次比较，因为字符串的hashCode有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">//world的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用第二个switch在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从第二份代码我们可以看出，一个switch操作其实是由两个switch配合完成的</p>
<ol>
<li>第一个用来<strong>匹配字符串</strong>，并给x赋值，x才是最后用来决定走哪个方法的<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突</li>
</ul>
</li>
<li>使用第一步确定的x去决定输出</li>
</ol>
<h5 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">         <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="comment">//将对应位置枚举元素的值赋给x，用于case操作</span></span><br><span class="line">      <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">//对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    	<span class="comment">//调用构造函数，传入枚举元素的值及ordinal</span></span><br><span class="line">    	MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   <span class="comment">//调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Demo8$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个额外的类，实现了Runnable接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如匿名内部类中引用了<mark>局部变量</mark>的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">//多创建了一个变量</span></span><br><span class="line">   <span class="keyword">int</span> val$x;</span><br><span class="line">   <span class="comment">//变为了有参构造器</span></span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h3><h4 id="前期知识储备（JVM-java编译器-java解释器）"><a href="#前期知识储备（JVM-java编译器-java解释器）" class="headerlink" title="前期知识储备（JVM java编译器 java解释器）"></a>前期知识储备（JVM java编译器 java解释器）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Ij2UZf.png" alt="img"></p>
<p><strong>JVM：</strong>JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。</p>
<p><strong>JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行</strong>。</p>
<p>JVM解释执行字节码文件：就是<strong>JVM操作Java解释器，将字节码翻译成机器码，然后执行的过程</strong></p>
<p><strong>Java编译器：</strong>将<mark>Java源文件（.java文件）</mark>编译成<mark>字节码文件</mark>（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的<strong>“机器语言”</strong>。 <strong>javac.exe</strong>可以简单看成是Java编译器。</p>
<p><strong>Java解释器：</strong>是JVM的一部分，用来解释执行Java编译器编译后的程序，即将<strong>字节码</strong>解释为<strong>机器码</strong>。<strong>java.exe</strong>可以简单看成是Java解释器。</p>
<p><em>注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！</em></p>
<p>个人理解：</p>
<p>解释器，翻译一点执行一点；</p>
<p>编译器是将源代码翻译成平台能理解的目标语言，然后交由平台直接执行。</p>
<h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="img"></p>
<p>程序语言 → 字节码 → 指令集。</p>
<p>运行java程序的过程是先用javac编译，然后用java解释。而一经编译成功后，就可以直接用java.exe随处解释运行了。</p>
<ul>
<li>前端编译器（编译器的前端）：<strong>主要是把*.java文件转变成*.class文件（特殊的二进制字节码文件）</strong></li>
<li>后端编译器<ul>
<li>JIT编译器（即时编译器）：字节码转化为本地机器代码</li>
<li>AOT编译器（提前编译器）：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码</li>
</ul>
</li>
<li>解释执行与编译执行<ul>
<li><mark>解释执行</mark>：需要执行什么代码，才对对应的源码进行翻译，将其变为机器码，因此也提高了启动时效率；<ul>
<li>优点：可以大大提高程序启动时的效率</li>
</ul>
</li>
<li><mark>编译执行</mark>：将中间代码（字节码）全部编译成了与机器相关的本地代码，并且在这一阶段，有些编译器还会对编译后的代码进行初步的优化，这也使得效率更加的优秀<ul>
<li>优点：可以获得更高的执行效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="即时编译器-JIT"><a href="#即时编译器-JIT" class="headerlink" title="即时编译器 JIT"></a>即时编译器 JIT</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>概念：是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损</p>
</li>
<li><p>作用：改善虚拟机的性能</p>
</li>
<li><p>原本Java程序：经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢</p>
</li>
<li><p>引入了JIT后：在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用</p>
</li>
</ul>
<p>而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。</p>
<p>（虚拟机将这些运行频繁的方法/代码块认定为:<strong>热点代码</strong>）</p>
<p>它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。</p>
<h5 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h5><p>上面我们提到了“热点代码”这个概念，即频繁执行的代码块，那么JVM如何进行热点代码的判断呢？</p>
<ul>
<li><strong>基于采样</strong>：周期性的检查栈顶，如果一段代码频繁出现在栈帧顶部，那么就判断其是热点代码。<ul>
<li>优点：实现简单，快；</li>
<li>缺点：探测很容易收到线程阻塞的影响。例如一个方法因为线程阻塞，一直在栈顶，但其实其执行次数并不多，那么将其判定为热点代码就是不合理的。</li>
</ul>
</li>
<li><strong>基于计数器</strong>：为每个方法甚至是代码块建立计数器来统计执行次数，如果统计的次数达到了一定的条件则说明是热点代码<ul>
<li>优点：结果精确</li>
<li>缺点：实现就比较麻烦了，需要维护计数器</li>
</ul>
</li>
</ul>
<p>HotSpot 中采取的是第二种方案，因为频繁执行的代码有如下两种：</p>
<ul>
<li>方法的频繁执行</li>
<li>一段代码的频繁执行</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163733386.png" alt="image-20210417163733386"></p>
<h6 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h6><ul>
<li>回边计数器，它的作用是统计一个方法中循环体代码执行的次数[3]，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，很显然建立回边计数 器统计的目的是为了触发栈上的替换编译。</li>
</ul>
<p>工作流程：</p>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有 的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回 边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163939413.png" alt="image-20210417163939413"></p>
<h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h5><p>HotSpot 中的即时编译器有两种，分别称为 Client Complier客户端编译器 和 Server Complier服务端编译器，或者简称为 C1 和 C2，目前虚拟机一般采用解释器和一个即时编译器直接配合的方式来运行，这种模式称之为 <strong>混合模式</strong>。</p>
<p>既然是两者合作，那么久需要考虑一个调度的问题，即何时使用编译执行，何时采用解释执行，多少的比例可以获得最佳平衡，得到最高的效率。</p>
<p>在 HotSpot 中是通过 <strong>分层编译</strong> 的策略来达到最优解的。其本质的思想如下所示：</p>
<ul>
<li>第0层：程序解释执行，解释器不开启性能监控（Profiling），触发第一层；</li>
<li>第1层：C1 编译，将<strong>字节码</strong>编译为<strong>本地代码</strong>，进行简单、可靠的优化，不开启性能监控</li>
<li>第2层：C1编译，仅开启方法及回边次数统计等有限的性能监控功能</li>
<li>第3层：C1编译，，开启全部性能监控，除了第2层的统计信息外，还会收集如 分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层层：C2 编译，也是将<strong>字节码</strong>编译为<strong>本地代码</strong>，但其会启动一些耗时较长的<mark>优化</mark>，甚至会根据监控的信息采取一些激进（不可靠）的优化措施。</li>
</ul>
<p>这种分层编译的方式可以达到一定情况的最优解：用 C1 获取更快的<strong>编译速度</strong>，用 C2 获取更好的<strong>编译质量</strong>，解释执行的时候也无需增加性能监控的任务，反而拖累了启动效率。</p>
<h4 id="提前编译器-AOT"><a href="#提前编译器-AOT" class="headerlink" title="提前编译器 AOT"></a>提前编译器 AOT</h4><ul>
<li>AOT 编译器的<strong>基本思想</strong>是：在程序执行<strong>前</strong>生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。</li>
</ul>
<p>但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。</p>
<p>总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。</p>
<p>在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。</p>
<p>所以说，<strong>AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略</strong>。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。</p>
<h4 id="编译器总结"><a href="#编译器总结" class="headerlink" title="编译器总结"></a>编译器总结</h4><p>在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。</p>
<p>前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。而 AOT 编译器则能将源代码直接编译为本地机器码。这三种编译器的编译速度和编译质量如下：</p>
<ul>
<li>编译速度上，解释执行 &gt; AOT 编译器 &gt; JIT 编译器。</li>
<li>编译质量上，JIT 编译器 &gt; AOT 编译器 &gt; 解释执行。</li>
</ul>
<p>而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。</p>
<h4 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h4><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<ul>
<li><strong>JVM内联函数</strong></li>
</ul>
<p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// to do something  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123; </span><br><span class="line">		&#x2F;&#x2F;这里调用了add2方法</span><br><span class="line">        return add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private int add2(int x1, int x2) &#123;  </span><br><span class="line">        return x1 + x2;  </span><br><span class="line">    &#125;Copy</span><br></pre></td></tr></table></figure>

<p>方法调用被替换后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;  </span><br><span class="line">    	<span class="comment">//被替换为了方法本身</span></span><br><span class="line">        <span class="keyword">return</span> x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是将小段代码，直接复制到调用的方法里面，不去真实的进行方法调用</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><ul>
<li>方法逃逸：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部 方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸</li>
<li>线程逃逸：甚至还有可能被外部线程访 问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸</li>
</ul>
<p>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度</p>
<p>按照逃逸程度的高低，为对象的实例采取不同程度的优化，就是逃逸分析的优化基本原理。</p>
<h6 id="优化办法"><a href="#优化办法" class="headerlink" title="优化办法"></a>优化办法</h6><ul>
<li><p><strong>栈上分配（Stack Allocations）</strong>：我们知道，对象的分配是在<strong>堆</strong>上进行，而，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引 用，就可以访问到堆中存储的对象数据。在GC的时候：标记、回收、整理都要耗费大量资源。如果确定一个对 象不会逃逸出线程之外，那让这个对象在<strong>栈上分配内存</strong>岂不是很好？对象所占用的内存空间就可以随栈帧出栈而销毁。</p>
</li>
<li><p><strong>标量替换（Scalar Replacement）</strong>：</p>
<ul>
<li>标量：无法再分解为更小数据的数据，例如 JVM 中的原始数据类型（int、long、reference 等）。</li>
<li>聚合量：可以继续分解的数据，例如 Java 中的对象。</li>
</ul>
<p>所谓「标量替换（Scalar Replacement）」，就是根据实际访问情况，将一个对象“拆解”开，把用到的成员变量恢复为原始类型来访问。</p>
<p>简单来说，就是把聚合量替换为标量。</p>
<p>若一个对象不会逃逸出「方法」，且可以被拆散，那么程序真正执行时就可能不去创建这个对象，而是直接创建它的若干个被该方法使用的成员变量代替。将对象拆分后，除了可以让对象的成员变量在栈上 （栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件</p>
<p>（标量替换可以视作栈上分配的一种特例）</p>
</li>
<li><p>同步消除（Synchronization Elimination）：线程同步本身相对耗时，如果逃逸分析能够确定一个变量不会逃逸出线程，则该变量的读写就不会有线程安全问题，对该变量的同步措施就可以安全的消除了。</p>
<p>换句话说，如果对线程安全的数据（不会逃逸出该线程的数据）加了锁，JVM 就可以把它优化消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量 o 不会逃逸出线程。因此，对它加的锁就可以被消除</span></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h6><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全未优化的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">Point p = <span class="keyword">new</span> Point(xx, <span class="number">42</span>);</span><br><span class="line"><span class="keyword">return</span> p.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将Point的构造函数和getX()方法进行内联优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：构造函数内联后的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">	Point p = point_memory_alloc(); <span class="comment">// 在堆中分配P对象的示意方法</span></span><br><span class="line">	p.x = xx; <span class="comment">// Point构造函数被内联后的样子</span></span><br><span class="line">	p.y = <span class="number">42</span></span><br><span class="line">	<span class="keyword">return</span> p.x; <span class="comment">// Point::getX()被内联后的样子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸， 这样可以对它进行标量替换优化，把其内部的x和y直接置换出来，分解为test()方法内的局部变量，从 而避免Point对象实例被实际创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ 步骤<span class="number">2</span>：标量替换后的样子</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> px = xx;</span><br><span class="line">	<span class="keyword">int</span> py = <span class="number">42</span></span><br><span class="line">	<span class="keyword">return</span> px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效 代码消除得到最终优化结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤3：做无效代码消除后的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h5><p>所谓公共子表达式，就是当有一个表达式 E 在以前被计算过，而且下次再遇到的时候 E 的所有变量都未改变，则这次 E 的出现就被称为「公共子表达式」。就像学习DP的时候，记忆集的概念。</p>
<p>根据作用域，公共子表达式的消除可分为两种：<strong>局部公共子表达式消除和全局公共子表达式消除</strong>。</p>
<ol>
<li>局部公共子表达式消除：优化仅限于程序基本块内</li>
<li>全局公共子表达式消除：优化的范围涵盖了多个基本块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> d = (c * b) * <span class="number">12</span> + a + (a + b * c);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码产生的字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  public int t1();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;4, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         # ...</span><br><span class="line">         6: iload_3</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: imul    # 计算 b*c</span><br><span class="line">         9: bipush        12</span><br><span class="line">        11: imul    # 计算 (c * b) * 12</span><br><span class="line">        12: iload_1</span><br><span class="line">        13: iadd    # 计算 (c * b) * 12 + a</span><br><span class="line">        14: iload_1</span><br><span class="line">        15: iload_2</span><br><span class="line">        16: iload_3</span><br><span class="line">        17: imul    # 计算 b*c</span><br><span class="line">        18: iadd    # 计算 (a + b * c)</span><br><span class="line">        19: iadd    # 计算 (c * b) * 12 + a + (a + b * c)</span><br><span class="line">        20: istore        4</span><br><span class="line">        22: iload         4</span><br><span class="line">        24: ireturn</span><br><span class="line">        # ...</span><br></pre></td></tr></table></figure>

<p>而相同的这段代码，进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c<em>b与b</em>c是一样的表达 式，而且在计算期间b与c的值是不变的</p>
<p>因此这条表达式就可能被视为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>

<p>此时，编译器还可能进行代数化简（Algebraic Simplification）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>



<h5 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h5><p>在遍历数组的时候：必须满足<code>i &gt;= 0 &amp;&amp; i &lt; arr.length</code>，否则就抛出异常：<code>java.lang.ArrayIndexOutOfBoundsException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// 数组越界</span></span><br><span class="line">  String s = array[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全起见，数组边界检查这件事是一定要做的，但是<strong>数组边界检查</strong>是不是一定得在运行期间发生就是不一定的了。</p>
<p>如果编译器只 要通过数据流分析（前端编译）就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可 以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><ul>
<li><p>JVM内存模型定义的是线程堆栈和堆之间的内存划分，它和Java内存模型是有区别的，参照《深入理解Java虚拟机》中的解释：</p>
<blockquote>
<p>这两者本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就是物理内存，而为了获取更好的执行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为运行时主要访问——读写的是工作内存。</p>
</blockquote>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/368583-20180711114821287-381545002.png" alt="img"></p>
<p>(Java内存模型JMM的相关知识，将在java并发部分进行学习)</p>
<h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><p>参考博客、书籍和视频：</p>
<ol>
<li><p>博客</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ace2aa692f96">https://www.jianshu.com/p/ace2aa692f96</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/103653184">https://blog.csdn.net/qq_34337272/article/details/103653184</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shan1393/p/8996954.html">https://www.cnblogs.com/shan1393/p/8996954.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38075425/article/details/81627349">https://blog.csdn.net/m0_38075425/article/details/81627349</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/looyee/articles/13954722.html">https://www.cnblogs.com/looyee/articles/13954722.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JRookie/p/11431784.html">https://www.cnblogs.com/JRookie/p/11431784.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jqhtml.com/49135.html">https://www.jqhtml.com/49135.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sword03/archive/2010/06/27/1766147.html">https://www.cnblogs.com/sword03/archive/2010/06/27/1766147.html</a></li>
</ul>
</li>
<li><p>书籍</p>
<ul>
<li>《深入理解JVM虚拟机》</li>
</ul>
</li>
<li><p>视频</p>
<ul>
<li>黑马程序员JVM</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/29/JVM/" data-id="ckppikuf50049p0widp58b2iu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java并发
        
      </div>
    </a>
  
  
    <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SpringBoot</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>