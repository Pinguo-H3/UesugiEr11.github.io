<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发 | Erii B1og</title><meta name="author" content="Erii"><meta name="copyright" content="Erii"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="关于java并发的一些">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="http://uesugier11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="关于java并发的一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png">
<meta property="article:published_time" content="2021-04-22T14:26:11.873Z">
<meta property="article:modified_time" content="2021-06-06T11:44:19.486Z">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png"><link rel="shortcut icon" href="/UesugiEr11.github.io/img/favicon.png"><link rel="canonical" href="http://uesugier11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/UesugiEr11.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/UesugiEr11.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-06 19:44:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/UesugiEr11.github.io/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/categories/"><div class="headline">分类</div><div class="length-num">72</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/UesugiEr11.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/UesugiEr11.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/UesugiEr11.github.io/">Erii B1og</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/UesugiEr11.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/UesugiEr11.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Java并发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-22T14:26:11.873Z" title="发表于 2021-04-22 22:26:11">2021-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-06T11:44:19.486Z" title="更新于 2021-06-06 19:44:19">2021-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">68.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>244分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>想要学习并发，必须首先对线程有一定的知识基础，因此强烈建议先复习一下这部分知识：</p>
<hr>
<p>在Java基础笔记中，对于Java线程有一定的说明：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E7%BA%BF%E7%A8%8B</a></p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B</a></p>
<hr>
<p>如果想在OS层面学习进程线程，在OS笔记中，对这部分有一定的说明：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B</a></p>
<p>对于进程的调度，死锁的相关知识：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81</a></p>
<h2 id="Java并发-核心理论"><a href="#Java并发-核心理论" class="headerlink" title="Java并发 - 核心理论"></a>Java并发 - 核心理论</h2><ul>
<li>Java异步核心原理分为五个基本性质：共享性、互斥性、原子性、可见性、有序性</li>
</ul>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>如果所有数据都是线程私有的，那编程的时候就无须考虑并发的情况了 —— 因为无论怎么操作，数据都可以保证正确，不会被其他线程访问。因此，数据具有共享性，是线程安全得不到保证的主要原因之一。那如何保证线程安全（数据一致性）呢，就得引入进程同步。</p>
<h3 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h3><p>操作系统中，关于进程互斥：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5</a></p>
<p>资源互斥是指同时只允许一个访问者对其进行访问，具有<mark>唯一性</mark>和<mark>排它性</mark>。</p>
<p>对于数据，我们可以进行读（查看）和写（修改）的操作，则我们应该对执行读写操作的线程分别有不同的限制，因此衍生了两种<strong>锁</strong></p>
<ul>
<li><p><strong>共享锁（读锁/S锁）</strong>：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
</li>
<li><p><strong>排它锁（写锁/X锁）</strong>：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</p>
<p>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>
</li>
</ul>
<p>Java中的保证数据安全性，实现互斥的方法有许多（比如synchronized，类似于操作系统中的管程机制）</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>操作系统中与原子性关系最贴切的应该是<strong>原语</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8E%9F%E8%AF%AD">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8E%9F%E8%AF%AD</a></p>
<p>原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改；</p>
<p>列举个例子来体现<strong>原子性</strong>：<code>i++</code> 这个操作，1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。</p>
<p>但却可能在多线程场景发生以下情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160410215649812-831081790.png" alt="img"></p>
<p>保证原子性（即不会被其他操作打断）的方法可以通过<strong>上锁</strong>去实现：<code>Synchronized或Lock</code>，或者是使用<code>CAS</code>：修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行（乐观锁）。但CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>关于可见性问题的解释：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430">https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430</a></p>
<ul>
<li>可见性：一个线程对共享变量的修改，更够及时的被其他线程看到</li>
</ul>
<p>可见性概念建立在JVM的内存模型上：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160412075618645-61482019.png" alt="img"></p>
<p>在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用synchronzied进行同步的时候，真正被同步的是在不同线程中表示被锁定对象的内存块（副本数据会保持和主内存的<strong>同步</strong>）</p>
<p>简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的</p>
<p>但有可能会出现这么一个问题：假如主内存的更新（通知）不及时，会导致一个线程A明明更新了数据，但线程B得到的还是原来的数据的问题。</p>
<p>解决这个问题可以使用：<code>volatile</code>和<code>synchronized</code>关键字进行解决。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性部分与进程的前驱问题有点类似：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB</a></p>
<p>为了提高性能，编译器和处理器可能会对指令做<strong>重排序</strong>，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<a href="#重排序">重排序相关内容</a></p>
<p>Java 中也可通过<code>Synchronized</code>或·<code>Volatile</code>来保证顺序性。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1190710-20181026151558231-206612292.png" alt="img"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存模型通过限制处理器优化和使用内存屏障，来保证共享内存的正确性<strong>（可见性、有序性、原子性）</strong></p>
<p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>JMM还通过<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等实现原子性、有序性、可见性。</p>
<p>而由于进程之间进行通信，数据进行同步，都依靠这个JMM。因此学习它就显得尤为重要了。</p>
<p>关于进程通信：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1</a></p>
<p>关于进程同步：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1</a></p>
<h2 id="并发编程模型基础"><a href="#并发编程模型基础" class="headerlink" title="并发编程模型基础"></a>并发编程模型基础</h2><p>在并发编程中，需要了解并会处理这两个关键问题：</p>
<h3 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a>线程之间如何通信</h3><p> 　<strong>通信是指线程之间以何种机制来交换信息</strong>。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存和消息传递</strong>。</p>
<p>　　a) 在<strong>共享内存</strong>的并发模型里，<strong>线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。（重点）</strong></p>
<p>　　b) 在<strong>消息传递</strong>的并发模型里，<strong>线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</strong></p>
<h3 id="线程之间如何同步"><a href="#线程之间如何同步" class="headerlink" title="线程之间如何同步"></a>线程之间如何同步</h3><p>　　<strong>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</strong></p>
<p>　　<strong>在共享内存的并发模型里，同步是显示进行的</strong>。因为程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>
<p>　　<strong>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</strong></p>
<p>　　知道并了解上面两个问题后，对java内存模型的了解，就打下了基础。因为Java的并发模型采用的是共享内存模型，java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h2 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/368583-20180711114747052-1472383817.png" alt="img"></p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>如图：硬件内存模型由<strong>CPU - 缓存 - 主存储</strong>三层结构组成</p>
<p>现代计算机通常有2个或以上的CPU，单个CPU可能有多个内核。每个CPU内核中都包含一组寄存器，CPU在寄存器中执行操作比在计算机主存储器中快的多</p>
<p>每个CPU之上还存在高速缓存，但高速缓存的层级和位置是不固定的，缓存的位置也各有不同，有的集成了部分缓存到CPU中。 同样，缓存的读写速度也大大快于计算机主存储器。</p>
<ul>
<li><strong>什么时候需要用到缓存呢？</strong></li>
</ul>
<p>CPU在程序的执行过程中，经常会频繁的调用相同的数据，比如在一个循环内调用了位于另外一个物理地址的函数，这个函数可能与当前指令的物理位置相距甚远，因为程序使用的物理内存并不是连续的，这就导致了需要花费很多不必要的时间在物理寻址上。但如果在CPU计算之前会将所需要用到的数据先读到缓存中，计算完成之后再一次性写入计算机主存储器，就可以避免频繁访问计算机主存储器造成的资源浪费。</p>
<h2 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h2><p>在Java中，所有<strong>实例域、静态域和数组元素</strong>都存储在<mark>堆内存</mark>中， 而堆内存在线程之间是共享的</p>
<p>而虚拟机栈（其中包括局部变量、方法参数定义等..）是线程私有的，不会在线程之间共享，所以它们不会有内存可见性的问题，也不受内存模型的影响。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1139681-20170911155342578-24594059.png" alt="img"></p>
<ul>
<li><p>线程与主内存间的抽象关系</p>
<ul>
<li><p>线程之间的共享变量存储在<strong>主内存（Main memory）</strong>中</p>
</li>
<li><p>每个线程都有一个私有的<strong>本地内存（local memory）</strong>或者说是<strong>工作内存（Working Memory）</strong>，本地内存中存储了该线程用以读/写共享变量的副本。</p>
<p>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过<strong>主内存</strong>来完成。</p>
</li>
<li><p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。线程对共享变量的操作并不会直接访问<strong>主内存</strong>，而是访问一个<strong>中间层</strong>，这个<strong>中间层</strong>包含了主内存中<mark>变量的拷贝</mark>，同时<strong>中间层</strong>的访问速度大大快于访问<strong>主内存</strong>的速度，在一定的操作之后将结果统一写回主内存，这样就大大提高了程序的性能</p>
<p>（同时也会产生另外一个问题，同一个共享变量在每一个线程之中都会有一份拷贝（对引用类型，并不是拷贝全部数据），产生的线程越多，缓存开销也就越大。）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>线程通信问题</li>
</ul>
<p>上图中,线程A与B想要进行通信（数据交互）的话，要经历：</p>
<ol>
<li>线程A把<mark>本地内存A</mark>中更新过的共享变量刷新到<mark><strong>主内存</strong></mark>中去。</li>
<li>线程B到<mark><strong>主内存</strong></mark>中去读取线程A之前已更新过的共享变量，接着复制一份到<mark>本地内存B</mark>中</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/690169-20180703125802114-1801798430.png" alt="img"></p>
<p>假设初始时，这三个内存中x的值都为0，线程A在执行时，把更新后的x值临时放在本地内存。当线程A与线程B需要通信时，</p>
<p>　　步骤1：线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。</p>
<p>　　步骤2：线程B到主内存中读取线程A更新后的X值，此时线程B的本地内存x的值也变为了1。</p>
<p>　　从整体(不考虑重排序，按顺序执行)来看，这两个步骤实质上是**线程A在向线程B发送消息，而</p>
<p>从整体(不考虑重排序，按顺序执行)来看，这两个步骤实质上是<strong>线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，提供内存可见性的保证。</strong></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul>
<li><strong>重排序分为三种</strong></li>
</ul>
<ol>
<li><mark>编译器优化的重排序</mark>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><mark>指令级并行的重排序</mark>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><Mark>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</Mark></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/690169-20180630231133468-875140136.png" alt="img"></p>
<ul>
<li><strong>为什么会发生重排序</strong></li>
</ul>
<p>为什么会重排序，上面这几个阶段里大概提到了，提高并行效率，编译器认为重排序后执行更优，指令级重排序并行效率更好等等。在单个线程的视角看来，重排序不存在任何问题，重排序不改变执行结果</p>
<p>对于语句：<code>int a = 1;int b = 2;int c = a + b;</code></p>
<p>首先需要明白：重排序的发生前提是具有<strong>数据依赖</strong>，什么意思呢？<code>int a = 1;int b = a;</code> b的数据依赖于a，那么这两个语句就不会被重排序，a一定会在b语句前执行；****</p>
<p>c因为对a和b有<strong>数据依赖</strong>，因此c不会被重排序，但是a 、b的执行可能被重排序。但在单个线程下，这种重排序不存在任何问题，不论先初始化a、还是先初始化b，c的值都是3</p>
<ul>
<li><strong>重排序带来的问题</strong></li>
</ul>
<p>然而重排序可能会导致多线程出现<strong>内存可见性的问题</strong>，比如：处理器在对内存进行读写操作未必与实际发生的内存读写顺序一致，导致重排序→引发了可见性问题（数据更新不及时）</p>
<p>在这我们不举例处理器的例子，我们还是以代码为例：</p>
<p>现在有两个线程</p>
<ol>
<li><p>线程T1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="comment">//共享变量</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">true</span>; <span class="comment">//共享变量 boolean b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程T2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b)&#123;</span><br><span class="line">	<span class="keyword">int</span> c = a;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们默认b的值是线程T2可读取的，假如b为<code>true</code>，c一定为1吗？（在并发环境中）</p>
<p>按照我们上面的学习，a与b是没有数据依赖关系的，因此运行的顺序的可以被重排序的。假如此时b先与a执行，虽然对T1没什么影响，但是对T2就不一样了。T2可能一直在进行这个if的测试，突然间发现b为true了，而a还没来得及被赋值呢，就进入了T2的if语句中，则此时的c就读不到a的值（1）了。</p>
<blockquote>
<p>当代码中存在控制依赖的时候，会影响指令序列执行的并行度。为此，编译器和处理器会采用<code>猜测执行</code>来克服控制相关性对并行度的影响。比如可以提前读取变量，计算，将计算结果临时保存起来，当条件为真的时候，把临时变量写入真的变量中。这个猜测执行其实就是对指令进行了重排序，此处的重排序是破坏了多线程程序的语义的。</p>
</blockquote>
<h2 id="happens-before-重点"><a href="#happens-before-重点" class="headerlink" title="happens-before - 重点"></a>happens-before - 重点</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/201812083001.png" alt="img"></p>
<ul>
<li><strong>JMM把happens- before要求禁止的重排序分为了下面两类：</strong></li>
</ul>
<ol>
<li><p><strong>会改变</strong>程序执行<strong>结果</strong>的重排序，JMM要求编译器和处理器<strong>必须禁止</strong>这种重排序。</p>
</li>
<li><p><strong>不会改变</strong>程序执行<strong>结果</strong>的重排序，JMM对编译器和处理器<strong>不作要求</strong>（JMM<strong>允许</strong>这种重排序）。</p>
<p>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。</p>
<p>比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。</p>
<p>再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。</p>
</li>
</ol>
<p><strong>这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</strong></p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li><strong>happens-before原则定义</strong></li>
</ul>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。 <a href="#可见性">关于可见性</a></li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ol>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li><strong>happens-before规则</strong></li>
</ul>
<ol>
<li><p><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<blockquote>
<p>一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对【单线程】有效，在【多线程】环境下无法保证正确性。</p>
</blockquote>
</li>
<li><p><strong>锁定规则</strong>：一个unLock操作<mark>先行发生</mark>于后面对同一个锁的Lock操作</p>
<blockquote>
<p>这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p>
</blockquote>
</li>
<li><p><strong>volatile变量规则</strong>：对一个volatile变量的<mark>写操作</mark>先行发生于后面（时间上）对这个变量的<mark>读操作</mark></p>
<blockquote>
<p>这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before(先行)于读操作的。</p>
</blockquote>
</li>
<li><p><strong>传递规则</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<blockquote>
<p>提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p>
</blockquote>
</li>
<li><p><strong>线程</strong></p>
<ol>
<li><p><strong>启动规则</strong>：Thread对象的<code>start()</code>方法先行发生于此线程的每个一个动作；</p>
<blockquote>
<p>假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p>
</blockquote>
</li>
<li><p><strong>中断规则</strong>：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
</li>
<li><p><strong>终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行；</p>
<blockquote>
<p>假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
</li>
</ol>
<p><mark>简单来说</mark> </p>
<blockquote>
<p>程序顺序规则： 对于单个线程中的每个操作，前继操作happens-before于该线程中的任意后续操作。<br>监视器锁规则： 对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则： 对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>传递性： 如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</blockquote>
<ul>
<li><strong>以上为原生Java满足Happens-before关系的规则，可引申推导出其他六条</strong>：</li>
</ul>
<ol>
<li>将一个元素<mark>放入</mark>一个线程安全的队列的操作Happens-Before从队列中<mark>取出</mark>这个元素的操作</li>
<li>将一个元素<mark>放入</mark>一个线程安全容器的操作Happens-Before从容器中<mark>取出</mark>这个元素的操作</li>
<li>在CountDownLatch上的<mark>倒数操作</mark>Happens-Before 于CountDownLatch<mark>#await()</mark>操作</li>
<li><mark>释放</mark>Semaphore许可的操作Happens-Before<mark>获得</mark>许可操作</li>
<li><strong>Future</strong>表示的<strong>任务的</strong><mark>所有操作</mark>Happens-Before Future<mark>#get()</mark>操作</li>
<li>向Execut<mark>提交</mark>一个Runnable或Callable的操作Happens-Before任务<mark>开始执行</mark>操作</li>
</ol>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>下面还是以书中的实例(计算圆的面积)进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;           <span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;            <span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;    <span class="comment">// C![]</span></span><br></pre></td></tr></table></figure>

<p>上面3个操作的数据依赖关系如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190227104137511.png" alt="img"></p>
<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面(因为C排到A和B的前面，程序的结果将会被改变)。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p>
<p>该程序的两种可能执行顺序：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190227104236982.png" alt="img"></p>
<blockquote>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。<br>as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><strong>jvm运行时刻内存的分配</strong></li>
</ul>
<hr>
<p><strong>前言：一定要注意！Java内存区域(运行时数据区 )<mark>不等于</mark>Java内存模型(JMM)</strong></p>
<p><strong>Java内存区域是指JVM运行时数据分区域存储，而Java内存模型是定义了线程和主内存之间的抽象关系！</strong></p>
<hr>
<p>根据[JMM](#JMM（Java Memory Model)我们可以知道线程与主内存之间还存在着一个<strong>本地内存（工作内存）</strong>，在这个内存中保存着变量的副本。</p>
<p>同样的，以类比的思想，jvm运行时刻内存的分配中，有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个<strong>线程栈</strong>。</p>
<blockquote>
<p>线程的工作内存与java的堆、栈并不是一个层次上的内存划分，如果非要类比的话工作内存对应虚拟机栈的部分区域 —— 《深入理解java虚拟机》</p>
</blockquote>
<p>线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存中的变量的具体值<code>load</code>到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/11172340-1b4ffc1abd6047798761edf5c5070ec1.jpg" alt="img"></p>
<ul>
<li><strong>问题引入</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest vt = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        vt.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        vt.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;stope&quot;</span> + vt.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行流程：</p>
<ol>
<li>首先创建 VolatileTest vt = new VolatileTest();</li>
<li>然后启动线程 vt.start();</li>
<li>暂停主线程2秒（Main） Thread.sleep(2000);</li>
<li>这时的vt线程已经开始执行，进行i++;</li>
<li>主线程暂停2秒结束以后将 vt.flag = true;</li>
<li>打印语句 System.out.println(“stope” + vt.i); 在此同时由于vt.flag被设置为true,所以vt线程在进行下一次while判断 while (!flag) 返回假 结束循环 vt线程方法结束退出！</li>
<li>主线程结束</li>
</ol>
<p>然而输出结果是：<code>stope1620137804</code>,并且程序不会退出。也就是说我们在主线程设置的 vt.flag = true;没有起作用</p>
<ul>
<li><strong>问题解决 理解</strong></li>
</ul>
<p>问题：主线程中设置<code>flag = true</code>,然而子线程并未获取到修改后的值，进行判断时的flag仍然为false。</p>
<p>需要结合<strong>jvm运行时刻内存的分配</strong>去理解</p>
<p><strong>子线程执行过程</strong></p>
<ol>
<li><p>首先子线程（vt线程）运行时，将*<em>变量 flag 与 i *</em>从 <mark>主内存</mark> 拷贝到 <mark>线程栈内存（即线程工作内存）</mark></p>
</li>
<li><p>接着执行while循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>while (!flag)</strong> 进行判断的flag 是在<mark>线程工作内存</mark>当中获取，而不是从 <mark>主内存 </mark>中获取。</p>
<p><strong>i++;</strong> 将<mark>线程工作内存</mark>中的i++; 加完以后将结果写回至 <mark>主内存</mark>，如此重复。</p>
</li>
</ol>
<p><strong>主线程执行过程</strong></p>
<ol>
<li><p>创建子线程</p>
</li>
<li><p>启动子线程</p>
</li>
<li><p>主线程sleep</p>
</li>
<li><p><code>vt.flag = true;</code>（重点）</p>
<ol>
<li>主线程将vt.flag的值从<mark>主内存</mark>中拷贝到自己的<mark>线程工作内存</mark></li>
<li>然后修改flag=true. </li>
<li>然后再将新值回到<mark>主内存</mark>。</li>
</ol>
<blockquote>
<p>这就解释了为什么在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false。那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！</p>
</blockquote>
</li>
</ol>
<p><strong>问题解决</strong></p>
<p>我们在上面主线程的第四步发现了问题了，是由于子线程的取值并不是在主内存中进行，而是在自己的工作内存中获取的，因此，要想解决这个问题也很简单：<strong>让vt线程每次判断flag的时候都强制它去主内存中取值</strong></p>
<p>这就是<strong>volatile关键字</strong>的作用：被加了这个关键字的数据，在被线程修改后，会从本地工作内存被强制的刷新回主内存，也就是让主内存中的变量值变成最新的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest vt = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        vt.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        vt.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;stope&quot;</span> + vt.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stope1662380642</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>程序能够正常退出了。</p>
<ul>
<li><strong>bonus</strong></li>
</ul>
<p>例子：现在让线程1去修改data为1，然而线程2由于可见性问题，并不能读取到变更后的data（也就是线程2读取到的data一直是工作内存中的data（即为0）。因此就需要使用<strong>volatile</strong>去解决了。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVqMXSxviaaZibG2aSGUTcWOJJ8X025g88RRicic9TDjfj5oic0TicUOU1Am0Sw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<p><strong>而volatile关键字除了能够让本地工作内存中的数据被强制的刷新回主内存外，还有着别的作用</strong></p>
<ol>
<li><p>如果此时别的线程的工作内存中有这个data变量的本地缓存，也就是一个变量副本的话，那么会强制让其他线程的工作内存中的data变量缓存直接失效过期，不允许再次读取和使用了</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVq3n1gLtNhBMfdEiaMic4icZcWVD95shDdwib3WKC4xge12SqdPapZJPOwxA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
</li>
<li><p>如果线程2在代码运行过程中再次需要读取data变量的值，此时尝试从本地工作内存中读取，就会发现这个data = 0已经过期了！</p>
<p>此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了！</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVqHCIS4F18UGeSroHvicdUKDf0XkWWmgfftENvjHMU9kP4bnkfQEQ2WDg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
</li>
</ol>
<ul>
<li><strong>总结</strong></li>
</ul>
<p><strong>volatile主要作用是保证可见性以及有序性。</strong></p>
<p>但是内存模型三大要素缺漏了一个：<strong>原子性</strong>，也就是说，volatile关键字并不能保证原子性</p>
<p>结合线程理解就是：</p>
<ol>
<li>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</li>
<li>多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题</li>
</ol>
<p>原子性的问题需要去结合<strong>锁机制</strong>去解决。</p>
<h1 id="Java并发机制底层实现"><a href="#Java并发机制底层实现" class="headerlink" title="Java并发机制底层实现"></a>Java并发机制底层实现</h1><ul>
<li>前言</li>
</ul>
<p>在OS学习中，我们学习了<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1">线程同步</a>的相关知识。</p>
<p>其中有一个<strong>临界区</strong>的概念</p>
<blockquote>
<p>临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。</p>
</blockquote>
<p>在OS中，我们使用了信号量、管程等方法去实现同步。现在学习了Java，就需要用Java中类似的机制去实现。</p>
<p>Java提供了同步机制。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区；如果已有线程进入了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入<strong>临界区</strong>的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。</p>
<h2 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h2><p>在前面<a href="#volatile">volatile</a> 部分中，学习了volatile的基本概念，但是没有去学习其底层实现，下面就来看看volatile是如何保证可见性与有序性的</p>
<h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515164459977.png" alt="image-20210515164459977"></p>
<p>如图所示，CPU中高速缓存内部结构是一个拉链散列表（与HashMap的底层结构以及原理十分相似）。它分为若干桶，每个桶是一个链表，包含若干缓存条目，每个缓存条目就是一个cache line（64 bytes）。</p>
<p>作用是什么呢？假设程序中读取某一个int变量，CPU并不是只从主存中读取4个字节，而是会一次性读取64个字节，然后放到cpu cache中。因为往往紧挨着的数据，更有可能在接下来会被使用到。</p>
<blockquote>
<p>这里类似于IO的磁盘读取，应用到了时间和空间局部性原理</p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。<br>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。比如循环、递归、方法的反复调用等。<br>空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。</p>
</blockquote>
<ul>
<li>进一步可分为三部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190418185737219.png" alt="在这里插入图片描述"><br>CPU访问内存时，会通过内存地址解码的三个数据：index（桶编号）、tag（缓存条目的相对编号）、offset（变量在缓存条目中的位置偏移）来获取高速缓存中对应的数据。</p>
<p>这时候可以看到Flag这个标识了，然后就可以引出了状态值的概念，然后就可以引出我们所说的MSEI协议了。</p>
<h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>E（独占）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515165217310.png" alt="image-20210515165217310"></p>
<p>只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。</p>
<ul>
<li>S（共享）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113707384.png" alt="在这里插入图片描述"></p>
<p>3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。</p>
<ul>
<li>M（修改）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113533520.png" alt="在这里插入图片描述"></p>
<p>Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态</p>
<ul>
<li>I状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113533520.png" alt="在这里插入图片描述"></p>
<p>在一个Core修改x后，相应的，其他Core对应的Cache line变成了I(Invalid)状态。</p>
<ul>
<li>状态的改变</li>
</ul>
<p>cache line存在四种状态，状态是动态的，肯定是有一定的操作使得状态发生了改变，那么操作是什么呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190418194836533.png" alt="在这里插入图片描述"></p>
<ol>
<li>Local Read表示本内核读本Cache中的值</li>
<li>Local Write表示本内核写本Cache中的值</li>
<li>Remote Read表示其它内核读其它内核Cache中的值</li>
<li>Remote Write表示其它内核写其它内核Cache中的值</li>
</ol>
<ul>
<li>总结</li>
</ul>
<p>MESI协议为了保证多个CPU cache中共享数据的一致性，定义了cache line的四种状态，而CPU对cache的4种操作可能会产生不一致状态，因此cache控制器监听到本地操作和远程操作的时候，需要对地址一致的cache line状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。</p>
<h3 id="写缓存-Store-Buffer"><a href="#写缓存-Store-Buffer" class="headerlink" title="写缓存 - Store Buffer"></a>写缓存 - Store Buffer</h3><ul>
<li><strong>场景引入</strong></li>
</ul>
<p>有一个变量在多个核中的缓存存在，那么这个缓存的状态是<strong>S（shared）共享</strong>的，现在核A想要<mark>修改</mark>这个变量，首先核A会向所有拥有相同缓存的其他核发送一个请求，告诉其他核中的缓存是<strong>I（Invalid）无效</strong>的，其他核收到这个信息将自己核中的缓存状态设置为无效之后，返回一个设置完成的消息，这个核A收到这个无效状态修改的消息后，再把自己的状态改为<strong>E（Exclusive）独享</strong>的，然后修改为<strong>M（Modified）</strong>进行缓存修改。</p>
<p>思考下：在核A等待其他核返回无效状态修改的消息返回的时候它做了什么？它什么都没做，一直处于阻塞状态。</p>
<p>因此，设计者引入了写缓存（Store Buffer）的无效化队列（Invalidate Queue）来解决这个问题。</p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>写缓存是一个容量极小的高速存储部件，每个核都有自己的写缓存，而且一个核不能够读取到其他核的写缓存（Store Buffer）的内容，相当于一个自己的本地缓存。</p>
<p>如上面的场景，核A修改共享的缓存，先将这个修改操作放入到写缓存（Store Buffer）中，再告诉其他核中的缓存失效了，然后核A继续执行其他指令操作，当接受到了其他核返回无效状态修改的消息之后，才将写缓存（Store Buffer）中的操作写入到核A中的缓存中，这时写操作才算完成。</p>
<p>这样就解决了等待阻塞所带来的性能问题，减少了延时，提高了执行效率。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515201924136.png" alt="image-20210515201924136"></p>
<h3 id="无效化队列-Invalidate-Queue"><a href="#无效化队列-Invalidate-Queue" class="headerlink" title="无效化队列 - Invalidate Queue"></a>无效化队列 - Invalidate Queue</h3><p>修改方为了能够快速进行回应所以，先将无效的操作放到队列里面去，并立刻返回无效状态修改的消息，等当前的操作执行完再回来真正的把缓存里面的值标识为I状态，这个存放无效操作的队列就叫做<strong>无效化队列</strong>。同时可能也是考虑到了写缓存（Store Buffer）是比较小的高速缓存，如果不能够及时返回会造成写缓存满了，还是需要等待无效状态修改的消息的返回才能继续进行后续的指令，所以就出现了无效化队列和写缓存配合使用。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205726015.png" alt="image-20210515205726015"></p>
<h3 id="写缓存与无效化队列的不足性"><a href="#写缓存与无效化队列的不足性" class="headerlink" title="写缓存与无效化队列的不足性"></a>写缓存与无效化队列的不足性</h3><ul>
<li>单核情况</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515203558901.png" alt="image-20210515203558901"></p>
<p>令b=x+1，因为x已经在缓存中读到的为0，b为1，所以判断是false，虽然后来Store Buffer后来将x的值刷新到了缓存中，但是已经晚了</p>
<p>所以为了避免这个问题，Store Buffer设计了一种策略叫做Store Forwarding。就是说核A在读取数据的时候会先看Store Buffer中的数据，如果Store Buffer中有数据，直接使用Store Buffer中的，从而避免使用错误数据。</p>
<ul>
<li>多核情况</li>
</ul>
<ol>
<li><p>情况一</p>
<p>核B在进行判断的时候发现在自己的缓存存在x=0，就直接+1进行了赋值判断，但此时核A刚刚将x=2的操作放到Store Buffer中，所以由于Store Buffer的存在导致多核下不能获取到最新值，所以产生了错误的结果。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205858812.png" alt="image-20210515205858812"></p>
<p>所以为了解决上面的问题出现了<strong>写屏障</strong>，写屏障的出现保证屏障两边写的执行是分开的，也就是说需要先将之前Store Buffer中的所有写指令都刷新到缓存之后，才执行后面的写指令。<br><strong>具体实现方法</strong>是，【先将屏障之前的<strong>Store Buffer中所有操作</strong>都刷新到缓存中】，将屏障后的所有指令操作也同样放到Store Buffer中，不管后续的操作是什么都往里面放，这样可以提高CPU的执行效率，都通过Store Buffer刷新到了缓存中,达到了数据来源的统一性。</p>
</li>
<li><p>情况二</p>
<p>核B在进行判断的时候发现在自己的缓存存在x=0，就直接+1进行了赋值判断，但此时核B刚刚将x的无效操作放到Invalidate Queue中，所以由于Invalidate Queue的存在导致多核下不能获取到最新值，所以产生了错误的结果。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205805900.png" alt="image-20210515205805900"></p>
<p>所以为了解决上面的问题出现了读屏障，读屏障的出现保证屏障两边读的执行是分开的，也就是说需要先将之前Invalidate Queue中的所有指令处理完之后，才执行后面的指令，保证下一次读取共享变量的时候读到的是最新的变量。</p>
</li>
</ol>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>通过上面对错误情况的分析可以知道，内存屏障的出现就是为了解决因为Store Buffer和Invalidate Queue所带来的数据可见性问题，也就是读和写不能实时更新到其他核的问题。内存屏障同时还具备强制将Store Buffer的内容刷到缓存中，强制将Invalidate Queue中的内容设置完毕的作用。</p>
<ul>
<li>硬件层的内存屏障分为两种：<code>Load (Memory) Barrier读屏障</code> 和 <code>Store (Memory) Barrier写屏障</code></li>
<li>内存屏障有两个作用：</li>
</ul>
<blockquote>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
</blockquote>
<ul>
<li><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</p>
<p>或者说： 强制将Invalidate Queue中的内容处理完毕，也被称之为smp_rmb</p>
</li>
<li><p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<p>或者说：强制将Store Buffer中的内容写入到缓存中或者将该指令之后的写操作写入store buffer直到之前的内容被刷入到缓存中，也被称之为smp_wmb</p>
</li>
</ul>
<h4 id="内存屏障分类"><a href="#内存屏障分类" class="headerlink" title="内存屏障分类"></a>内存屏障分类</h4><ol>
<li><p><strong>按照可见性保障来划分</strong><br>内存屏障可分为：<strong>加载屏障（Load Barrier）和存储屏障（Store Barrier）</strong>。</p>
<p>加载屏障：<mark>StoreLoad屏障</mark>可充当加载屏障，作用是刷新处理器缓存，即清空无效化队列，使处理器在读取共享变量时，先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中</p>
<p>存储屏障：<mark>StoreLoad屏障</mark>可充当存储屏障，作用是冲刷处理器缓存，即将写缓冲器内容写入高速缓存中，使处理器对共享变量的更新写入高速缓存或者主内存中<br>这两个屏障一起保证了数据在多处理器之间是可见的。</p>
</li>
<li><p><strong>按照有序性保障来划分</strong><br>内存屏障分为：<strong>获取屏障（Acquire Barrier）和释放屏障（Release Barrier）</strong>。</p>
<p>获取屏障：相当于<mark>LoadLoad屏障与LoadStore屏障</mark>的组合。在读操作后插入，禁止该读操作与其后的任何读写操作发生重排序；</p>
<p>释放屏障：相当于<mark>LoadStore屏障与StoreStore屏障</mark>的组合。在一个写操作之前插入，禁止该写操作与其前面的任何读写操作发生重排序。</p>
<p>这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外。</p>
</li>
</ol>
<h4 id="Java内存屏障"><a href="#Java内存屏障" class="headerlink" title="Java内存屏障"></a>Java内存屏障</h4><ul>
<li><p>Java四种屏障其实是<strong>Load Barrier</strong>与<strong>Store Barrier</strong>的两两组合（2 × 2 = 4）</p>
<p>此处提及的【load → 加载】和【store → 写入】</p>
<ul>
<li><p><mark>LoadLoad</mark>：对于语句 <code>Load1; 【LoadLoad】; Load2</code>，这个屏障的作用是确保在Load2加载代码在要读取的数据之前，保证Load1加载代码要从主内存里面读取的数据读取完毕。</p>
<blockquote>
<p>即：该屏障保证了在屏障前的读取操作效果先于屏障后的读取操作效果发生。在各个不同平台上会插入的编译指令不相同，可能的一种做法是插入也被称之为smp_rmb指令，强制处理完成当前的invalidate queue中的内容</p>
</blockquote>
</li>
<li><p><mark>StoreStore</mark>：对于语句<code>Store1; 【StoreStore】; Store2</code>，这个屏障的作用是保证在Store2存储代码进行写入操作执行前，保证Store1的写入操作已经把数据写入到主内存里面，确认Store1的写入操作对其它处理器可见。</p>
<blockquote>
<p>即：该屏障保证了在屏障前的写操作效果先于屏障后的写操作效果发生。可能的做法是使用smp_wmb指令，而且是使用该指令中，将后续写入数据先写入到store buffer的那种处理方式。因为这种方式消耗比较小</p>
</blockquote>
</li>
<li><p><mark>LoadStore</mark>：对于语句<code>Load1; 【LoadStore】; Store2</code>，这个屏障的作用是保证在Store2存储代码进行写入操作执行前，保证Load1加载代码要从主内存里面读取的数据读取完毕。</p>
<blockquote>
<p>即：该屏障保证了屏障前的读操作效果先于屏障后的写操作效果发生。</p>
</blockquote>
</li>
<li><p><mark>StoreLoad</mark>：对于语句<code>Store1; StoreLoad; Load2</code>，这个屏障的作用是保证load2从主内存里加载数据之前，store1的写入操作已经把数据写入到内存中，确认store1的写入操作对其他处理器可见</p>
<blockquote>
<p>即：该屏障保证了屏障前的写操作效果先于屏障后的读操作效果发生。可能的做法就是插入一个smp_mb指令来完成。StoreLoad屏障是开销最昂贵的一种屏障，其中一部分原因是因为他需要把写缓冲区的所有数据全部刷新到内存</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><blockquote>
<p>可见性的实现依靠了：lock前缀指令 + MESI缓存一致性协议</p>
</blockquote>
<h4 id="实现原理-Lock前缀"><a href="#实现原理-Lock前缀" class="headerlink" title="实现原理 - Lock前缀"></a>实现原理 - Lock前缀</h4><p>被volatile修饰的字段会在其对应的汇编操作指令上加个<strong>lock前缀指令</strong>，这个指令就可以解决可见性问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改了共享变量flag的值&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其执行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/67587e41ea3db7fca75c01ac163d66d6.png" alt="在这里插入图片描述"></p>
<p>lock前缀的指令在多核处理器下会引发两件事情</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但是操作完了不知道什么时候写回内存。而对声明了volatile关键字的变量进行写操作，JVM会向处理器发送一条lock前缀的指令，将这个变量所在的缓存行立即写回系统内存。并且为了保证各个处理器的缓存是一致的，实现了<code>缓存一致性协议</code>，各个处理通过<code>嗅探</code>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，那么下次对这个数据进行操作，就会重新从系统内存中获取最新的值。对应JMM来说就是：</p>
<ol>
<li>Lock前缀的指令让线程工作内存中的值写回主内存中；</li>
<li>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</li>
<li>其他线程会重新从主内存中获取最新的值；</li>
</ol>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><blockquote>
<p>可靠性的实现依靠了：内存屏障，禁止了重排序</p>
</blockquote>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515162606107.png" alt="image-20210515162606107"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515162606107.png" alt></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h3><p>使用锁时，线程获取锁是一种<strong>悲观锁策略</strong>，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种<strong>乐观锁策略</strong>，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。</p>
<p>因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用<strong>CAS(compare and swap / 比较与替换)</strong>又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。</p>
<ul>
<li>悲观锁：会阻塞其他线程</li>
<li>乐观锁：不会阻塞其他线程，如果发生冲突，采用死循环的方式一直重试，直到更新成功。</li>
</ul>
<p>是一种<strong>无锁算法</strong></p>
<h3 id="CAS操作过程"><a href="#CAS操作过程" class="headerlink" title="CAS操作过程"></a>CAS操作过程</h3><p>CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：<strong>V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值</strong>。</p>
<ul>
<li>当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。</li>
<li>反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程</li>
</ul>
<p>CAS的实现需要硬件指令集的支撑，在JDK1.5后虚拟机才可以使用处理器提供的<strong>CMPXCHG</strong>指令实现。</p>
<blockquote>
<p>Synchronized VS CAS</p>
</blockquote>
<p>元老级的Synchronized(未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而CAS并不是武断的间线程挂起，当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。</p>
<h3 id="CAS应用场景"><a href="#CAS应用场景" class="headerlink" title="CAS应用场景"></a>CAS应用场景</h3><p>在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现。具体实现后续详细聊；</p>
<h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><p><strong>1. ABA问题</strong><br>因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。java这么优秀的语言，当然在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的。</p>
<p><strong>2. 自旋时间过长</strong></p>
<p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。</p>
<p><strong>3. 只能保证一个共享变量的原子操作</strong></p>
<blockquote>
<p>原子性：原子性问题指的是多线程并发的情况下，当我们要进行数据的读取与修改时，可能会因为线程同时读取数据，导致进行了重复修改的情况，但是我们希望每个线程进行读取修改操作是连贯的、原子性的，在A线程进行读取修改的时候，不允许其他线程进行读取修改，而一定要等到A线程完成修改后，其他线程再去进行读取修改。比如我们要将数字0累加到10，在多线程的情况下，可能会因为线程A在读完数字但是还没有进行修改的时候，线程B也来读了数字，导致线程A的原子性被打破，使得它们累加后得到的数据是一样的，这就破坏了原子性。</p>
</blockquote>
<p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p>
<h2 id="Java对象头-monitor"><a href="#Java对象头-monitor" class="headerlink" title="Java对象头 monitor"></a>Java对象头 monitor</h2><blockquote>
<p> Java对象头和monitor是实现synchronized的基础</p>
</blockquote>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210426161645623.png" alt="image-20210426161645623"></p>
<ul>
<li><p>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
</li>
<li><p>对齐填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐</p>
</li>
<li><p>对象头</p>
<ul>
<li><p>普通对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200903143715550.png" alt="在这里插入图片描述"></p>
</li>
<li><p>数组对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200903143731342.png" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h4 id="对象头的组成"><a href="#对象头的组成" class="headerlink" title="对象头的组成"></a>对象头的组成</h4><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><blockquote>
<p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等</p>
</blockquote>
<ul>
<li>32位JVM 的Mark Word的默认存储结构</li>
</ul>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190308094615410.png" alt="img"></p>
<ul>
<li><p>具体结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200225114028735.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>锁标记位（lock）</strong>：该标记的值不同，则Mark word表示的含义不同</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200225113633471.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>无锁：</strong>无锁状态时，存储的是对象的hashcode值</li>
<li><strong>偏向锁</strong>：偏向锁时，<strong>前23位存储偏向的线程ID</strong>，并将倒数第三位置为1，表示偏向锁。</li>
<li><strong>轻量级锁</strong>：轻量级锁时，存储的是 <strong>指向JVM栈中的锁记录Lock Record的指针</strong></li>
<li><strong>重量级锁</strong>：当自旋次数超过10次时，将转换成重量级锁，重量级锁存储的是 <strong>指向重量级锁Monitor的指针</strong></li>
</ul>
</li>
<li><p><strong>是否为偏向锁（biased_lock）</strong>：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。</p>
</li>
<li><p><strong>对象分代年龄（age）</strong>：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为15的原因。</p>
</li>
<li><p><strong>identity_hashcode</strong>： 25位的对象标识<mark>Hash码</mark>，采用延迟加载技术。调用方法<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。</p>
</li>
<li><p><strong>thread</strong>： 持有偏向锁的线程ID。</p>
</li>
<li><p><strong>epoch</strong>：偏向时间戳。</p>
</li>
<li><p><strong>ptr_to_lock_record</strong>：指向栈中锁记录的指针。</p>
</li>
<li><p><strong>ptr_to_heavyweight_monitor</strong>：指向管程Monitor的指针。</p>
</li>
</ul>
<h5 id="class-pointer"><a href="#class-pointer" class="headerlink" title="class pointer"></a>class pointer</h5><blockquote>
<p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。</p>
</blockquote>
<p>为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。</p>
<h5 id="array-length"><a href="#array-length" class="headerlink" title="array length"></a>array length</h5><p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。</p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><blockquote>
<p>monitor是什么？它是一个同步工具，是一种同步机制，通常被描述为一个【对象】；</p>
<p>monitor概念其实我们早就接触过了，它就是OS中的【管程】；</p>
</blockquote>
<p>Monitor是一个对象，这代表着什么？在Java世界中，一切皆对象，那么所有的Java对象其实都是monitor，或者说所有的对象都可以去关联一个<strong>Monitor</strong>对象。（这也是为什么上面需要学习Java对象头，因为结合monitor我们就可以通过设置标识位做到线程同步了）</p>
<ul>
<li><strong>Monitor概念</strong></li>
</ul>
<p>Monitor 是<mark><strong>线程私有</strong></mark>的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个<strong>全局的可用列表</strong>。</p>
<p>每一个被锁住的对象都会和一个monitor关联（对象头<strong>的MarkWord</strong>中的<strong>LockWord</strong>指向<strong>monitor的起始地址</strong>）</p>
<p>同时monitor中有一个<strong>Owner字段</strong>存放拥有<strong>该锁的线程的唯一标识</strong>，表示该锁被这个线程占用</p>
<ul>
<li><strong>Monitor结构图</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170205214544590" alt="这里写图片描述"></p>
<ol>
<li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li><strong>Nest</strong>:用来实现重入锁的计数。</li>
<li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ol>
<h2 id="synchronized（内置锁）"><a href="#synchronized（内置锁）" class="headerlink" title="synchronized（内置锁）"></a>synchronized（内置锁）</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Java中最常用的同步机制就是<strong>synchronized关键字</strong>，它是一种基于语言的<strong>粗略锁</strong>（也就是说本质其实也是一把锁），能够作用于<strong>对象、函数、Class</strong>上。</p>
<p>synchronized是一种<strong>互斥锁</strong>：意味着一次只能允许一个线程进入被锁住的代码块</p>
<p>synchronized是一种<strong>内置锁/监视器锁</strong>：Java中每个对象都有一个<strong>内置锁（监听器monitor，可理解为锁标记）</strong>，synchronized就是通过使用<strong>对象的内置锁（监听器）</strong>来将代码块（方法）锁定的。（这部分内容结合monitor的相关知识好理解一点）</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ul>
<li>synchronized保证了线程的<strong>原子性</strong>。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</li>
<li>synchronized还保证了<strong>可见性</strong>。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</li>
</ul>
<p>Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了<strong>对变量操作的原子性和其他线程对变量的可见性</strong>，从而确保了并发情况下的线程安全。</p>
<p>一句话来说：</p>
<blockquote>
<p>synchronized修饰的区域看作是一个临界区，临界区内只能有一个线程在访问，当访问线程退出临界区，另一个线程才能访问临界区资源。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>synchronized原理 - 指令层面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method 1 start&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160414215316020-1963237484.png" alt="img"></p>
<hr>
<p>这里出现了两个关键指令【monitorenter】和【monitorexit】</p>
<p>【monitorenter】</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权（类似于操作系统中的<strong>P操作</strong>），过程如下：</p>
<ol>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li>
</ol>
<p>【monitorexit】</p>
<p>注意：执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>该指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。（类似于OS中的<strong>V操作</strong>）其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
<hr>
<p>结合这两个指令的含义，我们能够推断出Synchronized的实现原理：Synchronized的语义底层是通过一个monitor的对象来完成类似于OS中的PV操作，达到线程同步。</p>
<ul>
<li><strong>synchronized实现原理 - 底层/字节码层面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160418202553429-1642545018.png" alt="img"></p>
<p>从字节码中可以看出，synchronized修饰的方法并没有<strong>monitorenter指令和monitorexit指令</strong>，取得代之的确实是<mark>ACC_SYNCHRONIZED标识</mark>，该标识指明了该方法是一个同步方法，JVM通过该<mark>ACC_SYNCHRONIZED标识</mark>访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</p>
<p>具体实现：</p>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><strong>使用synchronized实现同步</strong></li>
</ul>
<p>使用synchronized关键字声明的方法 成为了 临界区。这样做，就使得临界区被创建出来了，由之前所学可以知道，同一个对象的临界区，在同一时间只有一个允许被访问。</p>
<blockquote>
<p>用synchronized关键字声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的synchronized方法，其中一个是静态方法，一个是非静态方法</p>
</blockquote>
<h4 id="synchronized作用于实例方法"><a href="#synchronized作用于实例方法" class="headerlink" title="synchronized作用于实例方法"></a>synchronized作用于实例方法</h4><blockquote>
<p>修饰实例方法，作用于当前【实例对象】加锁，进入同步代码前要获得当前【实例对象】的锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 2000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>我们使用<strong>static关键字</strong>构造了一个临界资源：<code>static int i=0;</code></p>
<p>同时，构建了一个实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i++</code>的操作并不具备<strong>原子性</strong>（先读i的值，对i进行++操作，后写回新值），如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。</p>
<p><code>synchronized</code>修饰的是实例方法<code>increase()</code>，即：当前线程上的锁作用于<strong>实例对象instance</strong></p>
<p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法。</p>
<hr>
<p>如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncBad</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>代码解释</strong>：</p>
<p>这段代码中创建了两个新实例：AccountingSyncBad</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new新实例</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line"><span class="comment">//new新实例</span></span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br></pre></td></tr></table></figure>

<p>然后启动两个不同的线程对共享变量i进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        increase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但结果却不会是<mark>2000000</mark>，因为虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的</p>
<p><strong>解决方案：</strong></p>
<p>将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。</p>
<hr>
<h4 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h4><blockquote>
<p>修饰静态方法，作用于当前【类对象/class对象】加锁，进入同步代码前要获得当前【类对象/class对象】的锁</p>
</blockquote>
<p>果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，是因为：</p>
<ul>
<li><p>访问<strong>静态 synchronized 方法</strong>占用的<strong>锁</strong>是<strong>当前类的class对象</strong></p>
</li>
<li><p>而访问<strong>非静态 synchronized 方</strong>法占用的<strong>锁</strong>是当前<strong>实例对象（this）</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用于静态方法,锁是当前class对象,也就是</span></span><br><span class="line"><span class="comment">     * AccountingSyncClass类对应的class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态,访问时锁不一样不会发生互斥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase4Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>由于<strong>synchronized关键字</strong>修饰的是<code>静态increase</code>方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的<code>increase4Obj方法</code>是<strong>实例方法</strong>，其对象锁是<strong>当前实例对象</strong>，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题（操作了共享静态变量i）。</p>
<hr>
<h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><blockquote>
<p>修饰代码块，指定加锁对象，对【给定对象（括号中的对象）】加锁，进入同步代码库前要获得【给定对象（括号中的对象）】的锁</p>
</blockquote>
<ul>
<li><strong>使用场景</strong></li>
</ul>
<p>在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>将synchronized作用于一个给定的<strong>实例对象instance</strong>，即当前实例对象就是锁对象，每次当线程进入<strong>synchronized</strong>包裹的代码块时就会要求当前线程持有<strong>instance实例对象锁</strong>，如果当前有其他线程正持有<strong>该对象锁</strong>，那么新到的线程就必须<strong>等待</strong>，这样也就保证了每次只有一个线程执行<code>i++;</code>操作。</p>
<hr>
<p>另外一种写法，用<code>this对象</code>（代表当前实例）或者直接用当前类的class对象作为锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this,当前实例对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(AccountingSync.class)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁-锁优化"><a href="#锁-锁优化" class="headerlink" title="锁/锁优化"></a>锁/锁优化</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。</p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，这种策略是为了提高获得锁和释放锁的效率</p>
</blockquote>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由<strong>同一线程</strong>多次获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">&quot;test:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了<code>synchronized</code>的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作。</p>
<p>因此为了<strong>减少同一线程获取锁（会涉及到一些CAS操作,耗时）的代价</strong>，或者说为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，我们引入了<mark>偏向锁</mark>。</p>
<ul>
<li><strong>思想</strong></li>
</ul>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能</p>
<ul>
<li><strong>具体执行</strong></li>
</ul>
<ol>
<li><p><strong>对象创建</strong></p>
<p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的，可通过参数关闭），那<strong>新创建对象</strong>的<code>mark word</code>将是<mark>可偏向状态</mark>，此时<code>mark word中</code>的<strong>thread id</strong>为<strong>0</strong>：表示未偏向任何线程，也叫做<strong>匿名偏向（anonymously biased）</strong>。</p>
</li>
<li><p><strong>加锁/获取锁过程</strong></p>
<ol>
<li><p>检测Mark Word是否为<mark>可偏向状态</mark>。即访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p>
</li>
<li><p>假如是<mark>可偏向状态</mark>，则测试<strong>线程ID是否指向当前线程</strong>，如果是，会往当前线程的栈中添加一条<code>Displaced Mark Word</code>为空的<code>Lock Record</code>中，进入步骤（5）；如果<strong>线程ID不指向当前线程</strong>，则进入步骤（3）。</p>
<p>（当该对象<strong>第一次</strong>被线程获得锁的时候，发现是<strong>匿名偏向状态（即thread id = 0）</strong>，则会用CAS指令，将<code>mark word</code>中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。在以后只要不发生竞争，这个对象就归该线程所持有。失败的话，进入步骤（4））</p>
<blockquote>
<p>当被偏向的线程再次进入同步块时，操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，<code>synchronized</code>关键字带来的性能开销基本可以忽略</p>
</blockquote>
</li>
<li><p>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID（<strong>竞争成功的线程将获得偏向锁的所有权</strong>），然后执行（5）；如果竞争失败，执行（4）。</p>
</li>
<li><p>【<mark><strong>进行撤销偏向锁的操作</strong></mark>】通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达<strong>全局安全点（safepoint）</strong>，之前<strong>获得偏向锁</strong>的线程被<strong>挂起</strong>，对该线程进行状态判断。</p>
<ol>
<li>若线程仍存活且还在同步块：锁升级为轻量级锁。</li>
<li>如果偏向的线程已经不存活或者不在同步块中：则将对象头的<code>mark word</code>改为无锁状态（unlocked），偏向锁不升级，并且环形</li>
</ol>
</li>
<li><p>执行同步代码块</p>
</li>
</ol>
<p>由此可见：偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>解锁/偏向锁释放过程</strong></p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点<code>safe point</code>（在这个时间点上没有字节码正在执行）</p>
<ol>
<li>它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>偏向锁的获取/解锁流程图解</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429174346151.png" alt="image-20210429174346151"></p>
<ul>
<li><strong>锁状态的转换流程</strong></li>
</ul>
<p><img src="https://camo.githubusercontent.com/a63795e864c710178fada8ddc8748c064185bd474fe0f4d2254dfc4e708305ff/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162323739343633623f773d35393826683d32383526663d706e6726733d3232323430" alt="img"></p>
<p>1）一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p>
<p>2） 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了。检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程。如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁；如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p>
<p>3）轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>
<h4 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h4><ul>
<li><strong>概述</strong></li>
</ul>
<p>对于偏向锁的加锁解锁过程，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到<code>safe point</code>时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。</p>
<p>想一想，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降，那么有没有一种方法可以改变这种情况呢？JVM替我们想到了这个问题的解决方案 —— 引入了批量重偏向/撤销的机制。</p>
<ul>
<li><strong>批量重偏向</strong></li>
</ul>
<blockquote>
<p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。</p>
</blockquote>
<p>举个例子：在不存在锁竞争的条件下，如果同一个类有50个对象偏向线程t1，而线程t2又分别对这50个对象进行循环加锁，此时t2加锁的<strong>前19个对象</strong>会膨胀为<strong>轻量锁</strong>，等到<strong>第20个对象</strong>时，JVM会预测这个类后面的所有对象都要偏向t2，所以再加锁时，就不会执行锁膨胀了，而是<strong>重偏向到线程t2</strong>。</p>
<p><strong>具体实现</strong></p>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到<strong>重偏向阈值（默认20）</strong>时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的<code>epoch</code>字段，每个处于偏向锁状态对象的<code>mark word中</code>也有该字段，其初始值为创建该对象时，class中的<code>epoch</code>的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其<code>epoch</code>字段改为新值。下次获得锁时，发现当前对象的<code>epoch</code>值和class的<code>epoch</code>不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其<code>mark word</code>的Thread Id 改成当前线程Id。</p>
<ul>
<li><strong>批量撤销（批量撤销偏向锁）</strong></li>
</ul>
<blockquote>
<p>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p>
</blockquote>
<p>举个例子：</p>
<ul>
<li><p>假设有80个A类的对象实例，开始时全部偏向线程t1，然后t2线程对第1-40个对象又进行了加锁处理</p>
<ul>
<li><p>此时根据批量重定向机制，<strong>1-19</strong>个对象先是会膨胀为轻量级锁，退出同步块后变为无锁；</p>
</li>
<li><p>而第<strong>20-40</strong>个对象会因为触发批量重定向，锁状态变为偏向t2线程的偏向锁。</p>
</li>
<li><p>这时t3线程来了，它对第21-43个对象进行加锁处理（注意t3线程的前20个对象不能跟t2线程的前20个对象重合），这时由于t2线程撤销偏向锁撤销了19次（JVM会按20次计算），t3线程撤销偏向锁撤销了19次（JVM会按20次计算），总共撤销的次数达到了40的阈值</p>
<p>此时JVM会判定为这个A类的对象有问题（不断的切换偏向线程会降低执行效率），从第21-43，都会变为轻量级锁，不再进行重偏向操作，而且会对这个A类的对象关闭偏向的设置，即往后再newA类的对象时，不会进入偏向锁状态，只能走<code>无锁 - 轻量级锁 - 重量级锁</code>的膨胀过程。所以批量撤销全称应该为：<strong>批量撤销偏向锁</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1558028-20191201175406151-122576693.png" alt="img"></p>
<p>一言蔽之：当达到重偏向阈值（20）后，若class计数器还在继续增长，那么其达到批量撤销的阈值后（默认40），JVM认为该class的使用场景是存在<strong>多线程竞争</strong>的，就标记该class为<mark>不可偏向</mark>，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul>
<li><strong>背景</strong></li>
</ul>
<p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在<strong>竞争</strong>的，即不同的线程交替的执行同步块中的代码。我们应该减少传统的重量级锁带来的性能消耗（重量级锁使用操作系统互斥量去实现同步）。</p>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁将会导致<strong>偏向锁</strong>升级为<strong>轻量级锁</strong></p>
<ul>
<li><strong>Lock Record</strong></li>
</ul>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个<code>Lock Record</code>，其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为<code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428201217469.png" alt="image-20210428201217469"></p>
<ul>
<li><strong>加锁过程</strong></li>
</ul>
<p>下列代码中：有2个方法同步代码块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> ( obj ) &#123;</span><br><span class="line">         <span class="comment">//同步块A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">         <span class="comment">//do something...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428203105992.png" alt="image-20210428203105992"></p>
</li>
<li><p>执行到<code>synchronized ( obj )</code>后</p>
<ol>
<li>让<code>锁记录（Lock Record）</code>中的Object reference指向锁对象（Object）</li>
<li>JVM利用CAS去操作尝试用<code>Displaced Mark Word</code>去替换对象头中的<code>Mark Word</code>如果成功了，就表示竞争到锁了，标志位从<strong>01</strong>更新为<strong>00</strong>（表示此对象处于轻量级锁状态）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428203519196.png" alt="image-20210428203519196"></p>
<p>下图为CAS替换成功后的状态，对象头中存储了<strong>锁记录地址和状态 00</strong>，表示由该线程给对象加锁</p>
<p><img src="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210428204323729.png" alt="image-20210428204323729"></p>
</li>
<li><p>假如CAS替换失败，则表示两种情况</p>
<ol>
<li><p>若是其他线程已经持有了该<strong>Object</strong>的轻量级锁，就代表着有竞争，下面就进入<mark>锁膨胀过程</mark></p>
</li>
<li><p>若是自己执行了<code>Synchronized锁重入</code>，就设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用（即添加一条Lock Record作为重入的计数）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428204857790.png" alt="image-20210428204857790"></p>
</li>
</ol>
<p>此时，将会发生<strong>锁膨胀</strong>（轻量级锁 升级为 重量级锁）</p>
</li>
</ol>
<ul>
<li><strong>解锁过程</strong></li>
</ul>
<ol>
<li><p>首先.遍历线程栈,找到所有<code>obj</code>字段等于当前锁对象的<code>Lock Record</code>。</p>
</li>
<li><p>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>为null，代表这是一次重入，就重置锁记录（将<code>obj</code>设置为null），表示重入计数 -1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428205823619.png" alt="image-20210428205823619"></p>
</li>
<li><p>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>不为null，则利用CAS指令将<strong>对象头</strong>的<code>mark word</code>恢复成为<code>Displaced Mark Word</code>。</p>
<p>（这里也可以解释，为什么获得锁时，我们将<code>Lock Record</code>中的<code>Displaced Mark Word</code>与对象头中的<code>Mark Word</code>进行交换操作了，在解锁的时候可以还原状态嘛）</p>
<ol>
<li>如果成功，则表示解锁成功</li>
<li>如果失败，说明轻量级锁进行锁膨胀/已经升级为重量级锁，就不能按照轻量级锁去办事，下面就会进入重量级锁解锁过程</li>
</ol>
</li>
</ol>
<ul>
<li><strong>轻量级锁的获取和释放过程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429180918744.png" alt="image-20210429180918744"></p>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>在上述轻量级锁的获取步骤中，我们提及了一个锁膨胀的概念，其发生在其他线程为相同对象加上了<strong>轻量级锁</strong>，这个时候就需要进行<mark>锁膨胀</mark>了，即将轻量级锁升级为重量级锁</p>
<blockquote>
<p>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</p>
<p>而最为我们所熟知的重量级锁就是Synchronized了</p>
</blockquote>
<ul>
<li><strong>引入</strong></li>
</ul>
<p>如下图所示，T1想要对对象进行轻量级加锁时，发现T0先它一步，已经给该对象加上了轻量级锁（发现后两位是00）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428211813089.png" alt="image-20210428211813089"></p>
<ul>
<li><strong>锁膨胀过程</strong></li>
</ul>
<p>以上述情况为例</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>为Objcet对象申请<code>Monitor</code>锁(最后两位改成10），让Object指向重量级锁的地址</p>
</li>
<li><p>接着T1线程进入<code>Monitor</code>的*<em>EnrtyList *</em>发生阻塞</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428212641730.png" alt="image-20210428212641730"></p>
</li>
</ol>
<p><strong>释放锁</strong></p>
<p>当T0退出同步块进行解锁的时候，会使用<strong>CAS</strong>将<code>Displaced Mark Word</code>的值还原给对象头，但这一步能成功吗？不能，因为此时对象的后两位是10，是重量级锁。之前轻量级锁那一套在这里不管用了，接下来就会进入重量级锁的解锁流程</p>
<ol>
<li>首先按照Monitor的地址找到Monitor对象</li>
<li>设置Owner为Null</li>
<li>唤醒<strong>EnrtyList</strong>中阻塞的线程</li>
</ol>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>由于线程的<strong>阻塞和唤醒</strong>需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。而同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的——因此我们引入了<strong>自旋锁</strong></p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>所谓<strong>自旋锁</strong>，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p>
<p>使用场景：当重量级锁竞争的时候可以使用自旋进行优化处理，如果<strong>当前线程</strong>自旋成功了（即这时候<strong>持锁的线程</strong>已经退出了同步块，释放了锁 ），这个时候<strong>当前的线程</strong>就可以避免阻塞，减少CPU切换，提高系统并发性。</p>
<ul>
<li><strong>自旋成功情况</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429154732197.png" alt="image-20210429154732197"></p>
<ul>
<li><strong>自旋失败情况</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429154840307.png" alt="image-20210429154840307"></p>
<ul>
<li><strong>注意点</strong></li>
</ul>
<p><strong>自旋等待不能替代阻塞</strong>。虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作。（占有处理器，却不做任何事）。这会带来性能上的浪费。</p>
<p>因此，<strong>自旋不能无限自旋</strong>，自旋的次数必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>自旋是会占用处理机的时间的，自旋的思想是先等待一下，让执行同步块的线程跑一下，看看自旋后的线程能不能过会能不能用上处理机，因此单核CPU使用自旋有意义吗？没有。<strong>因此单核CPU自旋就是浪费，只有多核CPU自旋才能够发挥优势</strong></p>
<p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整</p>
<h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>在学习自旋锁相关知识时，我们发现：如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），这种情况就显得我们很蠢。</p>
<p>于是JDK1.6引入<strong>自适应的自旋锁</strong>，让虚拟机会变得越来越聪明。</p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h3 id="锁转换流程图"><a href="#锁转换流程图" class="headerlink" title="锁转换流程图"></a>锁转换流程图</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200728235120589.png" alt="img"></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到<strong>不可能存在共享数据竞争</strong>，这是JVM会对这些同步锁进行锁消除；</p>
<ul>
<li><strong>依据</strong></li>
</ul>
<p>锁消除的依据是<strong>逃逸分析</strong>的数据支持。这也是jvm的语法糖的一种，是编译器的一种优化措施。</p>
<p>锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定。</p>
<ul>
<li><strong>例子</strong></li>
</ul>
<p>有时候，我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小，即仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。</p>
<ul>
<li><strong>例子</strong></li>
</ul>
<p>类似锁消除的<code>concatString()</code>方法。如果<code>StringBuffer sb = new StringBuffer();</code>定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把<strong>加锁同步的范围</strong>扩展到整个操<strong>作序列的外部</strong>，即扩展到【<strong>第一个append()操作之前和最后一个append()操作之后</strong>】，这样的一个锁范围扩展的操作就称之为<mark>锁粗化</mark>。</p>
<p>用上述的锁消除的代码为例的话：</p>
<p>JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<blockquote>
<p>将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
</blockquote>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final基础"><a href="#final基础" class="headerlink" title="final基础"></a>final基础</h3><p>final基础在java基础部分有学习过：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#final">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#final</a></p>
<h3 id="多线程中的final"><a href="#多线程中的final" class="headerlink" title="多线程中的final"></a>多线程中的final</h3><h4 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h4><h5 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h5><p>先看一段示例性的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">//普通域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">//final域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1. 写普通域</span></span><br><span class="line">        b = <span class="number">2</span>; <span class="comment">// 2. 写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = demo.a;    <span class="comment">//4.读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = demo.b;    <span class="comment">//5.读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A在执行writer()方法，线程B执行reader()方法。</p>
<blockquote>
<p><strong>写final域重排序规则</strong></p>
</blockquote>
<p>写final域的重排序规则<strong>禁止对final域的写重排序到构造函数之外</strong>，这个规则的实现主要包含了两个方面：</p>
<ol>
<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>
<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障（关于内存屏障可以看<a target="_blank" rel="noopener" href="https://juejin.im/post/5ae6d309518825673123fd0e">这篇文章</a>）。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>
</ol>
<p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p>
<ol>
<li>构造了一个FinalDemo对象；</li>
<li>把这个对象赋值给成员变量finalDemo。</li>
</ol>
<p>我们来画下存在的一种可能执行时序图，如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-9e3937df955a9862.png" alt="final域写可能的存在的执行时序"></p>
<p>由于a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p>
<p>因此，写final域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障</strong>。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。</p>
<blockquote>
<p><strong>读final域重排序规则</strong></p>
</blockquote>
<p>读final域重排序规则为：<strong>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</strong>（注意，这个规则仅仅是针对处理器），处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
<p>read()方法主要包含了三个操作：</p>
<ol>
<li>初次读引用变量finalDemo;</li>
<li>初次读引用变量finalDemo的普通域a;</li>
<li>初次读引用变量finalDemo的final域b;</li>
</ol>
<p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-2a93b67948d7fc64.png" alt="final域读可能存在的执行时序"></p>
<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>
<p>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</strong></p>
<h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><p>我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了？如果是<strong>引用数据类型</strong>呢？我们接着继续来探讨。</p>
<blockquote>
<p><strong>对final修饰的对象的成员域写操作</strong></p>
</blockquote>
<p>针对引用数据类型，final域写针对编译器和处理器重排序<strong>增加了这样的约束</strong>：在构造函数内对<strong>一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量</strong>，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论（耐心看完才有收获）。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-1f5f0a39a3f6977e.png" alt="写final修饰引用类型数据可能的执行时序"></p>
<p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<blockquote>
<p><strong>对final修饰的对象的成员域读操作</strong></p>
</blockquote>
<p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>
<blockquote>
<p><strong>关于final重排序的总结</strong></p>
</blockquote>
<p>按照final修饰的数据类型分类：</p>
<p>基本数据类型:</p>
<ol>
<li>final域写：禁止<strong>final域写</strong>与<strong>构造方法</strong>重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li>
<li>final域读：禁止初次<strong>读对象的引用</strong>与<strong>读该对象包含的final域</strong>的重排序。</li>
</ol>
<p>引用数据类型：</p>
<p>额外增加约束：禁止在构造函数对<strong>一个final修饰的对象的成员域的写入</strong>与随后将<strong>这个被构造的对象的引用赋值给引用变量</strong> 重排序</p>
<h3 id="final实现原理"><a href="#final实现原理" class="headerlink" title="final实现原理"></a>final实现原理</h3><p>上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p>
<p>很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以<strong>StoreStore屏障可以省略</strong>。由于<strong>不会对有间接依赖性的操作重排序</strong>，所以在X86处理器中，读final域需要的<strong>LoadLoad屏障也会被省略掉</strong>。也就是说，<strong>以X86为例的话，对final域的读/写的内存屏障都会被省略</strong>！具体是否插入还是得看是什么处理器</p>
<h3 id="为什么final引用不能从构造函数中-“逸出”"><a href="#为什么final引用不能从构造函数中-“逸出”" class="headerlink" title="为什么final引用不能从构造函数中 “逸出”"></a>为什么final引用不能从构造函数中 “逸出”</h3><p>这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：<strong>在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”</strong>。以下面的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">//1</span></span><br><span class="line">        referenceDemo = <span class="keyword">this</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = referenceDemo.a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的执行时序如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-e020492056ee1242.png" alt="final域引用可能的执行时序"></p>
<p>假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p>
<h1 id="Lock体系"><a href="#Lock体系" class="headerlink" title="Lock体系"></a>Lock体系</h1><h2 id="cocurrent包结构层次"><a href="#cocurrent包结构层次" class="headerlink" title="cocurrent包结构层次"></a>cocurrent包结构层次</h2><p>在针对并发编程中，Doug Lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-da951eb99c5dabfd.png" alt="concurrent目录结构.png"></p>
<p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors,这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及CAS，从整体上来看concurrent包的整体实现图如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-24da822ddc226b03.png" alt="concurrent包实现整体示意图.png"></p>
<h2 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h2><p>我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</p>
<p>在Lock接口出现之前，java程序主要是靠<code>synchronized</code>关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。</p>
<p><strong>虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</strong>通常使用显示使用lock的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<strong>synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁</strong>。</p>
<h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><p>我们现在就来看看lock接口定义了哪些方法：</p>
<blockquote>
<p>void lock(); //获取锁<br>void lockInterruptibly() throws InterruptedException；//获取锁的过程能够响应中断<br>boolean tryLock();//非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle<br>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//超时获取锁，在超时内或者未中断的情况下能够获取锁<br>Condition newCondition();//获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</p>
</blockquote>
<p>上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的ReentrantLock说起。</p>
<blockquote>
<p>public class ReentrantLock implements <strong>Lock</strong>, java.io.Serializable</p>
</blockquote>
<p>很显然ReentrantLock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。</p>
<p>当你查看源码时你会惊讶的发现ReentrantLock并没有多少代码，另外有一个很明显的特点是：<strong>基本上所有的方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而Sync类继承了<code>AbstractQueuedSynchronizer（AQS）</code></strong>。</p>
<p>可以看出要想理解ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer（简称同步器）的理解。</p>
<h2 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><strong>AQS - 抽象 队列 同步器；简称同步器</strong></li>
</ul>
<p>关于AQS在源码中有十分具体的解释：</p>
<pre><code>Provides a framework for implementing blocking locks and related
synchronizers (semaphores, events, etc) that rely on
first-in-first-out (FIFO) wait queues.  This class is designed to
be a useful basis for most kinds of synchronizers that rely on a
single atomic &#123;@code int&#125; value to represent state. Subclasses
must define the protected methods that change this state, and which
define what that state means in terms of this object being acquired
or released.  Given these, the other methods in this class carry
out all queuing and blocking mechanics. Subclasses can maintain
other state fields, but only the atomically updated &#123;@code int&#125;
value manipulated using methods &#123;@link #getState&#125;, &#123;@link
#setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect
to synchronization.

&lt;p&gt;Subclasses should be defined as non-public internal helper
classes that are used to implement the synchronization properties
of their enclosing class.  Class
&#123;@code AbstractQueuedSynchronizer&#125; does not implement any
synchronization interface.  Instead it defines methods such as
&#123;@link #acquireInterruptibly&#125; that can be invoked as
appropriate by concrete locks and related synchronizers to
implement their public methods.</code></pre><p>同步器是用来构建锁和其他同步组件的基础框架</p>
<ul>
<li><strong>它的实现方式（同步状态 + 等待队列）</strong><ul>
<li>依赖一个int成员变量来表示同步状态</li>
<li>再通过一个<mark>FIFO队列构成等待队列</mark>。</li>
</ul>
</li>
</ul>
<p>它的<strong>子类必须重写AQS的几个protected修饰的用来改变同步状态的方法</strong>，其他方法主要是实现了排队和阻塞机制。</p>
<p><strong>状态的更新使用getState,setState以及compareAndSetState（也就是我们常说的<mark>CAS</mark>）这三个方法</strong>。</p>
<p>子类被<strong>推荐定义为自定义同步组件的静态内部类</strong>，同步器自身<strong>没有实现</strong>任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<ul>
<li><strong>理解二者的关系</strong></li>
</ul>
<p><strong>锁是面向【使用者】，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的【实现者】，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<h3 id="AQS模板方法设计模式"><a href="#AQS模板方法设计模式" class="headerlink" title="AQS模板方法设计模式"></a>AQS模板方法设计模式</h3><ul>
<li>AQS的设计是使用【<mark>模板方法设计模式</mark>】，它将<strong>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</strong></li>
</ul>
<p>举个例子，AQS中需要重写的方法tryAcquire：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock中NonfairSync（继承AQS，本质是一个锁）会重写该方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而AQS中的模板方法acquire():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式，在弄懂这点后会lock的实现理解有很大的提升。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p>可以归纳总结为这么几点：</p>
<ol>
<li>同步组件（这里不仅仅指锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState(),setState(),compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
<p>AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-214b5823e76f8eb0.png" alt="AQS可重写的方法.png"></p>
<p>在实现同步组件时AQS提供的模板方法如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-214b5823e76f8eb0.png" alt="AQS提供的模板方法.png"></p>
<p>AQS提供的模板方法可以分为3类：</p>
<ol>
<li>独占式获取与释放同步状态；</li>
<li>共享式获取与释放同步状态；</li>
<li>查询同步队列中等待线程情况；</li>
</ol>
<p>同步组件通过AQS提供的模板方法实现自己的同步语义。</p>
<h3 id="AQS底层细节"><a href="#AQS底层细节" class="headerlink" title="AQS底层细节"></a>AQS底层细节</h3><h4 id="AQS模板方法"><a href="#AQS模板方法" class="headerlink" title="AQS模板方法"></a>AQS模板方法</h4><p>在同步组件的实现中，AQS是核心部分，同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对<strong>同步状态的管理，以及对阻塞线程进行排队，等待通知</strong>等等一些底层的实现处理。</p>
<p>AQS的核心也包括了这些方面:<strong>同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现</strong>，而这些实际上则是AQS提供出来的模板方法，归纳整理如下：</p>
<p><strong>独占式锁：</strong></p>
<blockquote>
<p>void acquire(int arg)：独占式获取同步状态，如果获取失败则插入同步队列进行等待；<br>void acquireInterruptibly(int arg)：与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；<br>boolean tryAcquireNanos(int arg, long nanosTimeout)：在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;<br>boolean release(int arg)：释放同步状态，该方法会唤醒在同步队列中的下一个节点</p>
</blockquote>
<p><strong>共享式锁：</strong></p>
<blockquote>
<p>void acquireShared(int arg)：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；<br>void acquireSharedInterruptibly(int arg)：在acquireShared方法基础上增加了能响应中断的功能；<br>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在acquireSharedInterruptibly基础上增加了超时等待的功能；<br>boolean releaseShared(int arg)：共享式释放同步状态</p>
</blockquote>
<p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。在学习这些模板方法之前，我们得首先了解下AQS中的同步队列是一种什么样的数据结构，因为同步队列是AQS对同步状态的管理的基石。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。</p>
<p>就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是<strong>通过链式方式</strong>进行实现。接下来，很显然我们至少会抱有这样的疑问：</p>
<ol>
<li><strong>节点的数据结构是什么样的？</strong></li>
<li><strong>是单向还是双向？</strong></li>
<li><strong>是带头结点的还是不带头节点的？</strong></li>
</ol>
<ul>
<li><strong>Node类 属性</strong></li>
</ul>
<p>在AQS有一个静态内部类Node，其中有这样一些属性：</p>
<blockquote>
<p>volatile int waitStatus //节点状态<br>volatile Node prev //当前节点/线程的前驱节点<br>volatile Node next; //当前节点/线程的后继节点<br>volatile Thread thread;//加入同步队列的线程引用<br>Node nextWaiter;//等待队列中的下一个节点</p>
</blockquote>
<ul>
<li><strong>节点状态</strong></li>
</ul>
<p>节点的状态有以下这些：</p>
<blockquote>
<p>int CANCELLED =  1//节点从同步队列中取消<br>int SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；<br>int CONDITION = -2//当前节点进入等待队列中<br>int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去<br>int INITIAL = 0;//初始状态</p>
</blockquote>
<p>现在我们知道了节点的数据结构类型，并且每个节点拥有其前驱和后继节点，很显然这是<strong>一个双向队列</strong>。</p>
<p>同样的我们可以用一段demo看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//调用lock方法</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//别忘了解锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例代码中开启了5个线程，先获取锁之后再睡眠10S中，实际上这里让线程睡眠是想模拟出当线程无法获取锁时进入同步队列的情况。</p>
<p>通过debug，当Thread-4（在本例中最后一个线程）获取锁失败后进入同步时，AQS时现在的同步队列如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-d05d3f44ce4c205a.png" alt="LockDemo debug下 .png"></p>
<p>Thread-0先获得锁后进行睡眠，其他线程（Thread-1,Thread-2,Thread-3,Thread-4）获取锁失败进入同步队列，同时也可以很清楚的看出来每个节点有两个域：<strong>prev(前驱)和next(后继)</strong>，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。</p>
<p>另外AQS中有两个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>也就是说AQS实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-d05d3f44ce4c205a.png" alt="队列示意图.png"></p>
<p>通过对源码的理解以及做实验的方式，现在我们可以清楚的知道这样几点：</p>
<ol>
<li><strong>节点的数据结构，即AQS的静态内部类Node,节点的等待状态等信息</strong>；</li>
<li><strong>同步队列是一个双向队列，AQS通过持有头尾指针管理同步队列</strong>；</li>
</ol>
<p>那么，节点如何进行入队和出队是怎样做的了？实际上这对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。</p>
<h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><h5 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h5><p>在上面的demo中我们使用了<code>Lock.lock()</code>上了锁，其本质是获取<strong>独占锁</strong>，获取失败就将当前线程加入同步队列，成功则线程执行</p>
<p>lock()方法实际上会调用AQS的<strong>acquire()</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span></span><br><span class="line">		<span class="comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire根据当前获得同步状态成功与否做了两件事情：</p>
<ol>
<li>成功，则方法结束返回</li>
<li>失败，则先调用addWaiter()然后在调用acquireQueued()方法。</li>
</ol>
<blockquote>
<p><strong>获取同步状态失败，入队操作</strong></p>
</blockquote>
<p>当线程获取独占式锁失败后就会将当前线程加入同步队列，那么加入队列的方式是怎样的了？</p>
<p>我们接下来就应该去研究一下addWaiter()和acquireQueued()。addWaiter()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 将当前线程构建成Node类型</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 2. 当前尾节点是否为null？</span></span><br><span class="line">		Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 2.2 将当前节点尾插入的方式插入同步队列中</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可以看上面的注释。程序的逻辑主要分为两个部分：</p>
<p><strong>1. 当前同步队列的尾节点为null，调用方法enq()插入;</strong></p>
<p><strong>2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail（）方法）的方式入队。</strong></p>
<p>另外还会有另外一个问题：如果 <code>if (compareAndSetTail(pred, node))</code>为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环）进行重试。</p>
<p>因此，经过我们这样的分析，enq()方法可能承担两个任务：</p>
<ol>
<li><strong>处理当前同步队列尾节点为null时进行入队操作；</strong></li>
<li><strong>如果CAS尾插入节点失败后负责自旋进行尝试。</strong></li>
</ol>
<ul>
<li>enq()源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">			<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">				<span class="comment">//1. 构造头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 2. 尾插入，CAS操作失败自旋尝试</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的分析中我们可以看出在第1步中会先创建头结点，说明同步队列是<strong>带头结点的链式存储结构</strong>。</p>
<ul>
<li><strong>带头结点与不带头结点区别</strong></li>
</ul>
<p>带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。</p>
<ul>
<li><strong>队列初始化时机</strong></li>
</ul>
<p>那么带头节点的队列初始化时机是什么？自然而然是在<strong>tail为null时，即当前线程是第一次插入同步队列</strong>。compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，如果CAS操作失败会在<code>for (;;)</code>for死循环中不断尝试，直至成功return返回为止。</p>
<ul>
<li><strong>enq方法总结</strong></li>
</ul>
<p>因此，对enq()方法可以做这样的总结：</p>
<ol>
<li><strong>在当前线程是第一个加入同步队列时，调用compareAndSetHead(new Node())方法，完成链式队列的头结点的初始化</strong>；</li>
<li><strong>自旋不断尝试CAS尾插入节点直至成功为止</strong>。</li>
</ol>
<p>现在我们已经很清楚获取独占式锁失败的线程包装成Node然后插入同步队列的过程了。</p>
<p>那么紧接着会有下一个问题 —— 在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁呢？</p>
<p>带着这样的问题我们就来看看<code>acquireQueued()</code>方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">				<span class="comment">// 1. 获得当前节点的先驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">				<span class="comment">// 2. 当前节点能否获取独占式锁					</span></span><br><span class="line">				<span class="comment">// 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">					<span class="comment">//队列头指针用指向当前节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">					<span class="comment">//释放前驱节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;;)），代码首先获取当前节点的先驱节点，<strong>如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head &amp;&amp; tryAcquire(arg))），当前节点所指向的线程能够获取锁</strong>。</p>
<p>反之，获取锁失败进入等待状态。整体示意图为下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-3fe83cfaf03a02c8.png" alt="自旋获取锁整体示意图.png"></p>
<blockquote>
<p><strong>获取锁成功，出队操作</strong></p>
</blockquote>
<p>获取锁的节点出队的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头结点引用指向当前节点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">//释放前驱节点</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br></pre></td></tr></table></figure>

<p>setHead()方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前节点通过setHead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用，这样做方便GC时能够将内存进行回收。示意图如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-3fe83cfaf03a02c8.png" alt="当前节点引用线程获取锁，当前节点设置为队列头结点.png"></p>
<p>那么当获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法，看看他们做了什么事情。</p>
<p>shouldParkAfterFailedAcquire()方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法逻辑</strong></li>
</ul>
<p>shouldParkAfterFailedAcquire()方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由INITIAL设置成SIGNAL，表示当前线程阻塞。</p>
<p>当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire方法返回false，然后会在acquireQueued()方法中for (;;)死循环中会继续重试，直至compareAndSetWaitStatus设置节点状态位为SIGNAL时shouldParkAfterFailedAcquire返回true时才会执行方法<code>parkAndCheckInterrupt()</code>方法</p>
<p>该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使得该线程阻塞</span></span><br><span class="line">		LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的关键是会调用LookSupport.park()方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued()在自旋过程中主要完成了两件事情：</p>
<ol>
<li><strong>如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出</strong>；</li>
<li><strong>获取锁失败的话，先将节点状态设置成SIGNAL，然后调用LookSupport.park方法使得当前线程阻塞</strong>。</li>
</ol>
<ul>
<li>整体流程图</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="未命名文件 (1)"></p>
<h5 id="独占锁的释放"><a href="#独占锁的释放" class="headerlink" title="独占锁的释放"></a>独占锁的释放</h5><p>独占锁的释放就相对来说比较容易理解了，废话不多说先来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。</p>
<ul>
<li><strong>unparkSuccessor方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点的状态小于0，那么就用CAS去设置成0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取头节点的后继节点（也就是我们真正要去唤醒的节点）</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果后继结点为空 || 后继结点状态 &gt; 0 (为取消状态) 这两种都代表着后继结点都是无效的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//从尾结点开始查找状态不是取消的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//后继节点不为null时唤醒该线程，去竞争同步锁</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码的关键信息请看注释，首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark()方法，该方法会唤醒该节点的后继节点所包装的线程。因此，<strong>每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。</strong></p>
<p>到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。</p>
<ul>
<li><strong>独占锁总结</strong></li>
</ul>
<p>AQS的本质是去维护一个CLH同步队列，具体细节如下：</p>
<ol>
<li><strong>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试</strong>;</li>
<li><strong>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是<mark>头结点</mark>.并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞</strong>；</li>
<li><strong>释放锁的时候会唤醒后继节点；</strong></li>
</ol>
<p>总体来说：<strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p>
<blockquote>
<p><strong>独占锁特性学习</strong></p>
</blockquote>
<h5 id="可中断式获取锁（acquireInterruptibly方法）"><a href="#可中断式获取锁（acquireInterruptibly方法）" class="headerlink" title="可中断式获取锁（acquireInterruptibly方法）"></a>可中断式获取锁（acquireInterruptibly方法）</h5><p>我们知道lock相较于synchronized有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。</p>
<p>可响应中断式锁可调用方法<code>lock.lockInterruptibly();</code>而该方法其底层会调用AQS的<code>acquireInterruptibly</code>方法</p>
<ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">		<span class="comment">//线程获取锁失败</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在获取同步状态失败后就会调用<code>doAcquireInterruptibly</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//将节点插入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取锁出队</span></span><br><span class="line">			<span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">				<span class="comment">//线程中断抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键信息请看注释，现在看这段代码就很轻松了吧:),与acquire方法逻辑几乎一致、唯一的区别是当<strong>parkAndCheckInterrupt</strong>返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。</p>
<ul>
<li><strong>流程图</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210519202012102.png" alt="image-20210519202012102"></p>
<h5 id="超时等待式获取锁（tryAcquireNanos-方法）"><a href="#超时等待式获取锁（tryAcquireNanos-方法）" class="headerlink" title="超时等待式获取锁（tryAcquireNanos()方法）"></a>超时等待式获取锁（tryAcquireNanos()方法）</h5><p>通过调用lock.tryLock(timeout,TimeUnit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回false。</li>
</ol>
<p>我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用AQS的方法tryAcquireNanos(),源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">		<span class="comment">//实现超时等待的效果</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然这段源码最终是靠doAcquireNanos方法实现超时等待的效果，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//1. 根据超时时间和当前时间计算出截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">//2. 当前线程获得锁出队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 3.1 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 3.2 已经超时返回false</span></span><br><span class="line">			<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// 3.3 线程阻塞等待 </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 3.4 线程被中断抛出被中断异常</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-a80779d4736afb87.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p>
<p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上：</p>
<ol>
<li>在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据<code>deadline = System.nanoTime() + nanosTimeout</code>计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。</li>
<li>然后根据<code>deadline - System.nanoTime()</code>就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，<code>deadline - System.nanoTime()</code>计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。</li>
<li>如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过<strong>LockSupport.parkNanos</strong>使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。</li>
</ol>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><h5 id="共享锁的获取（acquireShared-方法）"><a href="#共享锁的获取（acquireShared-方法）" class="headerlink" title="共享锁的获取（acquireShared()方法）"></a>共享锁的获取（acquireShared()方法）</h5><p>在聊完AQS对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireShared，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//获取锁失败，则自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码的逻辑很容易理解，在该方法中会首先调用tryAcquireShared方法，tryAcquireShared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行<code>doAcquireShared</code>方法，</p>
<p>该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加共享模式节点到队列之中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱结点为head结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试去获取共享同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 返回值&gt;=0，表示获取同步锁成功了</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 当该节点的前驱节点是头结点且成功获取同步状态</span></span><br><span class="line">                    <span class="comment">// 那么接下来就会将把当前结点设置为头结点，释放共享同步状态，唤醒下一个节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享锁的获取逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件<strong>是当前节点的前驱节点是头结点并且tryAcquireShared(arg)返回值大于等于0（表示获得了锁）即能成功获得同步状态</strong>。</p>
<h5 id="共享锁的释放（releaseShared-方法）"><a href="#共享锁的释放（releaseShared-方法）" class="headerlink" title="共享锁的释放（releaseShared()方法）"></a>共享锁的释放（releaseShared()方法）</h5><ul>
<li><strong>背景</strong></li>
</ul>
<p>在<code>setHeadAndPropagate(node, r);</code>方法中，代码功能分为两部分：</p>
<ol>
<li>设置头结点</li>
<li>释放同步状态，唤醒下一个节点，其中的释放同步状态就使用了<code>releaseShared</code>方法</li>
</ol>
<p>共享锁的释放在AQS中会调用方法<code>releaseShared</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当成功释放同步状态之后即tryReleaseShared会继续执行doReleaseShared方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 自旋释放共享同步状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 若头结点不为空 且 头结点不等于尾结点 说明存在【有效】node节点 （因为我们是带头结点的链表）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 若头结点状态为signal，表示存在需要唤醒的后继结点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//将头结点状态更新为 0（初始值状态），因为头结点此时没用了，需要去释放同步锁了</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">// continue为了保证替换成功</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态为初始值状态0，那么久设置成PROPAGATE状态</span></span><br><span class="line">            <span class="comment">// 作用： 确保在释放同步状态的时候能去通知后继结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试。</p>
<h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock - 可重入锁"></a>ReentrantLock - 可重入锁</h2><h3 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h3><p>ReentrantLock重入锁，是基于<mark>AQS</mark>同时实现<mark>Lock接口</mark>的一个类，在并发编程的时候实现<strong>公平锁和非公平锁</strong>两种方式对共享资源进行同步。</p>
<p><strong>重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</strong></p>
<p>在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。</p>
<p>要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：</p>
<ol>
<li>重入性的实现原理</li>
<li>公平锁和非公平锁</li>
</ol>
<h3 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h3><p>要想支持重入性，就要解决两个问题：</p>
<p><strong>1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；</strong></p>
<p><strong>2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。</strong></p>
<p>通过[AQS](# AbstractQueuedSynchronizer（AQS)的学习，我们知道，同步组件主要是通过重写AQS的几个protected方法来表达自己的同步语义。针对第一个问题，我们来看看ReentrantLock是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为<code>nonfairTryAcquire</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//占用锁成功,设置独占线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新state值为新的重入次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑也很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为tryRelease：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑看注释</p>
<ul>
<li><strong>注意点</strong></li>
</ul>
<p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。因此，return的值并不是代表有没有释放成功，而是代表有没有完全释放！</p>
<p>到现在我们可以理清ReentrantLock重入性的实现了，也就是理解了同步语义的第一条。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><ol>
<li>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<strong>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO</strong>。</li>
</ol>
<blockquote>
<p><strong>公平锁  VS  非公平锁</strong></p>
</blockquote>
<ol>
<li><p>公平锁每次获取到锁为同步队列中的第一个节点，<strong>保证请求资源时间上的绝对顺序</strong>，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</p>
</li>
<li><p>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</p>
</li>
</ol>
<blockquote>
<ul>
<li><strong>公平锁</strong>：按照请求锁的顺序分配，拥有稳定获得锁的机会，但是性能可能比非公平锁低</li>
<li><strong>非公平锁</strong>：不按照请求锁的顺序分配，不一定拥有获得锁的机会，但是性能可能比公平锁高</li>
</ul>
</blockquote>
<ul>
<li><strong>非公平锁源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过CAS获取锁（一次机会，并不是无限自旋获取）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// CAS获取失败了，则调用AQS的acquire方法获取锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用非公平锁，插队获取</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>公平锁源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类AQS的acquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ReentrantLock的构造方法无参时是构造<strong>非公平锁</strong>，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面非公平锁获取时（nonfairTryAcquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看<strong>公平锁</strong>的处理逻辑是怎样的，核心方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 锁状态空闲</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过CAS原子性更改state,更改成功，表示成功获取锁，将当前线程设置为独占线程</span></span><br><span class="line">        <span class="comment">// 判断当前同步队列中有没有排在当前线程之前的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁状态不空闲，再判断是不是独占线程（因为可能是一个线程多个锁，可重入锁嘛）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 进行状态的累加</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断重入次数，如果&lt;0，则表示超出次数了（int 最大值2147483647）</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑与nonfairTryAcquire基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。</p>
<p>如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。<strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong>。</p>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock - 读写锁"></a>ReentrantReadWriteLock - 读写锁</h2><h3 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//同步类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">       </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//调用同步器 获取共享锁</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">               <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> r = sync.getReadLockCount();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">               <span class="string">&quot;[Read locks = &quot;</span> + r + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h4><p>它的各种代码都与AQS的没太大变化，我们关心一下其独特的部分：<code>tryAcquireShared</code>方法</p>
<ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        	<span class="comment">// 当前线程获取读锁失败返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位。</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);  c &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="comment">// !readerShouldBlock() 和写锁的逻辑一样（根据公平与否策略和队列是否含有等待节点）</span></span><br><span class="line">    <span class="comment">// 不能大于 65535，且 CAS 修改成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">		<span class="comment">//2. 当前线程获取读锁</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">		<span class="comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span></span><br><span class="line">		<span class="comment">//返回当前获取读锁的次数</span></span><br><span class="line">        <span class="comment">// 如果锁次数为0，表示读锁空闲，获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 把读锁交给当前线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 锁计数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果锁不是空闲的，且当前线程是第一个读线程，代表着重入；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 持有的读锁数量自增1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果都不是，就代表不是第一个节点</span></span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程，那么就新建一个 HoldCounter 对象</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 给当前线程新建一个 HoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 如果不是 null，且 count 是 0，就将上个线程的 HoldCounter 覆盖本地的。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 对 count 加一</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回大于0的数，表示获取到了共享锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程：</p>
<ol>
<li>step1：如果写锁被获取，直接获取资源<code>acquire</code>失败（返回 -1）。</li>
<li>step2：写锁没被获取，则首先根据 <code>queue policy</code>（公平锁或非公平锁） 判断一下要不要阻塞。不需要阻塞则有其次，通过修改 原子<code>state</code> 来尝试获取资源，成功则要修改一下<strong>重入计数</strong>。</li>
<li>step3：上面的都失败了，则进入到<code>fullTryAcquireShared</code>中。</li>
</ol>
<ul>
<li><strong>exclusiveCount(c) 与 sharedCount(c)</strong></li>
</ul>
<p><code>exclusiveCount(c)</code>方法，其源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数表达的意思是：</p>
<p><code>c &amp; EXCLUSIVE_MASK != 0</code>，<code>c</code> 是我们的 原子<code>state</code>，如果 <code>c</code> 和 <code>EXCLUSIVE_MASK</code> 按位与后<strong>不为零</strong>，代表无权获取资源，即已经有线程持有了写锁。</p>
<p>其中<strong>EXCLUSIVE_MASK</strong>为:  <code>static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code>      EXCLUSIVE _MASK为1左移16位然后减1，即为0x0000FFFF（二进制的1111 1111，即十进制的255）。</p>
<p>而exclusiveCount方法是将同步状态（state为int类型）与0x0000FFFF相与，即取同步状态的低16位。那么低16位代表什么呢？根据exclusiveCount方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论<strong>同步状态的低16位用来表示写锁的获取次数</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/ba54d59b3442b6d10c38f7160456076b121.jpg" alt="位与图示"></p>
<p><strong>那么问题就来了，为什么高位不需要做判断呢？</strong>别急，往下看。</p>
<p><code>sharedCount(c)</code>方法，其源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure>

<p>该方法是获取读锁被获取的次数，是将同步状态（int c）右移16次，即取同步状态的高16位，现在我们可以得出另外一个结论<strong>同步状态的高16位用来表示读锁被获取的次数</strong>。读写锁是怎样实现分别记录读锁和写锁的状态的，现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-6af1818bbfa83051.png" alt="读写锁的读写状态设计.png"></p>
<blockquote>
<p><strong>读写锁共用一个 原子<code>state</code>，但读锁控制高 16 位，写锁控制低 16 位。</strong> 对于写锁来说，低 16 位都为 0 代表没有持锁，只要有一个 1 ，则代表某线程已经持有写锁。</p>
</blockquote>
<ul>
<li><strong>fullTryAcquireShared</strong>方法</li>
</ul>
<p>这个方法与<code>tryAcquireShared</code>高度类似，代码逻辑在注释中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这段代码与tryAcquireShared中的代码有部分重复，但整体更简单。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//判断是不是有线程持有写锁了</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若不是当前线程持有写锁，则获取读锁失败，反之，如果持有写锁的是当前线程，那么就会进入下面的逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果写锁空闲，且可以获取读锁。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 这里的代码逻辑是用于处理【读锁重入】的</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 从 ThreadLocal 中取出计数器。get方法会执行初始化</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                         <span class="comment">// 如果count == 0，表示是由上一行代码初始化的，进行remove操作</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// return -1，去排队</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果读锁次数达到 65535 ，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试对 state 加 65536, 也就是设置读锁，实际就是对高16位加一。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁是空闲的</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置第一个读锁</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// 计数器为 1</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果不是空闲的，查看第一个线程是否是当前线程。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// 这里代表着锁重入</span></span><br><span class="line">                firstReaderHoldCount++;<span class="comment">// 更新计数器</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 自己创建一个，get方法会执行初始化</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 对计数器 ++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">// 更新缓存计数器。</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回大于0的数，表示获取到了锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>firstReader</code> 是获取读锁的第一个线程。如果只有一个线程获取读锁，很明显，使用这样一个变量速度更快。</li>
<li><code>firstReaderHoldCount</code>是 <code>firstReader</code>的计数器。同上。</li>
<li><code>cachedHoldCounter</code>是最后一个获取到读锁的线程计数器，每当有新的线程获取到读锁，这个变量都会更新。这个变量的目的是：当最后一个获取读锁的线程重复获取读锁，或者释放读锁，就会直接使用这个变量，速度更快，相当于缓存。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>图解流程</strong></p>
<p>发现了没？我们获取读锁的时候根本不关心读锁有没有被获取，因此从这点也可以知道读锁的共享锁，也就是允许 读 - 读 的场景，而不允许 读 -写 的场景。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/4236553-c747934c55844272.png" alt="img"></p>
<h4 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h4><p>读锁释放的实现主要通过方法<code>tryReleaseShared</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 前面还是为了实现getReadHoldCount等新功能</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">//如果计数器等于1，那么此次解锁之后就不会再持有锁了</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// firstReader 置为null，留给后面的线程用</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果不为1，表示被重入了，就减-1</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 判断 cachedHoldCounter 中是否缓存的是当前线程，不是的话就需要用get，到ThreadLoacl中获取</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 ThreadLoacl remove掉，防止内存泄漏，因为此时当前线程已经不再持有锁了</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 防止有些人lock一次，unlock很多次，导致count变为负数</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程持有读锁的数量 - 1</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">		<span class="comment">// 读锁释放 将同步状态减去读状态即可</span></span><br><span class="line">        <span class="comment">// 即：nextc 为 state高16位减1 后的值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="comment">// nextc == 0，表示state 32位全部为0 ，表示读锁写锁全为空</span></span><br><span class="line">            <span class="comment">// 若返回true，则帮助唤醒后继节点中获取写锁的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回想一下重入锁，重入锁每次释放资源使得 原子<code>state</code> - -，当 原子<code>state</code> 为零时，则唤醒队列中下一个等待的线程。</p>
<p>读锁实际上也是如此，但要注意读锁是有两个状态来维护锁的层级和持有共享锁的线程数量的：</p>
<ul>
<li>一个是 <code>HoldCounter</code> 负责重入计数，</li>
<li>一个是 原子<code>state</code>高位，负责记录有多少个线程持有了共享锁。</li>
</ul>
<p>也就是说，我们释放资源<code>release</code>时，需要首先使得 <code>HoldCounter--</code>，直到其为零，再去操作 原子<code>state</code>高位。</p>
<p>最后，直到原子<code>state</code>高位归零了，就去唤醒下一个等待的线程。</p>
<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread o = sync.getOwner();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + ((o == <span class="keyword">null</span>) ?</span><br><span class="line">                                   <span class="string">&quot;[Unlocked]&quot;</span> :</span><br><span class="line">                                   <span class="string">&quot;[Locked by thread &quot;</span> + o.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 1. 获取写锁当前的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">// 2. 获取写锁获取的次数,即state中写锁（状态）的值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 翻译：state不为0，写状态为0，则表示读状态不为0，表示读锁已被获取</span></span><br><span class="line">		<span class="comment">// 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话（判断是不是重入的）防止 读 - 写，和写 - 写</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">         <span class="comment">// 当前线程获取写锁失败，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁拥有的是state的【低16位】，这里进行校验是否大于其16位能表示的数据范围</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 代码进行到这里，能保证写锁状态不为0，且当前线程是已经获取写锁的线程，即支持可重入</span></span><br><span class="line">		<span class="comment">// 3.2 当前线程获取写锁，支持可重复加锁</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// writerShouldBlock 非公平锁永远返回false，即可以插入获取，不必阻塞</span></span><br><span class="line">    <span class="comment">// 而公平锁则需要检验前一个节点是否为头结点</span></span><br><span class="line">	<span class="comment">// 3.3 写锁未被任何线程获取，当前线程可获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 设置为当前线程持有</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回过头来看写锁获取方法tryAcquire，其主要逻辑为：<strong>当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。</strong></p>
<h4 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁的释放是线程安全的，因为写锁是独占锁，具有排他性（一次只能有一个线程拥有）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="comment">//1. 同步状态减去写状态</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">	<span class="comment">//2. 当前写状态是否为0，为0则释放写锁（这里的 0,是包括可重入的，即所有的写锁都是被释放了的</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//3. 不为0则更新同步状态</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="comment">// 返回 true的话，会进行唤醒后继节点的操作</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，减少写状态<code>int nextc = getState() - releases;</code>只需要用<strong>当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的</strong>。</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><ul>
<li><p><strong>锁降级指的是写锁降级成为读锁</strong>。</p>
<ul>
<li>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程<mark>不能</mark>称之为锁降级。</li>
<li><strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></li>
</ul>
<p>(有锁降级，那有没有锁升级呢？答案是没有的)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;  <span class="comment">// update使用volatile修饰，使得其他线程均能实时访问</span></span><br><span class="line">        <span class="comment">// 必须先释放读锁（如果不释放读锁就去获取写锁就会发生死锁）</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 然后获取写锁(锁降级从获取写锁开始)</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123; </span><br><span class="line">                <span class="comment">// 准备数据的流程(略)</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();  <span class="comment">// 持有写锁的同时，获取读锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ֵ使用数据的流程(略)</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>细节解析：</p>
<ol>
<li>update变量用volatile修饰，使得所有访问 processData() 方法的线程都能够感知到变化，保证了可见性</li>
<li>只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。</li>
<li>当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。</li>
</ol>
<ul>
<li><p>问题：</p>
<ul>
<li><p>锁降级中的读锁的获取是否是必须？</p>
</li>
<li><p>是必须的，为了保证数据的可见性。怎么保证呢？假如现在有一个线程A他拥有写锁，现在要释放该写锁。但他不先去获得读锁，就直接释放了写锁。这就导致了一个问题，有另一个线程B，它获取了你释放掉的写锁，去修改了数据，但A线程是无法感知到这个数据被修改了的，就会导致一些错误。</p>
<p>但假如遵循锁降级步骤，释放写锁前获得了读锁，那么线程B在获取该写锁的时候就会阻塞，直到线程A把数据处理完了，真正释放了读锁后，才能轮到线程B去进行相应的写锁获取流程。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><strong>Condition用途</strong></li>
</ul>
<p>当多个线程需要访问一个共享资源时，需要给共享资源加锁。 当一个线程释放锁时，所有等待锁的线程都会尝试去获取锁。 但是如果想只让部分等待锁的线程去获取锁时，就需要用到<strong>Condition</strong>。</p>
<ul>
<li><strong>整体分析</strong></li>
</ul>
<p>从整体上来看<strong>Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。</p>
<p>Condition具体实现在AbstractQueuedSynchronizer类中。这个类中管理了一个阻塞队列和N多个条件队列。</p>
<p>阻塞队列记录了等待获取锁的线程，头结点记录了当前正在运行的线程。</p>
<p>条件队列记录了由Condition.await()阻塞的线程，一个Lock可以有多个Condition,每个Condition是一个队列。</p>
<p>Condition是AbstractQueuedSynchronizer的一个内部类ConditionObject,所以创建的Condition对象是可以访问整个AbstractQueuedSynchronizer对象的属性的，通过这样将Condition与Lock相关联。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><ul>
<li><strong>前言</strong></li>
</ul>
<p>Condition是AQS的内部类，准确的来说创建一个condition对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会new出一个<strong>ConditionObject</strong>对象，而这个<strong>ConditionObject</strong>对象是AQS的一个内部类。</p>
<blockquote>
<p>前面我们说过，Condition是要和lock配合使用的也就是condition和Lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。</p>
</blockquote>
<ul>
<li><strong>等待队列</strong></li>
</ul>
<p>每个Condition对象都包含一个条件队列 (等待队列)。</p>
<p><strong>等待队列是一个FIFO的队列</strong>，在队列中的每个节点Node都包含了一个线程引用，该线程就是在Condition对象上等待的线程。</p>
<p>详细来说的话：如果是独占式锁的话，所有获取锁失败的线程的尾插入到<strong>同步队列</strong>，同样的，Condition内部也是使用同样的方式，内部维护了一个 <strong>等待队列</strong>，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。</p>
<ul>
<li><strong>ConditionObject中两个成员变量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以看出来ConditionObject通过持有等待队列的头尾指针来管理等待队列。</p>
<ul>
<li><strong>等待队列为单向队列</strong></li>
</ul>
<p>值得注意的是Node类复用了在AQS中的Node类，而Node类有这样一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后继节点</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>这说明 ，<strong>等待队列是一个单向队列</strong>，而学习AQS的时候我们学习到了，<strong>同步队列是双向队列</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210522212045608.png" alt="image-20210522212045608"></p>
<ul>
<li><strong>一个Lock可以持有多个等待队列</strong></li>
</ul>
<p>我们可以多次调用lock.newCondition()方法创建多个condition对象，<strong>也就是一个lock可以持有多个等待队列</strong>。而在之前利用Object的方式实际上是指在<strong>对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列</strong>。</p>
<p>需要注意概念混淆的问题：同步队列是在同步的环境下才有的概念，一个对象（即一个锁）永远只对应一个同步队列。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-6621181fc19603c2.png" alt="AQS持有多个Condition.png"></p>
<p>如图所示，ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<p>那么为什么每个并发包的同步器需要有多个等待队列呢？有什么作用呢？</p>
<p>因为AQS可以实现排他锁（ReentrantLock）和非排他锁（ReentrantReadWriteLock——读写锁），读写锁就是一个需要多个等待队列的锁。等待队列（Condition）用来保存被阻塞的线程的。因为读写锁是一对锁，所以需要两个等待队列来分别保存被阻塞的读锁和被阻塞的写锁。</p>
<h4 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h4><ul>
<li><strong>await流程</strong></li>
</ul>
<p><strong>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，并且释放锁</strong>。</p>
<blockquote>
<p>注意点：当该方法返回时，当前线程一定获取了同步状态（锁）；</p>
<p>具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await()</code>方法返回，而唤醒该线程后会加入同步队列</p>
</blockquote>
<ul>
<li><strong>await源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//当前线程如果中断抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">	<span class="comment">// 1. 将当前线程包装成Node，尾插入到等待队列中 - 这里的等待队列是一个【单向链表】</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">	<span class="comment">// 2. 释放当前线程所占用的lock（用await之前当前线程是占有锁的）</span></span><br><span class="line">    <span class="comment">// 在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// isOnSyncQueue用于判断线程是否在同步队列中，第一次判断为false,因为线程已经释放了</span></span><br><span class="line">	<span class="comment">// 释放完毕后,遍历AQS队列,看当前节点是否在同步队列中,</span></span><br><span class="line">	<span class="comment">// 如果不在,说明它还没有竞争锁的资格,继续等待 ;直到被加入到队列(singal)</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">		<span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 线程被挂起,阻塞在这个位置</span></span><br><span class="line">　　	   <span class="comment">// 判断线程被打断后,退出循环。</span></span><br><span class="line">	    <span class="comment">// 该方法的返回值代表当前线程是否在 park 的时候被中断唤醒</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="comment">// 下面是细节：</span></span><br><span class="line">    <span class="comment">//被唤醒后,重新开始正式竞争锁,如果竞争不到还是会将自己沉睡,等待唤醒重新开始竞争</span></span><br><span class="line">	<span class="comment">//acquireQueued: 该方法的功能是循环的尝试获取锁, 如果返回false就表示拿到锁了	</span></span><br><span class="line">	<span class="comment">// interruptMode !=THROW_IE 表示这个线程没有成功将node入队，但signal执行了enq方法让其入队了 ,将这个变量设置成 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果 node 的下一个等待者不是 null, 则进行清理,清理 Condition 队列上的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">	<span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码整体流程：</p>
<p><strong>当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong>。</p>
<ul>
<li><strong>细节/问题</strong></li>
</ul>
<p>那么关于这个实现过程我们会有这样几个问题：</p>
<ol>
<li>是怎样将当前线程添加到等待队列中去的？</li>
<li>释放锁的过程？</li>
<li>怎样才能从await方法退出？</li>
</ol>
<p>要回答这几个问题，我们就需要去注意这几个方法：</p>
<p><code>addConditionWaiter</code> <code>unlinkCancelledWaiters()</code> <code>fullyRelease(Node node)</code> <code>isOnSyncQueue(Node node)</code></p>
<ul>
<li><strong>addConditionWaiter方法 - 线程添加到等待队列</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 翻译：如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清空所有等待队列中 状态不为Condition的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 将最新的尾结点赋值</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">	<span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的流程是：</p>
<p>首先判断尾结点状态，如果尾结点已经中断的话，那么我们就不应该把当前线程包装成节点，接在它的后面，因此需要调用<code>unlinkCancelledWaiters</code>去剔除等待队列中所有的已经中断或已经释放同步状态的线程节点。</p>
<p>接着，将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node，</p>
<p>否则，更新lastWaiter(尾节点)即可,即<strong>通过尾插入的方式将当前线程封装的Node插入到等待队列中即可</strong>，同时可以看出等待队列是一个<strong>不带头结点的链式队列</strong>，之前我们学习AQS时知道同步队列<strong>是一个带头结点的链式队列</strong>，这是两者的一个区别。</p>
<p>将当前节点插入到等待对列之后，会使当前线程释放lock，由<code>fullyRelease</code>方法实现</p>
<ul>
<li><strong>unlinkCancelledWaiters()方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//获取等待队列中的头节点</span></span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//遍历等待队列，将已经中断的线程节点从等待队列中移除。</span></span><br><span class="line">          <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//重新定义lastWaiter的指向</span></span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>方法流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-fd08ef7d8f05fbe5.png" alt="img"></p>
<ul>
<li><strong>fullyRelease方法 - 释放锁的方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">			<span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑：</p>
<p><strong>调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</strong>，如果释放成功则正常返回，若失败的话就抛出异常。</p>
<ul>
<li><strong>isOnSyncQueue(Node node)</strong></li>
</ul>
<p>该方法主要用于判断当前线程节点是否在【同步队列】中。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断当前节点 waitStatus ==Node.CONDITION或者当前节点上一节点为空,则不在同步队列中</span></span><br><span class="line">      <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//如果当前节点拥有下一个节点，则在同步队列中。</span></span><br><span class="line">      <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//如果以上条件都不满足，则遍历同步队列。检查是否在同步队列中。</span></span><br><span class="line">      <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果你还记得AQS中的同步队列，那么你应该知道同步队列中的Node节点才会使用其内部的<code>pre</code>与<code>next</code>字段，那么在同步队列中因为只使用了<code>nextWaiter</code>字段，所以我们就能很简单的通过这两个字段是否为<code>==null</code>，来判断是否在同步队列中。</p>
<p>当然也有可能有一种特殊情况：有可能需要阻塞的线程节点还没有加入到同步队列中，那么这个时候我们需要遍历同步队列来判断是该线程节点是否已存在。</p>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node p = tail;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (p == node)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           p = p.prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里为什么是从尾结点向前遍历呢？思考一下，这个方法是用于找哪种线程节点的呢？是找那种还没有加入到同步队列中的线程，这种线程是独立的一个节点，它并没有被连接在任何一个在同步队列中的线程后面，因此，我们需要从后往前找，找到一个<code>node.next == null</code>的，就代表他不在同步队列中，反之，他在同步队列中。</p>
<ul>
<li><strong>如何从await方法退出</strong></li>
</ul>
<p>学习了上面几个方法，我们也可以回答这第三个问题了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">	<span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：</p>
<p><strong>1. 逻辑走到break退出while循环；</strong></p>
<p><strong>2. while循环中的逻辑判断为false</strong>。</p>
<p>那么下面就分点讨论这两种情况该如何实现：</p>
<ol>
<li>当前等待的线程被中断后，代码就会走到 <code>break</code>处退出</li>
<li>当前节点被移动到了<strong>【同步队列】</strong>中（即另外线程调用的condition的signal或者signalAll方法），此时while循环中判断结果就会为false，结束循环</li>
</ol>
<p>总结下，就是<strong>当前线程被中断或者调用condition.signal/condition.signalAll方法当前节点移动到了同步队列后</strong> ，这是当前线程退出await方法的前提条件。当退出while循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在<strong>自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）</strong>。这样也说明了<strong>退出await方法必须是已经获得了condition引用（关联）的lock</strong>。</p>
<ul>
<li><strong>图解阻塞流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-fbdd2f637ac198f9.png" alt="img"></p>
<ol>
<li>将该线程节点从同步队列中移除，并释放其同步状态。</li>
<li>构造新的阻塞节点，加入到等待队列中。</li>
</ol>
<h4 id="signal-signalAll实现原理"><a href="#signal-signalAll实现原理" class="headerlink" title="signal/signalAll实现原理"></a>signal/signalAll实现原理</h4><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。</strong></p>
<p>按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。</p>
<p><code>signal</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 先检测当前线程是否已经获取lock</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//2. 获取等待队列中第一个节点，将其移入同步队列，接着对该结点进行操作</span></span><br><span class="line">	Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了两个方法：</p>
<ol>
<li><strong>isHeldExclusively()方法</strong></li>
<li><strong>doSignal(first)方法</strong></li>
</ol>
<p>下面对这两个方法进行学习</p>
<ul>
<li><strong>isHeldExclusively()方法</strong></li>
</ul>
<p><code>isHeldExclusively()</code>方法是AQS中的方法，默认交给其子类实现，主要用于判断当前调用<code>singal()</code>方法的线程，是否在同步队列中，且已经获取了同步状态。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>doSignal(first)方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">//（1）将等待队列中的首节点从等待队列中移除，并重新制定firstWaiter的指向</span></span><br><span class="line">           <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">               lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">           first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">       <span class="comment">//（2）将等待队列中的首节点，加入同步队列中，并重新唤醒该节点</span></span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将等待队列中的首节点从等待队列中移除，并设置firstWaiter的指向为首节点的下一个节点</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-416aebe1f25d17f0.png" alt="img"></p>
</li>
<li><p>通过 <code>transferForSignal(Node node)</code>方法，将等待队列中的首节点，加入到同步队列中去，然后重新唤醒该线程节点。</p>
</li>
</ol>
<ul>
<li><h5 id="transferForSignal-Node-node-方法"><a href="#transferForSignal-Node-node-方法" class="headerlink" title="transferForSignal(Node node)方法"></a>transferForSignal(Node node)方法</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了</span></span><br><span class="line">    <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//（2）将该节点放入同步队列中，</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//（3）获取当前节点的状态并判断，尝试将该线程节点状态设置为Singal，如果失败则唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键逻辑请看注释，这段代码主要做了两件事情</p>
<ol>
<li>将头结点的状态更改为CONDITION；</li>
<li>调用enq方法，将该节点尾插入到同步队列中；</li>
<li>当将该线程节点放入同步队列后，获取当前节点的状态并判断，如果该节点的<code>waitStatus&gt;0</code>或者通过<code>compareAndSetWaitStatus(ws, Node.SIGNAL)</code>将该节点的状态设置为Singal，如果失败则通过<code>LockSupport.unpark(node.thread)</code>唤醒线程。</li>
</ol>
<ul>
<li><strong>结论</strong></li>
</ul>
<p><strong>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出</strong>。</p>
<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-694a82e957dce046.png" alt="img"></p>
<h4 id="await与signal结合"><a href="#await与signal结合" class="headerlink" title="await与signal结合"></a>await与signal结合</h4><p>await和signal和signalAll方法就像一个开关控制着线程A（等待方）和线程B（通知方）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-02449dc316fe1de6.png" alt="condition下的等待通知机制.png"></p>
<p>如图，<strong>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列</strong>。</p>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread waiter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> waiter());</span><br><span class="line">        waiter.start();</span><br><span class="line">        Thread signaler = <span class="keyword">new</span> Thread(<span class="keyword">new</span> signaler());</span><br><span class="line">        signaler.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前条件不满足等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;接收到通知条件满足&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">signaler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<blockquote>
<p>Thread-0当前条件不满足等待<br>Thread-0接收到通知，条件满足</p>
</blockquote>
<ul>
<li><strong>代码流程</strong></li>
</ul>
<p>开启了两个线程waiter和signaler，waiter线程开始执行的时候由于条件不满足，执行condition.await方法使该线程进入等待状态同时释放锁，signaler线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter线程获取到锁，并由于signaler线程更改了条件此时相对于waiter来说条件满足，继续执行。</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Cannot be instantiated.</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象。</span></span><br><span class="line"><span class="comment">     * 如果该调用不受阻塞，则返回 null。</span></span><br><span class="line"><span class="comment">     * 返回的值只是一个瞬间快照，即由于未解除阻塞或者在不同的 blocker 对象上受阻而具有的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果给定线程的许可尚不可用，则使其可用。</span></span><br><span class="line"><span class="comment">     * 如果线程在 park 上受阻塞，则它将解除其阻塞状态。</span></span><br><span class="line"><span class="comment">     * 否则，保证下一次调用 park 不会受阻塞。</span></span><br><span class="line"><span class="comment">     * 如果给定线程尚未启动，则无法保证此操作有任何效果。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread: 要执行 unpark 操作的线程；该参数为 null 表示此操作没有任何效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了线程调度，在许可可用之前阻塞当前线程。 </span></span><br><span class="line"><span class="comment">     * 如果许可可用，则使用该许可，并且该调用立即返回；</span></span><br><span class="line"><span class="comment">     * 否则，为线程调度禁用当前线程，并在发生以下三种情况之一以前，使其处于休眠状态：</span></span><br><span class="line"><span class="comment">     *  1. 其他某个线程将当前线程作为目标调用 unpark</span></span><br><span class="line"><span class="comment">     *  2. 其他某个线程中断当前线程</span></span><br><span class="line"><span class="comment">     *  3. 该调用不合逻辑地（即毫无理由地）返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，不过增加了等待的相对时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>)</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，不过增加了等待的绝对时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parkNanos(long nanos)方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            setBlocker(t, blocker);</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">            setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parkUntil(long deadline)方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextSecondarySeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> ((r = UNSAFE.getInt(t, SECONDARY)) != <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((r = java.util.concurrent.ThreadLocalRandom.current().nextInt()) == <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">1</span>; <span class="comment">// avoid zero</span></span><br><span class="line">        UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSeed&quot;</span>));</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSecondarySeed&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap简介"><a href="#ConcurrentHashMap简介" class="headerlink" title="ConcurrentHashMap简介"></a>ConcurrentHashMap简介</h3><p>在使用HashMap时在多线程情况下扩容会出现CPU接近100%的情况，因为Hashmap并不是线程安全的，通常我们可以使用在java体系中古老的hashtable类，该类基本上所有的方法都采用synchronized进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。</p>
<p>另外一种方式通过Collections的<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code>将hashmap包装成一个线程安全的map。比如SynchronzedMap的put方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上SynchronizedMap实现依然是采用synchronized独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。</p>
<p>相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中<strong>利用了锁分段的思想提高了并发度</strong>。</p>
<ul>
<li><strong>JDK 1.6版本关键要素</strong></li>
</ul>
<ol>
<li>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；</li>
<li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。</li>
</ol>
<ul>
<li><strong>JDK 1.8版本关键要素</strong></li>
</ul>
<p>1.8版本舍弃了segment，并且大量使用了synchronized，以及CAS无锁操作以保证ConcurrentHashMap操作的线程安全性。</p>
<p>至于为什么不用ReentrantLock而是Synchronzied呢？实际上，synchronzied做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用synchronized相较于ReentrantLock的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。</p>
<p>另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。（之前是数组 + 链表的形式）</p>
<h3 id="关键属性-amp-类"><a href="#关键属性-amp-类" class="headerlink" title="关键属性 &amp; 类"></a>关键属性 &amp; 类</h3><p>在了解ConcurrentHashMap的具体方法实现前，我们需要系统的来看一下几个关键的地方。</p>
<blockquote>
<p><strong>ConcurrentHashMap的关键属性</strong></p>
</blockquote>
<ol>
<li><p><strong>table</strong><br>volatile Node&lt;K,V&gt;[] table://装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</p>
</li>
<li><p><strong>nextTable</strong><br>volatile Node&lt;K,V&gt;[] nextTable; //扩容时使用，平时为null，只有在扩容的时候才为非null</p>
</li>
<li><p><strong>sizeCtl</strong><br><code>volatile int sizeCtl;</code></p>
<blockquote>
<p>（Ctl的意思Control，从sizeControl也可以明白这个变量的作用了）</p>
<p><code>sizeCtl</code>为0，代表数组未初始化， 且数组的初始容量为16</p>
<p><code>sizeCtl</code>为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值（数组的初始容量*0.75【加载因子】）</p>
<p><code>sizeCtl</code>为-1，表示数组正在进行初始化，如果为-N则表示当前正有N-1个线程进行扩容操作；</p>
<p><code>sizeCtl</code>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操作</p>
</blockquote>
</li>
<li><p><strong>sun.misc.Unsafe U</strong><br>在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而CAS操作依赖于现代处理器指令集，通过底层<strong>CMPXCHG</strong>指令实现。CAS(V,O,N)核心思想为：<strong>若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，在进行重试</strong>。而在大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">		.......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p><strong>ConcurrentHashMap中关键内部类</strong></p>
</blockquote>
<ol>
<li><p><strong>Node</strong><br>Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。</p>
<ol start="2">
<li><p><strong>TreeNode</strong><br>树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeBin</strong><br>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ForwardingNode</strong><br>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p><strong>CAS关键操作</strong></p>
</blockquote>
<p>在上面我们提及到在ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作。因此，在理解ConcurrentHashMap的方法前我们需要了解下面几个常用的利用CAS算法来保障线程安全的操作。</p>
<ol>
<li><p><strong>tabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用来获取table数组中索引为i的Node元素。</p>
</li>
<li><p><strong>casTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 利用CAS操作设置table数组中索引为i的元素</p>
</li>
<li><p><strong>setTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 该方法用来设置table数组中索引为i的元素</p>
</li>
</ol>
<h3 id="容器初始化方法"><a href="#容器初始化方法" class="headerlink" title="容器初始化方法"></a>容器初始化方法</h3><h4 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h4><blockquote>
<p>在jdk8的ConcurrentHashMap中一共有5个构造方法，这四个构造方法中都没有对内部的数组做初始化， 只是对一些变量的初始值做了处理</p>
<p>jdk8的ConcurrentHashMap的数组初始化是在第一次添加元素时完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity) </span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无参构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有维护任何变量的操作，如果调用该方法，数组长度默认是16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带参构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递进来一个初始容量，ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量</span></span><br><span class="line"><span class="comment">// 比如你传32，右移1位（除以2）得到16，最后的sizeCtl = （32 + 16 + 1）→ 向上取最近的2的n次方 = 49 → 向上取最近的2的n次方 = 64</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    	<span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，调用这个方法，得到的初始容量和我们之前讲的HashMap以及jdk7的ConcurrentHashMap不同，即使你传递的是一个2的幂次方数，该方法计算出来的初始容量依然是比这个值大的2的幂次方数</p>
</blockquote>
<ul>
<li><strong>tableSizeFor源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment"> * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。</p>
<p>另外，需要注意的是，<strong>调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作</strong>。</p>
<ul>
<li><strong>带加载因子构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用四个参数的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给定一个Map构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于一个Map集合，构建一个ConcurrentHashMap</span></span><br><span class="line"><span class="comment">//初始容量为16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给定Map大小，加载因子以及并发度构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一个大于或者等于给定的容量值，该值是2的幂次方数作为初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化或者说正在扩容， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//n的值： sizeCtl为0，取默认长度16， 否则取sizeCtl的值</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//传给成员变量table: tansient volatile Node&lt;K, V&gt;[] table;</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc 【sc = 0.75n】  </span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                <span class="comment">// 此时的sizeCtl就记录了扩容阈值了</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码逻辑</strong></li>
</ul>
<p>由于有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化：</p>
<ol>
<li>首先通过if进行判断，若当前已经有一个线程正在初始化即sizeCtl值变为-1，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片</li>
<li>正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。</li>
</ol>
<p>如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h3 id="添加（put）方法"><a href="#添加（put）方法" class="headerlink" title="添加（put）方法"></a>添加（put）方法</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的本质是调用<code>putVal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="comment">//这个值一定为一个正数，方便后面添加元素判断该节点的类型</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">	    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="comment">// （tabAt方法用于获取角标对应的值） </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED（-1），证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="comment">//（这里涉及到了多线程的协助扩容相关知识点）</span></span><br><span class="line">        <span class="comment">// 第一次初始化肯定是不走这里的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//第一次初始化会走这个分支</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 防止树化之后 元素位置</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// hash值一样</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    <span class="comment">//旧值覆盖掉</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 尾插到链表</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="comment">//ps：并不是大于8了，就一定会树化，在树化前再进行一次判断，如果是小于64的，则不会树化，而是扩容</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作(根据临界值（实际大小*加载因子）与实际大小进行判断)</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码细节-amp-逻辑分析"><a href="#代码细节-amp-逻辑分析" class="headerlink" title="代码细节 &amp; 逻辑分析"></a>代码细节 &amp; 逻辑分析</h4><p>下图为ConcurrentHashMap的数据结构形式，为一个哈希桶数组；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-1884312328f221e7.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p>
<p>如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是<strong>标准的链地址的解决方式</strong>，将hash值相同的节点构成链表的形式，称为“拉链法”。</p>
<p>另外，在1.8版本中为了防止拉链过长，当链表的长度大于8（其实是大于64，在8 - 64之间只会扩容）的时候会将链表转换成红黑树。table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入table数组的索引i处。</p>
<blockquote>
<p>引申出来一个问题：如何计算得出索引？</p>
<p>回答：通过key的HashCode值</p>
</blockquote>
<p>如何计算呢？</p>
<ul>
<li><strong>spread()重哈希，以减小Hash冲突</strong></li>
</ul>
<p>对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。</p>
<p>因此通过<strong><code>spread</code></strong>方法进行了一次重hash从而大大减小哈希冲突的可能性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"><span class="comment">// HASH_BITS为0x7FFFFFFF,是除了首位为0，其余都是1的十六进制数;</span></span><br><span class="line"><span class="comment">// 首位为0表示为正数，这是最大的整形数int</span></span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。</p>
<ul>
<li><strong>初始化table</strong></li>
</ul>
<p>这里会判断table是否是经过初始化的，没有的话，就调用<code>initTable</code>进行初始化；</p>
<ul>
<li><strong>判断是否正在扩容</strong></li>
</ul>
<p>如果当前节点不为null，且该节点为特殊节点（forwardingNode）的话，就说明当前concurrentHashMap正在进行扩容操作，关于扩容操作，之后会详细讲述。</p>
<p>那么怎样确定当前的这个Node是不是特殊的节点了？是通过判断该节点的hash值是不是等于-1（MOVED）,代码为<code>(fh = f.hash) == MOVED</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="put方法图解"></p>
<hr>
<h3 id="取出（get）方法"><a href="#取出（get）方法" class="headerlink" title="取出（get）方法"></a>取出（get）方法</h3><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">	<span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a><strong>代码逻辑</strong></h4><p>首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<ul>
<li><strong>图解</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png" alt="get方法图解"></p>
<h3 id="扩容（-transfer）方法"><a href="#扩容（-transfer）方法" class="headerlink" title="扩容（ transfer）方法"></a>扩容（ transfer）方法</h3><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果是扩容线程，此时新数组为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//两倍扩容创建新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable记录新的数组 </span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移</span></span><br><span class="line">        <span class="comment">//tansferIndex记录当前旧数组的size</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">//进行迁移任务的分配工作</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i：记录当前正在迁移桶位的索引值</span></span><br><span class="line">            <span class="comment">//bound/nextBound：记录下一次任务迁移的开始桶位</span></span><br><span class="line">            <span class="comment">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//计算下一次任务迁移的开始桶位，并将这个值赋值给nextBound </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//扩容任务线程数减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class="line">                <span class="comment">// != 表示没扩容完， == 表示扩容完;</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//所有扩容线程都执行完，标识结束</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//当前节点已经被迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class="line">            <span class="comment">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// fh &gt;= 0:处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                         <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理当前节点是TreeBin时的情况，操作和上面的类似</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码流程-细节"><a href="#代码流程-细节" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h4><p>代码逻辑请看注释,整个扩容操作分为<strong>两个部分</strong>：</p>
<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p>
<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>
<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-f82d0791c6493019.png" alt="ConcurrentHashMap扩容示意图"></p>
<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/nnn.png" alt="transfer方法图解"></p>
<h3 id="协助扩容（helpTransfer）方法"><a href="#协助扩容（helpTransfer）方法" class="headerlink" title="协助扩容（helpTransfer）方法"></a>协助扩容（helpTransfer）方法</h3><p>在<code>putVal</code>处，有<code>helpTransfer</code>方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现此处为fwd节点，协助扩容，扩容结束后，再循环回来添加元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//扩容，传递一个不是null的nextTab</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合长度累计方式"><a href="#集合长度累计方式" class="headerlink" title="集合长度累计方式"></a>集合长度累计方式</h3><h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><blockquote>
<p><strong>① CounterCell数组不为空，优先利用数组中的CounterCell记录数量</strong></p>
<p><strong>② 如果数组为空，尝试对baseCount进行累加，失败后，会执行fullAddCount逻辑</strong></p>
<p><strong>③ 如果是添加元素操作，会继续判断是否需要扩容</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//当CounterCell数组不为空，则优先利用数组中的CounterCell记录数量</span></span><br><span class="line">    <span class="comment">//或者当baseCount的累加操作失败，会利用数组中的CounterCell记录数量</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//标识是否有多线程竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//当as数组为空</span></span><br><span class="line">        <span class="comment">//或者当as长度为0</span></span><br><span class="line">        <span class="comment">//或者当前线程对应的as数组桶位的元素为空</span></span><br><span class="line">        <span class="comment">//或者当前线程对应的as数组桶位不为空，但是累加失败</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a =  as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//以上任何一种情况成立，都会进入该方法，传入的uncontended是false</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//计算元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//当元素个数达到扩容阈值</span></span><br><span class="line">        <span class="comment">//并且数组不为空</span></span><br><span class="line">        <span class="comment">//并且数组长度小于限定的最大值</span></span><br><span class="line">        <span class="comment">//满足以上所有条件，执行扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//这个是一个很大的正数</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//sc小于0，说明有线程正在扩容，那么会协助扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//扩容结束或者扩容线程数达到最大值或者扩容后的数组为null或者没有更多的桶位需要转移，结束操作</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//扩容线程加1，成功后，进行协助扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容，newTable不为null</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有其他线程在进行扩容，达到扩容阈值后，给sizeCtl赋了一个很大的负数</span></span><br><span class="line">            <span class="comment">//1+1=2 --》 代表此时有一个线程在扩容</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//rs &lt;&lt; RESIZE_STAMP_SHIFT)是一个很大的负数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//扩容，newTable为null</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h4><blockquote>
<p><strong>① 当CounterCell数组不为空，优先对CounterCell数组中的CounterCell的value累加</strong></p>
<p><strong>② 当CounterCell数组为空，会去创建CounterCell数组，默认长度为2，并对数组中的CounterCell的value累加</strong></p>
<p><strong>③ 当数组为空，并且此时有别的线程正在创建数组，那么尝试对baseCount做累加，成功即返回，否则自旋</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//获取当前线程的hash值</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标识是否有冲突，如果最后一个桶不是null，那么为true</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//数组不为空，优先对数组中CouterCell的value累加</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//线程对应的桶位为null</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//创建CounterCell对象</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//利用CAS修改cellBusy状态为1，成功则将刚才创建的CounterCell对象放入数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//桶位为空， 将CounterCell对象放入数组</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">//表示放入成功</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created) <span class="comment">//成功退出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//桶位已经被别的线程放置了已给CounterCell对象，继续循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//桶位不为空，重新计算线程hash值，然后继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//重新计算了hash值后，对应的桶位依然不为空，对value累加 这里的x = 1 </span></span><br><span class="line">            <span class="comment">//成功则结束循环</span></span><br><span class="line">            <span class="comment">//失败则继续下面判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//数组被别的线程改变了，或者数组长度超过了可用cpu大小，重新计算线程hash值，否则继续下一个判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//当没有冲突，修改为有冲突，并重新计算线程hash，继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果CounterCell的数组长度没有超过cpu核数，对数组进行两倍扩容</span></span><br><span class="line">            <span class="comment">//并继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 下面进行的是对counterCells数组进行初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CounterCell数组为空，并且没有线程在创建数组，修改标记，并创建数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组为空，并且有别的线程在创建数组，那么尝试对baseCount做累加，成功就退出循环，失败就继续循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210529160604963.png" alt="image-20210529160604963"></p>
<h3 id="集合长度获取方式"><a href="#集合长度获取方式" class="headerlink" title="集合长度获取方式"></a>集合长度获取方式</h3><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sumCount方法"><a href="#sumCount方法" class="headerlink" title="sumCount方法"></a>sumCount方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">//获取baseCount的值</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组，累加每一个CounterCell的value值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这个方法并不是线程安全的</p>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>在多线程编程中通常解决线程安全的问题我们会利用synchronzed或者lock控制线程对临界区资源的同步顺序从而解决线程安全的问题，但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。</p>
<p><strong>线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作</strong>，那么，如果每个线程都使用自己的“共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，这样就不会出现线程安全的问题。</p>
<p>ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一乐ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，如下图所示</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1368768-20190613220434628-1803630402.png" alt="img"></p>
<p>从<strong>ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争</strong>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>学习实现原理主要根据：set get  remove 三个方法入手</strong></p>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><blockquote>
<p><strong>set方法设置在当前线程中threadLocal变量的值</strong></p>
</blockquote>
<h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程实例对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//3.如果Map不为null,则以当前threadLocl实例为key,值为value进行存入</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//4.map为null,则新建ThreadLocalMap并存入value</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码流程-细节-1"><a href="#代码流程-细节-1" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><p>方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道value是存放在了ThreadLocalMap里了，当前先把它理解为一个普普通通的map即可，也就是说，<strong>数据value是真正的存放在了ThreadLocalMap这个容器中了，并且是以当前threadLocal实例为key</strong>。</p>
<p>先简单的看下ThreadLocalMap是什么，有个简单的认识就好，下面会具体说的。</p>
<p><strong>首先ThreadLocalMap是怎样来的</strong>？源码很清楚，是通过<code>getMap(t)</code>进行获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法直接返回的就是当前线程对象t的一个成员变量threadLocals：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说<strong>ThreadLocalMap的引用是作为Thread的一个成员变量，被Thread进行维护的</strong>。</p>
<p>回过头再来看看set方法，当map为Null的时候会通过<code>createMap(t，value)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法就是<strong>new一个ThreadLocalMap实例对象，然后同样以当前threadLocal实例作为key,值为value存放到threadLocalMap中，然后将当前线程对象的threadLocals赋值为threadLocalMap</strong>。</p>
<h5 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210529172329653.png" alt="image-20210529172329653"></p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><h5 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h5><p><strong>get方法是获取当前线程中threadLocal变量的值</strong></p>
<ul>
<li><strong>get方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程的实例对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">//2. 获取当前线程的threadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//3. 获取map中当前threadLocal实例为key的值的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			<span class="comment">//4. 当前entitiy不为null的话，就返回相应的值value</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>setInitialValue方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="代码流程-细节-2"><a href="#代码流程-细节-2" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><blockquote>
<p><strong>通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回<mark>null</mark>。</strong></p>
</blockquote>
<h5 id="图解流程-1"><a href="#图解流程-1" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/get%E6%96%B9%E6%B3%95.png" alt="get方法"></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><blockquote>
<p><strong>remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</strong></p>
</blockquote>
<h5 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程的threadLocalMap</span></span><br><span class="line">	ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> 	<span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//2. 从map中删除以当前threadLocal实例为key的键值对</span></span><br><span class="line">		m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码流程-细节-3"><a href="#代码流程-细节-3" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><p><strong>删除数据是从map中删除数据，先获取与当前线程相关联的threadLocalMap然后从map中删除该threadLocal实例为key的键值对即可。</strong></p>
<p>如下图所示：每个线程内部有一个名为threadLocals的成员变量，该变量的类型为ThreadLocal.ThreadLocalMap类型（类似于一个HashMap），其中的key为当前定义的ThreadLocal变量的this引用，value为我们使用set方法设置的值。每个线程的本地变量存放在自己的本地内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量就会一直存在（所以可能会导致内存溢出），因此使用完毕需要将其remove掉。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1368768-20190614011044060-2111473950.png" alt="img"></p>
<h5 id="图解流程-2"><a href="#图解流程-2" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210530164606712.png" alt="image-20210530164606712"></p>
<h3 id="ThreadLoacl底层细节"><a href="#ThreadLoacl底层细节" class="headerlink" title="ThreadLoacl底层细节"></a>ThreadLoacl底层细节</h3><h4 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h4><blockquote>
<p>ThreadLocalMap是threadLocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadLocalMap内部维护了一个Entry类型的table数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two</span></span><br><span class="line"><span class="comment"> * table数组的长度必须为2的幂次方.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内部源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>细节</strong></li>
</ul>
<p>　在上面的代码中，我们可以看出，当前ThreadLocal的引用k被传递给WeakReference的构造函数，<strong>所以ThreadLocalMap中的key为ThreadLocal的弱引用</strong></p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2021/03/29/JVM/#%E5%BC%B1%E5%BC%95%E7%94%A8">弱引用</a>的相关知识在这</p>
</blockquote>
<p>每个线程实例中可以通过threadLocals获取到threadLocalMap，而threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry数组。当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210530172556140.png" alt="image-20210530172556140"></p>
<p>这就可能会导致一个问题：<strong>内存泄漏</strong>（这里是初步涉及一下，后面再重点学习）</p>
<p>考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在，即存在一条这样的链路：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>而这个value是无法被回收的，这就可能造成内存泄漏（因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)</p>
<p><strong>解决办法：使用线程池去维护线程的创建和复用，或及时使用remove方法</strong></p>
<h4 id="set方法细节"><a href="#set方法细节" class="headerlink" title="set方法细节"></a>set方法细节</h4><h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-bf2dfb86819f6823.png" alt="理想散列表的一个示意图"></p>
<p>在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。</p>
<p>为了解决散列冲突，主要采用下面两种方式：</p>
<ul>
<li>分离链表法（separate chaining）</li>
<li>开放定址法（open addressing）</li>
</ul>
<h5 id="分离链表法-与-开放定址法"><a href="#分离链表法-与-开放定址法" class="headerlink" title="分离链表法 与 开放定址法"></a>分离链表法 与 开放定址法</h5><ul>
<li><strong>分离链表法</strong></li>
</ul>
<p>分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素，典型实现为hashMap，concurrentHashMap的拉链法。下面是一个示意图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-32b422909f2f933c.gif" alt="分离链表法示意图"></p>
<ul>
<li><strong>开放定址法</strong></li>
</ul>
<p>开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 —— 线性探测法。</p>
<p>线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-0d85565e94c4bd6b.jpg" alt="开放定址法示意图"></p>
<blockquote>
<p><strong>ThreadLocalMap 中使用开放地址法来处理散列冲突</strong></p>
<p><strong>HashMap 中使用的分离链表法</strong></p>
</blockquote>
<p>究其原因在于：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。</p>
<h5 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">	<span class="comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用开放地址法，hash冲突的时候使用线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">//覆盖旧Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当key为null时，说明threadLocal外部强引用已经被释放掉，那么就无法</span></span><br><span class="line">		<span class="comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//用当前插入的值替换掉这个key为null的“脏”entry</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//新建entry并插入table中i处</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">	<span class="comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h5><blockquote>
<p>ThreadLoacl的HashCode如何确定？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =<span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以清楚的看到threadLocal实例的hashCode是通过nextHashCode()方法实现的，<strong>该方法实际上总是用一个AtomicInteger加上0x61c88647来实现的</strong>；那么这个<mark>0x61c88647</mark>是什么呢？他其实是：<code>Fibonacci Hashing</code>，能够保证hash表的每个散列桶能够均匀的分布</p>
<blockquote>
<p>怎样确定新值插入到哈希表中的位置？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span></span><br><span class="line">   <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>本质方法：利用当前key(即threadLocal实例)的hashcode与哈希表大小相与；</p>
<p>因为哈希表大小总是为2的幂次方，所以相与等同于一个取模的过程，这样就可以通过Key分配到具体的哈希桶中去。</p>
<p>采取相与而非与运算，因为位运算效率更高</p>
<blockquote>
<p>怎样解决hash冲突？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不断向后线性探测，到达末尾时再回到0重新开始，呈一个环形。</p>
<blockquote>
<p>怎样解决“脏”Entry？</p>
</blockquote>
<p>在分析threadLocal,threadLocalMap以及Entry的关系的时候，我们已经知道使用threadLocal有可能存在内存泄漏（对象创建出来后，在之后的逻辑一直没有使用该对象，但是垃圾回收器无法回收这个部分的内存），在源码中针对这种key为null的Entry称之为“stale entry”，直译为不新鲜的entry，我把它理解为“脏entry”，</p>
<p>针对这种情况，在set方法的for循环中寻找和当前Key相同的可覆盖entry的过程中通过<strong>replaceStaleEntry</strong>方法解决脏entry的问题。如果当前table[i]为null的话，直接插入新entry后也会通过<strong>cleanSomeSlots</strong>来解决脏entry的问题</p>
<blockquote>
<p>如何进行扩容？</p>
</blockquote>
<ul>
<li><strong>扩容阈值threshold</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 初始大小为16</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">       <span class="comment">// 创建初始大小为16的threadLoaclMap</span></span><br><span class="line">       table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">       <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">       table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">       size = <span class="number">1</span>;</span><br><span class="line">       setThreshold(INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将threshold值设置成当前哈希数组长度的2/3</span></span><br><span class="line">       threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码流程</strong></li>
</ul>
<p>根据源码可知，在第一次为threadLocal进行赋值的时候会创建初始大小为16的threadLocalMap,并且通过setThreshold方法设置threshold，其值为当前哈希数组长度乘以（2/3），可以理解为<strong>加载因子为2/3</strong></p>
<blockquote>
<p><strong>加载因子是衡量哈希表密集程度的一个参数，如果加载因子越大的话，说明哈希表被装载的越多，出现hash冲突的可能性越大，反之，则被装载的越少，出现hash冲突的可能性越小。同时如果过小，很显然内存使用率不高，该值取值应该考虑到内存使用率和hash冲突概率的一个平衡，如hashMap,concurrentHashMap的加载因子都为0.75</strong></p>
</blockquote>
<p>这里<strong>threadLocalMap初始大小为16</strong>，<strong>加载因子为2/3</strong>，所以哈希表可用大小为：16*2/3=10，即哈希表可用容量为10。</p>
<ul>
<li><strong>扩容resize</strong></li>
</ul>
<p>当我们的hash表size值大于阈值threshold，将触发resize方法，进行扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">	<span class="comment">//新数组为原数组的2倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">			<span class="comment">//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//重新确定entry在新数组的位置，然后进行插入</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置新哈希表的threshHold和size属性</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ol>
<li>新建一个大小为原来数组长度的两倍的数组</li>
<li>遍历旧数组中的entry并将其插入到新的hash数组中</li>
</ol>
<p><strong>注意点：在扩容的过程中针对脏entry的话会令value为null，以便能够被垃圾回收器能够回收，解决隐藏的内存泄漏的问题</strong></p>
<h4 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h4><h5 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 确定在散列数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2. 根据索引i获取entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">	<span class="comment">//3. 满足条件则返回该entry</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//4. 未查找到满足条件的entry，额外在做的处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法逻辑"><a href="#方法逻辑" class="headerlink" title="方法逻辑"></a>方法逻辑</h5><p>若能当前定位的entry的key和查找的key相同的话就直接返回这个entry，否则的话就是在set的时候存在hash冲突的情况，需要通过getEntryAfterMiss做进一步处理</p>
<ul>
<li><strong>getEntryAfterMiss源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">			<span class="comment">//找到和查询的key相同的entry则返回</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">//解决脏entry的问题</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="comment">//继续向后环形查找</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法同样很好理解，通过nextIndex往后环形查找，如果找到和查询的key相同的entry的话就直接返回，如果在查找过程中遇到脏entry的话使用expungeStaleEntry方法进行处理</p>
</blockquote>
<h5 id="图解流程-3"><a href="#图解流程-3" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210531203747470.png" alt="image-20210531203747470"></p>
<h4 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h4><h5 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 获取索引i，即key在数组中位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历table中每个entry</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 找到要移除的key：</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">			<span class="comment">//将entry的key置为null</span></span><br><span class="line">            e.clear();</span><br><span class="line">			<span class="comment">//将该entry的value也置为null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><p>通过传入的key获取索引i，环形遍历表中的entry，如果找到与指定key相同的entry，先通过clear方法将key置为null后，使其转换为一个脏entry，然后调用expungeStaleEntry方法将其value置为null，以便垃圾回收时能够清理，同时将table[i]置为null。</p>
<h5 id="图解流程-4"><a href="#图解流程-4" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210531205253033.png" alt="image-20210531205253033"></p>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>在[内存泄漏初认识](# Entry数据结构)处，我们已经初步知道了什么是内存泄漏；接下来就学习下如何去解决这个问题</p>
<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>在上面的set方法中，我们遇到了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replaceStaleEntry(key, value, i);</span><br><span class="line">cleanSomeSlots(i, sz);</span><br></pre></td></tr></table></figure>

<p>这两个方法用于处理<strong>【脏Entry】 —— key 为 null的Entry</strong></p>
<ol>
<li>出现hash冲突的时候，或是遇到脏数据的时候，使用<code>replaceStaleEntry</code>进行处理</li>
<li>在插入了新的Entry后，会调用<code>cleanSomeSlots</code>去检测并清除脏数据</li>
</ol>
<h5 id="cleanSomeSlots方法"><a href="#cleanSomeSlots方法" class="headerlink" title="cleanSomeSlots方法"></a>cleanSomeSlots方法</h5><ul>
<li><p>cleanSomeSlots方法用于检测，清除【脏Entry】</p>
</li>
<li><p><strong>源码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @param i a position known NOT to hold a stale entry. The</span></span><br><span class="line"><span class="comment"> * scan starts at the element after i.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param n scan control: &#123;@code log2(n)&#125; cells are scanned,</span></span><br><span class="line"><span class="comment"> * unless a stale entry is found, in which case</span></span><br><span class="line"><span class="comment"> * &#123;@code log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class="line"><span class="comment"> * When called from insertions, this parameter is the number</span></span><br><span class="line"><span class="comment"> * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class="line"><span class="comment"> * table length. (Note: all this could be changed to be either</span></span><br><span class="line"><span class="comment"> * more or less aggressive by weighting n instead of just</span></span><br><span class="line"><span class="comment"> * using straight log n. But this version is simple, fast, and</span></span><br><span class="line"><span class="comment"> * seems to work well.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 向后线性探测</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取i索引处的Entry</span></span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">//遇到了脏Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// n=当前Hash表长</span></span><br><span class="line">            n = len;</span><br><span class="line">            <span class="comment">// 标志为removed</span></span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理脏Entry</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="expungeStaleEntry方法"><a href="#expungeStaleEntry方法" class="headerlink" title="expungeStaleEntry方法"></a>expungeStaleEntry方法</h6><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.清除当前脏entry</span></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 置桶中的value为null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 置桶位为null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 表长减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 2.往后环形继续查找,直到遇到table[i]==null时结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">// 3. 如果在向后搜索过程中再次遇到脏entry，同样将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//处理rehash的情况</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法逻辑</strong></li>
</ul>
<ol>
<li>清理当前脏entry，即将其value引用置为null，并且将table[staleSlot]也置为null。value置为null后该value域变为不可达，在下一次gc的时候就会被回收掉，同时table[staleSlot]为null后以便于存放新的entry;</li>
<li>从当前staleSlot位置向后环形（nextIndex）继续搜索，直到遇到哈希桶（tab[i]）为null的时候退出；</li>
<li>若在搜索过程再次遇到脏entry，继续将其清除。</li>
</ol>
<p>也就是说该方法，<strong>清理掉当前脏entry后，并没有闲下来继续向后搜索，若再次遇到脏entry继续将其清理，直到哈希桶（table[i]）为null时退出</strong></p>
<blockquote>
<p>方法执行后结果： <strong>从当前脏entry（staleSlot）位到返回的i位，这中间所有的entry不是脏entry</strong></p>
</blockquote>
<blockquote>
<p>为什么是遇到null时退出？原因是存在脏entry的前提条件是 <strong>当前哈希桶（table[i]）不为null</strong>,只是该entry的key域为null。如果遇到哈希桶为null，代表着其根本就不是一个键值对Entry，那更不可能是一个脏的Entry</p>
</blockquote>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul>
<li><strong>运行流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-176285739b74da18.png" alt="cleanSomeSlots示意图.png"></p>
<ol>
<li>从当前位置i处（位于i处的entry一定不是脏entry）为起点在初始小范围（log2(n)，n为哈希表已插入entry的个数size）开始向后搜索脏entry，若在整个搜索过程没有脏entry，方法结束退出</li>
<li>如果在搜索过程中遇到脏entryt通过expungeStaleEntry方法清理掉当前脏entry，并且该方法会返回下一个哈希桶(table[i])为null的索引位置为i。这时重新令搜索起点为索引位置i，n为哈希表的长度len，再次扩大搜索范围为log2(n’)继续搜索。</li>
</ol>
<ul>
<li><strong>例子</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-217512cee7e45fc7.png" alt="cleanSomeSlots执行情景图.png"></p>
<ol>
<li><p>如图当前n等于hash表的size即n=10，i=1,在第一趟搜索过程中通过nextIndex,i指向了索引为2的位置，此时table[2]为null，说明第一趟未发现脏entry,则第一趟结束进行第二趟的搜索。</p>
</li>
<li><p>第二趟所搜先通过nextIndex方法，索引由2的位置变成了i=3,当前table[3]!=null但是该entry的key为null，说明找到了一个脏entry，<strong>先将n置为哈希表的长度len,然后继续调用expungeStaleEntry方法</strong>，该方法会将当前索引为3的脏entry给清除掉（令value为null，并且table[3]也为null）,但是<strong>该方法可不想偷懒，它会继续往后环形搜索</strong>，往后会发现索引为4,5的位置的entry同样为脏entry，索引为6的位置的entry不是脏entry保持不变，直至i=7的时候此处table[7]位null，该方法就以i=7返回。至此，第二趟搜索结束；</p>
</li>
<li><p>由于在第二趟搜索中发现脏entry，n增大为数组的长度len，因此扩大搜索范围（增大循环次数）继续向后环形搜索；</p>
</li>
<li><p>直到在整个搜索范围里都未发现脏entry，cleanSomeSlot方法执行结束退出。</p>
</li>
</ol>
<h5 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h5><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param  key the key</span></span><br><span class="line"><span class="comment"> * @param  value the value to be associated with key</span></span><br><span class="line"><span class="comment"> * @param  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment"> *         searching for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向前找到第一个脏entry</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">1.</span>          slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果在向后环形查找过程中发现key相同的entry就覆盖并且和脏entry进行交换</span></span><br><span class="line"><span class="number">2.</span>            e.value = value;</span><br><span class="line"><span class="number">3.</span>            tab[i] = tab[staleSlot];</span><br><span class="line"><span class="number">4.</span>            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">			<span class="comment">//如果在查找过程中还未发现脏entry，那么就以当前位置作为cleanSomeSlots</span></span><br><span class="line">			<span class="comment">//的起点</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">5.</span>                slotToExpunge = i;</span><br><span class="line">			<span class="comment">//搜索脏entry并进行清理</span></span><br><span class="line"><span class="number">6.</span>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">		<span class="comment">//如果向前未搜索到脏entry，则在查找过程遇到脏entry的话，后面就以此时这个位置</span></span><br><span class="line">		<span class="comment">//作为起点执行cleanSomeSlots</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">7.</span>            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">	<span class="comment">//如果在查找过程中没有找到可以覆盖的entry，则将新的entry插入在脏entry</span></span><br><span class="line"><span class="number">8.</span>    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">9.</span>    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line"><span class="number">10.</span>    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">		<span class="comment">//执行cleanSomeSlots</span></span><br><span class="line"><span class="number">11.</span>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue - 阻塞队列"></a>BlockingQueue - 阻塞队列</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>最常用的”<strong>生产者-消费者</strong>“问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p>
<p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。</p>
<blockquote>
<p><strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</strong></p>
</blockquote>
<h3 id="基本操作-接口"><a href="#基本操作-接口" class="headerlink" title="基本操作 - 接口"></a>基本操作 - 接口</h3><p>BlockingQueue基本操作总结如下（此图来源于JAVA API文档）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-19d06e0ba334fe52.png" alt="BlockingQueue基本操作.png"></p>
<ul>
<li><strong>BlockingQueue继承于Queue接口，因此，对数据元素的基本操作有：</strong></li>
</ul>
<blockquote>
<p>插入元素</p>
</blockquote>
<ol>
<li>add(E e) ：往队列插入数据，当队列满时，插入元素时会抛出IllegalStateException异常；</li>
<li>offer(E e)：当往队列插入数据时，插入成功返回<code>true</code>，否则则返回<code>false</code>。当队列满时不会抛出异常；</li>
</ol>
<blockquote>
<p>删除元素</p>
</blockquote>
<ol>
<li>remove(Object o)：从队列中删除数据，成功则返回<code>true</code>，否则为<code>false</code></li>
<li>poll：删除数据，当队列为空时，返回null；</li>
</ol>
<blockquote>
<p>查看元素</p>
</blockquote>
<ol>
<li>element：获取队头元素，如果队列为空时则抛出NoSuchElementException异常；</li>
<li>peek：获取队头元素（不会删除头结点），如果队列为空则抛出NoSuchElementException异常</li>
</ol>
<ul>
<li><strong>BlockingQueue具有的特殊操作：</strong></li>
</ul>
<blockquote>
<p>插入数据：</p>
</blockquote>
<ol>
<li>put：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；</li>
<li>offer(E e, long timeout, TimeUnit unit)：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与put方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；</li>
</ol>
<blockquote>
<p>删除数据</p>
</blockquote>
<ol>
<li>take()：当阻塞队列为空时，获取队头数据的线程会被阻塞；</li>
<li>poll(long timeout, TimeUnit unit)：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出（该方法可以获取队列的头结点，且会删除此结点）</li>
</ol>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20181026185652119.png" alt="在这里插入图片描述"></p>
<ul>
<li>阻塞队列分别为：<ul>
<li><strong>ArrayBlockingQueue - 有界队列（数组）</strong></li>
<li>*<em>LinkedBlockingQueue - 有界队列（链表） *</em></li>
<li><strong>PriorityBlockingQueue - 无界（优先）阻塞队列（数组）</strong></li>
<li><strong>SynchronousQueue -  同步队列</strong></li>
<li><strong>LinkedTransferQueue - 无界阻塞队列（链表）</strong></li>
<li><strong>LinkedBlockingDeque - 有界阻塞双端队列（链表）</strong></li>
<li><strong>DelayQueue - 延时无界阻塞队列（数组）</strong></li>
</ul>
</li>
</ul>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><blockquote>
<p>ArrayBlockingQueue</p>
</blockquote>
<p><strong>ArrayBlockingQueue</strong>是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。</p>
<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p>ArrayBlockingQueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue。而非公平性则是指访问ArrayBlockingQueue的顺序不是遵守严格的时间顺序，有可能存在，一旦ArrayBlockingQueue可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。</p>
<p><strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的ArrayBlockingQueue，可采用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="comment">//保存队列元素的数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line">    <span class="comment">//取出元素的位置 - 队列头的位置</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line">   <span class="comment">//添加元素的位置 - 队列尾的位置</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Number of elements in the queue */</span></span><br><span class="line">   <span class="comment">//队列中元素的数量</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment">     * found in any textbook.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="comment">//锁对象 用来保证多线程操作共享变量的安全问题</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">  	<span class="comment">/** 当队列为空时，就会调用notEmpty的wait方法，让当前线程等待 */</span></span><br><span class="line">  	<span class="comment">/** 当生产者生产了一个产品后,调用notEmpty的signal方法，唤醒消费者 */</span></span><br><span class="line"> 	 <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">  	<span class="comment">/** 当队列为满时，就会调用notFull的wait方法，让当前线程等待 */</span></span><br><span class="line">  	<span class="comment">/** 当消费者消费了一个产品后,调用notFull的signal方法，唤醒生产者 */</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared state for currently active iterators, or null if there</span></span><br><span class="line"><span class="comment">     * are known not to be any.  Allows queue operations to update</span></span><br><span class="line"><span class="comment">     * iterator state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h5><table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>队列满时处理方式</th>
<th>方法返回值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>add(E e)</td>
<td>抛出“Queue full”异常</td>
<td>boolean</td>
</tr>
<tr>
<td>2</td>
<td>offer(E e)</td>
<td>返回false</td>
<td>boolean</td>
</tr>
<tr>
<td>3</td>
<td>put(E e)</td>
<td>线程阻塞，直到中断或被唤醒</td>
<td>void</td>
</tr>
<tr>
<td>4</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
<td>在规定时间内重试，超过规定时间返回false</td>
<td>boolean</td>
</tr>
</tbody></table>
<ul>
<li><strong>add方法、offer方法与enqueue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用AbstractQueue父类中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过调用offer来时实现</span></span><br><span class="line">  <span class="keyword">if</span> (offer(e))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列末尾新添加元素。返回true表示添加成功，false表示添加失败，不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断添加的数据是否为空</span></span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 队列已满，添加元素失败，返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (count == items.length)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用enqueue方法将元素插入队列中</span></span><br><span class="line">      enqueue(e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add方法 → offer方法 → enqueue方法，因此本质是调用<mark>enqueue</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"> <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line"> <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"> items[putIndex] = x; <span class="comment">//通过 putIndex 对数据赋值</span></span><br><span class="line"> <span class="keyword">if</span> (++putIndex == items.length) <span class="comment">// 当putIndex 等于数组长度时，将 putIndex 重置为 0</span></span><br><span class="line">   putIndex = <span class="number">0</span>;</span><br><span class="line"> count++;<span class="comment">//记录队列元素的个数</span></span><br><span class="line"> notEmpty.signal();<span class="comment">//唤醒处于等待状态下的线程，表示当前队列中的元素不为空,如果存在消费者线程阻塞，就可以开始取出元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解流程的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210603160048623.png" alt="image-20210603160048623"></p>
<ul>
<li><strong>put方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁，如果线程中断了抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数组满了，使用notFull等待</span></span><br><span class="line">        <span class="comment">// notFull等待的意思是说现在队列满了</span></span><br><span class="line">        <span class="comment">// 只有取走一个元素后，队列才不满</span></span><br><span class="line">        <span class="comment">// 然后唤醒notFull，然后继续现在的逻辑</span></span><br><span class="line">        <span class="comment">// 这里之所以使用while而不是if</span></span><br><span class="line">        <span class="comment">// 是因为有可能多个线程阻塞在lock上</span></span><br><span class="line">        <span class="comment">// 即使唤醒了可能其它线程先一步修改了队列又变成满的了</span></span><br><span class="line">        <span class="comment">// 这时候需要再次等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出来，区别于<strong>add方法</strong>的地方在于：如果队列满时，是使用<code>notFull.await();</code>进行等待，而<strong>add方法</strong>会抛出异常</p>
<h5 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h5><table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>队列空时处理方式</th>
<th>方法返回值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>remove()</td>
<td>抛出异常</td>
<td>E</td>
</tr>
<tr>
<td>2</td>
<td>poll()</td>
<td>返回null</td>
<td>E</td>
</tr>
<tr>
<td>3</td>
<td>take()</td>
<td>线程阻塞，指定中断或被唤醒</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>poll(long timeout, TimeUnit unit)</td>
<td>在规定时间内重试，超过规定时间返回null</td>
<td>E</td>
</tr>
</tbody></table>
<ul>
<li><strong>remove方法、poll方法与dequeue()方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用poll()方法出队</span></span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果有元素出队就返回这个元素</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果没有元素出队就抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除队列第一个元素(即队列头)，并返回它。如果队列是空的，它不会抛出异常，而是会返回null。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果count == 0，列表为空，就返回null，否则调用dequeue方法，返回列表头元素</span></span><br><span class="line">      <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove方法 → poll方法 → dequeue方法，因此本质是调用<mark>dequeue</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除队列头的元素，返回它</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">  <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="comment">// 得到当前队列头的元素</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  E x = (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将当前队列头位置设置为null</span></span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当takeIndex 等于数组长度时，将 takeIndex 重置为 0</span></span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列数量减一</span></span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">    itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 因为删除了一个元素，那么队列肯定不满了，那么唤醒在notFull条件下等待的一个线程</span></span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于itrs.elementDequeued()：ArrayBlockingQueue 中，实现了迭代器的功能，也就是可以通过迭代器来遍历阻塞队列中的元素<br>所以 itrs.elementDequeued() 是用来更新迭代器中的元素数据的</p>
</blockquote>
<p>同样，图解流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210603162413042.png" alt="image-20210603162413042"></p>
<ul>
<li><strong>take方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">		<span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出来，区别于<strong>remove方法</strong>的地方在于：如果队列空时，是使用<code>notEmpty.await();</code>进行等待，而<strong>remove方法</strong>会抛出异常</p>
<h5 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用AbstractQueue父类中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  E x = peek();</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看队列头元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前队列头的元素</span></span><br><span class="line">    <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><h5 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表头</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take锁，执行take, poll等操作时候需要获取该锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// notEmpty条件</span></span><br><span class="line"><span class="comment">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//put执行put, offer等操作时候需要获取该锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// notFull条件</span></span><br><span class="line"><span class="comment">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="入队方法-1"><a href="#入队方法-1" class="headerlink" title="入队方法"></a>入队方法</h5><blockquote>
<ul>
<li><p>void put(E e)； 如果队列满了，一直阻塞，直到队列不满了或者线程被中断–&gt;阻塞</p>
</li>
<li><p>boolean offer(E e)；如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞</p>
</li>
<li><p>boolean offer(E e, long timeout, TimeUnit unit); 在队尾插入一个元素,，如果队列已满，则进入等待，直到出现以下三种情况：–&gt;阻塞</p>
<ul>
<li>被唤醒</li>
<li>等待时间超时</li>
<li>当前线程被中断</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>put（E e）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取锁中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满，如果已满阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node放入队列中</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 再次判断队列是否有可用空间，如果有唤醒下一个线程进行添加操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一条数据，唤醒消费线程进行消费</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑：</p>
<ol>
<li>队列已满，阻塞等待。</li>
<li>队列未满，创建一个node节点放入队列中，如果放完以后队列还有剩余空间，继续唤醒下一个添加线程进行添加。如果放之前队列中没有元素，放完以后要唤醒消费线程进行消费。</li>
</ol>
<ul>
<li><strong>offer(E e)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 如果队列满了 返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 包装结点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 设置put锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列有可用空间，放入node节点，判断放入元素后是否还有可用空间，</span></span><br><span class="line">        <span class="comment">// 如果有，唤醒下一个添加线程进行添加操作。</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与put方法相同，区别在于：当队列没有可用元素的时候，不同于put方法的阻塞等待，offer方法直接方法false</p>
<ul>
<li><strong>signalNotEmpty方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑：获取了take锁，先上锁，然后唤醒消费者线程，最后释放锁；</p>
<ul>
<li><strong>enqueue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links node at end of queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">// 这里分为两步:</span></span><br><span class="line">    <span class="comment">// 1.last.next = node</span></span><br><span class="line">    <span class="comment">// 2.last = last.next</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="出队方法-1"><a href="#出队方法-1" class="headerlink" title="出队方法"></a>出队方法</h5><blockquote>
<ul>
<li>E take(); 如果队列空了，一直阻塞，直到队列不为空或者线程被中断–&gt;阻塞</li>
<li>E poll(); 如果没有元素，直接返回null；如果有元素，出队</li>
<li>E poll(long timeout, TimeUnit unit); 如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况：<ul>
<li>被唤醒</li>
<li>等待时间超时</li>
<li>当前线程被中断</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>take方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 队列中还有元素，唤醒下一个消费线程进行消费</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除元素之前队列是满的，唤醒生产线程进行添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑：</p>
<ol>
<li>队列为空，阻塞等待。</li>
<li>队列不为空，从队首获取并移除一个元素，如果消费后还有元素在队列中，继续唤醒下一个消费线程进行元素移除。如果放之前队列是满元素的情况，移除完后要唤醒生产线程进行添加元素。</li>
</ol>
<ul>
<li><strong>poll方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与take方法相同，只是在队列满的时候，take方法进行阻塞等待，poll方法会return null；</p>
<ul>
<li><strong>signalNotFull方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑：获取了put锁，先上锁，然后唤醒生产者线程，最后释放锁；</p>
<ul>
<li><strong>dequeue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到head节点</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取到head节点指向的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// head节点指向自己等待下次gc回收</span></span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// head节点指向新的节点</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 获取到新的head节点的item值</span></span><br><span class="line">    E x = first.item;</span><br><span class="line">    <span class="comment">// 新head节点的item值设置为null</span></span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayBlockingQueue与LinkedBlockingQueue对比"><a href="#ArrayBlockingQueue与LinkedBlockingQueue对比" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue对比"></a>ArrayBlockingQueue与LinkedBlockingQueue对比</h4><ul>
<li>ArrayBlockingQueue：<ul>
<li>一个对象数组+一把锁+两个条件</li>
<li>入队与出队都用同一把锁</li>
<li>在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高</li>
<li>采用了数组，必须指定大小，即容量有限</li>
</ul>
</li>
<li>LinkedBlockingQueue：<ul>
<li>一个单向链表+两把锁+两个条件</li>
<li>两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。</li>
<li>在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多</li>
<li>采用了链表，最大容量为整数最大值，可看做容量无限</li>
</ul>
</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p><strong>为什么要使用线程池？</strong></p>
<p>在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用<strong>线程池</strong>来管理线程，使用线程池管理</p>
</li>
</ul>
<blockquote>
<p>假设一个服务器完成一项任务所需时间为：T1创建线程时间，T2在线程中执行任务的时间，T3销毁线程时间。如果：T1+T3远大于T2，则可以采用线程池，实现对线程的复用，以提高服务器性能。</p>
</blockquote>
<p>线程主要有如下好处：</p>
<ol>
<li><strong>降低资源消耗</strong>。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；</li>
<li><strong>提升系统响应速度</strong>。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</li>
</ol>
<ul>
<li><strong>线程池继承关系</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2269232-a162703262424ec6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/465/format/webp" alt="img"></p>
<ul>
<li><strong>线程池的组成部分</strong></li>
</ul>
<blockquote>
<ul>
<li><strong>线程池管理器</strong>：创建并管理线程池。例如创建线程池、销毁线程池、添加新任务等等。</li>
<li><strong>工作线程</strong>：线程池中的工作线程。空闲时处于空闲状态，可以循环的执行任务。</li>
<li><strong>任务接口</strong>：每个任务必须实现任务接口，以供工作线程调度任务的执行。</li>
<li><strong>任务队列</strong>：存放待处理任务的队列。</li>
</ul>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-2d3eb90c8e2cf51f.jpg" alt="线程池执行流程图.jpg"></p>
<p>从图可以看出，线程池执行所提交的任务过程主要有这样几个阶段：</p>
<ol>
<li>先判断线程池中<strong>核心线程池</strong>所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步；</li>
<li>判断当前<strong>阻塞队列</strong>是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；</li>
<li>判断<strong>线程池中所有的线程</strong>是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理</li>
</ol>
<h2 id="线程池-创建"><a href="#线程池-创建" class="headerlink" title="线程池 - 创建"></a>线程池 - 创建</h2><h3 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h3><ul>
<li><strong>线程池构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 池内核心线程数量, 超出数量的线程会进入阻塞队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize 最大可创建线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime 线程存活时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 存活时间的单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue 线程溢出后的阻塞队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 饱和策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>对于各个参数的说明：</p>
<table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池核心线程数（平时保留的线程数），创建后不会关闭的线程数量，如果设置了<code>allowCoreThreadTimeout</code>后，空闲时间超时后还是会关闭。执行任务时，没有达到核心线程数的话，是会直接创建新的线程。</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>规定线程池最多只能有多少个线程（worker）在执行。当核心线程数和任务队列也都满了，不能添加任务的时候，这个参数才会生效。如果当前有效工作线程数量小于最大线程数量，会再创建新的线程。</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>超出corePoolSize数量的线程的保留时间。</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime的时间单位。</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列，为阻塞队列<code>BlockingQueue</code>的实现。线程池会先满足<code>corePoolSize</code>的限制，在核心线程数满了后，将任务加入队列。但队列也满了后，线程数小于<code>maximumPoolSize</code>，线程池继续创建线程。</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程创建工厂，可以用来配置线程的命名、是否是守护线程、优先级等等。</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝处理器，为<code>RejectedExecutionHandler</code>的实现类。当任务队列满负荷，已经达到最大线程数，把新加入的任务交给这个handler 进行处理。线程池默认使用<code>AbortPolicy</code>（直接抛弃）策略，直接抛出异常。</td>
</tr>
<tr>
<td>allowCoreThreadTimeout</td>
<td>核心线程的空闲时间也要进行超时限制，也就是<code>keepAliveTime</code>的限制。如果配置为true后，所有的线程空闲时间超时后，都会进行线程退出操作。</td>
</tr>
</tbody></table>
<ul>
<li><strong>关于四种拒绝处理器饱和策略：</strong></li>
</ul>
<blockquote>
<p>AbortPolicy（中止策略）：直接抛弃。</p>
<p>CallerRunsPolicy（调用者运行策略）：用调用者的线程执行任务。</p>
<p>DiscardPolicy（丢弃策略）：抛弃当前任务。</p>
<p>DiscardOldestPolicy（弃老策略）：抛弃队列中最久的任务。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210605204529008.png" alt="线程池参数说明"></p>
<h2 id="线程池-提交"><a href="#线程池-提交" class="headerlink" title="线程池 - 提交"></a>线程池 - 提交</h2><p>线程池创建之后，后面就是要提交任务执行了，通常是使用使用线程池自带的<strong>submit或者excute方法</strong>，然后用lambda表达式传入函数体后，就可以执行任务了</p>
<p>而<strong>submit</strong>的方法本质上也是调用的<strong>execute</strong>方法，因此只需要学习<strong>execute</strong>方法即可</p>
<ul>
<li><strong>使用Thread创建启动线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Executor启动线程执行任务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
</blockquote>
<h3 id="execute源码"><a href="#execute源码" class="headerlink" title="execute源码"></a>execute源码</h3><p><strong>execute方法主要含义：通过调用这个方法可以向线程池提交一个任务，交由线程池去执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要执行的任务command为空，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *执行的流程实际上分为三步</span></span><br><span class="line"><span class="comment">    *1、如果运行的线程小于corePoolSize，以用户给定的Runable对象新开一个线程去执行</span></span><br><span class="line"><span class="comment">    *  并且执行addWorker方法会以原子性操作去检查runState和workerCount，以防止当返回false的</span></span><br><span class="line"><span class="comment">    *  时候添加了不应该添加的线程</span></span><br><span class="line"><span class="comment">    *2、 如果任务能够成功添加到队列当中，我们仍需要对添加的线程进行双重检查，有可能添加的线程在前</span></span><br><span class="line"><span class="comment">    *  一次检查时已经死亡，又或者在进入该方法的时候线程池关闭了。所以我们需要复查状态，并有必</span></span><br><span class="line"><span class="comment">    *  要的话需要在停止时回滚入列操作，或者在没有线程的时候新开一个线程</span></span><br><span class="line"><span class="comment">    *3、如果任务无法入列，那我们需要尝试新增一个线程，如果新建线程失败了，我们就知道线程可能关闭了</span></span><br><span class="line"><span class="comment">    *  或者饱和了，就需要拒绝这个任务</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池的控制状态 （runState和workerCount）</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过workCountOf方法得到当前活动的线程数，</span></span><br><span class="line">    <span class="comment">// 当前活动线程数小于corePoolSize，新建一个线程放入线程池中；</span></span><br><span class="line">    <span class="comment">// addWorker(): 在线程池中创建一个新的线程并且执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//添加任务到worker集合 - 线程池当中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) </span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//成功返回</span></span><br><span class="line">        <span class="comment">//失败的话再次获取线程池的控制状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *判断线程池是否正处于RUNNING状态,并且往工作队列中添加该任务</span></span><br><span class="line"><span class="comment">    *是的话添加Runnable对象到workQueue队列当中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次检查状态</span></span><br><span class="line">        <span class="comment">//线程池不处于RUNNING状态，将任务从任务队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">           * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">           * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">           * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">           * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//workerCount等于0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  <span class="comment">// 4</span></span><br><span class="line">            <span class="comment">//添加worker</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入阻塞队列失败，则尝试以线程池最大线程数新开线程去执行该任务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))  <span class="comment">// 5 </span></span><br><span class="line">        <span class="comment">//执行失败则拒绝任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execute执行流程"><a href="#execute执行流程" class="headerlink" title="execute执行流程"></a>execute执行流程</h3><ul>
<li><strong>执行流程</strong></li>
</ul>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>这里要注意一下<code>addWorker(null, false);</code>，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false);</code>也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p>
<ul>
<li><strong>图解方法流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/a7edb97ea88e40b19b758f475fa4c70b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><ul>
<li>作用：<strong>addWorker方法的主要工作是在线程池中创建一个新的线程并执行</strong>=</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//外部循环标记</span></span><br><span class="line">          retry:</span><br><span class="line">          <span class="comment">//外层死循环</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">//获取线程池控制状态</span></span><br><span class="line">              <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">              <span class="comment">//获取runState运行状态</span></span><br><span class="line">              <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">      ​</span><br><span class="line">              <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 这个if判断</span></span><br><span class="line"><span class="comment">                 * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">                 * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">                 * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">                 * 2. firsTask为空</span></span><br><span class="line"><span class="comment">                 * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">                 * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">                 * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">                 * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">              <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;  <span class="comment">//runState大于等于SHUTDOWN,初始位RUNNING</span></span><br><span class="line">                  ! (rs == SHUTDOWN &amp;&amp;  <span class="comment">//runState等于SHUTDOWN</span></span><br><span class="line">                     firstTask == <span class="keyword">null</span> &amp;&amp;  <span class="comment">//firstTask为null</span></span><br><span class="line">                     ! workQueue.isEmpty()))  <span class="comment">//workQueue任务队列不为空</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      ​</span><br><span class="line">              <span class="comment">//内层死循环</span></span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  <span class="comment">//获取线程池的workerCount数量</span></span><br><span class="line">                  <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                  <span class="comment">//如果workerCount超出最大值或者大于corePoolSize/maximumPoolSize</span></span><br><span class="line">                  <span class="comment">//返回false</span></span><br><span class="line">                  <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                      wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  <span class="comment">//通过CAS操作，使workerCount数量+1，成功则跳出循环，回到retry标记</span></span><br><span class="line">                  <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                      <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//CAS操作失败，再次获取线程池的控制状态</span></span><br><span class="line">                  c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                  <span class="comment">//如果当前runState不等于刚开始获取的runState，说明状态被改变了，则跳出内层循环，继续外层循环</span></span><br><span class="line">                  <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                      <span class="keyword">continue</span> retry;</span><br><span class="line">                  <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">                  <span class="comment">//CAS由于更改workerCount而失败，继续内层循环</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">//通过以上循环，能执行到这是workerCount成功+1了</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//worker开始标记</span></span><br><span class="line">          <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//worker添加标记</span></span><br><span class="line">          <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//初始化worker为null</span></span><br><span class="line">          Worker w = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//初始化一个当前Runnable对象的worker对象</span></span><br><span class="line">              w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">              <span class="comment">//获取该worker对应的线程</span></span><br><span class="line">              <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">              <span class="comment">//如果线程不为null</span></span><br><span class="line">              <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//初始线程池的锁</span></span><br><span class="line">                  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                  <span class="comment">//获取锁</span></span><br><span class="line">                  mainLock.lock();</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                      <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                      <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                      <span class="comment">//获取锁后再次检查，获取线程池runState</span></span><br><span class="line">                      <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">      </span><br><span class="line">                      <span class="comment">//当runState小于SHUTDOWN或者runState等于SHUTDOWN并且firstTask为null</span></span><br><span class="line">                      <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                          (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">//线程已存活</span></span><br><span class="line">                          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                              <span class="comment">//线程未启动就存活，抛出IllegalThreadStateException异常</span></span><br><span class="line">                              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                          <span class="comment">//将worker对象添加到workers集合当中</span></span><br><span class="line">                          workers.add(w);</span><br><span class="line">                          <span class="comment">//获取workers集合的大小</span></span><br><span class="line">                          <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                          <span class="comment">//如果大小超过largestPoolSize</span></span><br><span class="line">                          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                              <span class="comment">//重新设置largestPoolSize</span></span><br><span class="line">                              largestPoolSize = s;</span><br><span class="line">                          <span class="comment">//标记worker已经被添加</span></span><br><span class="line">                          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//释放锁</span></span><br><span class="line">                      mainLock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果worker添加成功</span></span><br><span class="line">                  <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                      <span class="comment">//启动线程</span></span><br><span class="line">                      t.start();</span><br><span class="line">                      <span class="comment">//标记worker已经启动</span></span><br><span class="line">                      workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//如果worker没有启动成功</span></span><br><span class="line">              <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                  <span class="comment">//workerCount-1的操作</span></span><br><span class="line">                  addWorkerFailed(w);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回worker是否启动的标记</span></span><br><span class="line">          <span class="keyword">return</span> workerStarted;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，其中<strong>firstTask参数</strong>指定的是新线程需要执行的第一个任务，<strong>core参数</strong>决定于活动线程数的比较对象是corePoolSize还是maximumPoolSize。</p>
<p>根据传进来的参数首先对线程池和队列的状态进行判断，满足条件就新建一个Worker对象，并实例化该对象的线程，最后启动线程。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-f4682a62cbff2231.jpg" alt="addWorker.jpg"></p>
<h4 id="runworker"><a href="#runworker" class="headerlink" title="runworker"></a>runworker</h4><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">//获取worker里的任务</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      <span class="comment">//将worker实例的任务赋值为null</span></span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      *unlock方法会调用AQS的release方法</span></span><br><span class="line"><span class="comment">      *release方法会调用具体实现类也就是Worker的tryRelease方法</span></span><br><span class="line"><span class="comment">      *也就是将AQS状态置为0，允许中断</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">      <span class="comment">//是否突然完成</span></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//worker实例的task不为空，或者通过getTask获取的不为空</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//获取锁</span></span><br><span class="line">              w.lock();</span><br><span class="line">              <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">              <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">              <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">              <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              *获取线程池的控制状态，至少要大于STOP状态</span></span><br><span class="line"><span class="comment">              *如果状态不对，检查当前线程是否中断并清除中断状态，并且再次检查线程池状态是否大于STOP</span></span><br><span class="line"><span class="comment">              *如果上述满足，检查该对象是否处于中断状态，不清除中断标记</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                   (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                  !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">//中断改对象</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//执行前的方法，由子类具体实现</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//执行任务</span></span><br><span class="line">                      task.run();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//执行完后调用的方法，也是由子类具体实现</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;<span class="comment">//执行完后</span></span><br><span class="line">                  <span class="comment">//task设置为null</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">//已完成任务数+1</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">//释放锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//处理并退出当前worker</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong></li>
</ul>
<blockquote>
<ol>
<li>首先在方法一进来，就执行了w.unlock()，这是为了将AQS的状态改为0，因为只有getState() &gt;= 0的时候，线程才可以被中断；</li>
<li>判断firstTask是否为空，为空则通过getTask()获取任务，不为空接着往下执行</li>
<li>判断是否符合中断状态，符合的话设置中断标记</li>
<li>执行beforeExecute()，task.run()，afterExecute()方法</li>
<li>任何一个出异常都会导致任务执行的终止；进入processWorkerExit来退出任务</li>
<li>正常执行的话会接着回到步骤2</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-23abafc5e23fb5c2.jpg" alt="runWorker.jpg"></p>
<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标志是否获取任务超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池的控制状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取线程池的runState</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *判断线程池的状态，出现以下两种情况</span></span><br><span class="line"><span class="comment">        *1、runState大于等于SHUTDOWN状态</span></span><br><span class="line"><span class="comment">        *2、runState大于等于STOP或者阻塞队列为空</span></span><br><span class="line"><span class="comment">        *将会通过CAS操作，进行workerCount-1并返回null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取线程池的workerCount</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *allowCoreThreadTimeOut：是否允许core Thread超时，默认false</span></span><br><span class="line"><span class="comment">        *workerCount是否大于核心核心线程池</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *1、wc大于maximumPoolSize或者已超时</span></span><br><span class="line"><span class="comment">        *2、队列不为空时保证至少有一个任务</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *通过CAS操作，workerCount-1</span></span><br><span class="line"><span class="comment">            *能进行-1操作，证明wc大于maximumPoolSize或者已经超时</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//-1操作成功，返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//-1操作失败，继续循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *wc大于核心线程池</span></span><br><span class="line"><span class="comment">            *执行poll方法</span></span><br><span class="line"><span class="comment">            *小于核心线程池</span></span><br><span class="line"><span class="comment">            *执行take方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="comment">//判断任务不为空返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//获取一段时间没有获取到，获取超时</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong></li>
</ul>
<blockquote>
<ol>
<li>获取线程池控制状态和runState，判断线程池是否已经关闭或者正在关闭，是的话则workerCount-1操作返回null</li>
<li>获取workerCount判断是否大于核心线程池</li>
<li>判断workerCount是否大于最大线程池数目或者已经超时，是的话workerCount-1，-1成功则返回null，不成功则回到步骤1重新继续</li>
<li>判断workerCount是否大于核心线程池，大于则用poll方法从队列获取任务，否则用take方法从队列获取任务</li>
<li>判断任务是否为空，不为空则返回获取的任务，否则回到步骤1重新继续</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-32d0795e439afc03.jpg" alt="getTask.jpg"></p>
<h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><p>从名称来看 Process Worker Exit：任务过程 退出，当任务执行完或者出现异常中断执行，强制被退出的时候，会有相应的操作，这个方法就是这个【相应的操作】</p>
<ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池-关闭"><a href="#线程池-关闭" class="headerlink" title="线程池 - 关闭"></a>线程池 - 关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是<strong>shutdown()</strong>和<strong>shutdownNow()</strong>：</p>
<ul>
<li><strong>shutdown方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态</span></span><br><span class="line"> advanceRunState(SHUTDOWN);</span><br><span class="line"><span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 清理一些资源</span></span><br><span class="line">        onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池 - 使线程池的状态设置为TERMINATED。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>shutdownNow方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池 - 使线程池的状态设置为TERMINATED。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池-监控"><a href="#线程池-监控" class="headerlink" title="线程池 - 监控"></a>线程池 - 监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li><strong>getTaskCount</strong>：线程池已经执行的和未执行的任务总数；</li>
<li><strong>getCompletedTaskCount</strong>：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li><strong>getLargestPoolSize</strong>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li><strong>getPoolSize</strong>：线程池当前的线程数量；</li>
<li><strong>getActiveCount</strong>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><ul>
<li><p>博客</p>
<ul>
<li><p>（java并发理论）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5374810.html">https://www.cnblogs.com/paddix/p/5374810.html</a></p>
</li>
<li><p>（java并发理解）<a target="_blank" rel="noopener" href="https://blog.csdn.net/jackfrued/article/details/44499227">https://blog.csdn.net/jackfrued/article/details/44499227</a></p>
</li>
<li><p>（可见性解释）<a target="_blank" rel="noopener" href="https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430">https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430</a></p>
</li>
<li><p>（指令重排）<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018909340">https://segmentfault.com/a/1190000018909340</a></p>
</li>
<li><p>（Java内存模型）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanfy008/p/9252555.html">https://www.cnblogs.com/yuanfy008/p/9252555.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/konck/p/9292584.html">https://www.cnblogs.com/konck/p/9292584.html</a></p>
<p>（Java内存模型和JVM内存管理）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjd_hycf_space/p/7505372.html">https://www.cnblogs.com/yjd_hycf_space/p/7505372.html</a></p>
</li>
<li><p>(happens-before) <a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=2102">http://cmsblogs.com/?p=2102</a></p>
</li>
<li><p>（volatile关键字的应用）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/daxin/p/3364014.html">https://www.cnblogs.com/daxin/p/3364014.html</a></p>
<p>（volatile解决了什么问题？）<a target="_blank" rel="noopener" href="https://blog.csdn.net/duqi_2009/article/details/94939145">https://blog.csdn.net/duqi_2009/article/details/94939145</a></p>
</li>
<li><p>（线程同步 - synchronized与锁） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/uodut/p/6775419.html">https://www.cnblogs.com/uodut/p/6775419.html</a></p>
</li>
<li><p>（深入分析Synchronized实现原理） <a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/54883355">https://blog.csdn.net/chenssy/article/details/54883355</a></p>
</li>
<li><p>（Java并发 -对象头）<a target="_blank" rel="noopener" href="https://blog.csdn.net/cold___play/article/details/104494045">https://blog.csdn.net/cold___play/article/details/104494045</a></p>
</li>
<li><p>（Synchronized实现原理与应用） <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012465296/article/details/53022317">https://blog.csdn.net/u012465296/article/details/53022317</a></p>
</li>
<li><p>（深入理解Java并发之synchronized实现原理）<a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p>
</li>
<li><p>（synchronized的三种应用方式） <a target="_blank" rel="noopener" href="https://blog.csdn.net/Kurry4ever_/article/details/109560858">https://blog.csdn.net/Kurry4ever_/article/details/109560858</a></p>
</li>
<li><p>（简单描述一下synchronized三种应用方法） <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44040505/article/details/102731061">https://blog.csdn.net/weixin_44040505/article/details/102731061</a></p>
</li>
<li><p>（Synchronized底层实现 - 概论、偏向锁、轻量级锁和重量级锁） <a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
</li>
<li><p>（锁膨胀原理分析 基于JDK6后） <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33762302/article/details/114297801">https://blog.csdn.net/qq_33762302/article/details/114297801</a></p>
</li>
<li><p>（synchronized关键字深度解析 - 批量重定向/撤销） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzq6032010/p/11967179.html">https://www.cnblogs.com/zzq6032010/p/11967179.html</a></p>
</li>
<li><p>（锁粗化与锁消除技术演示分析） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/webor2006/p/11448673.html">https://www.cnblogs.com/webor2006/p/11448673.html</a></p>
</li>
<li><p>（内存屏障） <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ab5e3d7e510">https://www.jianshu.com/p/2ab5e3d7e510</a></p>
</li>
<li><p>（volatile 可见性 有序性 - 内存层面上实现）<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014830955">https://segmentfault.com/a/1190000014830955</a></p>
</li>
<li><p>（内存屏障 - 分类）<a target="_blank" rel="noopener" href="https://blog.csdn.net/z55887/article/details/80836313">https://blog.csdn.net/z55887/article/details/80836313</a></p>
</li>
<li><p>（写缓存Store Buffer 与 无效化队列）<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44936828/article/details/89430358">https://blog.csdn.net/weixin_44936828/article/details/89430358</a></p>
</li>
<li><p>（可见性与有序性问题 volatile底层细节）<a target="_blank" rel="noopener" href="https://www.freesion.com/article/9021645644/">https://www.freesion.com/article/9021645644/</a></p>
</li>
<li><p>（可见性与有序性问题）<a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/239766">https://bbs.huaweicloud.com/blogs/239766</a></p>
</li>
<li><p>（synchronized学习 - 实现原理 - 优化 -例子）<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903600334831629">https://juejin.cn/post/6844903600334831629</a></p>
</li>
<li><p>（深入理解AQS）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc308d82cc71">https://www.jianshu.com/p/cc308d82cc71</a></p>
</li>
<li><p>（AQS）<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903601538596877">https://juejin.cn/post/6844903601538596877</a></p>
</li>
<li><p>（ReentanLock底层理解）<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuyuwei2015/article/details/83719444">https://blog.csdn.net/fuyuwei2015/article/details/83719444</a></p>
</li>
<li><p>（从底层深入解析读写锁）<a target="_blank" rel="noopener" href="https://blog.csdn.net/chongshizhuo8736/article/details/101042514">https://blog.csdn.net/chongshizhuo8736/article/details/101042514</a></p>
</li>
<li><p>（读锁源码分析）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cd485e16456e">https://www.jianshu.com/p/cd485e16456e</a></p>
</li>
<li><p>（死磕Java并发 读写锁源码分析）<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137797509">https://zhuanlan.zhihu.com/p/137797509</a></p>
</li>
<li><p>（例子讲解锁降级）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/takemybreathaway/articles/9399914.html">https://www.cnblogs.com/takemybreathaway/articles/9399914.html</a></p>
</li>
<li><p>（详解等待队列和同步队列的关系）<a target="_blank" rel="noopener" href="https://www.freesion.com/article/6246850783/">https://www.freesion.com/article/6246850783/</a></p>
</li>
<li><p>（LockSupport）<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1036645146/article/details/105635421">https://blog.csdn.net/a1036645146/article/details/105635421</a></p>
</li>
<li><p>（ThreadLoacl）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html#_label0">https://www.cnblogs.com/fsmly/p/11020641.html#_label0</a></p>
</li>
<li><p>（关于Hash）<a target="_blank" rel="noopener" href="http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm">http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm</a></p>
</li>
<li><p>（详解ThreadLoacl）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html">https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html</a></p>
</li>
<li><p>（ArrayBlockingQueue实现原理1）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/teach/p/10665199.html">https://www.cnblogs.com/teach/p/10665199.html</a></p>
</li>
<li><p>（LinkedBlockingQueue）<a target="_blank" rel="noopener" href="https://blog.csdn.net/tonywu1992/article/details/83419448">https://blog.csdn.net/tonywu1992/article/details/83419448</a></p>
</li>
<li><p>（详细分析Java并发集合ArrayBlockingQueue用法 - 这个确实讲的可以）<a target="_blank" rel="noopener" href="https://www.jb51.net/article/137750.htm">https://www.jb51.net/article/137750.htm</a></p>
</li>
<li><p>（LinkedBlockingQueue源码解析）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-zhao/p/5135958.html">https://www.cnblogs.com/java-zhao/p/5135958.html</a></p>
</li>
<li><p>（线程池）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c99ae559bdf7">https://www.jianshu.com/p/c99ae559bdf7</a></p>
</li>
</ul>
</li>
<li><p>书籍文献</p>
<ul>
<li>《java并发编程的艺术》</li>
<li>《疯狂java讲义》</li>
</ul>
</li>
<li><p>视频</p>
<ul>
<li>（AQS底层原理）<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zz4y197iF?t=624">https://www.bilibili.com/video/BV1Zz4y197iF?t=624</a></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Erii</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://uesugier11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">http://uesugier11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://uesugier11.github.io" target="_blank">Erii B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/"><img class="prev-cover" src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210602195137767.png" onerror="onerror=null;src='/UesugiEr11.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql进阶</div></div></a></div><div class="next-post pull-right"><a href="/UesugiEr11.github.io/2021/03/29/JVM/"><img class="next-cover" src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143528531.png" onerror="onerror=null;src='/UesugiEr11.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/UesugiEr11.github.io/img/avater.jpg" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Erii</div><div class="author-info__description">普普通通程序员</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/categories/"><div class="headline">分类</div><div class="length-num">72</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91-%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">Java并发 - 核心理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">共享性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">互斥性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.1.5.</span> <span class="toc-text">有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">并发编程模型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">线程之间如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">线程之间如何同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">硬件内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%EF%BC%88Java-Memory-Model%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">JMM（Java Memory Model）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before-%E9%87%8D%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">happens-before - 重点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">2.6.3.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-if-serial%E8%AF%AD%E4%B9%89"><span class="toc-number">2.6.4.</span> <span class="toc-text">as-if-serial语义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">2.7.</span> <span class="toc-text">volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Java并发机制底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">volatile的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.1.</span> <span class="toc-text">MESI缓存一致性协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-line"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">cache line</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MESI"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">MESI</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%AD%98-Store-Buffer"><span class="toc-number">3.1.2.</span> <span class="toc-text">写缓存 - Store Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%95%88%E5%8C%96%E9%98%9F%E5%88%97-Invalidate-Queue"><span class="toc-number">3.1.3.</span> <span class="toc-text">无效化队列 - Invalidate Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%AD%98%E4%B8%8E%E6%97%A0%E6%95%88%E5%8C%96%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%8D%E8%B6%B3%E6%80%A7"><span class="toc-number">3.1.4.</span> <span class="toc-text">写缓存与无效化队列的不足性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">3.1.5.</span> <span class="toc-text">内存屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">内存屏障分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">Java内存屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.1.6.</span> <span class="toc-text">如何保证可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-Lock%E5%89%8D%E7%BC%80"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">实现原理 - Lock前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">3.1.7.</span> <span class="toc-text">如何保证有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">3.2.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">CAS概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">CAS操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.3.</span> <span class="toc-text">CAS应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.4.</span> <span class="toc-text">CAS存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4-monitor"><span class="toc-number">3.3.</span> <span class="toc-text">Java对象头 monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">3.3.1.</span> <span class="toc-text">Java对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">对象头的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mark-Word"><span class="toc-number">3.3.1.2.1.</span> <span class="toc-text">Mark Word</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#class-pointer"><span class="toc-number">3.3.1.2.2.</span> <span class="toc-text">class pointer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#array-length"><span class="toc-number">3.3.1.2.3.</span> <span class="toc-text">array length</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monitor"><span class="toc-number">3.3.2.</span> <span class="toc-text">monitor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%EF%BC%88%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">synchronized（内置锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A4%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">synchronized作用于实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">synchronized作用于静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">synchronized同步代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">锁&#x2F;锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">3.5.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.5.3.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E4%B8%8E%E6%92%A4%E9%94%80"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">批量重偏向与撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.5.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">3.5.5.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.5.6.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.5.7.</span> <span class="toc-text">适应自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.5.8.</span> <span class="toc-text">锁转换流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">3.5.9.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">3.5.10.</span> <span class="toc-text">锁粗化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">3.6.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%9F%BA%E7%A1%80"><span class="toc-number">3.6.1.</span> <span class="toc-text">final基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84final"><span class="toc-number">3.6.2.</span> <span class="toc-text">多线程中的final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">final域重排序规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final%E5%9F%9F%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.2.1.1.</span> <span class="toc-text">final域为基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final%E5%9F%9F%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.2.1.2.</span> <span class="toc-text">final域为引用类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">final实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD-%E2%80%9C%E9%80%B8%E5%87%BA%E2%80%9D"><span class="toc-number">3.6.4.</span> <span class="toc-text">为什么final引用不能从构造函数中 “逸出”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lock%E4%BD%93%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">Lock体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cocurrent%E5%8C%85%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1"><span class="toc-number">4.1.</span> <span class="toc-text">cocurrent包结构层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Lock简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3API"><span class="toc-number">4.3.</span> <span class="toc-text">Lock接口API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractQueuedSynchronizer%EF%BC%88AQS%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">AbstractQueuedSynchronizer（AQS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">AQS模板方法设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82"><span class="toc-number">4.4.3.</span> <span class="toc-text">AQS底层细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">AQS模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">同步队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">独占锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">4.4.3.3.1.</span> <span class="toc-text">独占锁的获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">4.4.3.3.2.</span> <span class="toc-text">独占锁的释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%88acquireInterruptibly%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.4.3.3.3.</span> <span class="toc-text">可中断式获取锁（acquireInterruptibly方法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%88tryAcquireNanos-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.4.3.3.4.</span> <span class="toc-text">超时等待式获取锁（tryAcquireNanos()方法）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">共享锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%EF%BC%88acquireShared-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.4.3.4.1.</span> <span class="toc-text">共享锁的获取（acquireShared()方法）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%EF%BC%88releaseShared-%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.4.3.4.2.</span> <span class="toc-text">共享锁的释放（releaseShared()方法）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">4.5.</span> <span class="toc-text">ReentrantLock - 可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%AE%80%E4%BB%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">ReentrantLock简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">重入性的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.5.3.</span> <span class="toc-text">公平锁与非公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">4.6.</span> <span class="toc-text">ReentrantReadWriteLock - 读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadLock"><span class="toc-number">4.6.1.</span> <span class="toc-text">ReadLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">读锁的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">读锁的释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteLock"><span class="toc-number">4.6.2.</span> <span class="toc-text">WriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">写锁的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">写锁的释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">4.6.3.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition"><span class="toc-number">4.7.</span> <span class="toc-text">Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">4.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">4.7.2.</span> <span class="toc-text">原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">await实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-signalAll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">signal&#x2F;signalAll实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transferForSignal-Node-node-%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.2.3.1.</span> <span class="toc-text">transferForSignal(Node node)方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await%E4%B8%8Esignal%E7%BB%93%E5%90%88"><span class="toc-number">4.7.2.4.</span> <span class="toc-text">await与signal结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90"><span class="toc-number">4.7.2.5.</span> <span class="toc-text">代码例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.8.</span> <span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.1.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">ConcurrentHashMap简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-amp-%E7%B1%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text">关键属性 &amp; 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">容器初始化方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">实例构造器方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initTable%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">initTable方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%EF%BC%88put%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">添加（put）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82-amp-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">代码细节 &amp; 逻辑分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA%EF%BC%88get%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.5.</span> <span class="toc-text">取出（get）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-1"><span class="toc-number">5.1.5.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">5.1.5.2.</span> <span class="toc-text">代码逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%EF%BC%88-transfer%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.6.</span> <span class="toc-text">扩容（ transfer）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">5.1.6.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B-%E7%BB%86%E8%8A%82"><span class="toc-number">5.1.6.2.</span> <span class="toc-text">代码流程&#x2F;细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8A%A9%E6%89%A9%E5%AE%B9%EF%BC%88helpTransfer%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.7.</span> <span class="toc-text">协助扩容（helpTransfer）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%95%BF%E5%BA%A6%E7%B4%AF%E8%AE%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.8.</span> <span class="toc-text">集合长度累计方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addCount%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.8.1.</span> <span class="toc-text">addCount方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fullAddCount%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.8.2.</span> <span class="toc-text">fullAddCount方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%95%BF%E5%BA%A6%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.9.</span> <span class="toc-text">集合长度获取方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#size%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.9.1.</span> <span class="toc-text">size方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sumCount%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.9.2.</span> <span class="toc-text">sumCount方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">5.2.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">set方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-3"><span class="toc-number">5.2.2.1.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B-%E7%BB%86%E8%8A%82-1"><span class="toc-number">5.2.2.1.2.</span> <span class="toc-text">代码流程&#x2F;细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.2.1.3.</span> <span class="toc-text">图解流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">get方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-4"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B-%E7%BB%86%E8%8A%82-2"><span class="toc-number">5.2.2.2.2.</span> <span class="toc-text">代码流程&#x2F;细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-1"><span class="toc-number">5.2.2.2.3.</span> <span class="toc-text">图解流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">remove方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-5"><span class="toc-number">5.2.2.3.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B-%E7%BB%86%E8%8A%82-3"><span class="toc-number">5.2.2.3.2.</span> <span class="toc-text">代码流程&#x2F;细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-2"><span class="toc-number">5.2.2.3.3.</span> <span class="toc-text">图解流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLoacl%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82"><span class="toc-number">5.2.3.</span> <span class="toc-text">ThreadLoacl底层细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Entry%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">Entry数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">set方法细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">5.2.3.2.1.</span> <span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E8%A1%A8%E6%B3%95-%E4%B8%8E-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">5.2.3.2.2.</span> <span class="toc-text">分离链表法 与 开放定址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-6"><span class="toc-number">5.2.3.2.3.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.3.2.4.</span> <span class="toc-text">一些问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getEntry%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">getEntry方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-7"><span class="toc-number">5.2.3.3.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%BB%E8%BE%91"><span class="toc-number">5.2.3.3.2.</span> <span class="toc-text">方法逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-3"><span class="toc-number">5.2.3.3.3.</span> <span class="toc-text">图解流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">remove方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-8"><span class="toc-number">5.2.3.4.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91-1"><span class="toc-number">5.2.3.4.2.</span> <span class="toc-text">代码逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%B5%81%E7%A8%8B-4"><span class="toc-number">5.2.3.4.3.</span> <span class="toc-text">图解流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.4.</span> <span class="toc-text">内存泄漏问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cleanSomeSlots%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.4.1.1.</span> <span class="toc-text">cleanSomeSlots方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#expungeStaleEntry%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.4.1.1.1.</span> <span class="toc-text">expungeStaleEntry方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.4.1.1.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replaceStaleEntry"><span class="toc-number">5.2.4.1.2.</span> <span class="toc-text">replaceStaleEntry</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockingQueue-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.3.</span> <span class="toc-text">BlockingQueue - 阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">5.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.2.</span> <span class="toc-text">基本操作 - 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.3.3.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">ArrayBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-number">5.3.3.1.1.</span> <span class="toc-text">主要属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.1.2.</span> <span class="toc-text">入队方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E9%98%9F%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.1.3.</span> <span class="toc-text">出队方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.1.4.</span> <span class="toc-text">查看方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">LinkedBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7-1"><span class="toc-number">5.3.3.2.1.</span> <span class="toc-text">主要属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.3.3.2.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.3.3.2.3.</span> <span class="toc-text">入队方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BA%E9%98%9F%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.3.3.2.4.</span> <span class="toc-text">出队方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue%E4%B8%8ELinkedBlockingQueue%E5%AF%B9%E6%AF%94"><span class="toc-number">5.3.3.3.</span> <span class="toc-text">ArrayBlockingQueue与LinkedBlockingQueue对比</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%88%9B%E5%BB%BA"><span class="toc-number">6.3.</span> <span class="toc-text">线程池 - 创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">6.3.1.</span> <span class="toc-text">线程池参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E6%8F%90%E4%BA%A4"><span class="toc-number">6.4.</span> <span class="toc-text">线程池 - 提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execute%E6%BA%90%E7%A0%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">execute源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.4.2.</span> <span class="toc-text">execute执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addWorker"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">addWorker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runworker"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">runworker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getTask"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">getTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processWorkerExit"><span class="toc-number">6.4.2.4.</span> <span class="toc-text">processWorkerExit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%85%B3%E9%97%AD"><span class="toc-number">6.5.</span> <span class="toc-text">线程池 - 关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%9B%91%E6%8E%A7"><span class="toc-number">6.6.</span> <span class="toc-text">线程池 - 监控</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">线程协作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">技术参考</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" title="Mysql进阶"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210602195137767.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="Mysql进阶"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" title="Mysql进阶">Mysql进阶</a><time datetime="2021-06-02T12:34:12.103Z" title="发表于 2021-06-02 20:34:12">2021-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" title="Java并发"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="Java并发"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" title="Java并发">Java并发</a><time datetime="2021-04-22T14:26:11.873Z" title="发表于 2021-04-22 22:26:11">2021-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/29/JVM/" title="JVM"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143528531.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/29/JVM/" title="JVM">JVM</a><time datetime="2021-03-29T07:51:18.960Z" title="发表于 2021-03-29 15:51:18">2021-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" title="SpringBoot"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321190228486.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2021-03-21T11:04:51.373Z" title="发表于 2021-03-21 19:04:51">2021-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" title="SSM整合"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318222358752.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="SSM整合"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a><time datetime="2021-03-18T14:26:02.754Z" title="发表于 2021-03-18 22:26:02">2021-03-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Erii</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/UesugiEr11.github.io/js/utils.js"></script><script src="/UesugiEr11.github.io/js/main.js"></script><script src="/UesugiEr11.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>