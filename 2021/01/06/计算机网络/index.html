<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机网络 | Erii B1og</title><meta name="author" content="Erii"><meta name="copyright" content="Erii"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="计网知识点小小总结">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://uesugier11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="计网知识点小小总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/u=3865179010,761192413&fm=26&gp=0.jpg">
<meta property="article:published_time" content="2021-01-06T14:02:59.477Z">
<meta property="article:modified_time" content="2021-01-06T13:56:42.074Z">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/UesugiEr11/pictures/raw/master/img/u=3865179010,761192413&fm=26&gp=0.jpg"><link rel="shortcut icon" href="/UesugiEr11.github.io/img/favicon.png"><link rel="canonical" href="http://uesugier11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/UesugiEr11.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/UesugiEr11.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-06 21:56:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/UesugiEr11.github.io/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/UesugiEr11.github.io/categories/"><div class="headline">分类</div><div class="length-num">72</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/UesugiEr11.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/UesugiEr11.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/UesugiEr11/pictures/raw/master/img/u=3865179010,761192413&amp;fm=26&amp;gp=0.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/UesugiEr11.github.io/">Erii B1og</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/UesugiEr11.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/UesugiEr11.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/UesugiEr11.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-06T14:02:59.477Z" title="发表于 2021-01-06 22:02:59">2021-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-06T13:56:42.074Z" title="更新于 2021-01-06 21:56:42">2021-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">51.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>155分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h3><ul>
<li>计算机网络：是一个<strong>分散的</strong>、<strong>并具有独立功能</strong>的 <strong>计算机系统</strong>，通过<strong>通信设备</strong>（路由器、交换机、无线网卡…）与<strong>线路</strong>（端系统与通信设备连接的介质）连接起来，由功能完善的<br>软件<strong>实现</strong>资源共享<strong>和</strong>信息传递<strong>的</strong>系统</li>
<li>一句话来说，计算机网络是互连的、自治的计算机集合。<ul>
<li>互连：互联互通，通过通信链路（卫星，电波…)</li>
<li>自治：相互独立,端系统之间可以通信，但不能控制对方，没主从关系</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012200821531.png" alt="image-20201012200821531"></p>
<h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><ul>
<li><strong>数据通信</strong>：文档传输   </li>
<li><strong>资源共享</strong> ：凡是入网用户均能享受网络中各个计算机系统的全部或部分软件、硬件和数据资源，为最本质的功能。</li>
<li><strong>分布式处理</strong>：通过算法将大型的综合性问题交给不同的计算机同时进行处理。用户可以根据需要合理选择网络资源，就近快速地进行处理。</li>
<li><strong>提高可靠性</strong>：一旦某台计算机出现故障，它的任务就可由其他的计算机代为完成，这样可以避免在单机情况下，一台计算机发生故障引起整个系统瘫痪的现象，从而提高系统的可靠性</li>
<li><strong>负载均衡</strong>：而当网络中的某台计算机负担过重时，网络又可以将新的任务交给较空闲的计算机完成，均衡负载，从而提高了每台计算机的可用性</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203319972.png" alt="image-20201012203319972"></p>
<h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203839874.png" alt="image-20201012203839874"></p>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>工作方式<ul>
<li>边缘部分：用户直接使用</li>
<li>核心部分：为边缘部分服务</li>
</ul>
</li>
<li>核心部分为边缘部分服务，支撑边缘部分实现各种功能</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203947005.png" alt="image-20201012203947005"></p>
<h4 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h4><ul>
<li><p>主要功能分 <strong>数据通信</strong> 和 <strong>资源共享</strong></p>
<ul>
<li>通信子网：实现数据通信</li>
<li>资源子网：实现数据处理/资源共享</li>
</ul>
</li>
<li><p>通信子网:包含网络层，数据链路层，物理层</p>
</li>
<li><p>资源子网:包含应用层，表示层，会话层</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012204615021.png" alt="image-20201012204615021"></p>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012205917270.png" alt="image-20201012205917270"></p>
<ul>
<li>按分布范围分：广域网 城域网 局域网 个人区域网</li>
<li>按使用者分：公用网 专用网</li>
<li>按交换技术分：电路交换 报文交换 分组交换</li>
<li>按拓扑结构分：线型 星型 环形 网状型 混合型</li>
<li>按传输技术分：广播式网络 点对点网络</li>
</ul>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><ul>
<li>速率：<strong>数据率</strong> or <strong>数据传输率</strong> or <strong>比特率</strong></li>
<li>表示连接在计算机网络上的<strong>主机</strong> 在 <strong>数字信道上</strong>传送<strong>数据位数的速率</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012211716629.png" alt="image-20201012211716629"></p>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><ul>
<li>带宽是用于表示网络的通信线路栓送数据的能力，是指<strong>单位时间</strong>内能<strong>向链路发送</strong>多少<strong>数据</strong>，而<strong>不是</strong>单位时间内能<strong>实际传输多少数据</strong>，因为能传输多少数据有很多其他因素限制，<strong>带宽是理想条件下的最高速率</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012213423873.png" alt="image-20201012213423873"></li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><ul>
<li><p>吞吐量：表示单位时间内通过某个网络（或信道，接口）的数据量，是实际速率，其单位是b/s，kb/s，Mb/s</p>
</li>
<li><p>受网络带宽或网络的额定速率的限制。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012214948913.png" alt="image-20201012214948913"></p>
</li>
</ul>
<h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><ul>
<li><strong>时延</strong>：指数据从网络的<strong>一端传送导另一端</strong>所需要的<strong>时间</strong>，也叫<strong>延迟或迟延</strong>，单位是<strong>s</strong>。</li>
<li>时延包括：<strong>发送时延，传播时延，排队时延，处理时延</strong><ul>
<li><strong>发送时延</strong><ul>
<li>是主机或路由器发送数据帧所需要的时间</li>
<li>也是指从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间</li>
<li>发送时延（传输时延）发生在机器的内部的发送器中</li>
<li>等于数据长度/信道带宽</li>
</ul>
</li>
<li><strong>传播时延</strong>:<ul>
<li>取决于电磁波传播速度和链路长度</li>
<li>传播时延则发生在机器外部的传输信道媒体上</li>
<li>等于信道长度/电磁波在信道上的传播速率（这个速率主要由介质影响）</li>
</ul>
</li>
<li><strong>排队时延</strong>:<ul>
<li>是路由器或者交换机处理数据包排队所消耗的时间</li>
<li>一个特定分组的排队时延取决于先期到达的、正在排队等待向链路传输分组的数量</li>
</ul>
</li>
<li><strong>处理时延</strong>:<ul>
<li>主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错或查找适当的路由等等</li>
</ul>
</li>
</ul>
</li>
<li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li>
<li>《计算机网络》一书中将<strong>传输时延</strong>与<strong>传播时延</strong>的关系类比成车队经由收费站的例子；十分生动形象</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017221745259.png" alt="image-20201017221745259"></p>
<h5 id="时延宽带积"><a href="#时延宽带积" class="headerlink" title="时延宽带积"></a>时延宽带积</h5><ul>
<li><p>时延带宽积 = 传播时延 × 带宽</p>
<p>bit                      s                b/s</p>
</li>
<li><p>如何生动形象的描述时延带宽积呢？</p>
<p>我们把链路的<strong>长</strong>定义为<strong>传播时延</strong>;把横截面的<strong>宽</strong>定义为<strong>带宽</strong></p>
<p>一个<strong>比</strong>特经过一个<strong>传播时延</strong>正好通过一个<strong>链路</strong></p>
<p>当第一个比特在左侧出现 然后 碰到右侧时停止，此时链路中的比特数量就是时延带宽积了</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022170410645.png" alt="image-20201022170410645"></p>
<h5 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h5><ul>
<li>从<strong>发送方</strong>发送数据完开始，到<strong>发送方</strong>收到<strong>接收方</strong>的确认，总共经历的时延</li>
<li>RTT越<strong>大</strong>，在收到确认之前，可以发送的<strong>数据越多</strong></li>
<li>RTT包括<ul>
<li><strong>往返传播时延</strong> = <strong>传播时延 × 2</strong></li>
<li>末端处理时间（指的是接收方对数据进行处理所花费的时间）</li>
</ul>
</li>
<li>RTT不包括传输时延，大部分只由<strong>传播时延</strong>决定</li>
</ul>
<h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><ul>
<li><p>利用率</p>
<ul>
<li>信道利用率：有数据通过时间/（有+无）数据通过时间</li>
<li>网络利用率：信道利用率的加权平均值</li>
</ul>
</li>
<li><p>利用率并不是越高越好的，当利用率升高的时候，时延也会急剧增大</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022190039038.png" alt="image-20201022190039038"></p>
</li>
</ul>
<h2 id="计算机体系结构与参考模型"><a href="#计算机体系结构与参考模型" class="headerlink" title="计算机体系结构与参考模型"></a>计算机体系结构与参考模型</h2><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022192251153.png" alt="image-20201022192251153"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022200844795.png" alt="image-20201022200844795"></p>
<ul>
<li>首先我们考虑一下为什么要分层？</li>
</ul>
<p>我们知道，一端要发送文件到另一端前要完成的工作有：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong></li>
<li>告知网络如何识别目的主机</li>
<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常</li>
<li>发起通信的计算机要弄清楚，对方计算机中<strong>文件管理程序</strong>是否已经做好了准备工作</li>
<li>确保差错和意外可以解决</li>
<li>……….等等等等</li>
</ol>
<p>我们这些问题都需要解决，显然不可能在一层就解决，那对于我们程序员来说，最喜欢的事情就是分层处理（大问题→小问题）</p>
<h4 id="分层基本原则"><a href="#分层基本原则" class="headerlink" title="分层基本原则"></a>分层基本原则</h4><ol>
<li>各层之间相互独立，每层 只实现<strong>一种相对独立</strong>的功能</li>
<li>各层之间界面<strong>自然清晰，易于理解</strong>，相互交流尽可能<strong>少</strong></li>
<li>结构上可分隔开，每层都采用<strong>最合适的技术</strong>来实现</li>
<li>保持<strong>下层</strong>对<strong>上层</strong>的独立性，上层单向使用<strong>下层提供的服务</strong></li>
<li>整个分层结构应该能促进<strong>标准化工作</strong></li>
</ol>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022194736600.png" alt="image-20201022194736600"></p>
<ul>
<li>在分层网络结构中，在传输系统的每一层都将建立<strong>协议数据单元（PDU）</strong></li>
<li>PDU由两部分组成：<strong>SDU服务数据单元 + PCI协议控制信息</strong></li>
<li>PDU协议数据单元：对等层次之间传送的数据单位<ul>
<li>SDU服务数据单元：为完成用户所要求的功能而应传送的数据</li>
<li>PCI协议控制信息：控制协议操作的信息</li>
</ul>
</li>
</ul>
<h3 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h3><ul>
<li><strong>实体</strong><ul>
<li>在第n层的活动元素称为n层实体，同一层实体叫做<strong>对等实体</strong>；</li>
<li>当研究开放系统中的信息交换时，往往使用<strong>实体(entity)</strong>这一较为抽象的名词。</li>
</ul>
</li>
<li>协议<ul>
<li>协议为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议；</li>
<li>协议的语法方面规则定义了所交换的信息的格式。</li>
<li>协议是<strong>水平</strong>的，即协议是控制<strong>对等实体</strong>之间通信的规则。</li>
<li>协议的语义方面<strong>规则定义</strong>了<strong>发送者</strong>或<strong>接收者</strong>所要<strong>完成的操作</strong>，例如，在何种条件下数据必须重传或丢弃。</li>
<li>在协议的控制下，两个<strong>对等实体间</strong>的通信使得本层能够<strong>向上一层提供服务</strong>。要<strong>实现本层协议</strong>，还<strong>需要使用下面一层所提供的服务。</strong></li>
<li>协议的实现保证了能够<strong>向上一层提供服务</strong>。使用<strong>本层服务的实体</strong>只能<strong>看见服务</strong>而<strong>无法看见下面的协议</strong>。<strong>下面的协议对上面的实体是透明的。</strong></li>
<li>协议由三部分组成：<ul>
<li>语法：规定传输数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：执行各种操作的条件、时序关系等等</li>
</ul>
</li>
</ul>
</li>
<li><strong>接口</strong><ul>
<li>在同一系统中相邻两层的实体进行交互(即交换信息)的地方，通常称为<strong>服务访问点SAP(Service Access Point)</strong>。</li>
<li>服务访问点SAP是一个抽象的概念，它<strong>实际上</strong>就是一个<strong>逻辑接口</strong>，有点像邮政信箱(可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口(并行的或串行的)并不一样。</li>
<li>OSI把层与层之间交换的数据的单位称为<strong>服务数据单元SDU(Service Data Unit)</strong>，它可以与PDU不一样，例如，可以是多个SDU合成为一个PDU，也可以是一个SDU划分为几个PDU。</li>
</ul>
</li>
<li><strong>服务</strong><ul>
<li><strong>服务是垂直的，即服务是由下层向上层通过层间接口提供的。</strong></li>
<li>并非在一个层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</li>
<li>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为<strong>服务原语</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022195305866.png" alt="image-20201022195305866"></p>
<h3 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h3><table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>功能</th>
<th>对应的网络协议</th>
<th>TCP/IP四层概念模型</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>文件传输，文件管理，电子邮件的信息处理——apdu</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td>确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，最小单位——ppdu</td>
<td>Telnet, Rlogin, SNMP, Gopher，JPEG,ASCII</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
<td>负责在网络中的两节点建立，维持和终止通信，在一层协议中，可以解决节点连接的协调和管理问题。包括通信连接的建立，保持会话过程通信连接的畅通，两节点之间的对话，决定通信是否被终端一斤通信终端是决定从何处重新发送，最小单位——spdu</td>
<td>SMTP, DNS，ADSP,ASP</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>定义一些传输数据的协议和端口。传输协议同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题——tpdu</td>
<td>TCP, UDP</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>控制子网的运行，如逻辑编址，分组传输，路由选择最小单位——分组（包）报文</td>
<td>IP, IPX，ICMP,IGMP, ARP, RARP, AKP, UUCP,OSPF</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装，也可以简单的理解为物理寻址。交换机就处在这一层，最小的传输单位——帧</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
<td>数据链路层</td>
</tr>
<tr>
<td>物理层</td>
<td>定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准，传输比特流，因此最小的传输单位——位（比特流）</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td>
<td>数据链路层</td>
</tr>
</tbody></table>
<h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/750327-20160822164857776-669486844.gif" alt="img"></p>
<ul>
<li>为解决计算机网络复杂大问题 → 分层结构</li>
<li>不同的公司使用不同的网络体系结构，因此异构网络是很难通信的</li>
<li>为了解决这个问题，<strong>国际标准化组织ISO</strong>在1984提出开放系统互连（<strong>OSI</strong>）参考模型</li>
<li>虽然它被TCP/IP模型打败了，但是仍具有很高学习价值，下面就来学习下什么是OSI参考模型</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022204144457.png" alt="image-20201022204144457"></p>
<h5 id="ISO-OSI参考模型通信过程"><a href="#ISO-OSI参考模型通信过程" class="headerlink" title="ISO/OSI参考模型通信过程"></a>ISO/OSI参考模型通信过程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205418866.png" alt="image-20201022205418866"></p>
<ul>
<li>我们不难发现，上面四层：应用层 表示层 会话层 传输层是中间系统没有进行处理的，那么我们可将这部分视作是<strong>端到端</strong>的</li>
<li>而下面三层只知道应该去往下一个节点，因此是<strong>点到点的</strong></li>
</ul>
<p>那么每一层每一层之间其实又进行了什么处理呢?其实就是添加各种<strong>PCI</strong>，而只有每一层对等的知道怎么解那个协议；像是礼物的包装和拆包一样。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205604505.png" alt="image-20201022205604505"></p>
<h5 id="每层的功能"><a href="#每层的功能" class="headerlink" title="每层的功能"></a>每层的功能</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205841421.png" alt="image-20201022205841421"></p>
<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022210842056.png" alt="image-20201022210842056"></p>
<ul>
<li>应用层是<strong>用户与网络的界面</strong>；</li>
<li>应用层定义的是应用程序用于请求网络服务的<strong>接口</strong>，而不是指应用程序本身。</li>
<li>应用层主要定义了应用程序能够从网络上请求使用哪种类型的服务，并且规定了在从应用程序接收消息或向应用程序发送消息时，数据所必须采用的<strong>格式</strong>。</li>
<li>典型的应用层服务以及对应的协议<ul>
<li><strong>文件传输 - FTP</strong></li>
<li><strong>电子邮件 - SMTP</strong></li>
<li><strong>万维网 - HTTP</strong></li>
</ul>
</li>
</ul>
<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022210853321.png" alt="image-20201022210853321"></p>
<ul>
<li>用于处理在两个通信系统中交换信息的表示方式（语法和语义)</li>
<li><strong>功能</strong><ul>
<li><strong>数据格式变换</strong></li>
<li><strong>数据加密解密</strong></li>
<li><strong>数据压缩和恢复</strong></li>
</ul>
</li>
</ul>
<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024164651127.png" alt="image-20201024164651127"></p>
<ul>
<li><p>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序的传输数据</strong>，这是会话，也是<strong>建立同步（SYN)</strong></p>
<p>会话之间彼此独立，不会互相影响</p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li>建立、管理、终止会话</li>
<li>使用校验点可以使会话在通信失效的时候从校验点/同步点继续恢复通信，实现数据同步</li>
</ul>
</li>
</ul>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024165727974.png" alt></p>
<ul>
<li><p>负责主机中两个进程的通信，即<strong>端到端</strong>的通信，传输内容是报文段或是用户数据报；</p>
</li>
<li><p>我们这里提到 <strong>端到端</strong> 什么是<strong>端到端</strong>呢？</p>
<p>OSI七层模型中，上面四层是<strong>端到端通信</strong>，下面三层是<strong>点到点通信</strong></p>
<p><strong>端到端通信</strong>，是一个网络连接，网络通信需要建立连接，只需要实现应用程序之间通信，而不需要知道底层是如何传输的</p>
<p> A → B → C → D → E</p>
<p><strong>点到点通信</strong>，是发送端把传给他直接相连的设备，这台设备在合适的时候把数据传给与之相连的下一台设备，通过一台一台直接相连的设备，把数据传到接收端。</p>
<p>A → B 、B → C、 C → D 、D → E</p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><p><strong>可靠传输、不可靠传输</strong></p>
<ul>
<li>可靠传输：传输层使用TCP来提供通信数据的可靠传输。（确认机制）</li>
<li>不可靠传输：传输层中不可靠的传输方式使用的是UDP协议（不管确不确认，直接发）</li>
</ul>
</li>
<li><p><strong>差错控制</strong>：报文段数据丢失，需要进行纠正</p>
</li>
<li><p><strong>流量控制</strong>：控制发送方的速度，不能一次传太多</p>
</li>
<li><p><strong>复用分用</strong></p>
<ul>
<li><p><strong>复用</strong>：多个应用层进程可同时使用下面运输层的服务</p>
</li>
<li><p><strong>分用</strong>：运输层把收到的信息分别交付给上面应用层中相应的进程</p>
<p>比如说一台手机上两个进程（应用）QQ和微信，QQ端口号是1 微信端口号是2；</p>
<p>这两个进程同时使用传输层传输数据 —— <strong>复用</strong></p>
<p>另一台手机接收了QQ和微信信息，并且根据其中端口号不同的不同用不同的应用程序接受信息 —— <strong>分用</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024172551239.png" alt="image-20201024172551239"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024172806918.png" alt="image-20201024172806918"></p>
<ul>
<li><p>主要任务是把<strong>分组</strong>（很小的无需分片的ip数据包就是分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务；</p>
<p>网络层传输单位是<strong>数据报</strong></p>
</li>
<li><p><strong>功能</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024174151515.png" alt="image-20201024174151515"></p>
<ul>
<li><strong>路由控制</strong>：左边的主机想和右边的主机通话，那么这个数据包一定会经过网络。中间灰色的圆圈是路由器，他们组成了一个网络，数据链路层只是把这个信息传递了“一跳”，也就是从介质的一端传递到另一端，在图里面比如说从路由器1传递到2.但是网络层做的事情是，规划好所有跳的路线，比如说数据包要依次经过1,2,3,6才能从左边主机到达右边主机，这就是网络层一个非常重要的作用，也就是提供“路由routing”。</li>
<li><strong>流量控制</strong>：控制发送方发送数据的速度（与传输层功能好像有点重读？</li>
<li><strong>差错控制</strong>：通信的节点之间约定一些规则，接收方根据规则校验分组有没有错，然后纠错，纠不了错就丢弃分组；保证传输层的数据是正确的</li>
<li><strong>拥塞控制</strong>：就像城市里面哪里堵车了，其他人就知道不要再去了，网络层也一样。比如上图中2，3路由器出现了严重的拥塞，那么左边主机往右边发送包就会从1236变成1456。拥塞控制对于网络的效率以及降低丢包率有着无可替代的作用。</li>
</ul>
</li>
</ul>
<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024175136346.png" alt="image-20201024175136346"></p>
<ul>
<li><p>主要任务是把网络层传下来的<strong>数据报</strong>组装成<strong>帧</strong></p>
<p>数据链路层/链路层的<strong>传输单位</strong>是<strong>帧</strong></p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><strong>成帧（定义帧的开始和结束）</strong>：</li>
<li><strong>差错控制/错误检测</strong>：这里的错误包括 <strong>帧错+位错</strong>，可以通过一些协议去纠错</li>
<li><strong>流量控制</strong>：同样，也是控制发送方数据的发送速度，确保数据通信的有序进行，还可避免通信过程中不会出现因为接收方来不及接收而造成的数据丢失。</li>
<li><strong>访问（接入）控制/链路控制</strong>：控制对信道的访问，当网络中两个节点要进行通信的时候，数据的发送方必须确知接收方是否已经处在准备接收的状态。为此通信双方必须先交换一些必要信息，以建立一条基本的数据链路。在传输数据时要维持数据链路，而在通信完毕的时候释放数据链路</li>
</ul>
</li>
</ul>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024180209001.png" alt="image-20201024180209001"></p>
<ul>
<li><p>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>（指不管所传数据是什么样的比特组合，都应当能够在链路上进行传输）</p>
<p>物理层传输单位是<strong>比特</strong></p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><p><strong>定义接口特性</strong></p>
<ul>
<li><p><strong>机械特性</strong>:说明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
</li>
<li><p><strong>电气特性</strong>:指明在接口电缆的各条线上出现的电压的范围。</p>
</li>
<li><p><strong>功能特性</strong>:指明某条线上出现的某一电平的电压表示何意。</p>
</li>
<li><p><strong>规程特性</strong>:说明对于不同功能的各种可能事件的出现顺序。</p>
</li>
</ul>
</li>
<li><p>定义传输模式：</p>
<ul>
<li>单工：只能一个发一个收</li>
<li>半双工：两者都可以当发的，可以同时发</li>
<li>双工：两者都可以当发的，但同一时间只能一个人发</li>
</ul>
</li>
<li><p>定义传输速率：十兆、百兆 这些传输速率由物理层进行定义</p>
</li>
<li><p>比特同步：发送方发一个 1 ，接收方接收一个 1</p>
</li>
<li><p>比特编码：什么电压0 ，什么电压表示1</p>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027190911334.png" alt></p>
<p>既然OSI七层协议体系结构概念清楚，理论也完整，那我们为什么不用他呢？因为它太复杂且不适用，而TCP/IP体系结构不然，TCP/IP其实是一个<strong>四层体系结构</strong>，它包含：应用层、传输层、网际层和网络接口层</p>
<p>从实质来说，TCP/IP只包含上面三层，下面的网络接口层没什么协议啊之类的，没什么内容。因此我们往往结合两种模型优点，形成了一种五层协议的体系结构。</p>
<p>在网上看到一段话 用于解释TCP/IP模型，我觉得说的非常好：</p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/90fa75863fce">https://www.jianshu.com/p/90fa75863fce</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">要理解TCP/IP，我们依旧要先搞清楚它想干嘛？</span><br><span class="line"></span><br><span class="line">一句话概括，就是用最少的资源，准确快速的把信息传送到对端去。</span><br><span class="line"></span><br><span class="line">那么这里面就有很多问题要解决了：怎样充分利用资源？用资源怎么发信息？怎样找到对端？怎样做到准确？怎样快速？怎样保证对端完整收到信息？………</span><br><span class="line"></span><br><span class="line">对于学计算机的我们，这个时候应该就能想到，这么多问题，不可能一次性解决，需要分解，分模块来解决，TCP/IP分层模型也是这么想的。</span><br><span class="line"></span><br><span class="line">首先是怎样充分利用资源，用什么物质传又省钱又好用？这就是物理层要解决的问题了，这里展开来就是无线铜线光纤损耗等等的问题。很好理解。</span><br><span class="line"></span><br><span class="line">然后知道介质了，怎样把信息传给设备？这就是数据链路层要解决的问题了。这里需要解决信息的封装问题，信息传送机制问题。所以这一层的所有协议设计都是围绕着怎么传信息展开。</span><br><span class="line"></span><br><span class="line">理论上到这里就结束了，但随着入网设备越来越多，就需要被管理了，所以网络层就来解决网络管理的问题。IP层是整个网络分层里承上启下的核心，他主要解决两个问题，一个是编号，一个是找人。网络太大，人太多，认识不过来，所以要用ip地址给人编号。编完号找人，几十亿人一个个问也不可行，也是要讲方法的，所以这里就有了路由技术。网络层的关键是路由技术，路由技术解决怎样快速准确找到对端的问题。</span><br><span class="line"></span><br><span class="line">找到对端后，怎样保证对端完整收到信息？这就是传输层要解决的问题了，这里就有传送速度的调节，传送信息的验证，传完信息的确认等等问题，对应的TCP和UDP也是两种不同的实现思路。</span><br><span class="line"></span><br><span class="line">来到这里，关于网络的问题基本上就结束了，因为终端已经拿到了别人发过来的信息了，至于怎么处理信息，就是会话层，表示层，应用层的问题了。不同的应用程序有着不同的通信协议（Email——SMTP，Web——Http，文件传输——Ftp等），这些通信协议都工作在应用层。</span><br><span class="line"></span><br><span class="line">可见，分层之间相互独立，却又是紧密合作，他们的出现不是无中生有，而是在问题的解决中，不断成熟并定形的。</span><br></pre></td></tr></table></figure>



<h5 id="面向连接、无连接"><a href="#面向连接、无连接" class="headerlink" title="面向连接、无连接"></a>面向连接、无连接</h5><p>下面我们介绍两种连接方式：<mark>面向连接</mark> 和 <mark>无连接</mark></p>
<ol>
<li><strong>面向连接</strong>分为三个阶段<ol>
<li>建立连接，在此阶段，发出一个建立连接的请求</li>
<li>只有建立成功之后，才能开始数据传输</li>
<li>当数据传输完毕之后，释放连接</li>
</ol>
</li>
<li><strong>无连接</strong>：没有上述阶段，直接进行数据传输</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027193631754.png" alt="image-20201027193631754"></p>
<h5 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h5><h6 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h6><ul>
<li>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</li>
</ul>
<h6 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h6><ul>
<li>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
</ul>
<p>运输层主要使用一下两种协议</p>
<ol>
<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<table>
<thead>
<tr>
<th>UDP</th>
<th>TCP</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p>运行在<code>TCP协议</code>上的协议：</p>
<ul>
<li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议）</code>，主要用于普通浏览。</li>
<li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,<code>HTTP</code>协议的安全版本。</li>
<li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li>
<li><code>POP3（Post Office Protocol, version 3，邮局协议）</code>，收邮件用。</li>
<li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li>
<li><code>TELNET（Teletype over the Network，网络电传）</code>，通过一个<code>终端（terminal）</code>登陆到网络。</li>
<li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li>
</ul>
<p>运行在<code>UDP协议</code>上的协议：</p>
<ul>
<li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li>
<li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li>
<li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li>
</ul>
<p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p>
<ul>
<li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li>
</ul>
<h6 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h6><ul>
<li>网络层(network layer)负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</li>
</ul>
<h6 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h6><ul>
<li>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</li>
</ul>
<h6 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h6><ul>
<li>在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</li>
</ul>
<h1 id="物理层-2"><a href="#物理层-2" class="headerlink" title="物理层"></a>物理层</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112220734703.png" alt="image-20201112220734703"></p>
<h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><ul>
<li>物理层主要关注的点是在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的<strong>传输媒体</strong></li>
<li>物理层的主要任务：确定与传输媒体接口有关的一些特性 也就是 ==定义标准==</li>
</ul>
<ol>
<li><p><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格，接口形状，引线数目，引脚数量和排列情况</p>
</li>
<li><p><strong>电气特性</strong>：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等</p>
</li>
<li><p><strong>功能特性</strong>：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</p>
<p>==电平==：是指两功率或电压之bai比的对数，du有时也可用来表示zhi两电流之比的对数。</p>
</li>
<li><p><strong>规程特性/过程特性</strong>：定义各条物理线路的工作规程和时序关系</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030212511637.png" alt="image-20201030212511637"></p>
<h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="典型数据通信模型"><a href="#典型数据通信模型" class="headerlink" title="典型数据通信模型"></a>典型数据通信模型</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030213350863.png" alt></p>
<p>如上图所示，我们的 电脑称为信源，用于信号转换的”猫”（路由猫）称为调职解调器，信号传入的公用电话网称为广域网；</p>
<p>其中 <strong>信源 + 发送器</strong> 称为 ==源系统==；中间<strong>传输系统</strong>依旧是==传输系统==；<strong>接收器 + 信宿</strong> 称为==目的系统==</p>
<h3 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h3><p>我们知道，数据的目的是为了传送消息，那么为了传送消息 需要什么呢？</p>
<ul>
<li><p>数据：传送信息的实体，通常是有意义的符号序列（汉字 转成的计算机可以理解的语言 010101….）</p>
</li>
<li><p>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式；</p>
<ul>
<li><p>数字信号：代表消息的参数取值是离散的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030215723704.png" alt="image-20201030215723704"></p>
</li>
<li><p>模拟信号：代表消息的参数取值的连续的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030215731831.png" alt="image-20201030215731831"></p>
</li>
</ul>
</li>
<li><p>信源：产生和发送数据的==源头==</p>
</li>
<li><p>信宿：接收数据的==终点==</p>
</li>
<li><p>信道：<strong>信号的传输媒介</strong>，一般用来表示向某个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道</p>
<ul>
<li>按照传输信号来分<ul>
<li>模拟信道：传送模拟信号</li>
<li>数字信道：传送数字信号</li>
</ul>
</li>
<li>按照传输介质来分<ul>
<li>无线信道：不需要介质，通过无线电波等</li>
<li>有线信道：需要介质，通过同轴电缆等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><p>从通信双方信息的交互方式来看，有三种基本方式：</p>
<ol>
<li>==单工通信==：只有<strong>一个方向的通信</strong>而<strong>没有反方向</strong>的交互，仅需要<strong>一条信道</strong></li>
<li>==半双工通信==：通信的双方都可以发送或接收信息，但任何一方都<strong>不能同时</strong>发送和接收，需要<strong>两条信道</strong></li>
<li>==全双工通信==：通信双方<strong>可以同时</strong>发送和接收信息，需要<strong>两条信道</strong></li>
</ol>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><p>如果说通信方式是决定谁来做发送方，谁来做接收方的话，那么数据传输方式就是研究数据在信道上的传输方式</p>
<p>传输方式主要分两种：串行传输 和 并行传输</p>
<ul>
<li><p>串行传输：使用bai一条数据线，将du数据一位一位地依次传输，每zhi一位数据占据一个固定的时间长度dao。只需要少数几条线就可以在系统间交换信息；</p>
<p>特点：速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远距离</strong>传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030221935943.png" alt="image-20201030221935943"></p>
</li>
<li><p>并行传输：并行传输指的是数据以成组的方式，在多条并行信道上同时进行传输，是在传输中有多个数据位同时在设备之间进行的传输。</p>
<p>特点：速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近距离</strong>传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030222150405.png" alt="image-20201030222150405"></p>
</li>
</ul>
<h2 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><ul>
<li>码元：是指用一个<strong>固定时长</strong>的<strong>信号波形（数字脉冲)</strong>，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个<strong>时长</strong>内的信号称为<strong>k进制码元</strong>，而该<strong>时长</strong>称为<strong>码元宽度</strong>。码元的<strong>离散状态（就是可以有几种形态)</strong>有M个的时候，此时码元就成为<strong>M进制码元</strong></li>
<li>一个码元可以<strong>携带多个比特的信息量</strong>。譬如在<strong>二进制</strong>编码中，只有2种不同码元，0状态和1状态</li>
</ul>
<p>是不是感觉很抽象，我们结合图示来理解</p>
<p>下面是一个4进制码元，代表着有四种离散状态，以为着有四种高低不同的波形</p>
<p>四种高低不同波形可以用比特组合：00，01，10，11 来表示</p>
<p>下图中，一个波形 代表着的是1个码元，携带着2个比特的信息量</p>
<p>要注意：四进制码元 代表着 可以由0、1组成4种组合，每个组合是由01组成的；</p>
<p><strong>因此 n进制码元 携带着log2n个比特的信息量</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103202344690.png" alt="image-20201103202344690"></p>
<h3 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h3><ul>
<li><p>速率，也称为<strong>数据率</strong>，代表着数据的<strong>传输速率</strong>（不是传播速率，不是一个概念），代表着单位时间内传输的数据量。</p>
<p>可以用==码元传输速率==和==信息传输速率==来表示</p>
<ul>
<li><p>==码元传输速率==：别名<strong>码元速率、波形速率、调制速率、符号速率等</strong></p>
<ul>
<li><p>表示单位时间内数字通信系统所传输的码元个数（也可以称为是<strong>脉冲个数或信号变化的次数</strong>）</p>
</li>
<li><p>单位是<strong>波特</strong>（Baud）</p>
</li>
<li><p>1波特表示数字通信系统每秒传输一个码元；此处的码元可以是多进制的；</p>
</li>
<li><p>码元速率与进制数<strong>无关</strong></p>
</li>
<li><p>==言简意赅：1s传输了多少个码元==</p>
<p>下图的码元传输速率就是5波特，表示1秒传送了5个码元</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103205304365.png" alt="image-20201103205304365"></p>
</li>
</ul>
</li>
<li><p>==信息传输速率==：别名<strong>信息速率、比特率</strong></p>
<ul>
<li>表示单位时间内数字通信系统传输的二进制码元个数（即比特数）</li>
<li>单位是比特/秒（b/s）</li>
<li>==言简意赅：1s传输了多少个比特==</li>
</ul>
</li>
<li><p>若一个码元携带<strong>n比特</strong>的信息量，则<strong>M 波特</strong>的码元传输速率所对应的<strong>信息传输速率</strong>为==*<em>M×n *</em>bit/s==</p>
</li>
</ul>
</li>
</ul>
<h3 id="带宽-1"><a href="#带宽-1" class="headerlink" title="带宽"></a>带宽</h3><ul>
<li>表示在单位时间内从网络的某一点到另一点所能通过的<strong>最高数据率</strong>，常用来表示网络的通信线路能传输数据的能力；</li>
<li>单位是 b/s</li>
</ul>
<h2 id="编码＆调制"><a href="#编码＆调制" class="headerlink" title="编码＆调制"></a>编码＆调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><ul>
<li>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质；因此一条通信线路往往包含一条<strong>发送信道</strong>和一条<strong>接受信道</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103212329122.png" alt="image-20201103212329122"></p>
<p>而信道上传送的信号肯定也有不同，分为：<strong>基带信号</strong>和<strong>宽带信号</strong></p>
<ul>
<li><p>基带信号：将数字信号1、0直接用不同的电压表示，再送到数字信道上传输（==基带传输==）；</p>
<p>最大的特点就是：基带信号是<strong>来自信源的信号</strong></p>
<p><strong>基带信号</strong>就是发出了<strong>直接表达了的要传输的信息的信号（无须二次加工）</strong></p>
</li>
<li><p>宽带信号：将基带信号进行调制后行程的频分复用<strong>模拟信号</strong>，再传送到<strong>模拟信道</strong>上去传输（==宽带传输==）；</p>
<p><strong>基带信号</strong>经过载波调制后，把信号的频率范围搬移到较高的频段上以便在信道种传输（二次加工)</p>
</li>
<li><p>传输距离近 → 基带传输</p>
</li>
<li><p>传输距离远 → 宽带传输</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103213741148.png" alt="image-20201103213741148"></p>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103215604932.png" alt="image-20201103215604932"></p>
<h4 id="先置概念"><a href="#先置概念" class="headerlink" title="先置概念"></a>先置概念</h4><ul>
<li><p>数据：即要传送的信息。分 数字数据（离散的）和模拟数据（连续的）两种。</p>
</li>
<li><p>信号：数据的电气或电磁表现。亦分 数字信号（离散的）和模拟信号（连续的）两种。</p>
</li>
</ul>
<p>我们要传输数据，但数据是不能直接传输的，必须转换成信号，即我们用信号来表示数据。<br>而当我们要使用数据，是不能直接使用信号的，需把信号转换成数据。</p>
<p>因此，我们有了<code>数据</code>和<code>信号</code>互相转换的需求。</p>
<p>数据有两种，信号有两种，自然就有四种转换</p>
<h4 id="模拟信号和数字信号"><a href="#模拟信号和数字信号" class="headerlink" title="模拟信号和数字信号"></a>模拟信号和数字信号</h4><p><img src="https://img-blog.csdnimg.cn/20190226235309127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>模拟信号：简单来说就是，用电信号去模拟其他信号。电话、传真、电视信号都是模拟信号。如上图第一行。</p>
<p>模拟信号具有连续的特点，可以表达丰富的数值信息，但在传播的过程中容易受到干扰，出现失真的情况。</p>
<p>而数字信号是离散的。因为数字信号只用两种物理状态来表示0和1的（如上图的第二行），故其抗干扰能力比模拟信号强很多。</p>
<p><img src="https://img-blog.csdnimg.cn/20190227000451909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>当传输距离较远时，波形失真度一般较大，这时候我们可以通过中继器（即休息站）来保持波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20190227000715561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">在现代技术的信号处理中，数字信号发挥的作用越来越大，几乎复杂的信号处理都离不开数字信号；或者说，只要能把解决问题的方法用数学公式表示，就能用计算机来处理代表物理量的数字信号。</p>
<h4 id="模拟数据-→-数字信号"><a href="#模拟数据-→-数字信号" class="headerlink" title="模拟数据 → 数字信号"></a>模拟数据 → 数字信号</h4><p><img src="https://img-blog.csdnimg.cn/20190227000850472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由于计算机内部处理的是二进制数据，处理的都是数字音频，因此需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）</p>
<p>模拟信号的数字化一般需要三个步骤：<strong>抽样、量化和编码</strong>。</p>
<ul>
<li><p>==抽样==：对模拟信号周期性的扫描，把时间上连续的信号变成时间上离散的信号。</p>
<p>如上图，每 1s 进行一次采样（采样的频率被称为采样率）。</p>
<p>当然 采样也不是随便采的，需要遵循采样定理进行采样<code>f采样频率 ≥ 2f信号最高频率</code></p>
</li>
<li><p>==量化==：因为模拟信号本质上是一连串连续的值，我们可以对这些值进行等级划分（量化的等级），这样步骤一的采集到的样品就可以被划分到不同的等级。</p>
<p>具体方法：把抽样取得的<strong>电平幅值</strong>按照一定的分级标度转换为对应的数字值，并取整数，这就把连续的<strong>电平幅值</strong>转换为离散的<strong>数字量</strong></p>
</li>
<li><p>==编码==：步骤二中的不同等级可以表示不同的编码。则连续的模拟信号最终可以转化 0101 的数字信号。也就是把量化的结果转换为与之对应的二进制编码</p>
</li>
</ul>
<p>综上，不难得出，随着采样率和量化等级的增加，转换后的数字信号的曲线也就越能贴近模拟信号的曲线（对比上图的原曲线和黄色曲线）。</p>
<h4 id="数字数据-→-数字信号"><a href="#数字数据-→-数字信号" class="headerlink" title="数字数据 → 数字信号"></a>数字数据 → 数字信号</h4><p>比如我们在键盘上输入<code>A</code>，实际上就是把<code>A</code>对应的 ASCII 二进制编码<code>0100 0001</code>转换成了对应的脉冲信号（脉冲信号是数字信号的一种，即离散的），传给了电脑的 CPU。</p>
<ul>
<li><p>常见的脉冲信号：</p>
<p><img src="https://img-blog.csdnimg.cn/20190804204605803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>比如我们可以用正脉冲表示<code>1</code>，负脉冲表示<code>0</code>。此即编码。</p>
</li>
<li><p>常见的编码方式：</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190804210807302.png" alt="img"></p>
<ul>
<li><p>==非归零编码【NRZ】(高1低0)==：编码容易实现，但是没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步，比如说发了一长串的1，接收方读不出来到底有几个1，需要发送方告知；</p>
</li>
<li><p>==归零编码【RZ】==：信号电平在一个码元之内都要恢复到0这种编码成编码方式</p>
</li>
<li><p>==反向不归零编码【NRZI】==信号电平翻转表示0，信号电平不变表示1 （下图例子为 1 0 0 1 1 0 1 0）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103222516296.png" alt="image-20201103222516296"></p>
</li>
<li><p>==曼彻斯特编码==：将一个码元分成两个相等的间隔：【前一个间隔为低电平+后一个间隔为高电平 = 码元1】【前一个间隔为高电平 + 后一个间隔为低电平 = 码元0】当然也可以采取相反的规定了。</p>
<p>该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步），又可以作数据信号，但他的频带宽度是原始的基带宽度的两倍</p>
<p>由于每一个码元都被调成了2个电平，因此<strong>栓据传输速率只有调制速率的1/2</strong></p>
</li>
<li><p>==差分曼彻斯特编码==: 如果<strong>前半个码元电平</strong>与<strong>上一个码元</strong>的<strong>后半个码元</strong>电平相同，则为1；反之则为0；</p>
<p>编码的特点是：在每个码元的中间，都有一次电平跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码</p>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108222609379.png" alt="image-20201108222609379"></p>
</li>
<li><p>==4B/5B编码==：比特流插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B；编码效率为80%；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109204002802.png" alt="image-20201109204002802"></p>
<p>我们知道 2^4^ = 16,2^5^ = 32；因此这种编码只会采用16种去对应16种不同的<strong>四位码</strong>，而另外的16位作为<strong>控制码（帧的开始和结束，线路的状态信息等）或保留</strong></p>
</li>
</ul>
<p>我们刚才说到，敲击键盘后，键盘会向 CPU 发出一串脉冲信号。</p>
<p>事实上，我们把这种，在数字信号频谱中，把直流（零频）开始到能量集中的一段频率范围称为基本频带，简称为基带。因此，数字信号被称为<code>数字基带信号</code>，在信道中直接传输这种基带信号就称为<code>基带传输</code>。</p>
<p>这种传输方式的缺点是，在基带传输中，整个信道只传输一种信号，通信信道利用率低。</p>
<p>由于在近距离范围内，基带信号的功率衰减不大，从而信道容量不会发生变化，因此，在局域网中通常使用基带传输技术。</p>
<h4 id="数字数据-→-模拟信号"><a href="#数字数据-→-模拟信号" class="headerlink" title="数字数据 → 模拟信号"></a>数字数据 → 模拟信号</h4><p>如果要将数据进行远距离传输，只能将数字信号转换为模拟信号，再进行传输。</p>
<p>为什么呢？因为上面有提到数字信号，又叫数字基带信号。频率低，在传输的过程中容易失真。因此需要<code>调制</code>为高频信号（频带信号）。</p>
<p>将<strong>基带信号（数字信号）</strong>转换为<strong>模拟信号</strong>的过程，称为<code>调制</code>。对应的转换器称为==调制器==。</p>
<p>反过来将<strong>模拟信号</strong>转换为<strong>数据（数字信号）</strong>的转换器称为==解调器==。</p>
<p><strong>模拟信号</strong>只在<strong>模拟信道</strong>上传输。如绞线、光纤，模拟信号以无线电波的形式在上面传递。这种传输叫<code>频带传输</code>。</p>
<p>4种数字调制形式：<strong>ASK,PSK,FSK,QAM</strong></p>
<ul>
<li><strong>ASK（调幅）</strong>:按波的幅度受到数字数据的调制而取不同的值，如对应二进制0 → 振幅位0，二进制1 → 振幅为1</li>
<li><strong>FSK（调频）</strong>:即按数字数据的值（0或1）调制载<strong>波的频率</strong>。例如对应二进制0的载波频率为F1，而对应二进制1的载波频率为F2。</li>
<li><strong>PSK（调相）</strong>：即按数字数据的值调制载波<strong>相位</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109210050702.png" alt="image-20201109210050702"></p>
<p>思考一下 某通信链路的波特率是1200Baud，采用了4个相位，每个相位有四种振幅的QAM（调幅+调相）技术，则该链路的信息传输速率是多少？</p>
<p>分析：我们需要算 信息传输速率 需要知道 波特率（码元传输速率）以及一个码元携带了多少个比特</p>
<p>我们现在知道其中一个条件了，则需要知道另一个条件即可求解</p>
<p>4个相位，每个相位有4种振幅，那么就有16种不同波形的码元 → 16进制的码元；</p>
<p>而16进制码元可以由 log2 16求解=4，也就是一个码元携带4个比特</p>
<p>那么信息传输速率 = 1200 × 4 = 4800(b/s)</p>
<h4 id="模拟数据-→-模拟信号"><a href="#模拟数据-→-模拟信号" class="headerlink" title="模拟数据 → 模拟信号"></a>模拟数据 → 模拟信号</h4><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用<strong>频分复用技术</strong>，充分利用贷款资源；</p>
<p>在电话机和本地交换机所传输的信号是采用<strong>模拟信号传模拟数据的方式</strong></p>
<p>比如下图:</p>
<p>有一个广播电台发射塔，然后我对着麦克风说话，我对着话筒说话，传出来声波，但这个声波是频率很低的，在信道上会衰减，导致传不出去；因此，需要把这个声波调制成高频的信号。通过解调器再把信号转成声波，通过收音机播放。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109213521662.png" alt="image-20201109213521662"></p>
<h2 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109214402508.png" alt="image-20201109214402508"></p>
<ul>
<li>影响失真程度的因素<ul>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ul>
</li>
</ul>
<h3 id="失真现象-码间串扰"><a href="#失真现象-码间串扰" class="headerlink" title="失真现象-码间串扰"></a>失真现象-码间串扰</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109214959124.png" alt="image-20201109214959124"></p>
<p>如果信道带宽太小，不能通过信道，我们这很好理解；</p>
<p>那为什么信道带宽高了也不能通过呢？这就是因为<strong>码间串扰</strong></p>
<ul>
<li><p>码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<p>为什么会有码间串扰呢？是由于信道带宽远大于脉冲带宽时，脉冲的拓展很小，当信道带宽接近于信号的带宽的时候，拓展会超过一个码元周期，造成信号脉冲的重叠，这就形成<strong>码间串扰</strong>了</p>
<p>其实简单来说就是频率过快了，分辨不出来码元了</p>
</li>
</ul>
<h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>奈氏准则是为了解决<strong>码间串扰</strong>这一问题的</p>
<ul>
<li><p>==<strong>奈氏准则</strong>==：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2 W Baud，w是信道带宽，单位是hz</p>
<p>只有在奈氏准则，香农定理中带宽单位采用hz，其他时候都是bit/s</p>
</li>
</ul>
<p>同时，我们也得到了以下几点结论：</p>
<ol>
<li><p>任何信道中，码元传输速率有上限，超过上限，就产生码间干扰。</p>
</li>
<li><p>信道的频带越宽，即通过的信号高频分量越多，可以用更高的速率就行码元的有效传输</p>
</li>
<li><p><strong>奈氏准则</strong>只是限制码元传输速率，<strong>香农定理</strong>才真的限制信息传输速率</p>
</li>
<li><p>由于码元的传输速率受奈氏准则制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多的信息量，这就需要采用<strong>多元制</strong>的调制方法。</p>
</li>
<li><p>理想低通信道下的极限数据传输率=<strong>2Wlog2V</strong> （b/s） <strong>w</strong>是带宽，<strong>v</strong>是几种码元，即码元的离散电平数目、</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111102027489.png" alt="image-20201111102027489"></p>
</li>
</ol>
<h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>奈氏准则只规定了极限码元传输速率，但没有规定极限比特传输速率是多少</p>
<p>而我们的<strong>香农定理</strong>就是来解决这个问题的，同时它还考虑了<strong>噪声</strong>的干扰</p>
<p>噪声是随机产生的，他的瞬时值很大，影响接收端的判决</p>
<p>但噪声的影响是相对的，若信号较强，那么噪声影响相对较小，因此，信噪比就很重要。</p>
<p><strong>信噪比=信号的平均功率/噪声的平均功率，常记作S/N，并用分贝(db)作为度量单位</strong></p>
<p><strong>即：信噪比（db）= 10log10（S/N）数值等价</strong></p>
<ul>
<li><p><strong>==香农定理==</strong>：在带宽受限且有噪声的情况下，为了不产生误差，信息的数据传输速率有上限值</p>
</li>
<li><p>信道的极限数据传输速率=Wlog2（1+S/N） b/s</p>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111102152770.png" alt="image-20201111102152770"></p>
</li>
</ul>
<p>同样，我们可以得出以下结论：</p>
<ol>
<li>带宽或者信噪比越大，信息的传输速率就越高</li>
<li>对一定的chuanshu带宽和一定信噪比，信息传输速率的上限就确定了</li>
<li>只要信息的传输速率低于信息的极限传输速率，就一定有方法来实现无差错传输</li>
<li>香农定理得到的为极限信息传输速率，实际信道能达到的传输速率比他低不少</li>
<li>若信道带宽W或者信噪比S/N没上限，那信道的极限信息传输速率也没有上限</li>
</ol>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111103347887.png" alt="image-20201111103347887"></p>
<h2 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h2><p>传输介质也称传输媒体/传输媒介，是数据传输系统中，在发送设备和接收设备之间的物理通路</p>
<p>传输媒体≠物理层，传输媒体在物理层下面，因为物理层是体系结构第一层，因此有时候称传输媒体为第0层。</p>
<p>在传输媒体中传输的是<strong>信号</strong>，传输媒体并不能解析这个信号</p>
<p>而物理层规定<strong>电气特性</strong>，因此可以识别传送的比特流</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111104318427.png" alt="image-20201111104318427"></p>
<h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><h4 id="导向性传输介质-1-双绞线"><a href="#导向性传输介质-1-双绞线" class="headerlink" title="导向性传输介质 - 1.双绞线"></a>导向性传输介质 - 1.双绞线</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111104958448.png" alt="image-20201111104958448"></p>
<h4 id="导向性传输介质-2-同轴电缆"><a href="#导向性传输介质-2-同轴电缆" class="headerlink" title="导向性传输介质 - 2.同轴电缆"></a>导向性传输介质 - 2.同轴电缆</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111105542264.png" alt="image-20201111105542264"></p>
<h4 id="导向性传输介质-3-光纤"><a href="#导向性传输介质-3-光纤" class="headerlink" title="导向性传输介质 - 3.光纤"></a>导向性传输介质 - 3.光纤</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111110145645.png" alt="image-20201111110145645"></p>
<ul>
<li>光纤特点<ul>
<li>传输损耗小、中继距离长，对远距离传输经济</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无传音干扰，保密性好，不容易被窃听或截取数据</li>
<li>体积小，重量轻</li>
</ul>
</li>
</ul>
<h5 id="单模光纤、多模光纤"><a href="#单模光纤、多模光纤" class="headerlink" title="单模光纤、多模光纤"></a>单模光纤、多模光纤</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111110741251.png" alt="image-20201111110741251"></p>
<h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111111321549.png" alt="image-20201111111321549"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112212848540.png" alt="image-20201112212848540"></p>
<ul>
<li><p>==诞生原因==：由于信号传输存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定的程度就会造成信号的失真，因此会导致接受错误</p>
</li>
<li><p>==中继器的功能==：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度</p>
</li>
<li><p>==中继器的两端==：两端的的网络部分是<strong>网段</strong>，而不是<strong>子网</strong>，适用于完全相同的两类网络的互连，且两个网段速率要相同</p>
<p>中继器只负责发送电缆端的数据，但读不懂里面的数据，因此里面就算有错误数据也照样会被传输</p>
<p>中继器两端可以连相同媒体也可以连不同媒体</p>
<p>中继器两端的网段必须要是同一个协议</p>
</li>
<li><p>==5-4-3规则==：网络标准中对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会造成网络的故障</p>
<p>所谓“5-4-3规则”，是指在10M<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/以太网">以太网</a>中，网络总长度不得超过<strong>5个区段</strong>，<strong>4台网络延长设备</strong>，且<strong>5个区段中只有3个区段可接<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/网络设备">网络设备</a>。</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112213440447.png" alt="image-20201112213440447"></p>
</li>
</ul>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><ul>
<li>集线器功能：对信号进行再生放大转发，对衰减的信号进行放大， 接着转发到其他所有处于工作状态的端口上，以增加<strong>信号传输的距离</strong>，延长网络的长度。</li>
<li>集线器不具备信号的定向传送能力，是一个共享式设备</li>
<li>集线器工作过程：节点发送信号到信道，集线器接收该信号，该信号在电缆传输中有衰减，集线器接收信号后将衰减的信号<strong>整形放大</strong>，最后集线器把放大的信号广播转发给其他所有<strong>端口</strong></li>
<li>由于集线器不能够分割<strong>冲突域</strong>，因此连在<strong>集线器上的工作主机</strong>需要平分带宽</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112215953832.png" alt="image-20201112215953832"></p>
<h1 id="数据链路层-2"><a href="#数据链路层-2" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><ul>
<li><p><strong>结点：</strong>主机、路由器</p>
</li>
<li><p><strong>链路（物理链路）：</strong>网络中两个结点之间的物理线路（有线或者无线），中间没有任其他的交换节点，链路的传输介质主要有双绞线、光纤和微波；进行数据通信的时候，两台计算机之间的通信路径往往要经过许多段这样的链路。链路只是一条路径的组成部分</p>
</li>
<li><p><strong>数据链路（逻辑链路）：</strong>数据链路≠链路，在一条线路上传送数据的时候，除了需要一条物理线路（链路），还需要一些必要的通信协议去控制数据的传输。把实现这些协议的<strong>硬件和软件</strong>加到链路上，就构成 <mark>数据链路</mark></p>
<p>现在常用<strong>网络适配器</strong>去实现这些协议；</p>
</li>
<li><p><strong>帧：</strong>点对点信道的数据链路层的协议数据单元</p>
</li>
</ul>
<p>数据链路层负责通过一条链路从<strong>一个结点</strong>向另一个物理链路直接相连的<strong>相邻结点</strong>传送数据报（数据报是网络层协议数据单元，又称为IP数据报，分组或是包）</p>
<p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自<strong>网络层</strong>的数据可靠的传输到相邻节点的<strong>目标机网络层</strong>，其主要作用是加强物理层传输原始比特流的功能：什么意思呢？原本不是说 物理层不管数据是否正确都会传输吗？那么数据链路层就会把物理层中可能出错的物理连接改成<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路了。</p>
<ul>
<li><mark><strong>数据链路层功能</strong></mark>：<ul>
<li><strong>为网络层提供服务</strong>：无确认无连接服务、有确认无连接服务、有确认面向连接服务<ul>
<li><mark><em>无确认无连接服务</em></mark>：发送数据的时候不需要建立连接，收到数据也不需要返回确认。通常用于实时通信、码率比较低的信道；</li>
<li><mark><em>有确认无连接服务</em></mark>：发送数据事先不需要建立连接，但目的主机收到数据需要返回确认。通常用于码率比较高的通信，比如无线通信</li>
<li><mark><em>有确认面向连接服务</em></mark>：最安全最可靠的服务，事先需要建立连接，收到数据也需要返回确认。通常用于通信质量差的无线传输链路</li>
</ul>
</li>
<li><strong>链路管理</strong>：即连接的建立、维持和释放</li>
<li><strong>组帧</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>差错控制（帧错/位错）</strong></li>
</ul>
</li>
</ul>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>首先我们需要明白一个概念：所有在互联网上传送的数据都是以分组（IP数据报）为传送单位</p>
<p>因此对于这分组进行<strong>加工处理</strong>就非常有必要了</p>
<p>如下图所示，<mark>IP数据报</mark>传送到数据链路层就成为了帧的<strong>数据部分</strong></p>
<ul>
<li><h4 id="组装成帧"><a href="#组装成帧" class="headerlink" title="组装成帧"></a>组装成帧</h4><p>就是在帧的数据部分前后部分分别添加上<strong>首部和尾部</strong>，构成一个完整的帧。这样的帧 → 数据链路层的<strong>数据传送单元</strong></p>
<p>接收端在收到物理层上交的比特流后，根据首部和尾部表寄，从收到的比特流中识别帧的开始和结束——这就是<strong>帧定界</strong></p>
<p>此外，首部尾部还包含许多控制信息。</p>
<p>一个帧的帧长 = 帧的数据部分长度 + 帧首部长度 + 帧尾部长度 </p>
<p>为了提高帧的传输效率，应尽可能使<strong>帧的数据部分长度</strong>尽可能大于首部和尾部长度，但不能无限大：每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限——最大传送单元MTU</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218213138634.png" alt="image-20201218213138634"></p>
<p>组帧的四种方式：字符计数法、字符填充法、零比特填充法、违规编码法</p>
<h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117220136249.png" alt="image-20201117220136249"></p>
<p>这种方法就是用每一个帧的<strong>第一个计数字段</strong>表命该帧包含了几个字符数</p>
<p>但是这种方法风险也很大，一旦某一帧开始出错了，后面的基本都会出错</p>
<h4 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117222624482.png" alt="image-20201117222624482"></p>
<h4 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h4><p>这个方法确定了发送端与接收端都是包含了6个1，这样的话我们只要保证数据部分不存在连续六个1即可</p>
<p>那么<strong>零比特填充法</strong>就是扫描信息字段，只要出现连续5个1，就填充个0来保证不出现连续的六个1</p>
<p>而接受的时候也非常方便，只需要扫描，发现连续5个1就删除掉后面的0，就可以保证数据的正确性啦</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117223137910.png" alt="image-20201117223137910"></p>
<h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>曼彻斯特编码中，不存在连续的高或者连续的低；</p>
<p>因此用连续高或者连续低表示首尾标志，这就是违规编码的思想</p>
<p>主要应用在物理层进行编码，只适用于采用冗余编码的特殊编码环境</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201118215607086.png" alt="image-20201118215607086"></p>
<p>由于字节计数法count字段脆弱性（如果一个错了后面跟着全错）</p>
<p>字符填充实现上的复杂和不兼容性</p>
<p>一般来说采用<strong>比特填充和违规编码法</strong></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul>
<li>在数据链路层透明传送数据：表示无论什么样的比特组合的数据都能按照原样无差错的通过数据链路层，因此链路层是看不到有什么妨碍数据传输的东西，换句话说就是，数据链路层对这些数据来说是<strong>透明的</strong></li>
<li>如下图所示：数据的某个二进制代码正好与EOT的控制字符相同，那接收端误以为是传输结束的控制符，其后面的数据因为找不到SOH就被接收端当作<strong>无效帧</strong>丢弃了。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113214934518.png" alt="image-20201113214934518"></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125203545446.png" alt="image-20201125203545446"></p>
<p>要进行控制，首先要明白差错是从何而来。</p>
<p>通常来说，传输中的差错都是由于噪声所引起的</p>
<p>噪声分两种：<strong>全局性噪声和局部性噪声</strong></p>
<ul>
<li>全局性：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125193958284.png" alt="image-20201125193958284"></li>
<li>局部性:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125193958284.png" alt></li>
</ul>
<p>差错也分为两种：<strong>位错和帧错</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194102872.png" alt="image-20201125194102872"></p>
<p>链路层为网络层提供服务：</p>
<ul>
<li>无确认无连接服务（通信质量好，通常用于有线传输链路）</li>
<li>有确认无连接服务（通信质量差的无线传输链路）</li>
<li>有确认面向连接服务（通信质量差的无线传输链路）</li>
</ul>
<h4 id="检错编码与纠错编码"><a href="#检错编码与纠错编码" class="headerlink" title="检错编码与纠错编码"></a>检错编码与纠错编码</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194435401.png" alt="image-20201125194435401"></p>
<h5 id="检错编码-奇偶校验码"><a href="#检错编码-奇偶校验码" class="headerlink" title="检错编码 - 奇偶校验码"></a>检错编码 - 奇偶校验码</h5><p>奇偶校验码 就是用 <strong>n - 1位信息元表示信息，1位校验元用于校验的校验方式</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194620006.png" alt="image-20201125194620006"></p>
<p>注意 这里的奇偶校验码指的是 加上了校验元后 1的个数是奇数还是偶数 而不是加之前</p>
<ul>
<li><p>奇偶校验码特点:</p>
<p>只能检查出奇数个比特错误，检错能力为50%：什么意思呢？假如有一串编码为111001的编码采用奇校验 → 111001<mark>1</mark></p>
<p>此时传过来的假如是111001<mark>0</mark> 那我可以发现是错的，但假如传过来是1110110 还是奇数个1，虽然是错误的，但我无法检验出来</p>
</li>
</ul>
<h5 id="检错编码-CRC循环冗余码"><a href="#检错编码-CRC循环冗余码" class="headerlink" title="检错编码 - CRC循环冗余码"></a>检错编码 - CRC循环冗余码</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125195452859.png" alt="image-20201125195452859"></p>
<p>发送端 把要传的数据 %（取余） 生成的多项式  所得到的结果是 <mark>FCS帧检验序列/冗余码</mark></p>
<ul>
<li><p>冗余码的计算方式：</p>
<p>题目给定生成多项式，求它的阶（最高次）r，在所传的数据后 + r个0</p>
<p>然后用这个新数据去 % 生成的多样式 所得到的余数就是FCS（冗余码）</p>
</li>
</ul>
<p>得到了冗余码之后，把该冗余码 添加在索要发送的数据后 这就是我们最重要发送的数据了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200200951.png" alt="image-20201125200200951"></p>
<p>而接收端把传过来的数据 % 所生成的多项式 </p>
<p>若没有余数，代表该帧在传输过程中无差错，否则认为出了差错。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200507201.png" alt="image-20201125200507201"></p>
<h5 id="纠错编码-海明码"><a href="#纠错编码-海明码" class="headerlink" title="纠错编码 - 海明码"></a>纠错编码 - 海明码</h5><p>海明码：发现双比特错，纠正单比特错</p>
<p>基本工作原理:<mark>动一发而牵全身</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200945084.png" alt="image-20201125200945084"></p>
<ul>
<li><p>确定校验码位数r</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125201218149.png" alt="image-20201125201218149"></p>
</li>
<li><p>确认校验码和数据的位置</p>
<p>将校验码放在2的几次方的位置 （2的几次方从0开始 ） 之后按照顺序把数据填下来，并写出实际值</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125201328620.png" alt="image-20201125201328620"></p>
</li>
<li><p>求出校验码的值</p>
<p> 这一步应该是最难懂的了：其求值方法是<strong>令所有要检验的位异或=0</strong>（异或，2个值相同为0，不相同为1）</p>
<p>什么意思呢？以P1为例子：</p>
<p>它的数据位是1，二进制表示成0001（因为有4位校验码 所以说是xxxx）</p>
<p>它的1在第一位，因此要找还有哪个代码的1在第四位：有D1,D2,D4,D5</p>
<p>那么就令P1⊕D1⊕D2⊕D4⊕D5 = 0</p>
<p>其中D1 D2 D4 D5的取值是用下面的实际值来代表</p>
<p>P1⊕1⊕0⊕1⊕0=P1⊕(1⊕0)⊕(1⊕0) = P1⊕（1⊕1）=P1⊕0=0</p>
<p>则P1 = 0 同理可求得 其他得校验码P2,P3,P4</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125202212275.png" alt="image-20201125202212275"></p>
</li>
<li><p>检错并纠错</p>
<p>纠错的方法与上面其实很相似。</p>
<p>首先用四个校验码分别异或运算 得出新的P1,P2,P3,P4实际值</p>
<p>然后反着从P4写到P1 形成新的二进制数，这个二进制数所表示的十进制数 就是出错的位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125203314628.png" alt="image-20201125203314628"></p>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125204100218.png" alt="image-20201125204100218"></p>
<p>为什么要有流量控制呢？因为<strong>高发送速度</strong>和<strong>低接受能力</strong>不匹配会造成传输出错</p>
<p>数据链路层与传输层都有流量控制 其区别在于：</p>
<ul>
<li>数据链路层的流量控制是<strong>点 → 点</strong>的，其流量控制手段是：接收方收不下就不回复确认</li>
<li>传输层的流量控制是<strong>端 → 端</strong>的，其流量控制手段是：接收端给发送端一个窗口公式（一个回复？）</li>
</ul>
<h4 id="流量控制方法"><a href="#流量控制方法" class="headerlink" title="流量控制方法"></a>流量控制方法</h4><p>控制方法有两种协议：<mark>停止 - 等待协议</mark> 和 <mark>滑动窗口协议（包括后退N帧协议<strong>GBN</strong>，选择重传协议<strong>SR</strong>）</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125204841578.png" alt="image-20201125204841578"></p>
<ul>
<li>停止-等待协议就是 发送完一个帧就等待一下确认，收到确认后再发下一个帧</li>
<li>滑动窗口协议就是 发送端和接收端各有一个窗口，发送端一股脑将窗口里的所有帧全部发送出去，当接收端收到帧后 接收窗口往后移一个单位，并返回确认，发送端接收到了接收端的确认后，发送窗口也往后移一个单位。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125205820355.png" alt="image-20201125205820355"></p>
<h5 id="可靠传输，滑动窗口，流量控制"><a href="#可靠传输，滑动窗口，流量控制" class="headerlink" title="可靠传输，滑动窗口，流量控制"></a>可靠传输，滑动窗口，流量控制</h5><ul>
<li>可靠传输：发送端发的数据，接收端都能接受</li>
<li>流量控制：控制发送速率，让接收端有<strong>足够的缓冲空间</strong>来接受每一个帧</li>
<li>解决方案:滑动窗口（包含了可靠传输和流量控制两个特性）<ul>
<li>可靠传输：依靠发送端的自动重传机制</li>
<li>流量控制：依靠接收端的如果收不下就不给确认，导致发送端想发送帧也发不了</li>
</ul>
</li>
</ul>
<h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止 - 等待协议"></a>停止 - 等待协议</h4><ol>
<li><p>为什么要有<strong>停止 - 等待协议？</strong></p>
<ol>
<li><p>因为除了比特出差错意外，底层的信道也会出现<strong>丢包</strong>的问题。</p>
<p>（丢包 是指物理线路故障、设备故障、病毒攻击、路由信息错误等原因，导致数据包的丢失</p>
</li>
<li><p>为了实现流量控制</p>
</li>
</ol>
</li>
<li><p>研究停止等待协议的前提？</p>
<p>虽然现在经常使用全双工通信方式，但为了讨论问题的方便，仅仅考虑一方发送数据（发送方），一方接受数据（接收方）</p>
<p>停止 - 等待协议就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下个分组。</p>
</li>
<li><p>停止- 等待协议有几种应用情况？</p>
<p>主要有两种：有差错情况 和 无差错</p>
</li>
</ol>
<h5 id="停-等协议-之-无差错情况"><a href="#停-等协议-之-无差错情况" class="headerlink" title="停 - 等协议 之 无差错情况"></a>停 - 等协议 之 无差错情况</h5><p>其实就是发送方发一个帧，接收方对于发送的帧进行确认 （通过返回ACK 0 / 1)</p>
<p>指的注意的是 第一次发送的0帧与第二次发送的0帧并不是一回事，这只是一个编号而已</p>
<p>如果可以的话 其实可以理解成发送A 确认A，发送B 确认B….发送N 确认N</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210203114341.png" alt="image-20201210203114341"></p>
<h5 id="停-等协议-有差错情况"><a href="#停-等协议-有差错情况" class="headerlink" title="停 - 等协议 有差错情况"></a>停 - 等协议 有差错情况</h5><ol>
<li><p><strong>当发现数据帧丢失或检测到帧出错</strong></p>
<ol>
<li>类似于OS中进程饥饿现象，假如接收端迟迟收不到发送端发来的数据帧，就会导致无法发送确认帧，下一个帧就无法发送过去，形成了<mark>饥饿</mark>现象；为了解决这个问题，引入了<strong>超时重传方法</strong></li>
<li><strong>超时计时器</strong> —— 每次发送一个帧就启动一个计时器 ；</li>
<li>回忆一下什么是<mark>RTT</mark>:数据从网络一端传送到另一端所需时间（包的往返时间，也就是单纯发出去还不够，还得包含回来的时间）</li>
<li><mark>超时重传时间（RTO）</mark>：计时器记录的时间超过RTO就重新传输数据，RTO的设置应该是比RTT值略大一点点</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210205156432.png" alt="image-20201210205156432"></p>
</li>
<li><p><strong>ACK丢失</strong></p>
<p>由于确认帧（ACK）的丢失，发送方会误认为没发过去数据，于是又发一次帧；</p>
<p>但这个帧是重复的，我们怎么办呢？</p>
<p>对于这种情况，确认方会丢弃重复的发送过来的帧，并进行重传确认；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210210003641.png" alt="image-20201210210003641"></p>
</li>
<li><p><strong>ACK迟到</strong></p>
<p>ACK的发送有可能会有延迟，此时发送方会把一开始来晚的确认帧收下并且丢弃掉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210210554755.png" alt="image-20201210210554755"></p>
</li>
</ol>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>这个方法虽然简单，但是信道的利用率非常低</p>
<p>什么是信道利用率呢？</p>
<p>是发送方在<strong>一个发送周期内</strong>,有效地发送数据所需要的的时间占<strong>整个发送周期的比率</strong></p>
<p>有效发送数据时间：发送时延 因为在这个时间段内有在一直发送数据</p>
<p>整个发送周期：<strong>发送时延 + RTT + 接受时延</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210212405281.png" alt="image-20201210212405281"></p>
<h4 id="GBN-与-SR"><a href="#GBN-与-SR" class="headerlink" title="GBN 与 SR"></a>GBN 与 SR</h4><p>GBN(后退重传协议) SR（选择重传协议）</p>
<p>有新协议肯定是为了解决之前协议所带来的不足问题的，回想一下之前的 停止-等待协议：</p>
<p>它每次只发一个帧，需要等到收到确认了才发下一个，这种方式信道利用率太低了。</p>
<p>有人说 可以在发送的时候不单单发一个帧，而是发很多个帧，这种方式叫<strong>流水线技术</strong></p>
<p>而这种技术需要：</p>
<ol>
<li>增加序号的范围</li>
<li>发送方需要缓存多个分组</li>
</ol>
<p>针对这两种解决方案 我们有两种协议：<strong>后退N帧协议 和 选择重传协议</strong></p>
<h4 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211180209766.png" alt="image-20201211180209766"></p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ul>
<li><p><mark>发送窗口</mark>：发送方维持一组<strong>连续</strong>的允许发送的<strong>帧</strong>的<strong>序号</strong></p>
<p>意思是格子中的数字并不代表数据，而是序号（1号帧，2号帧这样）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172238290.png" alt="image-20201211172238290"></p>
</li>
<li><p><mark>接收窗口</mark>：接收方维持一组连续的允许接收的<strong>帧</strong>的<strong>序号</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172238290.png" alt="image-20201211172244046"></p>
</li>
<li><p><strong>停止 - 等待协议</strong>其实可以理解成 <strong>接收窗口 和 发送窗口 都是1</strong>的后退N帧协议</p>
</li>
</ul>
<p>发送过程：</p>
<p>发送窗口一般可分为<strong>四</strong>部分:</p>
<ol>
<li>发完被确认的</li>
<li>已经发送但等待接收端确认的</li>
<li>在窗口内 还能继续发送的</li>
<li>不在窗口内 暂时不能发的</li>
</ol>
<p>ps:橙色部分是 发送端发送的帧的拷贝副本（保证帧不丢失嘛）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172542168.png" alt="image-20201211172542168"></p>
<h5 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h5><p>这三件事分别为：</p>
<ol>
<li><p><strong>上层的调用</strong></p>
<ol>
<li>上层要发送数据的时候，发送方要先检查发送窗口是否已满，如果<strong>未满</strong>，就产生一个帧并且将其发送；</li>
<li>如果窗口<strong>已满</strong>，发送方就只需要将数据返回给上层，按时上层窗口已满，等一会再发</li>
<li>对于2这种情况，发送方可以缓存这些数据，等到窗口不满的时候再发帧</li>
</ol>
</li>
<li><p><strong>收到了一个ACK</strong></p>
<p>GBN协议中，对n号帧的确认采用了<mark>累计确认</mark>的方式，标明接收方已经收到n号帧以及它之前的全部帧</p>
</li>
<li><p><strong>超时事件</strong></p>
<p>协议的名字叫后退N帧，来源于出现<strong>丢失</strong>和<strong>时延</strong>过长帧时发送方的<strong>行为</strong>。类似于停-等协议，定时器将再次用于<strong>恢复数据帧或确认帧的丢失</strong>。如果出现超时，发送方将会重传<mark>所有已发送但没有被确认的帧</mark></p>
</li>
</ol>
<h5 id="GBN接收方需要做的事"><a href="#GBN接收方需要做的事" class="headerlink" title="GBN接收方需要做的事"></a>GBN接收方需要做的事</h5><p>可以简单记忆为：接受正确帧回复ACK、其余情况都丢弃帧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211174152514.png" alt="image-20201211174152514"></p>
<h5 id="运行中的GBN"><a href="#运行中的GBN" class="headerlink" title="运行中的GBN"></a>运行中的GBN</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211174602686.png" alt="image-20201211174602686"></p>
<h5 id="滑动窗口的长度"><a href="#滑动窗口的长度" class="headerlink" title="滑动窗口的长度"></a>滑动窗口的长度</h5><p>如果是采用n个比特对帧的编号,那么发送窗口的尺寸W应该满足：</p>
<p><code>1 &lt;= W &lt; 2^n - 1</code></p>
<p>因为如果发送窗口太小，那就没什么意义，而如果过大，会导致接收方无法区别<strong>新帧和旧帧</strong></p>
<p>比如发送方为:12341234,窗口尺寸为4；然后我发第一个1丢失了，过了一会发送方又会发一次1234，那么究竟是前半段的还是后半段的呢？</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211175602540.png" alt="image-20201211175602540"></p>
<h5 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h5><ul>
<li><strong>优点</strong>：因为连续发送数据帧而提高了信道利用率</li>
<li><strong>缺点</strong>：在重传的时候必须把原来已经正确传送的数据帧给重传了，使得传送效率降低了</li>
</ul>
<h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203522001.png" alt="image-20201211203522001"></p>
<ul>
<li>选择重传协议（Selective Repeat）</li>
</ul>
<p>上一节我们学习了GBN，虽然方便，但有一个问题，它会批量重传，那么有没有一个办法可以只重传出错的帧呢？</p>
<p>有一个解决办法：设置单个确认，同时加大接受窗口，设置接受缓存，缓存乱序到达的帧</p>
<h5 id="SR中的滑动窗口"><a href="#SR中的滑动窗口" class="headerlink" title="SR中的滑动窗口"></a>SR中的滑动窗口</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211181238830.png" alt="image-20201211181238830"></p>
<h5 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h5><ol>
<li><p><strong>上层的调用</strong></p>
<ol>
<li>上层要发送数据的时候，发送方要先检查下一个<strong>可用于该帧的序号</strong>；</li>
<li>如果序号在发送窗口内，就发送数据帧</li>
<li>如果不在，就要么先将数据缓存没要么返回给上层之后在传输</li>
</ol>
</li>
<li><p><strong>收到了一个ACK</strong></p>
<p>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为<strong>已接收</strong>；</p>
<p>如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处</p>
<p>如果窗口移动了，并且有<strong>序号在窗口</strong>内的<strong>未发送帧</strong>，就发送这些帧</p>
</li>
<li><p><strong>超时事件</strong></p>
<p>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧</p>
</li>
</ol>
<h5 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218213350924.png" alt="image-20201218213350924"></p>
<h5 id="运行中的SR"><a href="#运行中的SR" class="headerlink" title="运行中的SR"></a>运行中的SR</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211201830691.png" alt="image-20201211201830691"></p>
<h5 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203045763.png" alt="image-20201211203045763"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203156437.png" alt=" "></p>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><h4 id="数据传输使用的两种链路"><a href="#数据传输使用的两种链路" class="headerlink" title="数据传输使用的两种链路"></a>数据传输使用的两种链路</h4><ul>
<li>点对点链路<ul>
<li>两个相邻的节点通过一个链路进行连接，其间没有第三者</li>
<li>应用：PPP协议，常应用于<mark>广域网</mark></li>
</ul>
</li>
<li>广播式链路<ul>
<li>所有的主机共享通信介质</li>
<li>应用：早期的总线以太网、无线局域网，常应用于<mark>局域网</mark></li>
<li>典型拓扑结构：总线型、星型（逻辑总线型）</li>
</ul>
</li>
</ul>
<h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><p>介质访问控制的内容就是采取一定的措施，使得两对节点之间的通信不会发生相互干扰的情况</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105161938675.png" alt="image-20210105161938675"></p>
<h5 id="信道划分介质访问控制-1"><a href="#信道划分介质访问控制-1" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h5><ul>
<li>这种控制方式的本质：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把<strong>时域</strong>和<strong>频域资源</strong>合理地分配给网络上的设备,是基于多路复用技术去划分资源的</li>
<li>网络负载重的时候：共享信道效率高（处于忙碌状态的主机很多，都在工作中），公平（分配资源平均分配的）</li>
<li>网络负载轻的时候：共享信道效率低（处于忙碌状态的主机很少）</li>
</ul>
<p>假设现在有三组主机间需要进行信号传输：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212175524387.png" alt="image-20201212175524387"></p>
<p>明明三组主机都需要经过同一个信道，那么有没有一种办法能只用一条信道去传输信息呢？</p>
<p>答案是：<mark>多路复用技术</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212175828985.png" alt="image-20201212175828985"></p>
<h6 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212180421784.png" alt="image-20201212180421784"></p>
<h6 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h6><p> 这里引入了一个概念:<strong>时隙</strong></p>
<p>时隙可以理解成一个<mark>时间片</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212180715242.png" alt="image-20201212180715242"></p>
<h6 id="改进的时分复用-统计时分复用STDM"><a href="#改进的时分复用-统计时分复用STDM" class="headerlink" title="改进的时分复用 - 统计时分复用STDM"></a>改进的时分复用 - 统计时分复用STDM</h6><p>上面的这种方式，有一个问题，假如我只有D用户需要发数据，但由于我排在了ABC后面，我得等他们的时隙转完了，才能轮到我</p>
<p>因此就有了改进措施了：用一个集中器，把所有要发的数据收集起来，只要收到的数据达到了一定帧长，就发送；</p>
<p>这样就不用管我排在第几位了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212181620617.png" alt="image-20201212181620617"></p>
<h6 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212201805495.png" alt="image-20201212201805495"></p>
<h6 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h6><p>分享两个解释码分多路复用的博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianlongtc/article/details/80152442">https://blog.csdn.net/tianlongtc/article/details/80152442</a></p>
<p><a target="_blank" rel="noopener" href="https://bingw.blog.csdn.net/article/details/52705205">https://bingw.blog.csdn.net/article/details/52705205</a></p>
<p>网上的博客喜欢把CDM与坐标系联系在一起，就是给定一个向量空间内的向量，然后就能解出各轴上的向量表达式；</p>
<p>（学过线代的同学应该对这个非常熟悉了）</p>
<p>码分多址（CDMA）是码分复用的一种方式：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212205538902.png" alt="image-20201212205538902"></p>
<p>其实可以理解成 把多个坐标轴上的数据统一了规格，然后用一个信道去传送符合某种算法的数据，接收方只需要根据算法反向破译，就能够得到原来不同坐标轴上的数据；</p>
<p>因此，我们只需要考虑三个问题：</p>
<ul>
<li><p>如何做到各坐标轴独立，数据能不弄混</p>
<ul>
<li><p>CDMA规定了，多个站点同时发送数据的时候，各站点芯片(码片)序列是<strong>相互正交的</strong></p>
<p>什么意思呢？正交：向量S和T<strong>规格化内积</strong>是0</p>
<p>即：两个向量相乘的点积再除以向量分量的个数 = 0（向量能点积就意味着向量长度相同）。</p>
</li>
</ul>
</li>
<li><p>如何做到合并，把各坐标轴上的数据放到一个信道上进行传输</p>
<ul>
<li>让各路数据在信道中被线性的相加（各比特对应的序列线性相加）</li>
</ul>
</li>
<li><p>如何分离，知道哪些数据是A站点发的，哪些是B站点发的</p>
<ul>
<li>使用第二步中合并的数据，与源站<strong>规格化内积</strong>（点乘再除以位数）就可以解出来是0还是1…（用-1表示0比特）</li>
</ul>
</li>
</ul>
<h5 id="随机访问介质控制"><a href="#随机访问介质控制" class="headerlink" title="随机访问介质控制"></a>随机访问介质控制</h5><p>这种控制方式特点是：所有用户都可以<strong>随机</strong>发送信息，发送信息的时候是可以占<strong>全部带宽的</strong></p>
<p>但这种情况就一定会产生用户冲突，于是就有了一系列规定或者说协议，去调和这个矛盾</p>
<ul>
<li>网络负载重的时候：产生冲突开销（产生冲突，发送的数据就会失效，因此产生开销）</li>
<li>网络负载轻的时候：共享信道效率高，单个结点就可以利用信道全部带宽</li>
</ul>
<h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><p>ALOHA协议分为两种：纯ALOHA协议和时隙ALOHA协议</p>
<ul>
<li><strong>纯ALOHA</strong><ul>
<li><strong>协议思想</strong>：不监听信道，不按时间槽发送，随机重发，想发就发；</li>
<li><strong>冲突检测方法</strong>：如果发生了冲突，接收方能够检测出差错，并且不予以确认，发送方在一定时间内收不到（确认帧）就判断出发生了冲突</li>
<li><strong>冲突解决办法</strong>：超时后，等待一个<strong>随机时间</strong>再重传</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213160036860.png" alt="image-20201213160036860"></p>
<ul>
<li><p><strong>时隙ALOHA</strong></p>
<ul>
<li><p><strong>协议思想：</strong>把时间分成了<strong>若干个相同的时间片</strong>，所有用户在时间片<strong>开始时刻</strong>同步接入网络信道，如果发生了冲突（发生冲突，就是一个完整的时间片内并不是只有我一个用户在发数据）</p>
<p>就必须等下一个时间片开始的时候再发送 —— 控制了ALOHA协议想发就发的<mark>随意性</mark></p>
</li>
<li><p><strong>冲突检测方法</strong>：只能在<mark>整时整分</mark>的时候发送数据，如果有两个用户同时发送了，接收方就会检测到出错，也就无法返回确认帧；</p>
</li>
<li><p><strong>冲突解决办法</strong>：发送方超时没接收到确认帧就等到下一个<mark>整时整分</mark>的时候重发</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213160941790.png" alt="image-20201213160941790"></p>
<ul>
<li>细枝末节<ul>
<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>
<li>纯ALOHA协议是想发就发的，而时隙ALOHA协议只有在时间片段开始的时候才能发</li>
</ul>
</li>
</ul>
<h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6><p>载波监听多路访问协议CSMA（carrier sense multiple access）</p>
<ul>
<li><strong>CS:载波监听</strong>，每个站发送数据之前检测一下总线上是否有其他的计算机在发送数据</li>
<li><strong>MA:多点接入</strong>，表示有许多计算机以多点接入的方式连接在<strong>一根总线</strong>上</li>
</ul>
<p>协议的核心思想是：发送帧<strong>之前</strong>，监听信道</p>
<p>根据信道空闲与否，选择发送完整帧还是推迟发送</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161550163.png" alt="image-20201213161550163"></p>
<ul>
<li><h4 id="1-坚持CSMA"><a href="#1-坚持CSMA" class="headerlink" title="1-坚持CSMA"></a><mark>1-坚持CSMA</mark></h4></li>
</ul>
<p>这里的<strong>坚持</strong>指的是对于监听到了信道<mark>忙</mark>后的坚持 （也就是发现忙了还继续听，直到空闲就抓住机会立刻传输）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213162607336.png" alt="image-20201213162607336"></p>
<hr>
<ul>
<li><h4 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a><mark>非坚持CSMA</mark></h4></li>
</ul>
<p><strong>非坚持</strong>指的是对于监听信道<mark>忙</mark>后就<strong>不继续监听了</strong>，也就是<strong>不坚持了</strong>（也就是发现忙了后，等一个随机时间后再监听，不会傻傻继续等）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213162858548.png" alt="image-20201213162858548"></p>
<hr>
<ul>
<li><h4 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p - 坚持CSMA"></a><mark>p - 坚持CSMA</mark></h4></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213163127853.png" alt="image-20201213163127853"></p>
<ul>
<li><h4 id="三种CSMA对比总结"><a href="#三种CSMA对比总结" class="headerlink" title="三种CSMA对比总结"></a><mark>三种CSMA对比总结</mark></h4></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213163300015.png" alt="image-20201213163300015"></p>
<hr>
<ul>
<li><h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA-CD协议"></a><mark>CSMA-CD协议</mark></h4></li>
</ul>
<p>学习该协议，需要明白 <strong>CS MA CD</strong>三个分别代表着什么</p>
<ul>
<li><p><mark>CS</mark>：<strong>载波监听</strong>，指的是每个<strong>站</strong>在<mark>发送数据之前</mark>以及<mark>发送数据的时候</mark>，都需要检测一下<strong>总线</strong>上是否有其他计算机在发送数据</p>
</li>
<li><p><mark>MA</mark>：<strong>多点接入</strong>，表示许多计算机以多点接入的方式连接在一根总线上</p>
<p>说明CSMA/CD协议用于<strong>总线型网络</strong></p>
</li>
<li><p><mark>CD</mark>：<strong>碰撞检测（冲突检测）</strong>，<strong>边发送边监听</strong>，适配器<strong>边发送数据边检测信道上信号电压变化情况</strong>，以便判断自己在发送数据的时候，别的站是不是也在发送数据</p>
<p>侧面说明了CSMA/CD协议应用于<strong>半双工网络</strong>（不允许双方同时发送信息的网络）</p>
</li>
<li><h5 id="传播时延对于载波监听影响"><a href="#传播时延对于载波监听影响" class="headerlink" title="传播时延对于载波监听影响"></a>传播时延对于载波监听影响</h5></li>
</ul>
<p>想一想，既然是监听后确定信道没人了再发送数据，那么为什么还会有<strong>冲突</strong>呢？是因为有着<strong>传播时延</strong>，也就是信号的传输是需要时间的，你正在征用信道的时候，你这个信号没传过去，别人还就误以为现在信道是空的了，也就是所谓的<strong>监听失误</strong></p>
<p>但我们需要明白，对于链路层这里来说，我发生了碰撞并不会影响发送数据，而是在发送到对方那端的时候进行差错检测，才能发现，哦原来发生了碰撞，这时候才能停发。</p>
<p>设总线上单程<strong>端到端</strong>的<strong>传播时延</strong>为τ（tao）</p>
<p>那么A发送数据后，最迟需要经过多久才能知道自己发送的数据与其他站发送的数据有么有发送碰撞？</p>
<p>答案是：2τ，也就是两倍的总线端到端的传播时延/总线的端到端往返传播时延</p>
<p>也就是说只要经过2τ的时间还没有检测到碰撞，那么就肯定这次发送不会发送碰撞</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105165259377.png" alt="image-20210105165259377"></p>
<ul>
<li>如何确定碰撞后的重传时机</li>
</ul>
<p>采用<strong>截断二进制指数规避算法</strong></p>
<p>主要分成以下几步：</p>
<ol>
<li>首先确定<strong>基本推迟的时间</strong>为2τ</li>
<li>第二步，定义<strong>参数k （重传次数）</strong>，k = min{重传次数，10}</li>
<li>第三步，在离散的整数集合[0,1,…..,2^k - 1]中选一个数作为<strong>r</strong>，此时重传的所需要推迟的时间就是<strong>r倍的基本退避时间</strong></li>
<li>第四步，判断重传次数，假如为16次，就说明网络太拥挤了，判断这个帧是永远无法正确发出去的，就抛弃掉，并向上层报告出错</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105171008058.png" alt="image-20210105171008058"></p>
<ul>
<li>最小帧长问题</li>
</ul>
<p>考虑下，假如一个帧，非常小，我发送方发出去了，在途中发生碰撞，由于有碰撞，接收方理所应当的会丢弃掉这个帧对吧？但我发送方以及发送完了，并不知道出了错啊，因此并不会再发一次，这个帧就白白丢失掉了。因此为了避免这种情况，以太网规定了<mark>最小帧长</mark></p>
<p>以太网规定了最小帧长为64字节 = 512bit，如果发送数据很小，没达到这个最小长度，就假如一些填充字节</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105172018775.png" alt="image-20210105172018775"></p>
<hr>
<ul>
<li><h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA-CA协议"></a><mark>CSMA-CA协议</mark></h4></li>
</ul>
<p>载波监听多点接入/碰撞<strong>避免</strong> CSMA/CA (carrier sense multiple access with collision avoidance)</p>
<p>为什么要有CSMA-CA协议呢？是因为 之前的CSMA -CD (冲突检测) 这种方式在无线局域网中有两个问题：</p>
<ol>
<li>无法做到360°全面检测冲突</li>
<li>当A和C都检测不到信号，认为信道是空闲的时候，就会向终端B发送数据帧，导致了冲突</li>
</ol>
<p><strong>工作原理：</strong></p>
<p>RTS/CTS机制的工作原理是，发送站点在向接收站点发送数据包之前，即在DIFS之后不是立即发送数据，而是代之以发送一个请求发送<mark>RTS（Ready To Send）帧</mark>，以申请对介质的占用</p>
<p>当接收站点收到<strong>RTS信号</strong>后，立即在一个<strong>短帧隙SIFS</strong>之后回应一个<mark>准许发 CTS（Clear To send）帧</mark>，告知对方已准备好接收数据。</p>
<p>双方在成功交换RTS/CTS信号对（即完成握手）后才开始真正的数据传递，保证了多个互不可见的发送站点同时向同一接收站点发送信号时，实际只能是收到接收站点回应CTS帧的那个站点能够进行发送，避免了冲突发生。</p>
<p>即使有冲突发生，也只是在发送RTS帧时，这种情况下，由于收不到接收站点的CTS消息，大家再回头用DCF提供的竞争机制，分配一个随机退守定时值，等待下一次介质空闲DIFS后竞争发送RTS帧，直到成功为止。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218002216775.png" alt="image-20201218002216775"></p>
<ul>
<li><h4 id="CSMA-CA-与-CSMA-CD"><a href="#CSMA-CA-与-CSMA-CD" class="headerlink" title="CSMA/CA 与 CSMA/CD"></a>CSMA/CA 与 CSMA/CD</h4><ul>
<li><p>相同点：这两种机制都属于CSMA的思路 —— <mark>先听再说</mark>（也就是这两种方式在接入信道之前都需要“敲敲门”，进行监听，发现了信道是空闲的，才能进行接入）</p>
</li>
<li><p>不同点：</p>
<ul>
<li><p>传输介质不同：CA方式用于<strong>无线局域网（无线）</strong>，CD方式用于<strong>总线式以太网（有线）</strong></p>
</li>
<li><p>载波检测方式不同：由于传输介质的不同，这两种方式的载波检测方式也是不同的</p>
<p>CD通过电缆中电压变化进行检测，数据发生碰撞的时候，电缆中电压会随之而变化；</p>
<p><strong>CA采用能量检测（ED）</strong>，<strong>载波检测（CS）</strong>和<strong>能量载波检测混合检测</strong>三种检测信道空闲的方式</p>
</li>
<li><p>CSMA/CD 是 <strong>检测冲突</strong>，CSMA/CA 是 <strong>避免冲突</strong>，两者发生冲突后都会进行<mark>有上限的重传</mark></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="轮询访问介质控制"><a href="#轮询访问介质控制" class="headerlink" title="轮询访问介质控制"></a>轮询访问介质控制</h5><p>结合了信道划分介质访问控制和随机访问介质控制的两个优点，做到：</p>
<p>既不产生冲突，又可以发送的时候占全部带宽</p>
<p>主要包括：轮询协议和令牌传递协议</p>
<h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><mark>轮询协议</mark></h6><p>核心思想：主节点轮流询问/邀请从属结点发送数据<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213165808469.png" alt="image-20201213165808469"></p>
<h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><mark>令牌传递协议</mark></h6><p>首先要明白什么是令牌：</p>
<p>“令牌”是一个特殊格式的MAC控制帧，不含任何信息。它是用于控制信道的使用，确保了<strong>同一时刻</strong>只有<strong>一个结点独占信道</strong></p>
<p>虽然说它不含任何信息，但不代表不能携带信息，假如一个主机想要用令牌传递数据，会修改令牌上的标记位，并说明要发给哪个主机</p>
<p>然后传递令牌，接受主机发现令牌上有自己的数据，就接受，最后令牌回到发送的主机上，清空标记位，进行令牌下一轮传递。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213170539234.png" alt="image-20201213170539234"></p>
<h2 id="局域网基本概念-amp-体系结构"><a href="#局域网基本概念-amp-体系结构" class="headerlink" title="局域网基本概念 &amp; 体系结构"></a>局域网基本概念 &amp; 体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul>
<li><p>局域网(Local Area Network, LAN)是指在一个较小的地理范围(如一所学校) 内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络</p>
<p>也就是 <strong>某一区域内</strong>由多台计算机互联组成的<strong>计算机组</strong>，使用的是<mark>广播信道</mark>（与点对点传输相对）</p>
</li>
<li><p>特点2中提到的是有线介质，其实局域网中包含无线局域网，就不用有线介质了；</p>
</li>
<li><p>决定局域网的因素为：<strong>网络拓扑</strong>、<strong>传输介质</strong>和<strong>介质访问控制办法</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218004411562.png" alt="image-20201218004411562"></p>
<h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><p>主要有四种拓扑结构：</p>
<ol>
<li><p><strong>星型拓扑</strong></p>
<p>定义：网络中各节点都连接到一个中心设备上，由该中心节点向目标节点传送信息。<br>优点：网络的维护和调试方便。</p>
</li>
<li><p><strong>总线型拓扑</strong></p>
<p>各个节点都连接到单一连续的物理线路上<br>常见的总线结构局域网<br>Ethernet 、ARCnet 、Token Bus 。<br>特征：信息广播式传播<br>特点：价格低廉，用户接入灵活，是一种小型、成熟、经济的解决方案。</p>
</li>
<li><p><strong>环形拓扑</strong></p>
<p>定义：连续网络中各节点的电缆构成一个封闭的环。<br>信息传递方式：沿节点单向传输。<br>应用范围：<br>一是工厂环境中，环网抗干扰能力强；<br>二是有许多大型机场合。</p>
</li>
<li><p><strong>树形拓扑</strong></p>
<p>易于拓展和隔离故障，但容易有<strong>单点故障</strong></p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218004811356.png" alt="image-20201218004811356"></p>
<h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><p>局域网细分为<strong>有线局域网和无线局域网</strong></p>
<ul>
<li>有线局域网：常用介质为 —— 双绞线、同轴电缆、光纤</li>
<li>无线局域网：常用介质为 —— 电磁波</li>
</ul>
<h4 id="介质访问控制办法"><a href="#介质访问控制办法" class="headerlink" title="介质访问控制办法"></a>介质访问控制办法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218005153816.png" alt="image-20201218005153816"></p>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><p>主要分为五种：</p>
<ol>
<li><p><strong>以太网</strong>：这个是目前应用最广泛的的<strong>局域网</strong>，包括了<mark><strong>标准以太网</strong>、<strong>快速以太网</strong>、<strong>千兆以太网</strong>和<strong>10G以太网</strong></mark>，他们都是符合<strong>IEE802.3系列标准规范</strong>。</p>
<p>采用的逻辑拓扑结构是：逻辑总线型</p>
<p>物理拓扑结构是：星型 or 拓展星型。</p>
<p>介质访问控制办法采用：<mark>CSMA/CD</mark></p>
</li>
<li><p><strong>令牌环网</strong>（有点被淘汰了已经）</p>
<p>逻辑拓扑结构：<strong>环形拓扑结构</strong></p>
<p>物理拓扑结构：<strong>星型拓扑结构</strong></p>
</li>
<li><p><strong>FDDI网</strong>（Fiber Distributed Data Interface）</p>
<p>逻辑拓扑结构：环形拓扑结构</p>
<p>物理拓扑结构：双环拓扑结构</p>
</li>
<li><p><strong>ATM网</strong>（Asynchronous Transfer Mode）：这是较为新型的单元交换技术，采用了53字节<strong>固定</strong>长度的单元进行交换</p>
<p>（为什么要强调是 固定的呢？因为1 - 3局域网等的数据交换单元是可变的，非固定的）</p>
</li>
<li><p><strong>无线局域网</strong>（Wireless  Local Area NetWord；也就是我们常常说的 <mark>WLAN</mark>)：采用的是IEEE 802.11标准;</p>
<p>不要把这个和WiFi搞混了，无线局域网覆盖的范围要比WiFi广很多</p>
</li>
</ol>
<h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><ul>
<li>IEEE 802标准描述的局域网参考模型仅仅只对应<strong>OSI参考模型中的</strong><mark>数据链路层和物理层</mark></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218170355928.png" alt="image-20201218170355928"></p>
<p>设立了很多的标准，这里只截取一小部分了：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218170435716.png" alt="image-20201218170435716"></p>
<h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><ul>
<li>上面说到IEEE 802标准只对应OSI参考模型中的数据链路层以及物理层，而他将<strong>数据链路层</strong>划分为了：<ul>
<li><mark>逻辑链路层LLC子层</mark></li>
<li><mark>介质访问控制MAC子层</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218184905744.png" alt="image-20201218184905744"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网概述"><a href="#以太网概述" class="headerlink" title="以太网概述"></a>以太网概述</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218191032708.png" alt="image-20201218191032708"></p>
<h3 id="以太网-1"><a href="#以太网-1" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>以太网提供的是<mark>无连接且不可靠</mark>的服务</li>
</ul>
<ol>
<li><strong>无连接</strong>:指的是发送方和接受方之间是没有<strong>握手过程的</strong></li>
<li><strong>不可靠</strong>:指的是 不对发送方的<strong>数据帧</strong>进行编号，接收方也不向发送方进行<mark>确认</mark>，差错的帧就会直接丢弃掉，差错的纠正由高层负责</li>
</ol>
<p>总的来说，就是以太网只负责<strong>无差错的接受</strong>，而不去实现<strong>可靠传输</strong></p>
<h3 id="以太传输介质与拓扑结构发展"><a href="#以太传输介质与拓扑结构发展" class="headerlink" title="以太传输介质与拓扑结构发展"></a>以太传输介质与拓扑结构发展</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218193653567.png" alt="image-20201218193653567"></p>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE - T以太网"></a>10BASE - T以太网</h3><p>如何理解这个以太网呢？我们拆开来看：</p>
<ul>
<li>10 ：指的是传输速率是10Mb/s</li>
<li>BASE : 指的是传送<strong>基带信号</strong></li>
<li>T ：指的是采用<strong>双绞线</strong>(如今采用的是无屏蔽双绞线UTP)</li>
</ul>
<p>which means：10BASE - T以太网是 <mark>传送基带信号的双绞线以太网</mark></p>
<p>物理上采取：星型拓扑</p>
<p>逻辑上采取：总线型拓扑</p>
<p>每段双绞线的最长为100m，采用<strong>曼彻斯特编码</strong>，采用CSMA/CD 介质访问控制</p>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h3><p>计算机 与 外界局域网是怎么连接的呢？是通过<strong>通信适配器</strong></p>
<p>这个名字我们也许并不是那么熟悉，他还有另外的名字叫：<strong>网络接口板 or 网络接口卡 （AKA 网卡</strong></p>
<p>它上面装有处理器和存储器</p>
<p>而存储器上就有着一个非常重要的东西：<mark>计算机硬件地址MAC地址</mark></p>
<p>硬件地址又称为物理地址/MAC地址 —— 相当于身份证？标识符的作用吧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218194922159.png" alt="image-20201218194922159"></p>
<h4 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h4><p>从图中我们可以发现：以太网MAC帧由这么几部分组成</p>
<ul>
<li><p>目的地址：标记<mark>接收方</mark>的地址，地址有三种情况：</p>
<ul>
<li>单播地址：专有的MAC地址</li>
<li>广播地址：全1或者是全F，发送给全部主机</li>
<li>多播地址</li>
</ul>
</li>
<li><p>源地址：标记<mark>发送方</mark>的地址</p>
</li>
<li><p>类型：用于标记上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。</p>
<p>理解起来很抽象的话举个例子：如果值是<strong>0x0800</strong> 代表上一层用的是<strong>IP数据报</strong></p>
<p>如果值是<strong>0x8137</strong>，表示帧是由<strong>NovellIPX</strong>发过来的</p>
</li>
<li><p>数据（IP数据报）：长度在<strong>46到1500</strong>字节之间</p>
<p>为什么是46呢？46是这么来的：最小长度64减去了（目的地址 + 源地址 + 类型 + FCS = 18) = 46</p>
</li>
<li><p>FCS（帧检验序列FCS）：使用前面所学习的CRC冗余码进行校验</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218200623396.png" alt="image-20201218200623396"></p>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><ul>
<li>速率 &gt;= 100Mb/s的以太网称之为<strong>高速以太网</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219011857324.png" alt="image-20201219011857324"></p>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219012505859.png" alt="image-20201219012505859"></p>
<h3 id="802-11-的-MAC帧头格式"><a href="#802-11-的-MAC帧头格式" class="headerlink" title="802.11 的 MAC帧头格式"></a>802.11 的 MAC帧头格式</h3><p>首先先看看MAC帧头格式的样子：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219190647470.png" alt="image-20201219190647470"></p>
<ul>
<li><p><mark>帧控制（2bytes大小）</mark>：用于指示数据帧的类型，是否分片等等信息，也就是记录了MAC 802.11的属性</p>
<ul>
<li><strong><em>Protocol version</em></strong>：表明版本类型，现在所有帧里面这个字段都是0x00</li>
<li><strong><em>Type</em></strong>：指明数据帧类型，是管理帧，数据帧还是控制帧</li>
<li><strong><em>Subtype</em></strong>：指明数据帧的子类型，因为就算是控制帧，控制帧还分RTS帧，CTS帧，ACK帧等等，通过这个域判断出该数据帧的具体类型</li>
<li><strong><em>To DS/From DS</em></strong>：这两个数据帧表明数据包的发送方向，分四种可能情况讨论</li>
<li><strong><em>若数据包To DS为0</em></strong>，From DS为0，表明该数据包在网络主机间传输**</li>
<li><strong><em>若数据包To DS为0</em></strong>，From DS为1，表明该数据帧来自AP</li>
<li><strong><em>若数据包To DS为1</em></strong>，From DS为0，表明该数据帧发送往AP</li>
<li><strong><em>若数据包To DS为1</em></strong>，From DS为1，表明该数据帧是从AP发送自AP的，也就是说这个是个WDS(Wireless Distribution System)数据帧，</li>
<li><strong>*Moreflag</strong>：分片标志，若数据帧被分片了，那么这个标志为1，否则为0*</li>
<li><strong><em>Retry</em></strong>：表明是否是重发的帧，若是为1，不是为0</li>
<li><strong>*PowerManage</strong>：当网络主机处于省电模式时，该标志为1，否则为0.*</li>
<li><strong><em>Moredata</em></strong>：当AP缓存了处于省电模式下的网络主机的数据包时，AP给该省电模式下的网络主机的数据帧中该位为1，否则为0</li>
<li><strong>*Wep</strong>：<a target="_blank" rel="noopener" href="http://www.2cto.com/Article/jiami/">加密</a>标志，若为1表示数据内容加密，否则为0*</li>
<li><strong><em>Order</em></strong> 这个表示用于PCF模式下，这里不予讨论</li>
</ul>
</li>
<li><p><mark>生存周期/Associate ID (2 bytes)</mark>:</p>
<p>Duration/ID 在frame control 后面，占2byte</p>
<ul>
<li>当设置为NAV 网络分配矢量情况 （network allowcation Vector ）<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="NAV"><br>第15bit 设置为0，0~14 用来设置NAV，单位微秒</li>
<li>免竞争期间（CFP contention free period）传送的帧<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="CFP frames"><br>第14bit 设置0 和15bit设置1 其他bit为0 所以duration/ID 为32768 设置为NAV，告诉收到beacon帧的sta，免竞争期间，所以其他sta 会更新NAV值，不干扰竞争传输</li>
<li>PS-Poll帧（省电模式-轮询）的 duration/ID的用法<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="PS-Poll"><br>处于省电模式的sta 会定期醒来，送出一个PS-Poll帧，从基站取出暂存的帧，会在Duration/ID中设置连接识别码AID（association ID），显示加入的BSS，1-2007范围</li>
</ul>
</li>
<li><p><mark>序列控制(2 bytes：4 bits/12 bits)</mark>：这个域分2部分，一个是分片序列号和标识帧列号。分片序列号就是记录分片序号的。比如一个帧A被分片成a1，a2，a3，那么a1，a2，a3这三个分片帧的分片序列分别是0,1,2。这个和IP分段原理一样的，该域占4个比特位。剩下的12个比特位就用于标识帧的序号，这个跟IP头里面的序列号一样。</p>
</li>
<li><p><mark>MAC地址 1-4</mark></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219185912839.png" alt="image-20201219185912839"></p>
<h4 id="RA-TA-BSSID-DA-SA"><a href="#RA-TA-BSSID-DA-SA" class="headerlink" title="RA TA BSSID DA SA"></a>RA TA BSSID DA SA</h4><ul>
<li><strong>BSSID(Basic Service Set ID)</strong>：在infrastructure BBS中，BSSID就是AP的mac地址。但是在IBBS中，它是一个随机即生成的46位二进制序列，还有最高两位分别是Universal/Local标志位和Individual/Group标志位。IBBS的BSSID中，Universal/Local标志位为1，表示本地MAC，Individual/Group标志位为0，表示是个人MAC。也就是说在IBBS中，BSSID地址应该类如 10xxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx（x表示随机数要么0要么1, 2进制表示）</li>
<li><strong>DA(destine address)</strong>：该帧的<code>目的mac地址</code></li>
<li><strong>SA(source address</strong>)：该帧的<code>源mac地址</code></li>
<li><strong>RA(receiver address)</strong>：无线网络中，该数据帧的<code>接收者</code></li>
<li><strong>TA(transmitter address)</strong>：无线网络中，该数据帧的<code>发送者</code></li>
</ul>
<p>注意 这上面两个定义中说的是无线网络 而不是 网络</p>
<p>有的人会觉得奇怪 有什么区别吗？</p>
<p>意思是说 RA TA 仅仅只在<strong>相应的无线网络</strong>中有作用</p>
<p>假如我现在有一台主机 需要向目的主机发送数据，而目的主机并不在我的无线网络中，我就没法发了。</p>
<p>在这种情况中此时，<strong>RA</strong>作为的是一个<mark>中转站</mark>的身份，并不能一次性的完成数据传输的作用。</p>
<p>最典型的一个例子就是在WDS模式下，数据帧会有4个地址，RA，TA表示接收端和发送端，这两个地址用于无线传输的时候。还有2个地址是DA和SA，分别跟以太网中一样表示源地址和目的地址。WDS帧的格式如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20120213105413973.jpg" alt="."><br>打个比方说，AP1有主机A，AP2有主机B。如果A要和B同学，那么A会首先发送数据帧给AP1，然后AP1发送帧给AP2 。这个时候帧里面会有4个地址，分别是RA=mac(AP2)，TA=mac(AP1)，DA=mac(B)，SA=mac(A)。</p>
<h3 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h3><p>主要分成两类：</p>
<ol>
<li>有固定基础设施无线局域网</li>
<li>无固定基础设施无线局域网的<strong>自组织网络</strong></li>
</ol>
<h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219193756031.png" alt="image-20201219193756031"></p>
<p>一个<mark>基本服务集 BSS </mark>包括一个<strong>基站</strong>和<strong>若干个移动站</strong>，</p>
<p>所有的站在<strong>本 BSS 以内</strong>都可以直接通信，</p>
<p>但在和<strong>本 BSS 以外</strong>的站通信时都要通过本 BSS 的<strong>基站</strong>。</p>
<p>基本服务集中的基站叫做接入点 AP (Access Point),其作用和网桥相似。</p>
<p>一个基本服务集可以是孤立的，也可通过接入点 AP连接到一个主干分配系统 DS (Distribution System)，然后再接入到另一个基本服务集，构成扩展的服务集ESS (Extended Service Set)。</p>
<p>ESS 还可通过叫做门桥(portal)为无线用户提供到非 802.11 无线局域网（例如，到有线连接的因特网）的接入。门桥的作用就相当于一个网桥。</p>
<p>移动站 A 从某一个基本服务集漫游到另一个基本服务集，而仍然可保持与另一个移动站 B 进行通信。</p>
<h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><p>在这个网络之中的各节点地位平等，每个主机既可以充当主机也可以当路由器的作用</p>
<p>也就是既可以发送数据，也可以接收数据</p>
<p>把主机都安排在一个网段就可以形成自组织网络</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219194044200.png" alt="image-20201219194044200"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>局域网只覆盖物理层和数据链路层，而广域网不仅仅如此，还覆盖了网络层；</p>
<p>广域网中强调的是：<mark>资源共享</mark> while 局域网强调<mark>数据传输</mark> </p>
<p>广域网中的通信子网采用：<strong>分组交换技术</strong>（在网络层会细讲）；</p>
<p>广域网能够将<strong>局域网或计算机系统</strong>连接起来，达到了<mark>资源共享</mark>的目的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219195652107.png" alt="image-20201219195652107"></p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ul>
<li>点对点协议PPP（<mark>P</mark>oint-to-<mark>P</mark>oint <mark>P</mark>rotocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网的时候一般使用该协议</li>
<li>只支持<strong>全双工链路</strong></li>
</ul>
<h4 id="PPP协议需要满足的要求"><a href="#PPP协议需要满足的要求" class="headerlink" title="PPP协议需要满足的要求"></a>PPP协议需要满足的要求</h4><ul>
<li><p><mark>简单</mark>：由于最复杂的部分在TCP协议中，而网络协议IP相对来说比较简单，它提供的是不可靠的数据报服务；</p>
<p>在这种情况下，数据链路层没必要提供比IP协议还多的功能；</p>
<p>因此对数据链路层的帧，不需要进行：<strong>纠错、序号、流量控制</strong></p>
<p>总的来说，这种数据链路层的协议（PPP协议）非常简单：接收方每收到了一个帧，进行<strong>CRC检验</strong></p>
<p>如果正确，就收下；反之则丢弃；</p>
</li>
<li><p><mark>封装成帧</mark>：PPP协议必须规定<mark>特殊的字符</mark>作为<strong>帧定界符</strong>（标志一个帧的开始和结束的字符）以便：</p>
<p>接收端从收到的的比特流中能准确的找出<strong>帧的开始和结束的位置</strong></p>
</li>
<li><p><mark>透明性</mark>：PPP协议必须保证数据传输的<strong>透明性</strong>，什么叫透明性呢？</p>
<p>意思是，如果数据中碰巧出现了和<strong>帧定界符</strong>一样的<strong>比特组合</strong>的时候，就必须要采取<mark>有效的措施</mark>去解决这个问题</p>
</li>
<li><p><mark>多种网络层协议</mark>：PPP协议必须能够在<strong>同一条物理链路上同时支持<mark>多种网络层协议</mark></strong>（IP、IPX）的运行</p>
<p>要注意：当<strong>点对点链路</strong>连接的是<strong>局域网or路由器</strong>的时候，PPP协议必须同时支持在链路所连接的<strong>局域网or路由器</strong>上所运行的各种<mark>网络层协议</mark></p>
</li>
<li><p><mark>多种类型链路</mark>：除了要支持多种<strong>网络层的协议</strong>以外，PPP还必须能够在多种类型的链路上运行；</p>
<p>比如：串行（一次只发一个比特）、并行（一次并行地发送多个比特）；</p>
<p>同步、异步；低速、高速；电的、光的；交换的、非交换的；</p>
</li>
<li><p><mark>差错检测</mark>：PPP协议必须能够对接收端收到的帧进行<strong>检测</strong>，并且对<strong>有差错的帧</strong>立即丢弃；</p>
<p>如果在数据链路层不进行差错检测，那么出现差错的<strong>无用帧</strong>就会在网络中继续向前转发，浪费很多网络资源</p>
</li>
<li><p><mark>检测连接状态</mark>：PPP协议必须具有一种<strong>机制</strong>能够及时自动检测出来链路有没有在正常工作；</p>
</li>
<li><p><mark>最大传送单元</mark>：PPP协议必须对每一种类型的点对点链路设置<strong>MTU（最大传送单元）</strong>的标准默认值；</p>
<p>这样做的目的是什么呢？是为了促进各种实现的<strong>互操作性</strong>；</p>
<p>如果高层协议发送的分组过长，超过了MTU数值，PPP就需要丢弃，并且返回差错；</p>
<p>ps：MTU是数据链路层的帧可以载荷的<strong>数据部分的最大长度</strong>，而不是<strong>帧的总长度</strong></p>
</li>
<li><p><mark>网络层地址协商</mark>：PPP协议必须提供一种<strong>机制</strong>，去让通信的两个<strong>网络层</strong>的实体能够通过协商去 →</p>
<p>知道或者说是能够配置彼此的网络层地址；</p>
<p>对于<strong>拨号连接</strong>的链路十分重要，若是只在链路层建立了连接 但不知道对方的网络层地址，就不能够保证网络层可以传送<mark>分组</mark></p>
</li>
<li><p><mark>数据压缩协商</mark>：PPP协议需要提供一种方法去协商使用<strong>数据压缩算法</strong>；但PPP协议并不要求将这个算法进行标准化；</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220161411120.png" alt="image-20201220161411120"></p>
<h4 id="PPP协议三个组成部分"><a href="#PPP协议三个组成部分" class="headerlink" title="PPP协议三个组成部分"></a>PPP协议三个组成部分</h4><ul>
<li>将IP数据报封装到串行链路的<strong>方法</strong></li>
<li>用来建立、配置和册数数据链路连接的<mark>链路控制协议LCP</mark></li>
<li>一套<mark>网络控制协议NCP</mark></li>
</ul>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201220164741323.png" alt="image-20201220164741323"></p>
<h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p>可以这么理解：</p>
<p>用户拨号接入了ISP(互联网服务提供商)，等于建立了一条<strong>用户个人电脑到ISP</strong>的物理连接</p>
<p>用户个人电脑向ISP发送一系列的<mark>链路控制协议LCP小组</mark>（封装成多个PPP帧），以便建立LCP连接；</p>
<p>接着NCP介入了，给新接入的用户个人电脑分配一个临时的IP地址；</p>
<p>结果就是：用户个人电脑成为互联网上一个有<strong>IP地址的主机</strong>了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220165159747.png" alt></p>
<h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201223222125357.png" alt="image-20201223222125357"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><ul>
<li>HDLC协议 - 高级数据链路控制，是一种在同步网上<strong>传输数据、面向比特</strong>的数据链路层协议</li>
</ul>
<p>这种协议的特点是：</p>
<ol>
<li>数据报文 可以透明传输，用于实现透明传输的<mark>0比特插入法</mark>易于硬件实现</li>
<li>采用全双工通信</li>
<li>所用的帧都采用<mark>CRC检验</mark>，对信息帧进行编号，可以防止<strong>漏收或重份</strong>，传输可靠性高</li>
</ol>
<h4 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h4><p>HDLC的站主要有三个：<strong>主站、从站、复合站</strong></p>
<p>其中：</p>
<ol>
<li>主站<ol>
<li>发送命令（包括数据信息）帧</li>
<li>接受响应帧</li>
<li>负责对整个链路的控制系统的初启</li>
<li>负责流程的控制</li>
<li>负责差错检测或恢复</li>
</ol>
</li>
<li>从站<ol>
<li>接受由主站发来的命令帧</li>
<li>向主站发送响应帧</li>
<li>配合主站参与差错恢复等链路控制</li>
</ol>
</li>
<li>复合站<ol>
<li>既能发送、又能接受命令帧和响应帧</li>
<li>负责整个链路的控制</li>
</ol>
</li>
</ol>
<p>下面提及三种数据的操作方式：</p>
<ul>
<li>正常响应方式</li>
<li>异步平衡方式</li>
<li>异步响应方式</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201223223014398.png" alt="image-20201223223014398"></p>
<h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><p>主要由这几部分组成：</p>
<p>标志F(首尾各一个) 地址A 控制C 信息Info 帧检验序列FCS </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224201319176.png" alt="image-20201224201319176"></p>
<h3 id="HDLC与PPP"><a href="#HDLC与PPP" class="headerlink" title="HDLC与PPP"></a>HDLC与PPP</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224201526269.png" alt="image-20201224201526269"></p>
<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h3><p>由于在物理层中，主机与集线器之间距离不能太远，不然会失真，信号怎么恢复都恢复不成原来的了；</p>
<p>而为了使远距离主机之间进行通信，就需要<strong>扩展</strong></p>
<ul>
<li>方法1：使用光线解调器</li>
</ul>
<p>主机到光线调制器：电信号 → 光信号</p>
<p>光线解调器到集线器：光信号 → 集线器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202049007.png" alt="image-20201224202049007"></p>
<ul>
<li>方法2：集线器连接集线器</li>
</ul>
<p>首先普及一个概念：<mark>冲突域</mark></p>
<p>如果一个集线器附近如果有多台主机同时发送消息，就会发生碰撞/冲突，构成的区域就叫<strong>冲突域</strong></p>
<p>没用集线器连接起来前：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202624221.png" alt="image-20201224202624221"></p>
<p>添加了主干集线器后：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202645059.png" alt="image-20201224202645059"></p>
<h3 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h3><p>由于上面的方法有个缺点：</p>
<p>冲突域增大了，发生冲突的概率会更高，那么除了物理层去扩展以太网以外，有没有办法从链路层去扩展呢？</p>
<p>主要是通过<mark>网桥和交换机</mark>去实现，顺便引入一个<mark>网段</mark>的概念</p>
<ul>
<li><p>网桥：是根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发和过滤</strong>，也就是说：</p>
<p>当网桥收到了一个<strong>帧</strong>之后，并不向所有接口转发这个帧，而是先去检查这个<strong>帧</strong>的<strong>目的MAC地址</strong>，然后再确定该<strong>帧</strong>转发到哪个接口</p>
<p>或是把它丢弃掉(过滤掉)</p>
</li>
<li><p>网段：一般是指一个计算机网络中使用同一 物理层设备（传输介质、中继器、集线器等）能够直接通讯的那一部分</p>
</li>
</ul>
<p>通过这个<mark>网桥</mark>就能将冲突域之间联系起来，进行数据传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224204821160.png" alt="image-20201224204821160"></p>
<h4 id="网桥分类"><a href="#网桥分类" class="headerlink" title="网桥分类"></a>网桥分类</h4><h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><ul>
<li>透明网桥指的是以太网上的站点是并不知道所发送的帧会经过哪几个网桥，是一种<strong>即插即用的设备——自学习</strong></li>
</ul>
<p>什么叫自学习？就是在传输过程中逐渐完善<strong>转发表（包含了地址和接口等信息）</strong>，这样子在下一次发送帧的时候，如果转发表中有对应的目的地址的信息，网桥就不用再转发帧了，就可以直接丢弃这个帧了。</p>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224210745626.png" alt="image-20201224210745626"></p>
<h5 id="多接口网桥"><a href="#多接口网桥" class="headerlink" title="多接口网桥"></a>多接口网桥</h5><p>多接口网桥 又名 以太网交换机（我觉得这个更广为人知一点）</p>
<p>这种方式的好处就是 连接了以太网交换机的<strong>设备</strong>可以做到<mark>独占传输媒体带宽</mark> </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224212235252.png" alt="image-20201224212235252"></p>
<h6 id="以太网交换机的两种交换方式"><a href="#以太网交换机的两种交换方式" class="headerlink" title="以太网交换机的两种交换方式"></a>以太网交换机的两种交换方式</h6><ul>
<li><p>直通式交换机：查完目的地址就立刻转发，延迟小，可靠性低</p>
<p>无法支持具有不同速率的端口的交换</p>
</li>
<li><p>存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃；</p>
<p>延迟大，可靠性高，可以支持具有不同速率的端口的交换</p>
</li>
</ul>
<h5 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a>冲突域与广播域</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224212734539.png" alt="image-20201224212734539"></p>
<h1 id="网络层-2"><a href="#网络层-2" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li><p>网络层的主要任务是把<mark>分组</mark>从<strong>源端</strong>传到<strong>目的端</strong>，为<mark>分组交换网</mark>上的不同主机提供通信服务；</p>
</li>
<li><p>网络层传输单位是<mark>数据报</mark></p>
</li>
</ul>
<h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><ul>
<li><p>路由选择与分组转发</p>
</li>
<li><p>异构网络互联</p>
</li>
<li><p>拥塞控制</p>
<p>什么叫拥塞呢？假如所有结点来不及接受<mark>分组</mark>，而要丢弃大量的<mark>分组</mark>的话呢，网络就会处于<strong>拥塞</strong>的状态；</p>
<p>因此，需要采取一些措施去缓解这种<strong>拥塞</strong></p>
</li>
</ul>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><p> 思考一下，我们知道数据想要从一个源主机传送到一个目的主机，需要经由<strong>路由器</strong>进行转发</p>
<p>那么究竟是如何进行的呢？就是通过<strong>数据交换</strong>这个技术了；</p>
<p> 下图有三种数据传输方式，P1没有引入交换设备，那么N个设备就需要CN2条链路</p>
<p>P2引入了一个交换设备，那么N设备各自只需要连接一条链路到交换设备即可，需要N条链路</p>
<p>P3将多个交换设备连接在一起，形成了一个交换网络，这样解决了远距离传输；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102145831047.png" alt="image-20210102145831047"></p>
<p>那么数据交换方式主要有三种：</p>
<ol>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换<ol>
<li>数据报方式</li>
<li>虚电路方式</li>
</ol>
</li>
</ol>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102151441549.png" alt="image-20210102151441549"></p>
<p>电话网络就是一种电路交换方式，这种方式的特点是：<mark>独占资源</mark></p>
<p>电路交换的阶段分为三步：</p>
<ol>
<li>建立连接（呼叫/电路建立）</li>
<li>通信</li>
<li>释放连接（拆除电路）</li>
</ol>
<p>这种方式的优点为:</p>
<ol>
<li>通信时延小（这是一种数据直达的过程，建立连接后，有数据就能通过交换设备发出去）</li>
<li>有序传输（发送数据按照顺序发送，按照顺序接受）</li>
<li>没有冲突（因为是独占资源的）</li>
<li>实时性强（建立连接后，随时可以进行通信）</li>
</ol>
<p>缺点为：</p>
<ol>
<li>建立连接时间长（需要建立连接，比如拨号）</li>
<li>线路独占，使用效率低（假如AB建立连接，但不传输数据，就白白浪费了了一个信道嘛）</li>
<li>灵活性差（假如其间一个交换设备宕机了，那么AB之间就完全无法进行通信了）</li>
<li>没有差错控制的能力（只转发，不检错）</li>
</ol>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102152148259.png" alt="image-20210102152148259"></p>
<p>首先需要明白什么是报文</p>
<ul>
<li>报文：是源应用发送的信息整体</li>
</ul>
<p>这种方式的优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态的分配线路（存储转发就是，不同于电路交换，拿到数据就转发，而是先存储，伺机转发，这样就可以做到动态的分配线路）</li>
<li>线路可靠性比较高（不用担心其间一个设备宕机了，就不能进行信息传输了，而是条条大路通罗马）</li>
<li>线路利用率比较高（在通信过程中，一段一段占用通信线路，而非占用一整条通信线路）</li>
<li>多目标服务（一个报文可以同时发往多个目的地址）</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储转发时延（因为需要存储嘛，肯定需要花额外一点时间的）</li>
<li>报文大小不定，需要网络节点有较大缓存空间</li>
</ol>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>思想上与报文交换差不多，都是使用<strong>存储转发</strong>，而分组转发就是将转发的数据块切分为了小的数据块——<strong>分组</strong></p>
<p>在分组交换中，只有最后一组（分组）的数据到达目的主机才算接受成功</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102153101471.png" alt="image-20210102153101471"></p>
<p>优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态分配线路（类比于报文交换，其实就是把转发的单位变了下，主要原理差不多）</li>
<li>线路可靠性比较高（分组短，出错几率小）</li>
<li>线路利用率较高（不同时间，只占用一段段路径）</li>
<li>相对于报文交换来说，存储管理更容易（对于缓存的要求没那么高了，因为不需要够大的缓存空间容纳大报文，而是可容纳小分组即可）</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储转发时延</li>
<li>需要传输额外的信息量（因为报文进行分片后，需要给各报文添加额外信息：源地址、目的地址、编号等）</li>
<li>乱序到目的主机的时候，需要对分组排序重组</li>
</ol>
<h4 id="数据报方式-amp-虚电报方式"><a href="#数据报方式-amp-虚电报方式" class="headerlink" title="数据报方式&amp;虚电报方式"></a>数据报方式&amp;虚电报方式</h4><p>分组交换方式分为两种：<strong>数据报方式&amp;虚电报方式</strong></p>
<p>其中，</p>
<p><mark>数据报方式</mark>为网络层提供<strong>无连接服务</strong></p>
<ul>
<li>无连接服务：不会事先为分组的传输确定传输路径，每个分组独立确定传输路径，因此不同分组的传输路径是可能不同的</li>
</ul>
<p><mark>虚电路方式</mark>为网络层提供<strong>连接服务</strong></p>
<ul>
<li>连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输<mark>系列分组</mark>，<mark>系列分组</mark>传输路径相同，传输结束后拆除连接</li>
</ul>
<h5 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h5><p>主要特点是：</p>
<p>每个分组携带源地址和目的地址</p>
<p>路由器根据分组的目的地址转发分组：</p>
<p>基于<strong>路由协议/算法</strong>去构建<mark>转发表</mark></p>
<p>而后检索<mark>转发表</mark>，每个分组独立选路</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102162414098.png" alt="image-20210102162414098"></p>
<h5 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h5><p>虚电路方式结合了<strong>数据报方式</strong>和<strong>电路交换方式</strong></p>
<p>虚电路：一条<strong>源主机</strong>到<strong>目的主机</strong>；类似于电路的路径，路径上所有的结点维持这条虚电路的建立，维持一张<mark>虚电路表</mark></p>
<p>这张表的每一项记录了一个<strong>打开的虚电路</strong>的信息</p>
<p>因此，属于同一条虚电路（路径）的分组会按照同一路由转发</p>
<p>你看 这样就有有问题了，假如一个虚电路上有一个结点出问题了，那么经由该结点的虚电路就都不能工作了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102163256159.png" alt="image-20210102163256159"></p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102163506772.png" alt="image-20210102163506772"></p>
<h4 id="传输单元名词辨析"><a href="#传输单元名词辨析" class="headerlink" title="传输单元名词辨析"></a>传输单元名词辨析</h4><p>分组、包，packet，信息在互联网当中传输的单元，网络层实现分组交付。用抓包工具抓到的一条条记录就是包。<br>帧，frame，数据链路层的协议数据单元。我们将链路层分组称为帧。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102161842138.png" alt="image-20210102161842138"></p>
<p>应用层——消息（报文）</p>
<p>传输层——数据段(segment)，报文段</p>
<p>网络层——分组、数据包（packet），IP数据报</p>
<p>链路层——帧（frame）</p>
<p>物理层——P-PDU（bit），比特流</p>
<p><mark>数据报，Datagram</mark>，通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。可以理解为传输数据的分组。我们将通过网络传输的数据的基本单元称为数据报。</p>
<p><mark>报文段，segment</mark>，组成报文的每个分组。我们将运输层分组称为报文段。</p>
<p><mark>报文，message</mark>，一般指完整的信息，传输层实现报文交付。我们将位于应用层的信息分组称为报文。</p>
<p>由此可见，抓包抓到的是传输层的包，所以packet，frame，Datagram，segment是存在于同条记录中的，而frame，Datagram，segment是基于所在协议层不同而取了不同的名字。</p>
<p><strong>1.报文(message)</strong><br>报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</p>
<p><strong>2.分组(packet)</strong><br>分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。</p>
<p><strong>3.数据包(data packet)</strong><br>数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。</p>
<p><strong>4.数据报(datagram)</strong><br>面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。</p>
<p><strong>5.帧(frame)</strong><br>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。</p>
<h3 id="报文交换-amp-分组交换对比"><a href="#报文交换-amp-分组交换对比" class="headerlink" title="报文交换 &amp; 分组交换对比"></a>报文交换 &amp; 分组交换对比</h3><p>对于下面这道题来说，将<code>10000bit</code>的报文分成了<code>1000组</code>每个大小为<code>10bit</code>的分组</p>
<p>其实可以这么想区别：类似于火车进隧道吧。报文交换需要将整个 </p>
<ul>
<li><p>对于报文交换来说：需要考虑将整个报文传到第二个设备所需要的的时间，也就是用报文长度/链路传输速率，再考虑传了几次</p>
</li>
<li><p>对于分组交换来说：先考虑单个分组的发送时延，也就是单个比特大小/传输速率；</p>
<p>而分组交换的总时延由2部分组成，一个是第一个分组开始发送直至最后一个分组发送到链路上所需要时间</p>
<p>另一个是由交换设备到交换设备，以及交换设备到目的主机的时间</p>
<p>（由于分组交换各个交换设备之间传输数据是重叠的，因此省时间）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102154646133.png" alt="image-20210102154646133"></p>
<h3 id="三种数据交换方式比较"><a href="#三种数据交换方式比较" class="headerlink" title="三种数据交换方式比较"></a>三种数据交换方式比较</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102160612397.png" alt="image-20210102160612397"></p>
<h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>首先需要有知识总览，要了解TCP/IP协议栈的构造</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102171803060.png" alt="image-20210102171803060"></p>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p>IP数据报粗糙来说有2部分组成：首部 + 数据部分</p>
<p>其中首部包含了固定部分和可变部分</p>
<p>数据部分包含了TCP段 和 UDP段</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>注释</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>版本 Version</td>
<td>ipv4或者ipv6</td>
<td>4位</td>
</tr>
<tr>
<td>首部长度 IHL</td>
<td>此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101</td>
<td>4位</td>
</tr>
<tr>
<td>区分服务 DSCP + ECN</td>
<td>希望获得哪种服务，用的比较少</td>
<td>8位</td>
</tr>
<tr>
<td>总长度 Total Length</td>
<td>首部+数据的长度，最大为2^16-1=65535</td>
<td>16位</td>
</tr>
<tr>
<td>标识 Identification</td>
<td>用来表示是哪一个数据报的分片，不同的分片标识各不相同</td>
<td>8位</td>
</tr>
<tr>
<td>标志 Flags</td>
<td>用来表示是否分片和分片是否结束</td>
<td>3位，但实际有用的只有后两位</td>
</tr>
<tr>
<td>片偏移 Fragment Offset</td>
<td>用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位</td>
<td>13位</td>
</tr>
<tr>
<td>生存时间 Time To Live</td>
<td>即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同</td>
<td>8位</td>
</tr>
<tr>
<td>协议 Protocol</td>
<td>用来标记协议名的字段值，如TCP,UDP,ICMP等等</td>
<td>8位</td>
</tr>
<tr>
<td>首部检验和 Header Checksum</td>
<td>检验首部的字段是否出错，出错就丢弃此数据报</td>
<td></td>
</tr>
<tr>
<td>源地址 Source IP Address</td>
<td>发送方ip地址</td>
<td>32位</td>
</tr>
<tr>
<td>目的地址 Destination IP Address</td>
<td>接收方ip地址</td>
<td>32位</td>
</tr>
<tr>
<td>可选字段 Options</td>
<td>用来排错等安全检测</td>
<td>未知，可在0-40位之间</td>
</tr>
<tr>
<td>填充</td>
<td>将数据报对齐成4字节的整数倍，数值全部为0</td>
<td>未知，根据可选字段来定</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102173951640.png" alt="image-20210102173951640"></p>
<p>标识、标志、片偏移留在下面IP数据报分片来讲</p>
<h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h3><p>首先需要了解为什么要分片</p>
<p>我们知道最大链路层中有一个概念叫<strong>最大传送单元MTU</strong></p>
<p>代表着数据链路层数据帧可以封装数据的上限，以太网的MTU是1500字节</p>
<p>那么，如果所传送的数据报长度超过了某个链路的MTU值，那么应该怎么办呢？<mark>分片</mark></p>
<p>首先把上面没讲完的 <strong>标识、标志、片偏移</strong>的概念理一下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102175308496.png" alt="image-20210102175308496"> </p>
<ul>
<li>例题</li>
</ul>
<p>要根据题目的所给的MTU将数据部分分片</p>
<p>其中片偏移 = 各分片在原来数据部分的位置 / 8b</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102200854563.png" alt="image-20210102200854563"></p>
<p>要注意的是：</p>
<p>总长度的单位是<strong>1B</strong></p>
<p>片偏移的单位是<strong>8B</strong></p>
<p>首部长度的单位是<strong>4B</strong></p>
<h3 id="IP数据报的传输方式"><a href="#IP数据报的传输方式" class="headerlink" title="IP数据报的传输方式"></a>IP数据报的传输方式</h3><p>参考博客1：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/CNHK1949/p/10680651.html">https://www.cnblogs.com/CNHK1949/p/10680651.html</a></p>
<p>参考博客2：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45755666/article/details/109552216">https://blog.csdn.net/weixin_45755666/article/details/109552216</a></p>
<p>有三种：<strong>单播、广播、组播</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104153654513.png" alt="image-20210104153654513"></p>
<h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>网络节点之间的通信就好像是人们之间的对话一样。如果一个人对另外一个人说话，那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行；用于发送数据包到单个目的地，且每发送一份单播报文都使用一个<strong>单播IP地址</strong>作为目的地址。</p>
<ul>
<li>是一种点对点传输方式。</li>
</ul>
<p>在发送者和每一接收者之间需要<strong>单独的数据信道</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104154754052.png" alt="image-20210104154754052"></p>
<p>单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用。</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播”可以理解为一个人通过广播喇叭对在场的全体说话，这样做的好处是通话效率高，信息一下子就可以传递到全体。</p>
<p>是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式</p>
<ul>
<li>是一种<mark>点对多点</mark>传输方式。</li>
<li>目的IP地址全1，目的MAC地址全F</li>
</ul>
<p>“广播”在网络中的应用较多，如客户机通过DHCP自动获得IP地址的过程就是通过广播来实现的。但是同单播和多播相比，广播几乎占用了子网内网络的所有带宽。拿开会打一个比方吧，在会场上只能有一个人发言，想象一下如果所有的人同时都用麦克风发言，那会场上就会乱成一锅粥。</p>
<p>在网络中不能长时间出现大量的广播包，否则就会出现所谓的“广播风暴”。广播风暴就是网络长时间被大量的广播数据包所占用，正常的点对点通信无法正常进行，外在表现为网络速度奇慢无比。出现广播风暴的原因有很多，一块有故障的网卡，就可能长时间向网络上发送广播包而导致广播风暴。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104155429364.png" alt="image-20210104155429364"></p>
<p>集线器由于其工作原理决定了不可能过滤广播风暴，一般的交换机也没有这一功能，不过现在有的网络交换机（如全向的QS系列交换机）也有过滤广播风暴功能了，路由器本身就有隔离广播风暴的作用。</p>
<p>广播风暴不能完全杜绝，但是只能在同一子网内传播，就好像喇叭的声音只能在同一会场内传播一样，因此在由几百台甚至上千台电脑构成的大中型局域网中，一般进行子网划分，就像将一个大厅用墙壁隔离成许多小厅一样，以达到隔离广播风暴的目的。</p>
<p>在IP网络中，广播地址用IP地址“255.255.255.255”来表示，这个IP地址代表同一子网内所有的IP地址。</p>
<h4 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h4><p>“多播”可以理解为一个人向多个人（但不是在场的所有人）说话，这样能够提高通话的效率。</p>
<p>如果你要通知特定的某些人同一件事情，但是又不想让其他人知道，使用电话一个一个地通知就非常麻烦，而使用日常生活的大喇叭进行广播通知，就达不到只通知个别人的目的了，此时使用“多播”来实现就会非常方便快捷，但是现实生活中多播设备非常少。</p>
<p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立<strong>组播分发树</strong>，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发。</p>
<ul>
<li>是一种<mark>点对多点</mark>传输方式。</li>
</ul>
<p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络（如果有组播路由器的支持）</p>
<p><strong>组播路由器</strong>：运行组播协议的路由器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104155349590.png" alt="image-20210104155349590"></p>
<p>“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。</p>
<p>因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；</p>
<p>如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。</p>
<p>采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。</p>
<p>IP网络的多播一般通过多播IP地址来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。Windows 2000中的DHCP管理器支持多播IP地址的自动分配。</p>
<h5 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h5><p>我们知道，IP地址是用于接收别人传送信息的，那么对于组播来说，如果还是以原来的IP地址作为接受信息的目的IP，那岂不是达不到组播的效果了？因此必须要有一个<strong>IP组播地址</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104160611338.png" alt="image-20210104160611338"></p>
<h5 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h5><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。</p>
<p>组播MAC地址以十六进制值 <strong>01-00-5E</strong> 打头，余下的6个十六进制位是根据IP组播组地址的最后 <strong>23</strong> 位转换得到的。</p>
<ul>
<li>TCP/IP协议使用的以太网多播MAC地址的范围：<br>01-00-5E-00-00-00 ~ 01-00-5E-7F-FF-FF。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104162812431.png" alt="image-20210104162812431"></p>
<p> 有可能不使用的5位不一样，但后23位一样，导致两个组播组的接收端成为了一个组播组：</p>
<p>收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>
<h5 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h5><h6 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h6><ul>
<li>IGMP协议，网际组管理协议</li>
<li>作用：让路由器知道<strong>本局域网</strong>上是否有主机（的进程）参加或者退出了某个<strong>组播组</strong></li>
</ul>
<p>如下图所示，四个主机参加了同一个组播组，每个路由器根据<strong>IGMP协议</strong>就可以判断，每接受一个组播组，要不要给局域网中的主机们呢？下图中，发送数据报的话就只会给R1 R2 R3而不会给R4，这就是根据IGMP协议来的</p>
<p>但这个IGMP协议也有不完备性，只能让路由器知道进程参加或者退出了这个组播组，而不能知道参加了组播组的成员在什么网络上</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104165551913.png" alt="image-20210104165551913"></p>
<p>在协议中的位置：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104165620489.png" alt="image-20210104165620489"></p>
<ul>
<li>工作的两个阶段</li>
</ul>
<ol>
<li><p>阶段1：某主机要加入组播组时，该主机向组播维的组播地址发送一个IGMP报文，声明自己要称为该组的成员。</p>
<p>本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
</li>
<li><p>阶段2：本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p>
<p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；</p>
<p>如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
</li>
</ol>
<p><strong>成员关系</strong>：组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>
<h6 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h6><p>一个组播组中的成员是可以动态变化的。</p>
<p>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</p>
<p>构造树可以避免在路由器之间兜圈子。</p>
<p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104170226000.png" alt="image-20210104170226000"></p>
<p>组播路由选择协议常使用的三种算法</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播（稀疏/密集）</li>
</ul>
<h2 id="路由算法-amp-路由协议"><a href="#路由算法-amp-路由协议" class="headerlink" title="路由算法 &amp; 路由协议"></a>路由算法 &amp; 路由协议</h2><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>路由器中有两个表：路由表/转发表</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102164632550.png" alt="image-20210102164632550"></p>
<p>路由算法的意义就在于：每次选择转发的路由都选择最佳的路由</p>
<p>ps：最佳路由中的<strong>最佳</strong>是相对于某一种特定要求下得出的较为合理地选择</p>
<p>路由算法有两种：</p>
<ol>
<li>静态路由算法（非自适应路由算法）</li>
<li>动态路由算法（自适应路由算法） </li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102165131431.png" alt="image-20210102165131431"></p>
<hr>
<p>关于动态路由算法，有两个性质：<strong>全局性</strong>和<strong>分散性</strong></p>
<ul>
<li><p>全局性：体现出全局性的算法叫<strong>链路状态路由算法 OSPF</strong></p>
<p>所有路由器掌握完整的网络拓扑和链路费用信息</p>
</li>
<li><p>分散性：体现出分散性的算法叫<strong>距离向量路由算法 RIP</strong></p>
<p>路由器只掌握物理相连的邻居及链路费用</p>
</li>
</ul>
<h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>为什么要分层次呢？</p>
<p>因为因特网的规模很大，而且单位不想让外界知道自己的路由选择协议，但仍想要连入因特网</p>
<p>因此就衍生了<mark>自制系统AS</mark>的概念：</p>
<p>在单一技术管理下的<strong>一组路由器</strong>，而这些路由器使用<strong>一种AS内部的路由选择协议</strong>和<strong>共同的度量</strong>以确定分组在该AS内的<strong>路由</strong></p>
<p>同时使用一种AS之间的额路由协议以确定在AS之间的路由属于一个行政单位进行管辖，一个自治系统的所有路由器在本自治系统内都必须要联通</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102170941984.png" alt="image-20210102170941984"></p>
<p>路由选择协议因此也分为两种：</p>
<ol>
<li>内部网关协议IGP：一个AS内使用的（<strong>RIP OSPF</strong>）</li>
<li>外部网关协议EGP：AS之间使用的（<strong>BGP</strong>）</li>
</ol>
<h3 id="RIP协议和距离向量算法"><a href="#RIP协议和距离向量算法" class="headerlink" title="RIP协议和距离向量算法"></a>RIP协议和距离向量算法</h3><h4 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h4><ul>
<li><p>这是一种分布式的基于<strong>距离向量</strong>的<mark>路由选择协议</mark></p>
</li>
<li><p>他要求网络中<strong>每个路由器</strong>都维护<em>从它自己到其他每一个目的网络的唯一最佳距离记录</em>（一组距离）</p>
</li>
<li><p><strong>距离</strong>：通常表示为<mark>跳数</mark>，即从<strong>源端口</strong>到<strong>目的端口</strong>所经过的路由器个数。经过一个路由器，跳数就+1</p>
<p>取值为1 ~ 15,16表示无穷大</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103204255367.png" alt="image-20210103204255367"></p>
<p> 那么RIP协议是交换什么信息，和谁交换呢？</p>
<ol>
<li>与<strong>相邻的路由器</strong>交换信息</li>
<li>所交换的信息是<strong>自己的路由表</strong></li>
<li><strong>每30秒</strong>交换一次路由信息，而后路由表根据新信息来更新自己的路由表，若180s没接收到邻居路由器的通告，就认定邻居路由器消失</li>
</ol>
<p>一开始路由器只知道数目有限的相邻路由器信息，后来更新次数多了，所有路由器最终都会知道到达<strong>AS</strong>任何一个网络的最短距离和下一跳路由器的地址，就<mark>收敛</mark>了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103205551346.png" alt="image-20210103205551346"></p>
<h4 id="RIP协议的报文格式"><a href="#RIP协议的报文格式" class="headerlink" title="RIP协议的报文格式"></a>RIP协议的报文格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103214456225.png" alt="image-20210103214456225"></p>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>如果有学过数据结构的图的内容的话，其实对于这个距离向量算法还是比较熟悉的</p>
<p>主要分为三步：</p>
<ol>
<li>初始化表项，修改相邻路由器发来的RIP报文中的所有表项</li>
<li>对于1中修改后的RIP报文中的每个项目，进行判断并做相应操作</li>
<li>如果180s未收到相邻路由器X的更新路由表，将X标记成不可达的路由器（距离=16）</li>
<li>返回 循环</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103211349636.png" alt="image-20210103211349636"></p>
<p>ps：</p>
<ul>
<li><strong>为什么改地址</strong>？因为图中是从x得到的信息</li>
<li><strong>为什么距离固定+1</strong>？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1</li>
<li><strong>为什么下一跳是x就要替换</strong>？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的</li>
<li><strong>为什么下一跳不是x时有更新和不处理两种手段</strong>？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解</li>
</ul>
<p>例题1分析：</p>
<p>首先把R4发来的路由信息（左下），进行更新，把距离+1，然后更改下一跳路由器为R4</p>
<p>第二步，根据发来的路由信息修改R6的路由表</p>
<p>发现：R6的路由表中没Net1的目标网络，因此填进去</p>
<p>对于目的网络Net2，R6表中有，且下一跳的路由器相同，因此进行替换</p>
<p>对于目的网络Net3，R6表中有，且下一跳的路由器不同，因此选择距离短的那个</p>
<p>（这里选择R4的那个是因为，新的含义为：如果我下一跳走R4，那么到达Net3只需要2跳）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103212724472.png" alt="image-20210103212724472"></p>
<p>例题2分析：</p>
<p>来自B的向量为（5,0,8,12,6,2）是什么意思呢？意思是B到达A、B、C、D、E、F的距离为这几个数字</p>
<p>后面几个向量同理</p>
<p>现在给定了C到B、D、E的延迟了，只需要把这几个延迟分别加到原来的向量里</p>
<p>然后在这几个新的向量组里，每一步选择距离最短的，最后即可得到C到达所有结点的最短路径了。</p>
<p>ps：0的意思是到自己的距离</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103213941432.png" alt="image-20210103213941432"></p>
<h4 id="RIP协议特点"><a href="#RIP协议特点" class="headerlink" title="RIP协议特点"></a>RIP协议特点</h4><p>  来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111526974.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111637786.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111700886.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111718198.png" alt="在这里插入图片描述"></p>
<h3 id="OSPF协议与链路状态算法"><a href="#OSPF协议与链路状态算法" class="headerlink" title="OSPF协议与链路状态算法"></a>OSPF协议与链路状态算法</h3><p>参考博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8ace17859bd1">https://www.jianshu.com/p/8ace17859bd1</a></p>
<h4 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h4><ul>
<li>Open Shortest Path First, 开放最短路径优先协议，是一种开源的使用最短路径优先（SPF）算法的内部网关协议（IGP）。</li>
<li>常用于路由器的动态选路。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103215911003.png" alt="image-20210103215911003"></p>
<h4 id="OSPF常见的几个概念"><a href="#OSPF常见的几个概念" class="headerlink" title="OSPF常见的几个概念"></a>OSPF常见的几个概念</h4><ul>
<li><p><mark>邻居（Neighbor）</mark>：宣告OSPF的路由器（也可能是通过quagga软件配置的普通服务器）从所有启动OSPF协议的接口上发出Hello数据包。</p>
<p>如果两台路由器位于同一条数据链路上，并且它们根据互相的hello消息中指定的某些信息（比如id等）协商成功，那么它们就成为了邻居（Neighbor）。</p>
</li>
<li><p><mark>邻接关系（Adjacency）</mark>：两台邻居路由器之间构成的一条点到点的虚链路，邻接关系的建立是由交换hello信息的路由器类型和网络类型决定的。</p>
</li>
<li><p><mark>链路状态通告（Link State Advertisement，LSA）</mark>：每一台路由器都会在所有形成邻接关系的邻居之间发送链路状态通告LSA。</p>
<p>LSA描述了路由器所有的链路、接口、邻居等信息。ospf定义了许多不同的LSA类型。</p>
</li>
<li><p><mark>链路状态数据库（LSDB）</mark>：每一台收到来自邻居路由器发出的LSA的路由器都会把这些LSA信息记录在它的LSDB中，并且发送一份LSA的拷贝给该路由器的其他所有邻居。</p>
<p>这样当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB。</p>
</li>
</ul>
<h4 id="OSPF的基本原理"><a href="#OSPF的基本原理" class="headerlink" title="OSPF的基本原理"></a>OSPF的基本原理</h4><p>OSPF算法是让每个路由器中的数据库储存整个网络的拓扑图，即每个路由器掌握了全局的信息，此时这个网络趋于稳定，便可以使用单源最短路径（Dijkstra）来选择路由。</p>
<p>每个路由器与其邻居的通信行为有以下几种：<br> 1.<strong>保持联系</strong><br> 整个自治系统中，每个路由器都有唯一标识RouterID(32-bit). 与其每个邻居间隔30s，发送一次Hello 报文，意思就是你还活着吗？<br> 二者相互通信发送Hello，并收到对方回应Hello。双方会周期性将自己的路由数据摘要发送给对方，一般30min，平时，<br> 双方只是联系感情，直到对方没有挂。<br> 2.<strong>告知现今情况</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/16845916-40717fbbfc3b07a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp" alt="img"></p>
<p>如图，R1会周期性地将自己的路由摘要发送给所有邻居。比如对R6路由器，R1会发送称为DD报文的包，里面会说自己认识R6,R2,R4,R5,R6对比自己的信息库发现 除了自己R1的朋友它一个都不认识，于是就发送请求报文，请求告知这些不认识的路由详情。</p>
<p>这个请求报文称为LSR(链路状态请求报文)报文。<br>R1收到之后，直到R6还不认识自己另外三个朋友，于是发送LSU报文（链路状态更新）告知R6详情</p>
<p>R6收到之后，给R1个确认-LSAck报文。两个人现在认识的路由器一样多了，此时两个人是好基友了-全毗邻关系。</p>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p>其实就是<strong>Dijkstra算法</strong>的实例运用吧 我感觉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104001203805.png" alt="image-20210104001203805"></p>
<h4 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h4><p>关于区域：<a target="_blank" rel="noopener" href="https://blog.51cto.com/14157628/2392133">https://blog.51cto.com/14157628/2392133</a></p>
<p><strong>为什么要分区域呢？</strong></p>
<p>在大型网络中，使用OSPF路由协议经常遇到以下问题：<br>1.在大型网络中，网络结构的变化是时常发生的，因此OSPF路由器就会经常运行SPF算法来重新计算路由信息，大量消耗路由器的CPU和内存资源；<br>2.在OSPF网络中，随着多条路径的增加，路由表会变得越来越庞大，每一次路径的改变都使路由器不得不花大量的时间和资源去重新计算路由表，路由器会变得越来越低效；<br>3.包含完整网络结构信息的链路状态数据库也会变得越来越大，这将有可能使路由器的CPU和内存资源彻底耗尽，从而导致路由器的崩溃。</p>
<p>为了解决这个问题，OSPF允许把大型区域划分成多个小区域，这些小区域可以交换路由汇总信息，而不是每个路由器的详细信息；也更容易管理；OSPF的工作也会更加流畅。</p>
<p><strong>生成OSPF多区域的原因</strong><br>改善网络的可扩展性；<br>快速收敛。<br>想要达到上面两个要求的关键就是把网络分成更小的区域。比如<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104005113687.png" alt="image-20210104005113687"><br>划分区域之后，每个OSPF区域中支持的最多路由器的个数30——200。</p>
<p>但是一个区域中实际加入的路由器的数量要小于单个区域所能容纳路由器的最大数量。因为有很多原因影响，比如：一个区域内链路的数量、网络拓补稳定性、路由器的内存和CPU等等。</p>
<p>对于和区域相关的通信量定义了三种类型，如：</p>
<ol>
<li>域内通信量：指由单个区域内的路由器之间交换的数据包构成的通信量；</li>
<li>域间通信量：指由不同区域的路由器之间交换的数据包构成的通信量；</li>
<li>外部通信量：指由OSPF区域内的路由器与OSPF区域外或两一个AS（自治系统）内的路由器之间交换的数据包构成的通信量。</li>
</ol>
<p>OSPF被分为多区域的能力是依照分层路由实现的。当划分成小区域以后，像重新计算拓补数据库这样的操作就被限定在该小区域内，区域间则只需通告一些汇总信息。<br>分层路由的优势：</p>
<ol>
<li>降低了SPF运算的频率；</li>
<li>减小了路由表；</li>
<li>减小了链路状态更新报文（LSU）的流量。</li>
</ol>
<p><strong>什么是区域呢？</strong></p>
<ul>
<li>为了使OSFP能够用于大规模的网络，OSPF将一个自治系统再划分成了<strong>若干个更小的范围：<mark>区域</mark></strong></li>
</ul>
<p>在区域内有着不同种类的路由器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104005642122.png" alt="image-20210104005642122"></p>
<p><strong>内部路由器</strong>：指所有接口都属于同一个区域的路由器；<br><strong>区域边界路由器（ABR）</strong>：指连接一个或多个区域到骨干区域的路由器并且这些路由器会作为域间通信量的网关。物理上至少连接两个区域。<br><strong>自治系统边界路由器（ASBR）</strong>：ASBR路由器是用来把其他路由选择协议学习到的路由通过路由选择重分配的方式注入OSPF域的路由器。至少配置两种路由协议。</p>
<p>OSPF根据能够学习到的路由种类将区域分为不同的类型，包括<strong>骨干区域、标准区域、末梢区域、完全末梢区域、非纯末梢区域</strong>等。<br>运行OSPF的整个区域属于一个AS，AS范围外的路由都属于外部路由。</p>
<p>骨干区域用于连接其他区域，骨干区域中的路由器大都是ABR。</p>
<p><strong>骨干区域Area 0</strong>该区域的ID一定是0，它是连接所有其他区域的核心，在不同的区域间传递路由信息，其他区域必须跟骨干区域直连。<br><strong>标准区域</strong>能够学习到其他区域的路由；也能学习到外部路由就称为标准区域。<br>每个路由器都创建了由每个接口、对应的相邻节点和接口速度组成的数据库，称为<mark>链路状态数据库</mark>。<br>链路状态数据库中每个条目称为<strong>LSA（链路状态通告）</strong>，常见的有六种LSA类型;</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104004124140.png" alt="image-20210104004124140"></p>
<h4 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104010148222.png" alt="image-20210104010148222"></p>
<h4 id="OSPF特点"><a href="#OSPF特点" class="headerlink" title="OSPF特点"></a>OSPF特点</h4><ol>
<li>每隔三十分钟，要刷新一次数据库中的链路状态</li>
<li>由于一个路由器的<strong>链路状态</strong>只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系；因此当<strong>互联网规模很大</strong>的时候，OSPF协议要比<strong>距离向量协议RIP</strong>好很多</li>
<li>OSPF不存在坏消息传的慢的问题，<strong>收敛速度很快</strong></li>
</ol>
<h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><ul>
<li>BGP协议是外部网关协议</li>
</ul>
<p>关于BGP协议：</p>
<ul>
<li>和谁交换信息？与其他的AS的临站BGP发言人交换信息</li>
<li>交换内容是什么？交换的是<strong>网络可达性的信息</strong>，即：要到达某个网络所要经过的一系列AS，也就是一个<strong>完整的路径</strong></li>
<li>多久交换一次呢？不同于RIP协议，30s更新一次，发生变化时就更新有变化的部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104144938982.png" alt="image-20210104144938982"></p>
<h4 id="BGP协议交换信息的过程"><a href="#BGP协议交换信息的过程" class="headerlink" title="BGP协议交换信息的过程"></a>BGP协议交换信息的过程</h4><p>上面我们提到过：BGP协议交换的网络可达性的信息就是<mark>要到达某个网络所要经过的一系列AS</mark>。当<strong>发言人</strong>互相交换了<strong>网络可达性</strong>的信息之后，各<strong>BGP发言人</strong>根据所采用的策略，从收到的<strong>路由信息</strong>中找到到达各AS的<strong>较好路由</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150436525.png" alt="image-20210104150436525"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150457601.png" alt="image-20210104150457601"></p>
<h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150644601.png" alt="image-20210104150644601"></p>
<h4 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h4><ul>
<li><p>BGP协议支持<strong>CIDR</strong>，which meas，BGP的路由表也就应当包括：<strong>目的网络前缀、下一跳路由器、以及到达目的网络索要经过的各个自治系统序列</strong></p>
</li>
<li><p>在BGP刚运行的时候，BGP的邻站是交换整个的<strong>BGP路由表</strong>。但在之后只需要<mark>发生变化的时候，更新有变化的部分</mark></p>
<p>这样做的好处：对节省网络带宽和减少路由器的处理开销都有好处</p>
</li>
</ul>
<h4 id="BGP-4-的四种报文"><a href="#BGP-4-的四种报文" class="headerlink" title="BGP-4 的四种报文"></a>BGP-4 的四种报文</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104151523075.png" alt="image-20210104151523075"></p>
<h3 id="三种报文的比较"><a href="#三种报文的比较" class="headerlink" title="三种报文的比较"></a>三种报文的比较</h3><ol>
<li><mark>RIP</mark>是一种<strong>分布式</strong>的<strong>基于距离向量</strong>的<strong>内部网关路由选择协议</strong>，通过广播<mark>UDP</mark>报文来交换路由信息</li>
<li><mark>OSPF</mark>是一个<strong>内部网关协议</strong>，要交换的信息量比较大，应该使得交换的报文尽可能的短，所以不使用<strong>传输层协议</strong>（比如UDP/TCP），而是直接采取<mark>IP</mark></li>
<li><MARK>IP是一种<strong>外部网关协议</strong>，在不同的自治系统AS之间交换路由信息，由于网络的环境很复杂，需要保证<strong>可靠传输</strong>，所以采用<mark>TCP</mark></MARK></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104152605563.png" alt="image-20210104152605563"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p>首先明白什么是IP地址</p>
<p> 其实就是给网络中的主机或是主机的接口、路由器的接口赋予标识符，能够做到全球唯一化，方便互联网中寻址通信</p>
<p>由两部分组成：网络号 + 主机号</p>
<p>顾名思义，网络号呢 就是用于确认在哪个区域网络，主机号用于确定该区域内哪个主机</p>
<p>通常采用<strong>点分十进制</strong></p>
<p>ip地址的四段数字分别代表了：网络类型、网络范围、网络位和主机位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102203123904.png" alt="image-20210102203123904"></p>
<p>在下图中，我们不难发现，红色区域和绿色区域内的网络位相同，总共有6个实际上的网络，只是绿色部分不是由主机，是由线路形成的</p>
<p>也不难发现，一个路由器，它的主机位是一样的，但是可以连接多个网络位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102212812420.png" alt="image-20210102212812420"></p>
<h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>A类中为什么是2^7 - 2呢？因为第一位固定0，因此可用的是7位，而减2是刨除了全0以及网络号为127这种情况</p>
<p>主机数为什么也要减2呢，一个是主机号为全0情况，一个是主机号为全1情况</p>
<p>同理也可以推出下面-1，-2的意思</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102215104191.png" alt="image-20210102215104191"></p>
<h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><p>特殊主要是体现在，网络号和主机号上，如果其全为0或是全为1，那么代表着什么呢？</p>
<p>（前三位是网络号，第四位是主机号）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102214017320.png" alt="image-20210102214017320"></p>
<h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>前面我们学习了IP地址分类，有A、B、C…类等等</p>
<p>根据类别不同就有了私有IP地址了，因为根据地址的类别，可以划分地址范围因而可以设定网段的个数</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102214458357.png" alt="image-20210102214458357"></p>
<p>为什么A类最大是126.xxx.xxx.xxx？<br>因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉<br>为什么B类最大是191.255.xxx.xxx？<br>因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址<br>为什么C类最大是223.255.xxx.xxx？<br>因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip</p>
<h4 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h4><p>网络层的分组为<strong>数据报</strong>，数据报为<strong>首部和数据</strong>两部分组成，如下图所示。</p>
<p><img src="https://images2015.cnblogs.com/blog/833392/201604/833392-20160404203420640-797750729.png" alt="img"></p>
<p>首部的长度是以<strong>4个字节</strong>为单位，长度可以是<strong>20-60</strong>字节，这跟首部的HLEN字段有关。</p>
<p><img src="https://images2015.cnblogs.com/blog/833392/201604/833392-20160404201653937-531539500.png" alt="img"></p>
<p><strong>版本：</strong></p>
<p>这个4位字段定义了IP协议的版本，目前主流的版本是4。</p>
<p><strong>首部长度：</strong></p>
<p>这个4位字段定义了数据报首部的长度，以<strong>4字节</strong>的字为<strong>单位</strong>。</p>
<p>当首部<strong>没有选项</strong>时，首部长度位<strong>20字节</strong>；当这个字段值位最大值F时，首部长度<strong>最大为60字节</strong>。</p>
<p><strong>服务类型：</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106140012964.png" alt="image-20210106140012964"></p>
<p><strong>总长度：</strong></p>
<p>这个16位字段定义了数据报总长度，其<strong>以字节为单位</strong>。故IPv4数据报总长度上限值位<strong>65536字节</strong>。</p>
<p>注：为什么需要这个字段？在许多情况下，我们确实不需要这个字段值。但是有些情况下，封装在一个帧里的并不仅仅是数据报，还可能附加了一些<strong>填充</strong>。比如，以太网协议对帧的数据有最大值（1500字节）和最小值（46字节）的限制，当数据小于46字节时，数据将含有填充数据。</p>
<p><strong>标识（identification）：</strong></p>
<p>这个16位字段标志了从源主机发出的一个数据报，这样就确定了<strong>数据报的唯一性</strong>。这样使得数据报被分片后，在到达终点时终点能根据标识号将同一个数据报的分片重新组装成一个数据报。</p>
<p><strong>标志（flag）：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>D</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第一位保留（未用），第二位为“不分片（do not fragment）”，第三位位“还有分片（more fragment）”。</p>
<p>D为1时，不能对数据进行分片；为0可以进行分片。</p>
<p>M为1时，标识还有分片；为0表示最后一个分片。</p>
<p><strong>片偏移：</strong></p>
<p>这个13位字段表示的是分片在整个数据报中的相对位置。这是<strong>数据</strong>在原始数据报中的<strong>偏移量</strong>，以<strong>8字节位单位</strong>。</p>
<p>注：分片本身还可能进行分片，这种情况下，分片偏移值永远是相对于原始数据报的。</p>
<p><strong>生存时间：</strong></p>
<p>这个8位字段用来控制数据报所经过的最大跳数（路由器），每经过一个路由器，这个字段数值都减1，减1后变位0时，路由器就丢弃这个数据报。</p>
<p><strong>协议：</strong></p>
<p>这个8位字段定义了使用IPv4服务的高层协议，如TCP，UDP，ICMP，IGMP，OSPF等的数据都将被封装到IP数据报中。这个字段指明数据报必须交付给哪个最终目的协议。</p>
<p>注：1表示ICMP，2表示IGMP，6表示TCP，17表示UDP，89表示OSPF</p>
<p><strong>检验和：</strong></p>
<p>检验IP数据报首部。</p>
<p><strong>源地址：</strong></p>
<p>定义了源点的IP地址，这个字段始终保持不变。</p>
<p><strong>目的地址：</strong></p>
<p>定义了终点的IP地址，这个字段始终保持不变。</p>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>网络地址转换NAT有什么用呢？之前我们学习到私有IP地址这个概念</p>
<p>我们知道：路由器对于目的地址是私有IP地址的数据报一律不进行转发，那假如我处于私有IP地址，我怎么与外界进行通信呢？</p>
<p>就要通过<mark>网络地址转换NAT</mark>这个技术了</p>
<p>在NAT技术中，通过NAT转换表，把<strong>源IP地址</strong>转换成<strong>NAT路由器的IP地址</strong>，<strong>原来的端口号</strong>替换成<strong>NAT路由器的端口号</strong>，就能够在因特网中进行转发了</p>
<p>而外部因特网想与专用网通信也是同样道理，数据报填上：源IP地址，目的地址（这个时候目的地址就得填NAT路由器的IP地址了），端口号；</p>
<p>经由NAT路由器查找对应的WAN端找到LAN端的端口号，进而找到对应主机</p>
<p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102221152359.png" alt="image-20210102221152359"></p>
<h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p>为什么要有子网划分呢？肯定是因为之前的<strong>分类的IP地址</strong>不够好</p>
<p>主要有以下两点缺点：</p>
<ol>
<li>IP地址空间的利用率有时候会很低</li>
<li>两级IP地址不够灵活(网络号+主机号)</li>
</ol>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>子网划分主要就是把：主机号中<strong>高位数</strong>换成了<strong>子网号</strong>，剩下依旧表示主机号</p>
<p>子网划分的意义是什么呢？是为了增加子网的数量，而子网之间数据传输又需要经由路由器，因此最终目的是减少了<strong>广播域</strong>的大小</p>
<p>同时，划分子网由于子网号占用主机号位，因此会减少主机的数量；</p>
<p>划分子网仅仅只提高了IP地址的利用率，并不会增加网络的数量</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103150436799.png" alt="image-20210103150436799"></p>
<p>下面是一个子网划分的例子：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt="image-20210103151451563"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码有什么用呢？是用于和IP地址一起计算<strong>子网的地址</strong>的</p>
<p>方法：子网掩码由1组成，与原来的ip地址进行<strong>与运算</strong>，即可得到<strong>子网的IP地址</strong></p>
<p>我感觉子网掩码部分需要记住的知识点就是十进制转二进制，然后找一下对应的属于哪一类网，然后看看对应网有什么性质，做题这样。</p>
<p>然后根据子网掩码和ip地址算子网地址，一个是通过与运算算出来子网地址之后，又要求广播地址</p>
<p>那么这个时候广播地址是基于子网地址的嘛，就在子网地址的基础上，分清楚主机号网络号，把主机号置为1就是广播地址</p>
<p>主机地址范围就是在子网地址的基础上：</p>
<p>最小值是主机号全为0 的二进制数+1，最大值是主机号全为1的二进制数 - 1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt="image-20210103151948576"></p>
<p>用IP的术语来说，互联这三个主机接口与一个路由器接口的网络形成一个<strong>子网</strong>。</p>
<p>（在因特网文献中，子网也称为IP网络或直接成为网络）Ip编址为这个子网分配一个地址：233.1.1.0/24，其中的/24记法，有时称为<strong>子网掩码</strong>（networkmask）,指示了32比特中的最左侧24比特定义了子网地址。</p>
<p>通俗来讲，子网掩码用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别<strong>网络标识</strong>和<strong>主机标识</strong>，并说明该IP地址是在局域网上，还是在远程网上。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt></p>
<p>子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。</p>
<ul>
<li>对于<strong>A</strong>类地址来说，默认的子网掩码是<strong>255.0.0.0</strong>；</li>
<li>对于<strong>B</strong>类地址来说默认的子网掩码是<strong>255.255.0.0</strong>；</li>
<li>对于<strong>C</strong>类地址来说默认的子网掩码是<strong>255.255.255.0</strong>；</li>
</ul>
<p>那么通过子网掩码我们可以知道什么信息呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过子网掩码，就可以判断两个IP在不在一个局域网内部。</span><br><span class="line">子网掩码可以看出有多少位是网络号，有多少位是主机号</span><br></pre></td></tr></table></figure>

<h5 id="子网掩码习题"><a href="#子网掩码习题" class="headerlink" title="子网掩码习题"></a>子网掩码习题</h5><p>通过用IP地址 与 子网掩码进行与运算（相同为1，不同为0）得到网络地址</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2020062821061359.png" alt></p>
<p>对于此类题，首先要判断出网络号有多少位：255.255.252.0 有 8 + 8 + 6 = 22位的网络号 则后面的 32 - 22 = 10位是主机号</p>
<p>180.80.77.55 解析 —— 可以知道在77部分某部分开始会用来表示主机号位</p>
<p>子网掩码前面是255.255 则180.80能保留下来 也就是占有8 + 8 = 16位，我们已知有22位的网络号，则留给IP地址180.80.77.55第三位<strong>77</strong>来构成网络号的就有6位，77二进制：010011 01，则前6位是归于网络号，后面01开始为主机号</p>
<p>则用于表示子网ip地址的就是<strong>180.80.76(<mark>010011 00</mark>).xxx</strong> </p>
<p>本体要求是发布广播地址 —— 主机号全为1</p>
<p>则目的地址应该是<strong>180.80.79（<mark>010011 11</mark>）.255(11111111）</strong> 选D</p>
<h4 id="使用子网的时候分组的转发"><a href="#使用子网的时候分组的转发" class="headerlink" title="使用子网的时候分组的转发"></a>使用子网的时候分组的转发</h4><p>当使用子网的时候分组转发分以下几步：</p>
<ol>
<li><p>从收到的分组首部提取<mark>目的IP地址D</mark></p>
</li>
<li><p>首先用各相邻网络的<mark>子网掩码和<strong>目的IP地址D</strong></mark>逐位相与，看是否和相应的网络地址匹配。</p>
<p>如果匹配了，就把分组直接交付了。否则进行<strong>间接交付，</strong>也就是执行3</p>
</li>
<li><p>若路由表中有目的地址为D的<mark>特定主机路由</mark>，就把分组传送给指明的下一跳路由器；</p>
<p>如果没有，则执行4</p>
</li>
<li><p>在这一步，对<strong>路由表</strong>中的每一行，将<mark>子网掩码</mark>和D逐位相与。</p>
<p>如果结果和该行的目的地址匹配，就把分组传送给该行指明的<strong>下一跳路由器</strong></p>
<p>否则，执行5</p>
</li>
<li><p>如果路由表中有一个<mark>默认路由</mark>。就把分组传送给路由表中指明的默认路由器</p>
<p>否则，执行6</p>
</li>
<li><p>报告转发分组出错</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt></p>
<h3 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h3><p>有个博客讲的真的不错：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dan15188387481/article/details/49873923">https://blog.csdn.net/dan15188387481/article/details/49873923</a></p>
<hr>
<ul>
<li><p>CIDR中文全称是无分类域间路由选择，英文全称是Classless Inter-Domain Routing</p>
</li>
<li><p>CIDR这种方法比较灵活，消除了传统A B C类以及划分子网的概念</p>
</li>
</ul>
<p>使用下面的IP地址表示法：</p>
<p><code>IP地址 ::= &#123;&lt;网络前缀&gt;， &lt;主机号&gt;&#125; / 网络前缀所占位数</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103161001783.png" alt="image-20210103161001783"></p>
<ul>
<li>融合了子网地址和子网掩码，方便子网划分</li>
</ul>
<p>CIDR表示法给出任何一个IP地址，就相当于给出了一个CIDR地址块，这是由连续的IP地址组成的，所以CIDR表示法构成了超网，实现了路由聚合，即从一个IP地址就可以得知一个CIDR地址块。</p>
<p>例如：已知一个IP地址是：128.14.35.7/20，那么这个已知条件告诉大家的并不仅仅是一个IP地址这么简单，我们来分析一下。</p>
<p>  <code>128.14.35.7/20 = 10000000  00001110  00100011  00000111</code></p>
<p>  即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即</p>
<p>  最小地址是：128.14.32.0    = <strong>10000000  00001110  0010</strong>0000  00000000 </p>
<p>  最大地址是：128.14.47.255  = <strong>10000000  00001110  0010</strong>1111 11111111   </p>
<p>  子网掩码是：255.255.240.0  = <strong>11111111  11111111  1111</strong>0000  00000000 </p>
<p>  因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103161649928.png" alt="image-20210103161649928"></p>
<h4 id="构成超网-路由聚合"><a href="#构成超网-路由聚合" class="headerlink" title="构成超网/路由聚合"></a>构成超网/路由聚合</h4><ul>
<li>基本概念：将多个子网聚合成一个较大的子网，就叫做<strong>构成超网</strong>或是<strong>路由聚合</strong> </li>
</ul>
<p>如下图中网络1和网络2的前16位都是一样的，因此可以聚合成一个网络</p>
<p>方法就是：<strong>网络前缀缩短</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103162648219.png" alt="image-20210103162648219"></p>
<h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p>使用缩短前缀这种方法，转发表会有多个匹配结果，因此使用<strong>最长前缀匹配</strong></p>
<p>前缀越长，地址块越小，那么所留下的范围就很小，路由就非常具体了</p>
<p>取/n的意思：就是目的网络中n位表示网络号，被截取的那部分剩下用0补充的意思</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103163727792.png" alt="image-20210103163727792"></p>
<p>例题：</p>
<p>这道题可以理解成前24为为一个网络号，后面8为取出一部分作为子网号，其他作为主机号</p>
<p>那么就看子网掩码号的<strong>248</strong>,二进制是11111 000，则前5位可作为子网号，后3位作为主机号；</p>
<p>那么最大子网个数就是前五位都充分利用起来：2^5 = 32</p>
<p>而每个子网内最大可分配地址个数就是根据主机号来的：2^3 - 2 = 6</p>
<p>为什么要减去2呢，因为不能用全0全1两种情况</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103165228306.png" alt="image-20210103165228306"></p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h4 id="发送数据的过程"><a href="#发送数据的过程" class="headerlink" title="发送数据的过程"></a>发送数据的过程</h4><p>应用层传一个文件 → 传输层拆分成报文段（传输单元）→ 网络层将传输层的报文段加源主机和目的主机IP地址还有一些其他信息  → 数据链路层封装 加上MAC地址（源和目的MAC地址）→ 物理层</p>
<p>在上述过程中有个问题，我怎么知道目的MAC地址呢？就是根据ARP高速缓冲得到的，它其中有IP地址与MAC地址的映射</p>
<p>下图中 1 → 3主机 （在一个网段内的请求）</p>
<p>假如没有映射呢 那就得根据<mark>ARP协议</mark>：首先广播一个<strong>ARP请求分组</strong>（包含源和目的IP地址以及源MAC地址以及全1的目的MAC地址 来达到广播的作用）</p>
<p>而后目标主机收到了请求，回应一个<strong>单播ARP响应分组</strong>（包括目的主机的IP地址和MAC地址）给源主机，这样数据链路层就有了目的主机的MAC地址了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103182614267.png" alt="image-20210103182614267"></p>
<p>假设 1 → 5 （不在一个网段内请求）</p>
<p>此时大体流程相似，但是广播ARP请求分组要的是IP6，也就是默认网关IP6的MAC地址</p>
<p>后续的路由器也是这样操作，源MAC和目的MAC地址一直在变换，直到要到了5号主机的MAC地址为止</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103183649947.png" alt="image-20210103183649947"></p>
<h4 id="ARP协议-1"><a href="#ARP协议-1" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul>
<li><p>ARP协议：完成了<strong>主机或路由器IP地址</strong>到<strong>MAC地址</strong>的映射 </p>
<p>解决了<mark>下一跳走哪</mark>的问题</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103184556700.png" alt="image-20210103184556700"></p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><ul>
<li>主机是如何获取IP地址的呢？</li>
</ul>
<p>通常有两种方式：静态配置 和 动态配置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103185646353.png" alt="image-20210103185646353"></p>
<p>而动态配置中就需要用到 <strong><mark>动态主机配置协议DHCP</mark></strong></p>
<p>这是一种<mark>应用层</mark>协议，使用<mark>客户/服务器</mark>方式，客户端和服务端通过<mark>广播</mark>方式进行交互，是基于<mark>UDP</mark>的</p>
<p> 它提供了一种<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取<mark>IP地址、子网掩码、默认网关、DNS服务器名称以及IP地址</mark>，</p>
<ul>
<li>它允许<strong>地址重用</strong>（什么意思呢？DHCP服务器有一个IP地址池，有很多IP地址，主机进来后，HDCP分配一个地址给它用，主机走后就回收，达到一个地址重用的效果）</li>
<li>支持<strong>移动用户加入网络</strong></li>
<li>支持<strong>在用地址续租</strong>（有时间性的分配一个地址，这段时间内叫租用期，时间过了后也可以续租继续用IP地址）</li>
</ul>
<p>工作流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103191040319.png" alt></p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP与IGMP是IP层协议 位于网络层与传输层之间，起桥梁作用，能够有效转发IP数据报和提高交互成功机会</p>
<ul>
<li>ICMP（Internet Control Message Protocol）Internet控制报文协议</li>
</ul>
<p>主要分为两种：ICMP差错报文和ICMP询问报文</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192150807.png" alt="image-20210103192150807"></p>
<h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h4><h5 id="ICMP差错报告报文数据字段"><a href="#ICMP差错报告报文数据字段" class="headerlink" title="ICMP差错报告报文数据字段"></a>ICMP差错报告报文数据字段</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192653668.png" alt="image-20210103192653668"></p>
<h5 id="5种ICMP差错报告报文"><a href="#5种ICMP差错报告报文" class="headerlink" title="5种ICMP差错报告报文"></a>5种ICMP差错报告报文</h5><p>主要分成五种：</p>
<ol>
<li><strong>终点不可达</strong></li>
<li><strong>源点抑制（已经废除了）</strong></li>
<li><strong>时间超过</strong></li>
<li><strong>参数问题</strong></li>
<li><strong>改变路由（重定向）</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192627572.png" alt="image-20210103192627572"></p>
<h5 id="不应该发送ICMP差错报文情况"><a href="#不应该发送ICMP差错报文情况" class="headerlink" title="不应该发送ICMP差错报文情况"></a>不应该发送ICMP差错报文情况</h5><ol>
<li>对<strong>ICMP差错报告报文</strong>不再发送ICMP差错报告报文</li>
<li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送IMCP差错报告报文</li>
<li>对具有<strong>组播地址</strong>的数据报都不发送ICMP差错报告报文</li>
<li>对具有<strong>特殊地址（比如127.0.0.0 or 0.0.0.0）</strong>的数据报不发送ICMP差错报告报文</li>
</ol>
<h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h4><h5 id="4种ICMP询问报文"><a href="#4种ICMP询问报文" class="headerlink" title="4种ICMP询问报文"></a>4种ICMP询问报文</h5><p>主要分为：</p>
<ol>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文（已废除）</li>
<li>路由器询问和通告报文（已废除）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103194019766.png" alt="image-20210103194019766"></p>
<h3 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103194445898.png" alt="image-20210103194445898"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为什么要有IPv6呢？因为我们的IPv4快用完了，虽然说有CIDR和NAT两门技术延缓了地址资源的不足，但是是治标不治本的，因此有了IPv6</p>
<p>同时还能趁机改进首部格式，让路由器能够快速处理/转发数据报</p>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul>
<li><strong>版本</strong>：指明了版本协议，总是为6</li>
<li><strong>优先级</strong>：区分数据报的类别的优先级</li>
<li><strong>流标签</strong>：有点类似与IPv4中的标识位的意思。首先需要明白<strong>流</strong>是什么，流是互联网络上从<strong>特定源点</strong>到<strong>特定终点</strong>的一一系列<strong>数据报</strong>。所有属于<strong>同一个流</strong>的数据报都具有相同的<strong>流标签</strong></li>
<li><strong>有效载荷长度</strong>：有效载荷长度的大小，也就是扩展首部+数据的大小</li>
<li><strong>下一个首部</strong>：标识下一个扩展首部或是上层协议首部</li>
<li><strong>跳数限制</strong>：IPv4的TTL，也就是生存时间，到0就会被丢弃</li>
<li><strong>源地址</strong>：不同于IPv4的源地址（32位），这里足足有128位，表示发送端的 IP 地址。</li>
<li><strong>目的地址</strong>：不同于IPv4的目的地址（32位），这里有128位，表示接收端 IP 地址。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104201536495.png" alt="image-20210104201536495"></p>
<p>可以看到，相较于 IPv4 ，IPv6 取消了下面几个字段</p>
<ul>
<li><strong>标识符、标志和比特偏移</strong>：IPv6 不允许在中间路由器上进行分片和重新组装。这种操作只能在端系统上进行，IPv6 将这个功能放在端系统中，加快了网络中的转发速度。</li>
<li><strong>首部校验和</strong>：因为在运输层和数据链路执行了报文段完整性校验工作，IP 设计者大概觉得在网络层中有首部校验和比较多余，所以去掉了。<strong>IP 更多专注的是快速处理分组数据</strong>。</li>
<li><strong>选项字段</strong>：选项字段不再是标准 IP 首部的一部分了，但是它并没有消失，而是可能出现在 IPv6 的扩展首部，也就是下一个首部中。</li>
</ul>
<h4 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104201921303.png" alt="image-20210104201921303"></p>
<h4 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h4><p> 一般使用<mark>冒泡十六进制记法</mark>：4个为一组，一共有8组，每组之间用冒号隔开</p>
<p>还能用压缩形式，将0000的压缩成0，00xx压缩成xx，000x压缩成x</p>
<p>还有零压缩形式：将一连串连续的0用一堆冒号取代</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104202519386.png" alt="image-20210104202519386"></p>
<h4 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>单播</td>
<td>一对一通信</td>
<td>可做源地址，目的地址</td>
</tr>
<tr>
<td>多播</td>
<td>一对多通信，以前的广播地址当做覆盖所有主机的多播</td>
<td>可做目的地址</td>
</tr>
<tr>
<td>任播</td>
<td>一对多当中的一个通信，看似一对多，实则一对一</td>
<td>可做目的地址</td>
</tr>
</tbody></table>
<h4 id="IPv6向IPv4过渡的策略"><a href="#IPv6向IPv4过渡的策略" class="headerlink" title="IPv6向IPv4过渡的策略"></a>IPv6向IPv4过渡的策略</h4><p>现在大部分还在使用IPv4，但我一个应用IPv6的协议的数据报怎么向只采取了IPv4协议的设备交流呢？</p>
<p>使用：<strong>双栈协议、隧道技术</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104203621228.png" alt="image-20210104203621228"></p>
<h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>现在已经在实践中使用的从 IPv4 迁移到 IPv6 的方法是 <code>隧道技术(tunneling)</code>。</p>
<blockquote>
<p>什么是隧道技术呢？</p>
</blockquote>
<p>隧道技术是一种使用互联网络的基础设施在网络之间的传输数据的方式，使用隧道传递的数据可以是不同协议的数据帧或包。使用隧道技术所遵从的协议叫做<code>隧道协议(tunneling protocol)</code>。隧道协议会将这些协议的数据帧或包封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络进行传递。</p>
<p>使用隧道技术一般都会建一个<code>隧道</code>，建隧道的依据如下：</p>
<p>比如两个 IPv6 节点(下方 B、E)要使用 IPv6 数据报进行交互，但是它们是经由两个 IPv4 的路由器进行互联的。那么我们就需要将 IPv6 节点和 IPv4 路由器组成一个隧道，如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTPDUWdATSUHbTwDfcxTqJWibibib4U1rWHyAubCs7QGVxU5UWSweACBE3sftNtTLicwicGH2NWLmBfFYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>借助于隧道，在隧道发送端的 IPv6 节点可将整个 IPv6 数据报放到一个 IPv4 数据报的<code>数据(有效载荷)</code> 字段中，于是，IPv4 数据报的地址被设置为指向隧道接收端的 IPv6 的节点，比如上面的 E 节点。然后再发送给隧道中的第一个节点 C，如下所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTPDUWdATSUHbTwDfcxTqJWbY3ziaFnz7e9gE0j9MNUsBRCjQLadlz5KUr1lu4BKLoZeLXFaKmgqrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>隧道中间的 IPv4 提供路由，路由器不知道这个 IPv4 内部包含一个指向 IPv6 的地址。隧道接收端的 IPv6 节点收到 IPv4 数据报，会确定这个 IPv4 数据报含有一个 IPv6 数据报，通过观察数据报长度和数据得知。然后取出 IPv6 数据报，再为 IPv6 提供路由，就好像两个节点直接相连传输数据报一样。</p>
<h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul>
<li><p>移动IP技术是<strong>移动结点</strong>（计算机\服务器等）以<mark>固定的网络IP地址</mark>，实现跨越不同网段的<strong>漫游</strong>功能，并保证了基于<strong>网络IP</strong>的网络权限在漫游过程中<strong>不发生任何改变</strong></p>
<p>which means：当你的手机在漫游时，虽然人在B地，IP却是A地购买手机卡的运营商提供的IP。于是当你在B地手机（用蜂窝网）、电脑同时登陆QQ时经常会提示异地登陆</p>
</li>
<li><p><strong>移动结点</strong>：具有永久IP地址的移动设备</p>
</li>
<li><p><strong>归属代理（本地代理）</strong>：一个<strong>移动结点</strong>拥有的<mark>就居所</mark>称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做<strong>g归属代理</strong></p>
</li>
<li><p><strong>外部代理（外地代理）</strong>：在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为<strong>外部代理</strong></p>
</li>
<li><p><strong>永久地址（归属地址/主地址）</strong>：移动结点在归属网络中的<strong>原始地址</strong></p>
</li>
<li><p><strong>转交地址（辅地址）</strong>：移动结点在外部网络使用的<strong>临时地址</strong></p>
</li>
</ul>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>相关博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gzxultra/article/details/45649083">https://blog.csdn.net/gzxultra/article/details/45649083</a></p>
<p>其实可以理解成A有事出去了，但碰巧B找A，这个时候由于本地代理知道A在哪，就能把消息转交给他</p>
<p>过程：</p>
<ol>
<li><p>移动节点在本地时，按传统的TCP/IP方式进行通信（在本地网固有地址）</p>
</li>
<li><p><strong>移动节点</strong>漫游到一个<strong>外地网络</strong>时，仍然使用固定的IP地址进行通信。为了能收到通信对端发给他的IP分组，<strong>移动节点</strong>需要向<strong>本地代理</strong>注册当前的位置地址，这个未知地址就是<strong>转交地址</strong>（它可以是外部代理地址或动态分配的地址）</p>
<p><mark>ps：可以理解成儿子要出远门了，告诉妈妈，有人找我就联系xxx这个地方就好，至于到底xxx是什么，我到了那个地方再告诉你。</mark></p>
</li>
<li><p><strong>本地代理</strong>接收到来自<strong>转交地址</strong>的注册后，会构建一条通往<strong>转交地址</strong>的<strong>隧道</strong>，将截获的发给<strong>移动节点</strong>的IP分组送到<strong>转交地址</strong>处。</p>
</li>
<li><p>在<strong>转交地址</strong>处解除隧道封装，恢复原始的IP分组，最后送到<strong>移动节点</strong>处，这样<strong>移动节点</strong>在外网就能收到这些发送给他的IP分组了。</p>
</li>
<li><p><strong>移动节点</strong>在外网通过外网的路由器或者外代理向本地发送IP数据包。</p>
</li>
<li><p>当<strong>移动节点</strong>来自一个外网时，只需要向<strong>本地代理</strong>更新注册的<strong>转交地址</strong>，就可以继续通信。</p>
<p><mark>这里就是第二步的，告知妈妈：哦，我这边的地址是xxx</mark></p>
</li>
<li><p>当<strong>移动节点</strong>回到本地网络，移动节点向<strong>本地代理</strong>注销<strong>转交地址</strong>，这时<strong>移动节点</strong>又将使用传统的TCP/IP方式进行通信</p>
</li>
</ol>
<p>为什么漫游收费贵呢？因为移动IP需要给你的设备分配两个IP地址（主地址和辅地址（转交地址）），并且需要完成这个转交工作。而各地区的运营商是独立运营的。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104193725381.png" alt="image-20210104193725381"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104195038315.png" alt="image-20210104195038315"></p>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>技术参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HpxpLgpltOzNrtnFBaP8SA">https://mp.weixin.qq.com/s/HpxpLgpltOzNrtnFBaP8SA</a></p>
<ul>
<li>路由器是一种具有<strong>多个输入端口</strong>和<strong>多个输出端口</strong>的<strong>专用计算机</strong>，任务是：<mark>转发分组</mark></li>
<li>每个路由器维护一个<mark>路由表</mark>,来决定分组的转发，为了提高路由表的查询效率并且减少路由表维护的内容，路由表只保留<strong>到达目的地址的下一个路由器的IP地址，而不保留整个传输路径的信息</strong></li>
<li>转发与路由选择的区别<ul>
<li>转发是在路由器内部，把一个<strong>分组</strong>由一个<strong>输入端口</strong>转发到另一个<strong>输出端口</strong></li>
<li>路由选择是比较宏观的了，是在路由器组之间，选择一个合适的路径，把一个信息从源主机发送到目的主机</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104204552835.png" alt="image-20210104204552835"></p>
<ul>
<li>输入端口：<code>输入端口(input port)</code>有很多功能。<code>线路终端功能</code>和<code>数据链路处理</code>功能，这两个功能实现了路由器的单个输入链路相关联的物理层和数据链路层。<code>输入端口查找/转发功能</code>对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是查询转发表来确定的。</li>
<li>交换结构：<code>交换结构(Switching fabric)</code>就是将路由器的输入端口连接到它的输出端口。这种交换结构相当于是路由器内部的网络。</li>
<li>输出端口：<code>输出端口(Output ports)</code> 通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。</li>
<li>路由选择处理器：<code>路由选择处理器(Routing processor)</code> 在路由器内执行路由协议，维护路由表并执行网络管理功能。</li>
</ul>
<p>上面只是这几个组件的简单介绍，其实这几个组件</p>
<h4 id="输入端口对线路上收到的分组的处理"><a href="#输入端口对线路上收到的分组的处理" class="headerlink" title="输入端口对线路上收到的分组的处理"></a>输入端口对线路上收到的分组的处理</h4><p>从线路那接收到了<strong>分组</strong>，分别交由<strong>物理层、数据链路层和网络层</strong>进行处理</p>
<p>其中网络层这块进行分组排队，并进行<mark>查表和转发</mark>，最后发送至交换结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104205946118.png" alt="image-20210104205946118"></p>
<p>每个输入端口中都有一个路由处理器维护的<strong>路由表的副本</strong>，根据路由处理器进行更新。这个路由表的副本能 够使每个输入端口进行切换，而无需经过路由处理器统一处理。这是一种<code>分散式</code>的切换，这种方式避免了路 由选择器统一处理造成转发瓶颈。</p>
<p>在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据 路由表查找并将数据包转发到相应的输出端口。</p>
<h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p>交换结构是路由器的核心功能，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，主要分为 <strong>通过内存交换、通过总线交换、通过互联网络进行交换</strong>，下面我们分开来探讨一下。</p>
<ul>
<li>经过内存交换：最开始的传统计算机就是使用<code>内存交换</code>的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以<code>中断</code> 的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后，路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。</li>
</ul>
<blockquote>
<p>这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<ul>
<li>经过总线交换：在这种处理方式中，总线经由输入端口直接将分组传送到输出端口，中间不需要路由选择器的干预。总线的工作流程如下：输入端口给分组分配一个<code>标签</code>，然后分组经由总线发送给所有的输出端口，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有 <code>多个</code> 分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<ul>
<li>经过互联网络交换：克服单一、共享式总线带宽限制的一种方法是使用一个更复杂的互联网络。如下图所示</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<p>每条垂直的的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启和闭合。当分组到达输入端口 A 时，如果需要转发到端口 X，交换机控制器会闭合 A 到 X 交叉部分的交叉点，然后端口 A 在总线上进行分组转发。这种网络互联式的交换结构是 <code>非阻塞的(non-blocking)</code>的，也就是说 A -&gt; X 的交叉点闭合不会影响 B -&gt; Y 的链路。如果来自两个不同输入端口的两个分组其目的地为相同的输出端口的话，这种情况下只能有一个分组被交换，另外一个分组必须进行等待。</p>
<h4 id="输出端口将交换结构传送来的分组发送到线路"><a href="#输出端口将交换结构传送来的分组发送到线路" class="headerlink" title="输出端口将交换结构传送来的分组发送到线路"></a>输出端口将交换结构传送来的分组发送到线路</h4><p>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。</p>
<p>缓存管理其实就是维护一个<strong>队列</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104210940469.png" alt="image-20210104210940469"></p>
<p>在输入端口中有等待进入交换的排队队列，而在输出端口中有等待转发的排队队列，排队的位置和程度取决于<strong>流量负载、交换结构</strong>的相对频率和线路速率。</p>
<p>随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现<code>丢包(packet loss)</code>，这就是我们说的在网络中丢包或者被路由器丢弃。</p>
<h4 id="路由表和路由转发"><a href="#路由表和路由转发" class="headerlink" title="路由表和路由转发"></a>路由表和路由转发</h4><p><strong>路由表</strong>是根据<strong>路由选择算法</strong>得出的，主要用途是<strong>路由选择</strong>，总用软件进行实现</p>
<ul>
<li><strong>路由表</strong>总会和<strong>转发表</strong>弄混</li>
</ul>
<p><mark>转发表</mark>是由<mark>路由表</mark>得来的，可用软件实现，也可以用特殊的硬件来实现。<strong>转发表</strong>必须包含<mark>完成转发功能所必须的信息</mark>，在<strong>转发表</strong>的每一行都必须包含：<mark>从要到达的目的网络到输出端口和某些MAC地址信息的映射</mark></p>
<p>路由表主要是选择我<strong>下一跳</strong>要走哪个路由器，或是下一个IP地址应该走什么</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104212236599.png" alt="image-20210104212236599"></p>
<h3 id="路由器-网桥-集线器"><a href="#路由器-网桥-集线器" class="headerlink" title="路由器 网桥 集线器"></a>路由器 网桥 集线器</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104211228632.png" alt></p>
<h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p>网络层是把数据从<strong>一个主机</strong>传送到<strong>另一个主机</strong>，但是并没有与<mark>进程</mark>建立联系</p>
<p>而传输层就是将<strong>进程</strong>与所收到的<strong>数据</strong>联系到一起，让数据能够用到应用上</p>
<ul>
<li><p>因此说 网络层提供：主机之间的逻辑通信，while 传输层提供：进程和进程之间的逻辑通信</p>
</li>
<li><p>传输层还能够进行：<strong>复用和分用</strong></p>
<ul>
<li><p><mark>复用</mark>：<strong>应用层</strong>所有的的应用进程都可以通过<strong>传输层</strong>再传输到<strong>网络层</strong></p>
<p>就是把多个进程的数据使用同一个传输层协议进行传输</p>
</li>
<li><p><mark>分用</mark>：<strong>传输层</strong>从<strong>网络层</strong>收到数据后交付给指明的<strong>应用进程</strong></p>
<p>就是把接收过来的报文传送给对应的进程</p>
</li>
</ul>
</li>
<li><p>传输层对收到的报文进行<strong>差错检测</strong></p>
</li>
<li><p>传输层还有两种重要的协议：<strong>TCP &amp; UDP</strong></p>
</li>
</ul>
<h3 id="寻址与端口"><a href="#寻址与端口" class="headerlink" title="寻址与端口"></a>寻址与端口</h3><p>之前说到了复用分用，那么这两个与进程是有着一定关系的，说到进程，就要想到主机中应用进程肯定有标识符</p>
<p>这就是<strong>端口</strong>，用于标识主机中的应用进程</p>
<p>端口号按照范围分有两种：一种是<mark>服务端</mark>使用的端口号，另一种是<mark>客户端</mark>使用的端口号</p>
<ul>
<li>服务端使用的端口号<ul>
<li>熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户都知道（0~1023）</li>
<li>登记端口号：为没有熟知端口号的应用程序使用（1024~49151）</li>
</ul>
</li>
</ul>
<p>一些重要的熟知端口号：</p>
<table>
<thead>
<tr>
<th>应用进程</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
</tr>
</tbody></table>
<ul>
<li>客户端使用的端口号：仅仅在客户进程运行才动态选择的端口号，客户进程结束后就收回（49152~65535）</li>
</ul>
<p>同时我们还需要知道：在网络中采用<strong>发送方</strong>和<strong>接收方</strong>的<mark>套接字组合</mark>来识别端点，<strong>套接字</strong><mark>唯一标识了</mark>网络中一个主机和它上面的一个进程</p>
<p><code>套接字Socket = (主机IP地址, 端口号)</code></p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105173004219.png" alt="image-20210105173004219"></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>用户数据报协议UDP：<strong>不可靠，无连接，时延小，适用于小文件</strong></li>
</ul>
<h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>UDP只在IP数据报服务上增加了很少的功能：<strong>复用、分用、差错检测</strong></p>
<p>UDP的特点是：</p>
<ol>
<li><p><strong>UDP是无连接的</strong></p>
</li>
<li><p>UDP使用<strong>尽最大努力交付</strong>，就是<mark>不保证可靠交付</mark>，因此主机是不需要维持复杂的连接状态表的</p>
</li>
<li><p><strong>UDP是面向报文的</strong>，什么意思呢？</p>
<ol>
<li><p><strong>发送方</strong>UDP对于应用程序发下来的<strong>报文</strong>，仅添加<strong>首部</strong>后就向下交付给了<strong>IP层</strong></p>
</li>
<li><p>UDP对于应用层交下来的报文，既<strong>不合并，也不拆分</strong>，而是保留这些<strong>报文</strong>的<mark>边界</mark></p>
<p>which means，应用层交给UDP多长报文，UDP就照样发送，也就是一次发一个完整报文</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105175958381.png" alt="image-20210105175958381"></p>
<p>因此，应用程序必须选择合适的报文：如果太长了，UDP发送给IP层后，IP层还得进行分片，影响效率；如果太短了，UDP发送给IP层后，IP数据报的<strong>首部</strong>相对长度也会太长，也降低了IP层效率</p>
</li>
<li><p><strong>UDP没有拥塞控制</strong>，网络出现的拥塞并不会使得<strong>源主机</strong>的发送速率降低（适用于实时应用：视频会议、IP电话）</p>
</li>
<li><p>UDP支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信</p>
</li>
<li><p><strong>UDP的首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要<strong>短</strong></p>
</li>
</ol>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><p>用户UDP有2个字段：<strong>数据字段和首部字段</strong></p>
<p>首部字段由8个字节，4个字段组成（每个字段长度为2字节）</p>
<ul>
<li><strong>源端口</strong>：源端口号，在需要对方回信的时候选用，不需要的时候可设置成全0</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时使用</li>
<li><strong>长度</strong>：UDP用户数据报的长度，最小值为8</li>
<li><strong>检验和</strong>：检验UDP和用户数据报在传输的时候是否有错，有错就丢弃</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105180902193.png" alt="image-20210105180902193"></p>
<p>运输层从IP层收到UDP数据报，根据<strong>首部</strong>中目的端口，把UDP数据报通过相应端口，上交到最后终点：应用进程</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105181614867.png" alt="image-20210105181614867"></p>
<p>如果接收方UDP发现收到的报文中的<strong>目的端口号</strong>错的（没有这个端口号对应着的应用程序），就丢弃，并有ICMP发送<mark>端口不可达</mark>差错报文给发送方</p>
<p>ps：UDP通信为无连接通信，不需要使用套接字（while TCP通信就必须在两个套接字间建立连接）</p>
<h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><p>UDP校验需要用到<mark>伪首部</mark></p>
<p>叫做伪首部，就证明并不是UDP用户数据报的真正首部了，伪首部既不向下传送也不向上递交，仅仅为了计算<strong>检验和</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105182636041.png" alt="image-20210105182636041"></p>
<p>计算方法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105182927004.png" alt="image-20210105182927004"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>传输通知协议TCP：可靠，面向连接，时延大，适用于大文件</li>
</ul>
<h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><ol>
<li><p>TCP是<strong>面向连接</strong>的传输层协议：应用程序在使用TCP协议前，必须先建立TCP连接；传送数据完毕后，必须释放已经建立的TCP连接</p>
<p>像是在打电话：通话前拨号建立连接，通话结束后挂机释放连接</p>
</li>
<li><p>每一条TCP连接只能有<strong>两个端点</strong>：每一条TCP连接只能是<strong>点对点的</strong></p>
</li>
<li><p>TCP提供<strong>可靠交付</strong>的服务：通过TCP连接传送的数据 —— 无差错，不丢失，不重复且按序到达</p>
</li>
<li><p>TCP提供<strong>全双工通信：</strong>TCP允许通信双方的应用程序在任何时候都能发送数据，因此TCP连接的两端设立了<mark>发送缓存</mark>和<mark>接受缓存</mark>。</p>
<ol>
<li>发送缓存：存储准备发送的数据和已经发送但尚未收到确认的数据</li>
<li>接收缓存：存储按序到达但尚未被接受应用程序读取的数据和不按序到达的数据</li>
</ol>
</li>
<li><p>TCP面向<strong>字节流：</strong>首先要明白<mark>流</mark>是什么：是指流入到进程或从进程流出的<strong>字节序列</strong>。面向字节流的意思是：TCP把应用程序交下来的数据仅看成是<strong>一连串的无结构的字节流</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105194822707.png" alt="image-20210105194822707"></p>
</li>
</ol>
<h4 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h4><p>技术参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32998153/article/details/79680704">https://blog.csdn.net/qq_32998153/article/details/79680704</a></p>
<ul>
<li>TCP报文段分别两部分：首部 + 数据</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105200622983.png" alt="image-20210105200622983"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105201245781.png" alt="image-20210105201245781"></p>
<p><strong><em>\</em>首部固定部分各字段意义如下：**</strong></p>
<p>1） <strong><em>\</em><mark>源端口和目的端口</mark>**</strong>    各占2个字节，分别写入源端口和目的端口。</p>
<p>2） <strong><em>\</em><mark>序号seq</mark>**</strong>   占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。 序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。</p>
<p>例如，一报文段的<strong>序号是301</strong>，而接待的数据共有<strong>100字节</strong>。这就表明：本报文段的数据的<strong>第一个字节的序号是301</strong>，<strong>最后一个字节</strong>的序号是<strong>400</strong>。显然，<strong>下一个报文段</strong>（如果还有的话）的<strong>数据序号应当从401</strong>开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。</p>
<p>3） <strong><em>\</em><mark>确认号</mark>**</strong>   占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。</p>
<p>​    总之：<strong><em>\</em>若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到**</strong>。</p>
<p>4） <strong><em>\</em><mark>数据偏移</mark>**</strong>     占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。</p>
<p>5） <strong><em>\</em><mark>保留</mark>**</strong>     占6位，保留为今后使用，但目前应置为0 。</p>
<ul>
<li><h3 id="下面有6个控制位，用来说明本报文段的性质。"><a href="#下面有6个控制位，用来说明本报文段的性质。" class="headerlink" title="下面有6个控制位，用来说明本报文段的性质。"></a><strong>下面有6个控制位，用来说明本报文段的性质。</strong></h3></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105201846182.png" alt="image-20210105201846182"></p>
<p>6） <strong><em>\</em><mark>紧急URG</mark>**</strong>（URGent）    当<strong>URG=1</strong>时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于<strong>高优先级</strong>的数据），<strong>而不要按原来的排队顺序来传送</strong>（就可以<mark>插队</mark>了）。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</p>
<p>​    当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p>
<p>7） <strong><em>\</em><mark>确认值ACK</mark>**</strong>（ACKnowledgment）   仅当<strong>ACK = 1时确认号字段</strong>才<strong>有效</strong>，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
<p>ps：<strong>大写ACK是确认值</strong>，确认位的意思；<strong>小写ack是确认编号</strong>，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。</p>
<p>8） <strong><em>\</em><mark>推送 PSH</mark>**</strong>（PuSH）  当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到<strong>PSH=1</strong>的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p>
<p>9） <strong><em>\</em><mark>复位RST</mark>**</strong>（ReSeT）    当<strong>RST=1</strong>时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
<p>10） <strong><em>\</em><mark>同步SYN</mark>**</strong>（SYNchronization）    在连接建立时用来同步序号。当<strong>SYN=1而ACK=0</strong>时，表明这是一个<strong>连接请求报文段</strong>。对方若<strong>同意建立连接</strong>，则应在响应的报文段中使<strong>SYN=1和ACK=1</strong>，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
<p>11） <strong><em>\</em><mark>终止FIN</mark>**</strong>（FINis，意思是“完”“终”）     用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105202241456.png" alt="image-20210105202241456"></p>
<p>12） <strong><em>\</em><mark>窗口</mark>**</strong>       占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>   例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。”</p>
<p>   总之：<strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化</strong>。</p>
<p>13） <strong><em>\</em><mark>检验和</mark>**</strong>    占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<p>14） <strong><em>\</em><mark>紧急指针</mark>**</strong>      占2字节。<strong>紧急指针仅在URG=1</strong>时才有意义，它指出本报文段中的<strong>紧急数据的字节数</strong>（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，<strong>即使窗口为0时也可以发送紧急数据</strong>。</p>
<p>15） <strong><em>\</em><mark>选项</mark>**</strong>    长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<p>​    TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>TCP连接传输分为三个阶段：</p>
<ol>
<li>连接建立</li>
<li>数据传送</li>
<li>连接释放</li>
</ol>
<p>TCP连接的建立采用<mark>客户服务器方式</mark>。</p>
<p>客户：主动发起连接建立的应用进程</p>
<p>服务器：被动等待连接建立的应用程序</p>
<h5 id="TCP连接过程-三次握手"><a href="#TCP连接过程-三次握手" class="headerlink" title="TCP连接过程 三次握手"></a>TCP连接过程 三次握手</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105204948685.png" alt="image-20210105204948685"></p>
<p>假设主机A运行TCP客户程序，B运行TCP服务器程序，连接过程是这样的：</p>
<ol>
<li><p>A的TCP客户进程首先创建<strong>传输控制模块TCB</strong>，此时，打算建立TCP连接的时候，向B发出<strong>连接请求报文段</strong></p>
<p>这个时候<mark>首部</mark>的<strong>同步位SYN = 1</strong>,同时选择一个<strong>初始序号seq = x</strong>。SYN报文段（即SYN = 1的报文段）不能携带数据，但会<strong>消耗一个序号</strong>。</p>
<p>这个时候，TCP客户进程进入了<mark>SYN-SENT（同步已发送）</mark>状态</p>
</li>
<li><p>B收到连接请求报文段后，如果同意建立连接，就向A发送确认。</p>
<p>在确认报文段中<strong>同步位SYN和确认值ACK = 1</strong>，然后<strong>确认编号ack = x +1</strong>，同时<strong>选择一个初始序号seq = y</strong>。此报文段也不能携带数据，但需要消耗一个序号。</p>
<p>TCP服务器进程进入<mark>SYN-RCYD（同步收到）</mark>状态</p>
</li>
<li><p>TCP客户进程收到B的确认之后，需要向B给出确认。</p>
<p><strong>确认报文段的ACK = 1，确认编号ack = y + 1,自己的序号seq = x + 1</strong></p>
<p>这个时候，TCP连接已经建立了，A进入了<mark>ESTABLISHED（已建立连接）状态</mark></p>
</li>
</ol>
<h5 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105211308051.png" alt="image-20210105211308051"></p>
<h5 id="TCP连接释放-四次挥手"><a href="#TCP连接释放-四次挥手" class="headerlink" title="TCP连接释放 四次挥手"></a>TCP连接释放 四次挥手</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105212114756.png" alt="image-20210105212114756"></p>
<p>第一段的意思是<br>FIN=1：(A)要释放连接了！<br>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的</p>
<p>第二段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）</p>
<p>第三段的意思是<br>FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）</p>
<p>第四段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据</p>
<p>为什么需要等待计时2MSL？<br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p>
<h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><ul>
<li><p>关于TCP可靠传输的很多协议放在了数据链路层的流量控制章节了</p>
</li>
<li><p>可靠：保证接收方进程从缓存区读出来的字节流与发送方发出来的字节流是完全一样的</p>
</li>
</ul>
<p>TCP实现可靠传输的机制有：校验 序号 确认 重传</p>
<h5 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h5><p>与UDP校验一样，增加一个伪首部，通过使用二进制反码计算方法判断有没有出错</p>
<h5 id="序号机制"><a href="#序号机制" class="headerlink" title="序号机制"></a>序号机制</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105220623846.png" alt="image-20210105220623846"></p>
<p>上面说了，传输层面向字节流的，因此会把文件分成字节用一个个序号标起来</p>
<p>但发出去的时候，肯定不是一个个字节发，是把多个字节放在一个形成一个报文段，再发出去</p>
<p>报文段的大小划分取决于MTU</p>
<p>其中，一个字节占一个序号。<strong>序号字段</strong>指的是一个报文段的<strong>第一个字节的序号</strong></p>
<p>有了序号就能保证数据有序提交给应用层</p>
<h5 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h5><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105221110228.png" alt="image-20210105221110228"></p>
<h5 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h5><p>重传机制是基于确认机制的，TCP的发送方在规定的时间内没有收到确认就要重传已经发送的报文段，也就是我们常说的：超时重传</p>
<p>那么对于这个重传机制来说，确定那个<mark>规定的时间</mark>就显得尤为重要了，不能太短也不能过长；</p>
<p>TCP采用<strong>自适应算法</strong>，动态改变<strong>重传时间RTTs（加权平均往返时间）</strong></p>
<p>一般来说还有<strong>冗余ACK方法</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105222008366.png" alt="image-20210105222008366"></p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>TCP流量控制的根本目的：是控制发送方的发送速率</p>
<p>实现方法：使用基于<strong>滑动窗口协议</strong>的<mark>流量控制机制</mark></p>
<p>与数据链路层流量控制区别：</p>
<ol>
<li>传输层定义端到端用户之间流量控制，窗口大小不可动态变化</li>
<li>数据链路层定义两个中间的相邻结点的流量控制，窗口大小可动态变化</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106151936352.png" alt="image-20210106151936352"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106153111239.png" alt="image-20210106153111239"></p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>要控制拥塞，首先要明白为什么会有拥塞：</p>
<ul>
<li>出现拥塞的条件是：对资源需求的总和&gt;可用的资源</li>
</ul>
<p>具体来说就是：网络中有许多的资源同时供应不足 → 网络性能变坏 → 网络吞吐量随着输入负荷增大而下降</p>
<ul>
<li>流量控制与拥塞控制<ul>
<li><mark>相同点</mark>：都是通过控制发送方发送数据的速率来达到控制效果的</li>
<li><mark>不同点</mark><ul>
<li>拥塞控制是让网络能够承受现有的网络负荷，是一个<strong>全局性</strong>的过程，为什么说是全局性？因为涉及到了所有的主机、所有路由器、以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制则是指<strong>点对点的通信量的控制</strong>，即接收端控制发送端，所要做的是<strong>抑制发送端发送数据的速率，以便接收端来得及接受</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h5><p>背景知识储备：发送窗口={接受窗口rwnd，拥塞窗口cwnd}</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106161742663.png" alt="image-20210106161742663"></p>
<h6 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h6><ul>
<li><mark>慢开始</mark>指的是一开始的窗口很小，然后逐步在每轮传输轮次后以指数形式增大，直至达到了<strong>慢开始门限ssthresh（阈值）</strong>，然后改用<mark>拥塞避免算法</mark></li>
<li><mark>拥塞避免算法</mark>，达到阈值之后，不再用指数增加形式了，改为线性增加，然后出现一次超时（网络拥塞），就令慢开始门限等于此时的拥塞窗口的一半（乘法减小）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106164029525.png" alt="image-20210106164029525"></p>
<h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><ul>
<li><p>快重传使用了<strong>冗余ACK</strong>来检测丢包的发生</p>
<p>当发送方连续收到<strong>三个重复的ACK报文</strong>的时候，直接<strong>重传</strong>对方<strong>尚未收到</strong>的报文段，就不去等待报文段设置的<strong>重传计时器</strong>超时了</p>
</li>
<li><p>快恢复：当发送端收到<strong>三个冗余ACK（重复确认）</strong>的时候，执行<strong>乘法减小</strong>算法，慢开始门限设置为cwnd（拥塞窗口）的一半，（不同于慢开始算法的将cwnd设置为1），此时的cwnd值为慢开始门限改变后的值，后执行<strong>加法增大</strong>，使得cwnd线性增大</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106164535792.png" alt="image-20210106164535792"></p>
<h1 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><ul>
<li>应用层是对应用程序的通信提供服务</li>
</ul>
<p>在这一层的协议中应该定义以下几点：</p>
<ol>
<li>应用进程交换的<strong>报文类型</strong>，是<strong>请求</strong>还是<strong>响应</strong>？</li>
<li>各种报文类型的<strong>语法</strong>，如报文中的各个字段及其详细描述</li>
<li>字段的<strong>语义</strong>，即 包含在字段中的信息的含义</li>
<li>进程何时、如何发送报文，以及对报文进行<strong>响应的规则</strong></li>
</ol>
<p>应用层的功能有以下几点：</p>
<ul>
<li>文件传输、访问和管理</li>
<li>电子邮件</li>
<li>虚拟终端</li>
<li>查询服务和远程作业登录</li>
</ul>
<p>在这一层中重要的几个协议：</p>
<ul>
<li>FTP</li>
<li>SMTP,POP3</li>
<li>HTTP</li>
<li>DNS</li>
</ul>
<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器-C-S-模型"><a href="#客户-服务器-C-S-模型" class="headerlink" title="客户/服务器 (C/S) 模型"></a>客户/服务器 (C/S) 模型</h3><p>在这个模型中，有一个总是打开的主机<strong>服务器</strong>，它服务于许多来自其他称为<strong>客户机</strong>的主机请求，工作流程：</p>
<ol>
<li>服务器处于<strong>接受请求</strong>的状态</li>
<li><strong>客户机</strong>发出服务请求，并且等待接受结果</li>
<li><strong>服务器</strong>收到请求后，分析请求，进行必要处理，得到结果后发送给<strong>客户机</strong></li>
</ol>
<p>客户程序必须知道服务器程序的地址，然而 服务器程序并不需要知道客户程序的地址</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106183551455.png" alt="image-20210106183551455"></p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul>
<li>P2P模型中，各计算机没有固定的客户和服务器划分。任意<mark>一对计算机</mark>我们称为<mark>对等方Peer</mark></li>
<li>每个节点既能作为客户又能作为服务器</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106183913961.png" alt="image-20210106183913961"></p>
<h2 id="DNS（域名系统）"><a href="#DNS（域名系统）" class="headerlink" title="DNS（域名系统）"></a>DNS（域名系统）</h2><ul>
<li>DNS系统就是用来把特定含义的主机名（<a target="_blank" rel="noopener" href="http://www.xxx.com）转成IP地址的一个系统">www.xxx.com）转成IP地址的一个系统</a></li>
<li>DNS可分为3部分：层次域名空间、域名服务器和解析器</li>
</ul>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106192148967.png" alt="image-20210106192148967"></p>
<p>顶级域名分三大类:</p>
<ol>
<li>国家顶级域名</li>
<li>通用顶级域名</li>
<li>基础结构域名</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106194218758.png" alt="image-20210106194218758"></p>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Erii</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://uesugier11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://uesugier11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://uesugier11.github.io" target="_blank">Erii B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/UesugiEr11/pictures/raw/master/img/u=3865179010,761192413&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/UesugiEr11.github.io/2021/03/03/Spring/"><img class="prev-cover" src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210303200945164.png" onerror="onerror=null;src='/UesugiEr11.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring</div></div></a></div><div class="next-post pull-right"><a href="/UesugiEr11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102195321649.png" onerror="onerror=null;src='/UesugiEr11.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/UesugiEr11.github.io/img/avater.jpg" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Erii</div><div class="author-info__description">普普通通程序员</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/UesugiEr11.github.io/categories/"><div class="headline">分类</div><div class="length-num">72</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">计算机网络概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">计算机网络概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">计算机网络的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">计算机网络的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">工作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">功能组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">计算机网络的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9F%E7%8E%87"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">速率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">带宽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-number">1.1.4.1.4.</span> <span class="toc-text">时延</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6%E5%AE%BD%E5%B8%A6%E7%A7%AF"><span class="toc-number">1.1.4.1.5.</span> <span class="toc-text">时延宽带积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%80%E8%BF%94%E6%97%B6%E5%BB%B6RTT"><span class="toc-number">1.1.4.1.6.</span> <span class="toc-text">往返时延RTT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.1.4.1.7.</span> <span class="toc-text">利用率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">计算机体系结构与参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机网络的分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">分层基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">计算机网络协议、接口、服务的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISO-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">ISO&#x2F;OSI参考模型和TCP&#x2F;IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">OSI参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ISO-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">ISO&#x2F;OSI参考模型通信过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%8F%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">每层的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.3.1.2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">1.2.3.1.2.2.</span> <span class="toc-text">表示层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-number">1.2.3.1.2.3.</span> <span class="toc-text">会话层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.3.1.2.4.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.2.3.1.2.5.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.2.3.1.2.6.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">1.2.3.1.2.7.</span> <span class="toc-text">物理层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">TCP&#x2F;IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E3%80%81%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">面向连接、无连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">五层参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-1"><span class="toc-number">1.2.3.2.2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.3.2.2.2.</span> <span class="toc-text">运输层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-1"><span class="toc-number">1.2.3.2.2.3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-1"><span class="toc-number">1.2.3.2.2.4.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82-1"><span class="toc-number">1.2.3.2.2.5.</span> <span class="toc-text">物理层</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82-2"><span class="toc-number">2.</span> <span class="toc-text">物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">物理层基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">数据通信基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">典型数据通信模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据通信相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">三种通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.4.</span> <span class="toc-text">两种数据传输方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%81%E5%85%83%E3%80%81%E6%B3%A2%E7%89%B9%E3%80%81%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD"><span class="toc-number">2.3.</span> <span class="toc-text">码元、波特、速率、带宽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%81%E5%85%83"><span class="toc-number">2.3.1.</span> <span class="toc-text">码元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E7%8E%87-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">速率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">带宽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%EF%BC%86%E8%B0%83%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">编码＆调制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%B8%A6%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.1.</span> <span class="toc-text">基带信号与宽带信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">编码与调制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E7%BD%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">先置概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">模拟信号和数字信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE-%E2%86%92-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">模拟数据 → 数字信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE-%E2%86%92-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">数字数据 → 数字信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE-%E2%86%92-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">数字数据 → 模拟信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE-%E2%86%92-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">模拟数据 → 模拟信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E3%80%81%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text">奈氏准则、香农定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E7%9C%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">失真</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E7%9C%9F%E7%8E%B0%E8%B1%A1-%E7%A0%81%E9%97%B4%E4%B8%B2%E6%89%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">失真现象-码间串扰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99"><span class="toc-number">2.5.3.</span> <span class="toc-text">奈氏准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86"><span class="toc-number">2.5.4.</span> <span class="toc-text">香农定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.5.</span> <span class="toc-text">关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">传输介质及分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">导向性传输介质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8-1-%E5%8F%8C%E7%BB%9E%E7%BA%BF"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">导向性传输介质 - 1.双绞线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8-2-%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">导向性传输介质 - 2.同轴电缆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8-3-%E5%85%89%E7%BA%A4"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">导向性传输介质 - 3.光纤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%A8%A1%E5%85%89%E7%BA%A4%E3%80%81%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4"><span class="toc-number">2.6.1.3.1.</span> <span class="toc-text">单模光纤、多模光纤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.6.2.</span> <span class="toc-text">非导向性传输介质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">2.7.</span> <span class="toc-text">物理层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E5%99%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">中继器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%88%E5%A4%9A%E5%8F%A3%E4%B8%AD%E7%BB%A7%E5%99%A8%EF%BC%89"><span class="toc-number">2.7.2.</span> <span class="toc-text">集线器（多口中继器）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-2"><span class="toc-number">3.</span> <span class="toc-text">数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">数据链路层功能概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7"><span class="toc-number">3.1.1.</span> <span class="toc-text">封装成帧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E8%A3%85%E6%88%90%E5%B8%A7"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">组装成帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">字符计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">字符填充法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">零比特填充法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">违规编码法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="toc-number">3.1.2.</span> <span class="toc-text">透明传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.3.</span> <span class="toc-text">差错控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81%E4%B8%8E%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">检错编码与纠错编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">3.1.3.1.1.</span> <span class="toc-text">检错编码 - 奇偶校验码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81-CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E7%A0%81"><span class="toc-number">3.1.3.1.2.</span> <span class="toc-text">检错编码 - CRC循环冗余码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81-%E6%B5%B7%E6%98%8E%E7%A0%81"><span class="toc-number">3.1.3.1.3.</span> <span class="toc-text">纠错编码 - 海明码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">流量控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.4.1.1.</span> <span class="toc-text">可靠传输，滑动窗口，流量控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">停止 - 等待协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE-%E4%B9%8B-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-number">3.1.4.2.1.</span> <span class="toc-text">停 - 等协议 之 无差错情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE-%E6%9C%89%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-number">3.1.4.2.2.</span> <span class="toc-text">停 - 等协议 有差错情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.1.4.2.3.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GBN-%E4%B8%8E-SR"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">GBN 与 SR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE%EF%BC%88GBN%EF%BC%89"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">后退N帧协议（GBN）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.1.4.4.1.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GBN%E5%8F%91%E9%80%81%E6%96%B9%E5%BF%85%E9%A1%BB%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-number">3.1.4.4.2.</span> <span class="toc-text">GBN发送方必须响应的三件事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GBN%E6%8E%A5%E6%94%B6%E6%96%B9%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-number">3.1.4.4.3.</span> <span class="toc-text">GBN接收方需要做的事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84GBN"><span class="toc-number">3.1.4.4.4.</span> <span class="toc-text">运行中的GBN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.1.4.4.5.</span> <span class="toc-text">滑动窗口的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.4.4.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-1"><span class="toc-number">3.1.4.4.7.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE%EF%BC%88SR%EF%BC%89"><span class="toc-number">3.1.4.5.</span> <span class="toc-text">选择重传协议（SR）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SR%E4%B8%AD%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.1.4.5.1.</span> <span class="toc-text">SR中的滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SR%E5%8F%91%E9%80%81%E6%96%B9%E5%BF%85%E9%A1%BB%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-number">3.1.4.5.2.</span> <span class="toc-text">SR发送方必须响应的三件事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SR%E6%8E%A5%E6%94%B6%E6%96%B9%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-number">3.1.4.5.3.</span> <span class="toc-text">SR接收方要做的事</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84SR"><span class="toc-number">3.1.4.5.4.</span> <span class="toc-text">运行中的SR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%95%BF%E5%BA%A6"><span class="toc-number">3.1.4.5.5.</span> <span class="toc-text">滑动窗口长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.1.4.5.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.</span> <span class="toc-text">信道划分介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%93%BE%E8%B7%AF"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">数据传输使用的两种链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-1"><span class="toc-number">3.1.5.2.1.</span> <span class="toc-text">信道划分介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%91%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8FDM"><span class="toc-number">3.1.5.2.1.1.</span> <span class="toc-text">频分多路复用FDM</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8TDM"><span class="toc-number">3.1.5.2.1.2.</span> <span class="toc-text">时分多路复用TDM</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8-%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8STDM"><span class="toc-number">3.1.5.2.1.3.</span> <span class="toc-text">改进的时分复用 - 统计时分复用STDM</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A2%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8WDM"><span class="toc-number">3.1.5.2.1.4.</span> <span class="toc-text">波分多路复用WDM</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A0%81%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8CDM"><span class="toc-number">3.1.5.2.1.5.</span> <span class="toc-text">码分多路复用CDM</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.2.2.</span> <span class="toc-text">随机访问介质控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ALOHA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.2.1.</span> <span class="toc-text">ALOHA协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CSMA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.2.2.</span> <span class="toc-text">CSMA协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9D%9A%E6%8C%81CSMA"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">1-坚持CSMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%9D%9A%E6%8C%81CSMA"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">非坚持CSMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p-%E5%9D%9A%E6%8C%81CSMA"><span class="toc-number">3.1.5.5.</span> <span class="toc-text">p - 坚持CSMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DCSMA%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.5.6.</span> <span class="toc-text">三种CSMA对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CD%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.7.</span> <span class="toc-text">CSMA-CD协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6%E5%AF%B9%E4%BA%8E%E8%BD%BD%E6%B3%A2%E7%9B%91%E5%90%AC%E5%BD%B1%E5%93%8D"><span class="toc-number">3.1.5.7.1.</span> <span class="toc-text">传播时延对于载波监听影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.8.</span> <span class="toc-text">CSMA-CA协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSMA-CA-%E4%B8%8E-CSMA-CD"><span class="toc-number">3.1.5.9.</span> <span class="toc-text">CSMA&#x2F;CA 与 CSMA&#x2F;CD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.9.1.</span> <span class="toc-text">轮询访问介质控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.9.1.1.</span> <span class="toc-text">轮询协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.9.1.2.</span> <span class="toc-text">令牌传递协议</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-amp-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">局域网基本概念 &amp; 体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">局域网拓扑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">传输介质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%8A%9E%E6%B3%95"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">介质访问控制办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">局域网的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE-802%E6%A0%87%E5%87%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">IEEE 802标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%E5%AD%90%E5%B1%82%E5%92%8CLLC%E5%AD%90%E5%B1%82"><span class="toc-number">3.2.4.</span> <span class="toc-text">MAC子层和LLC子层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.3.</span> <span class="toc-text">以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A6%82%E8%BF%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">以太网概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E4%B8%8E%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E5%8F%91%E5%B1%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">以太传输介质与拓扑结构发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10BASE-T%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.3.4.</span> <span class="toc-text">10BASE - T以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8EMAC%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.5.</span> <span class="toc-text">适配器与MAC地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91MAC%E5%B8%A7"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">以太网MAC帧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.3.6.</span> <span class="toc-text">高速以太网</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.4.</span> <span class="toc-text">无线局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE-802-11"><span class="toc-number">3.4.1.</span> <span class="toc-text">IEEE 802.11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#802-11-%E7%9A%84-MAC%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">802.11 的 MAC帧头格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RA-TA-BSSID-DA-SA"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">RA TA BSSID DA SA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.3.</span> <span class="toc-text">无线局域网的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">有固定基础设施无线局域网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%9B%BA%E5%AE%9A%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E8%87%AA%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">无固定基础设施无线局域网的自组织网络</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91"><span class="toc-number">3.5.</span> <span class="toc-text">广域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.5.1.</span> <span class="toc-text">PPP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">PPP协议需要满足的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E4%B8%89%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">PPP协议三个组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">PPP协议的状态图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">PPP协议的帧格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDLC%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.5.2.</span> <span class="toc-text">HDLC协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HDLC%E7%9A%84%E7%AB%99"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">HDLC的站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HDLC%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">HDLC的帧格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDLC%E4%B8%8EPPP"><span class="toc-number">3.5.3.</span> <span class="toc-text">HDLC与PPP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">3.6.</span> <span class="toc-text">链路层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.6.1.</span> <span class="toc-text">物理层扩展以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.6.2.</span> <span class="toc-text">链路层扩展以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A1%A5%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">网桥分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%BD%91%E6%A1%A5"><span class="toc-number">3.6.2.1.1.</span> <span class="toc-text">透明网桥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E8%B7%AF%E7%94%B1%E7%BD%91%E6%A1%A5"><span class="toc-number">3.6.2.1.2.</span> <span class="toc-text">源路由网桥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%8E%A5%E5%8F%A3%E7%BD%91%E6%A1%A5"><span class="toc-number">3.6.2.1.3.</span> <span class="toc-text">多接口网桥</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.2.1.3.1.</span> <span class="toc-text">以太网交换机的两种交换方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%9F%9F%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%9F%9F"><span class="toc-number">3.6.2.1.4.</span> <span class="toc-text">冲突域与广播域</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-2"><span class="toc-number">4.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">网络层功能概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">数据交换方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">电路交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.2.2.</span> <span class="toc-text">报文交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">4.2.3.</span> <span class="toc-text">分组交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%B9%E5%BC%8F-amp-%E8%99%9A%E7%94%B5%E6%8A%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">数据报方式&amp;虚电报方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">数据报方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.1.2.</span> <span class="toc-text">虚电路方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.3.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%E5%90%8D%E8%AF%8D%E8%BE%A8%E6%9E%90"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">传输单元名词辨析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2-amp-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.4.</span> <span class="toc-text">报文交换 &amp; 分组交换对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.5.</span> <span class="toc-text">三种数据交换方式比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">4.3.</span> <span class="toc-text">IP数据报</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">IP数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87"><span class="toc-number">4.3.2.</span> <span class="toc-text">IP数据报分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">IP数据报的传输方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%92%AD"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">单播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%EF%BC%88%E5%A4%9A%E6%92%AD%EF%BC%89"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">组播（多播）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.3.3.1.</span> <span class="toc-text">IP组播地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%92%AD"><span class="toc-number">4.3.3.3.2.</span> <span class="toc-text">硬件组播</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IGMP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.3.3.3.</span> <span class="toc-text">IGMP协议与组播路由选择协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#IGMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.3.3.3.1.</span> <span class="toc-text">IGMP协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.3.3.3.2.</span> <span class="toc-text">组播路由选择协议</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95-amp-%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.</span> <span class="toc-text">路由算法 &amp; 路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">路由算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%AC%A1%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.2.</span> <span class="toc-text">分层次的路由选择协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.3.</span> <span class="toc-text">RIP协议和距离向量算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">RIP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">RIP协议的报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">距离向量算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">RIP协议特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.4.</span> <span class="toc-text">OSPF协议与链路状态算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">OSPF协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">OSPF常见的几个概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.4.3.</span> <span class="toc-text">OSPF的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.4.4.</span> <span class="toc-text">链路状态路由算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.4.4.5.</span> <span class="toc-text">OSPF的区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E5%88%86%E7%BB%84"><span class="toc-number">4.4.4.6.</span> <span class="toc-text">OSPF分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.4.7.</span> <span class="toc-text">OSPF特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.5.</span> <span class="toc-text">BGP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E4%BA%A4%E6%8D%A2%E4%BF%A1%E6%81%AF%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.5.1.</span> <span class="toc-text">BGP协议交换信息的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.4.5.2.</span> <span class="toc-text">BGP协议报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.5.3.</span> <span class="toc-text">BGP协议特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP-4-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8A%A5%E6%96%87"><span class="toc-number">4.4.5.4.</span> <span class="toc-text">BGP-4 的四种报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%8A%A5%E6%96%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.6.</span> <span class="toc-text">三种报文的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">4.5.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.</span> <span class="toc-text">IPv4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">分类的IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">特殊的IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89IP%E5%9C%B0%E5%9D%80"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">私有IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.5.1.4.</span> <span class="toc-text">IPv4数据报格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT"><span class="toc-number">4.5.2.</span> <span class="toc-text">网络地址转换NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">4.5.3.</span> <span class="toc-text">子网划分和子网掩码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">子网划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">子网掩码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B9%A0%E9%A2%98"><span class="toc-number">4.5.3.2.1.</span> <span class="toc-text">子网掩码习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E7%9A%84%E6%97%B6%E5%80%99%E5%88%86%E7%BB%84%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">使用子网的时候分组的转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%88%B6CIDR"><span class="toc-number">4.5.4.</span> <span class="toc-text">无分类编制CIDR</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E6%88%90%E8%B6%85%E7%BD%91-%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="toc-number">4.5.4.1.</span> <span class="toc-text">构成超网&#x2F;路由聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-number">4.5.4.1.1.</span> <span class="toc-text">最长前缀匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.5.</span> <span class="toc-text">ARP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">发送数据的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE-1"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">ARP协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.6.</span> <span class="toc-text">DHCP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.7.</span> <span class="toc-text">ICMP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87"><span class="toc-number">4.5.7.1.</span> <span class="toc-text">ICMP差错报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">4.5.7.1.1.</span> <span class="toc-text">ICMP差错报告报文数据字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E7%A7%8DICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87"><span class="toc-number">4.5.7.1.2.</span> <span class="toc-text">5种ICMP差错报告报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%8F%91%E9%80%81ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E6%83%85%E5%86%B5"><span class="toc-number">4.5.7.1.3.</span> <span class="toc-text">不应该发送ICMP差错报文情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87"><span class="toc-number">4.5.7.2.</span> <span class="toc-text">ICMP询问报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E7%A7%8DICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87"><span class="toc-number">4.5.7.2.1.</span> <span class="toc-text">4种ICMP询问报文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E5%BA%94%E7%94%A8"><span class="toc-number">4.5.8.</span> <span class="toc-text">ICMP应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6"><span class="toc-number">4.5.9.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.5.9.1.</span> <span class="toc-text">IPv6数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6%E4%B8%8EIPv4"><span class="toc-number">4.5.9.2.</span> <span class="toc-text">IPv6与IPv4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6%E5%9C%B0%E5%9D%80%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.5.9.3.</span> <span class="toc-text">IPv6地址表示形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.9.4.</span> <span class="toc-text">IPv6基本地址类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6%E5%90%91IPv4%E8%BF%87%E6%B8%A1%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.9.5.</span> <span class="toc-text">IPv6向IPv4过渡的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.9.5.1.</span> <span class="toc-text">隧道技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8IP"><span class="toc-number">4.5.10.</span> <span class="toc-text">移动IP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.5.10.1.</span> <span class="toc-text">相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.10.2.</span> <span class="toc-text">通信过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">4.6.</span> <span class="toc-text">网络层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">路由器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%AF%B9%E7%BA%BF%E8%B7%AF%E4%B8%8A%E6%94%B6%E5%88%B0%E7%9A%84%E5%88%86%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">输入端口对线路上收到的分组的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">交换结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3%E5%B0%86%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84%E4%BC%A0%E9%80%81%E6%9D%A5%E7%9A%84%E5%88%86%E7%BB%84%E5%8F%91%E9%80%81%E5%88%B0%E7%BA%BF%E8%B7%AF"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">输出端口将交换结构传送来的分组发送到线路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%92%8C%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">路由表和路由转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8-%E7%BD%91%E6%A1%A5-%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">路由器 网桥 集线器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-1"><span class="toc-number">5.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">传输层概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">功能概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.1.2.</span> <span class="toc-text">寻址与端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">传输层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">5.2.1.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">UDP概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">UDP首部格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">UDP校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">5.2.2.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">TCP协议的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">TCP报文段首部格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%9C%896%E4%B8%AA%E6%8E%A7%E5%88%B6%E4%BD%8D%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%AF%B4%E6%98%8E%E6%9C%AC%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E6%80%A7%E8%B4%A8%E3%80%82"><span class="toc-number">5.2.3.</span> <span class="toc-text">下面有6个控制位，用来说明本报文段的性质。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">TCP连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.2.3.1.1.</span> <span class="toc-text">TCP连接过程 三次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-number">5.2.3.1.2.</span> <span class="toc-text">SYN洪泛攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.2.3.1.3.</span> <span class="toc-text">TCP连接释放 四次挥手</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">TCP可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.3.2.1.</span> <span class="toc-text">校验机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.3.2.2.</span> <span class="toc-text">序号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.3.2.3.</span> <span class="toc-text">确认机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.3.2.4.</span> <span class="toc-text">重传机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">TCP流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.3.4.1.</span> <span class="toc-text">拥塞控制四种算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">5.2.3.4.1.1.</span> <span class="toc-text">慢开始与拥塞避免</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-number">5.2.3.4.1.2.</span> <span class="toc-text">快重传和快恢复</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-2"><span class="toc-number">6.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">应用层概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">网络应用模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8-C-S-%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">客户&#x2F;服务器 (C&#x2F;S) 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">P2P模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%EF%BC%88%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">DNS（域名系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">6.3.1.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">域名服务器</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" title="Mysql进阶"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210602195137767.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="Mysql进阶"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" title="Mysql进阶">Mysql进阶</a><time datetime="2021-06-02T12:34:12.103Z" title="发表于 2021-06-02 20:34:12">2021-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" title="Java并发"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210422215218792.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="Java并发"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" title="Java并发">Java并发</a><time datetime="2021-04-22T14:26:11.873Z" title="发表于 2021-04-22 22:26:11">2021-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/29/JVM/" title="JVM"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143528531.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/29/JVM/" title="JVM">JVM</a><time datetime="2021-03-29T07:51:18.960Z" title="发表于 2021-03-29 15:51:18">2021-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" title="SpringBoot"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321190228486.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2021-03-21T11:04:51.373Z" title="发表于 2021-03-21 19:04:51">2021-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" title="SSM整合"><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318222358752.png" onerror="this.onerror=null;this.src='/UesugiEr11.github.io/img/404.jpg'" alt="SSM整合"/></a><div class="content"><a class="title" href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a><time datetime="2021-03-18T14:26:02.754Z" title="发表于 2021-03-18 22:26:02">2021-03-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Erii</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/UesugiEr11.github.io/js/utils.js"></script><script src="/UesugiEr11.github.io/js/main.js"></script><script src="/UesugiEr11.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>