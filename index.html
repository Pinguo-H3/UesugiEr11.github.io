<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="普普通通程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="Erii B1og">
<meta property="og:url" content="http://uesugier11.github.io/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="普普通通程序员">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Mysql进阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2021-06-02T12:34:12.103Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>要学习索引，首先要明白为什么要引入索引</p>
</blockquote>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E7%A3%81%E7%9B%98">关于磁盘</a></p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><ul>
<li><strong>局部性原理</strong></li>
</ul>
<p>在OS的学习中，我们学习了<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">局部性原理</a>的相关知识；</p>
<p>简单的来说就是：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用</strong></p>
<ul>
<li><strong>预读</strong></li>
</ul>
<p>基于这个理论，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</p>
<p>而由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<ul>
<li><strong>预读细节</strong></li>
</ul>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<blockquote>
<p><strong>所以IO一次就是读一页的大小</strong></p>
</blockquote>
<ul>
<li><strong>Mysql预读</strong></li>
</ul>
<p>这个道理适用于Mysql的数据处理：MySQL 在读取的时候，并不是每条每条读取，而是每次读取一页，一页通常包含好多条。</p>
<h3 id="B-Tree（Balance-Plus-Tree）"><a href="#B-Tree（Balance-Plus-Tree）" class="headerlink" title="B+Tree（Balance - Plus - Tree）"></a>B+Tree（Balance - Plus - Tree）</h3><blockquote>
<p>面试官：对于MySQL，你对他索引原理了解吗？<br>我：了解<br>面试官：MySQL的索引是用什么数据机构的？<br>我：B+树<br>面试官：为什么要用B+树，而不是B树？<br>我：…<br>面试官：用B+树作为MySql的索引结构，用什么好处？</p>
<p>我：…</p>
</blockquote>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul>
<li>二叉搜索树中<strong>每个节点</strong>的特点<ul>
<li>比保存在左子树的任何键值都要大</li>
<li>比保存在右子树的任何键值都要小</li>
</ul>
</li>
</ul>
<p><img src="https://notes.diguage.com/mysql/assets/images/binaray_search_tree.gif" alt></p>
<p>上图为在有序数组中查找元素【27】的二叉搜索树搜索过程</p>
<h4 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h4><p>对于要查找元素 6 的情况：</p>
<p>下图左边是二叉搜索树，时间复杂度为0（n）；而右边是经过调整（旋转）后的平衡二叉搜索树，此时树的高度减少了一半，查找效率变为O（log2n）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/array_to_bst.png" alt="二叉搜索树对比"></p>
<ul>
<li><strong>平衡树旋转保持平衡性</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/tree_balance.png" alt="平衡二叉搜索树旋转"></p>
<h4 id="B-树（Balance-Tree）"><a href="#B-树（Balance-Tree）" class="headerlink" title="B-树（Balance-Tree）"></a>B-树（Balance-Tree）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote>
<p><strong>B树</strong>，又称<strong>多路查找树</strong>，概括来说是一个<strong>节点可以拥有多于2个子节点</strong>的二叉查找树</p>
<p>B树中所有结点的孩子个数的最大值称为B树的<strong>阶</strong>，通常表示为一颗<strong>m阶树</strong>或<strong>空树</strong></p>
<p>B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在<strong>数据库</strong>和<strong>文件系统</strong>。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190430100803346.png" alt="img"></p>
<h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B_TNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> numOfKey;<span class="comment">//关键字个数 - 文件数</span></span><br><span class="line">    B_TNode *parent;<span class="comment">//指向父结点的指针</span></span><br><span class="line">    B_TNode **childPtr;<span class="comment">//指向子树的指针，childPtr[0]...childPtr[numOfKey]</span></span><br><span class="line">    <span class="keyword">int</span> *key;<span class="comment">//指向关键字数组的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDQ2MDg3LWJjMDIzZTQ3YmM3NGNmYTEuanBn" alt="B 树"></p>
<ol>
<li>每个节点最多有<em>m 个</em>孩子（m&gt;=2）。</li>
<li>每个非叶节点（根除外）至少有 ⌈ <em>m</em> /2⌉ （向上取整）个子节点。</li>
<li>如果根不是叶节点，则根至少有两个子节点。</li>
<li>一个有<em>k 个<em>孩子的非叶节点包含</em>k</em> − 1 个键，即孩子树为3的话，关键字个数为2，前者为4的话，后者为3，以此类推。</li>
<li>所有叶子都出现在同一层，不携带任何信息。</li>
</ol>
<h5 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B-树的查找"></a>B-树的查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Data* <span class="title">BTreeSearch</span><span class="params">(Root *node, Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data* data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    data = BinarySearch(node);</span><br><span class="line">    <span class="keyword">if</span>(data-&gt;key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node = ReadDisk(data-&gt;next);</span><br><span class="line">        BTreeSearch(node, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查找过程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/702782-20151226202710265-1268539318.png" alt="img"></p>
<p>下面，咱们来模拟下查找<strong>文件29的</strong>过程：</p>
<ol>
<li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】  </li>
<li>此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17&lt;29&lt;35，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】  </li>
<li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26&lt;29&lt;30，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】  </li>
<li>此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。</li>
</ol>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><blockquote>
<ol>
<li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），<strong>每个元素不保存数据，只用来索引</strong>，所有数据都保存在叶子节点。</li>
<li>所有的<strong>叶子结点</strong>中包含了<strong>全部元素的信息</strong>，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小<mark>自小而大顺序链接</mark>。（链表）</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是<strong>最大（或最小）</strong>元素。</li>
<li>B+树查找时是<mark>从上到下</mark>查找；B-树则是<mark>从下往上</mark>查找（中序遍历）</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDQ2MDg3LTMwYjcwYWFhMjg0MDM4MDMuanBn" alt="B+树 1"></p>
<ul>
<li><strong>B+树的优势</strong></li>
</ul>
<p>1.单一节点存储更多的元素（这样该节点下分支变多了，树变<strong>矮胖</strong>了），使得查询的IO次数更少。</p>
<p>2.所有查询都要查找到叶子节点，<strong>查询性能稳定</strong>。</p>
<p>3.所有叶子节点成有序链表，<strong>便于范围查询</strong>。</p>
<ul>
<li><mark>为什么说<strong><em>\</em>B+-tree**</strong>比B 树更适合实际应用中操作系统的文件索引和数据库索引？</mark></li>
</ul>
<ol>
<li>B+树更适合外部存储。由于内结点不存放真正的数据（只是存放其子树的最大或最小的关键字，作为索引），一个结点可以存储更多的关键字，每个结点能索引的范围更大更精确，也意味着B+树单次磁盘IO的信息量大于B树，I/O的次数相对减少。</li>
<li>MySQL是一种关系型数据库，区间访问是常见的一种情况，B+树叶结点增加的链指针，加强了区间访问性，可使用在区间查询的场景（即B+树只要遍历叶子节点就可以实现整棵树的遍历）；<strong>而使用B树则无法进行区间查找。</strong></li>
</ol>
<h2 id="InnoDB-逻辑存储结构"><a href="#InnoDB-逻辑存储结构" class="headerlink" title="InnoDB 逻辑存储结构"></a>InnoDB 逻辑存储结构</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul>
<li>（索引 - 树）<a target="_blank" rel="noopener" href="https://notes.diguage.com/mysql/#_%E6%A0%91">https://notes.diguage.com/mysql/#_%E6%A0%91</a></li>
<li>（b树和b+树）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ivictor/p/5849061.html">https://www.cnblogs.com/ivictor/p/5849061.html</a></li>
<li>（B树、B+树学习）<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34533266/article/details/112790436">https://blog.csdn.net/qq_34533266/article/details/112790436</a></li>
<li>（B树和B+树的区别）<a target="_blank" rel="noopener" href="https://blog.csdn.net/a519640026/article/details/106940115">https://blog.csdn.net/a519640026/article/details/106940115</a></li>
<li>（漫画图解B树与B+树）<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35571554/article/details/82759668?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs">https://blog.csdn.net/qq_35571554/article/details/82759668?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs</a></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>（二叉搜索时可视化工具）<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BST.html">https://www.cs.usfca.edu/~galles/visualization/BST.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/" data-id="ckppikudc0001p0wibqtjan34" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2021-04-22T14:26:11.873Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>想要学习并发，必须首先对线程有一定的知识基础，因此强烈建议先复习一下这部分知识：</p>
<hr>
<p>在Java基础笔记中，对于Java线程有一定的说明：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E7%BA%BF%E7%A8%8B</a></p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E7%BA%BF%E7%A8%8B</a></p>
<hr>
<p>如果想在OS层面学习进程线程，在OS笔记中，对这部分有一定的说明：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B</a></p>
<p>对于进程的调度，死锁的相关知识：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81</a></p>
<h2 id="Java并发-核心理论"><a href="#Java并发-核心理论" class="headerlink" title="Java并发 - 核心理论"></a>Java并发 - 核心理论</h2><ul>
<li>Java异步核心原理分为五个基本性质：共享性、互斥性、原子性、可见性、有序性</li>
</ul>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>如果所有数据都是线程私有的，那编程的时候就无须考虑并发的情况了 —— 因为无论怎么操作，数据都可以保证正确，不会被其他线程访问。因此，数据具有共享性，是线程安全得不到保证的主要原因之一。那如何保证线程安全（数据一致性）呢，就得引入进程同步。</p>
<h3 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h3><p>操作系统中，关于进程互斥：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5</a></p>
<p>资源互斥是指同时只允许一个访问者对其进行访问，具有<mark>唯一性</mark>和<mark>排它性</mark>。</p>
<p>对于数据，我们可以进行读（查看）和写（修改）的操作，则我们应该对执行读写操作的线程分别有不同的限制，因此衍生了两种<strong>锁</strong></p>
<ul>
<li><p><strong>共享锁（读锁/S锁）</strong>：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
</li>
<li><p><strong>排它锁（写锁/X锁）</strong>：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</p>
<p>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>
</li>
</ul>
<p>Java中的保证数据安全性，实现互斥的方法有许多（比如synchronized，类似于操作系统中的管程机制）</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>操作系统中与原子性关系最贴切的应该是<strong>原语</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8E%9F%E8%AF%AD">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8E%9F%E8%AF%AD</a></p>
<p>原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改；</p>
<p>列举个例子来体现<strong>原子性</strong>：<code>i++</code> 这个操作，1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。</p>
<p>但却可能在多线程场景发生以下情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160410215649812-831081790.png" alt="img"></p>
<p>保证原子性（即不会被其他操作打断）的方法可以通过<strong>上锁</strong>去实现：<code>Synchronized或Lock</code>，或者是使用<code>CAS</code>：修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行（乐观锁）。但CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>关于可见性问题的解释：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430">https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430</a></p>
<ul>
<li>可见性：一个线程对共享变量的修改，更够及时的被其他线程看到</li>
</ul>
<p>可见性概念建立在JVM的内存模型上：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160412075618645-61482019.png" alt="img"></p>
<p>在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用synchronzied进行同步的时候，真正被同步的是在不同线程中表示被锁定对象的内存块（副本数据会保持和主内存的<strong>同步</strong>）</p>
<p>简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的</p>
<p>但有可能会出现这么一个问题：假如主内存的更新（通知）不及时，会导致一个线程A明明更新了数据，但线程B得到的还是原来的数据的问题。</p>
<p>解决这个问题可以使用：<code>volatile</code>和<code>synchronized</code>关键字进行解决。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性部分与进程的前驱问题有点类似：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB</a></p>
<p>为了提高性能，编译器和处理器可能会对指令做<strong>重排序</strong>，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<a href="#重排序">重排序相关内容</a></p>
<p>Java 中也可通过<code>Synchronized</code>或·<code>Volatile</code>来保证顺序性。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1190710-20181026151558231-206612292.png" alt="img"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存模型通过限制处理器优化和使用内存屏障，来保证共享内存的正确性<strong>（可见性、有序性、原子性）</strong></p>
<p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>JMM还通过<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等实现原子性、有序性、可见性。</p>
<p>而由于进程之间进行通信，数据进行同步，都依靠这个JMM。因此学习它就显得尤为重要了。</p>
<p>关于进程通信：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1</a></p>
<p>关于进程同步：</p>
<p><a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1</a></p>
<h2 id="并发编程模型基础"><a href="#并发编程模型基础" class="headerlink" title="并发编程模型基础"></a>并发编程模型基础</h2><p>在并发编程中，需要了解并会处理这两个关键问题：</p>
<h3 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a>线程之间如何通信</h3><p> 　<strong>通信是指线程之间以何种机制来交换信息</strong>。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存和消息传递</strong>。</p>
<p>　　a) 在<strong>共享内存</strong>的并发模型里，<strong>线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。（重点）</strong></p>
<p>　　b) 在<strong>消息传递</strong>的并发模型里，<strong>线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</strong></p>
<h3 id="线程之间如何同步"><a href="#线程之间如何同步" class="headerlink" title="线程之间如何同步"></a>线程之间如何同步</h3><p>　　<strong>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</strong></p>
<p>　　<strong>在共享内存的并发模型里，同步是显示进行的</strong>。因为程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>
<p>　　<strong>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</strong></p>
<p>　　知道并了解上面两个问题后，对java内存模型的了解，就打下了基础。因为Java的并发模型采用的是共享内存模型，java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h2 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/368583-20180711114747052-1472383817.png" alt="img"></p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>如图：硬件内存模型由<strong>CPU - 缓存 - 主存储</strong>三层结构组成</p>
<p>现代计算机通常有2个或以上的CPU，单个CPU可能有多个内核。每个CPU内核中都包含一组寄存器，CPU在寄存器中执行操作比在计算机主存储器中快的多</p>
<p>每个CPU之上还存在高速缓存，但高速缓存的层级和位置是不固定的，缓存的位置也各有不同，有的集成了部分缓存到CPU中。 同样，缓存的读写速度也大大快于计算机主存储器。</p>
<ul>
<li><strong>什么时候需要用到缓存呢？</strong></li>
</ul>
<p>CPU在程序的执行过程中，经常会频繁的调用相同的数据，比如在一个循环内调用了位于另外一个物理地址的函数，这个函数可能与当前指令的物理位置相距甚远，因为程序使用的物理内存并不是连续的，这就导致了需要花费很多不必要的时间在物理寻址上。但如果在CPU计算之前会将所需要用到的数据先读到缓存中，计算完成之后再一次性写入计算机主存储器，就可以避免频繁访问计算机主存储器造成的资源浪费。</p>
<h2 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h2><p>在Java中，所有<strong>实例域、静态域和数组元素</strong>都存储在<mark>堆内存</mark>中， 而堆内存在线程之间是共享的</p>
<p>而虚拟机栈（其中包括局部变量、方法参数定义等..）是线程私有的，不会在线程之间共享，所以它们不会有内存可见性的问题，也不受内存模型的影响。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1139681-20170911155342578-24594059.png" alt="img"></p>
<ul>
<li><p>线程与主内存间的抽象关系</p>
<ul>
<li><p>线程之间的共享变量存储在<strong>主内存（Main memory）</strong>中</p>
</li>
<li><p>每个线程都有一个私有的<strong>本地内存（local memory）</strong>或者说是<strong>工作内存（Working Memory）</strong>，本地内存中存储了该线程用以读/写共享变量的副本。</p>
<p>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过<strong>主内存</strong>来完成。</p>
</li>
<li><p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。线程对共享变量的操作并不会直接访问<strong>主内存</strong>，而是访问一个<strong>中间层</strong>，这个<strong>中间层</strong>包含了主内存中<mark>变量的拷贝</mark>，同时<strong>中间层</strong>的访问速度大大快于访问<strong>主内存</strong>的速度，在一定的操作之后将结果统一写回主内存，这样就大大提高了程序的性能</p>
<p>（同时也会产生另外一个问题，同一个共享变量在每一个线程之中都会有一份拷贝（对引用类型，并不是拷贝全部数据），产生的线程越多，缓存开销也就越大。）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>线程通信问题</li>
</ul>
<p>上图中,线程A与B想要进行通信（数据交互）的话，要经历：</p>
<ol>
<li>线程A把<mark>本地内存A</mark>中更新过的共享变量刷新到<mark><strong>主内存</strong></mark>中去。</li>
<li>线程B到<mark><strong>主内存</strong></mark>中去读取线程A之前已更新过的共享变量，接着复制一份到<mark>本地内存B</mark>中</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/690169-20180703125802114-1801798430.png" alt="img"></p>
<p>假设初始时，这三个内存中x的值都为0，线程A在执行时，把更新后的x值临时放在本地内存。当线程A与线程B需要通信时，</p>
<p>　　步骤1：线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。</p>
<p>　　步骤2：线程B到主内存中读取线程A更新后的X值，此时线程B的本地内存x的值也变为了1。</p>
<p>　　从整体(不考虑重排序，按顺序执行)来看，这两个步骤实质上是**线程A在向线程B发送消息，而</p>
<p>从整体(不考虑重排序，按顺序执行)来看，这两个步骤实质上是<strong>线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，提供内存可见性的保证。</strong></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul>
<li><strong>重排序分为三种</strong></li>
</ul>
<ol>
<li><mark>编译器优化的重排序</mark>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><mark>指令级并行的重排序</mark>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><Mark>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</Mark></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/690169-20180630231133468-875140136.png" alt="img"></p>
<ul>
<li><strong>为什么会发生重排序</strong></li>
</ul>
<p>为什么会重排序，上面这几个阶段里大概提到了，提高并行效率，编译器认为重排序后执行更优，指令级重排序并行效率更好等等。在单个线程的视角看来，重排序不存在任何问题，重排序不改变执行结果</p>
<p>对于语句：<code>int a = 1;int b = 2;int c = a + b;</code></p>
<p>首先需要明白：重排序的发生前提是具有<strong>数据依赖</strong>，什么意思呢？<code>int a = 1;int b = a;</code> b的数据依赖于a，那么这两个语句就不会被重排序，a一定会在b语句前执行；****</p>
<p>c因为对a和b有<strong>数据依赖</strong>，因此c不会被重排序，但是a 、b的执行可能被重排序。但在单个线程下，这种重排序不存在任何问题，不论先初始化a、还是先初始化b，c的值都是3</p>
<ul>
<li><strong>重排序带来的问题</strong></li>
</ul>
<p>然而重排序可能会导致多线程出现<strong>内存可见性的问题</strong>，比如：处理器在对内存进行读写操作未必与实际发生的内存读写顺序一致，导致重排序→引发了可见性问题（数据更新不及时）</p>
<p>在这我们不举例处理器的例子，我们还是以代码为例：</p>
<p>现在有两个线程</p>
<ol>
<li><p>线程T1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="comment">//共享变量</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">true</span>; <span class="comment">//共享变量 boolean b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程T2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b)&#123;</span><br><span class="line">	<span class="keyword">int</span> c = a;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们默认b的值是线程T2可读取的，假如b为<code>true</code>，c一定为1吗？（在并发环境中）</p>
<p>按照我们上面的学习，a与b是没有数据依赖关系的，因此运行的顺序的可以被重排序的。假如此时b先与a执行，虽然对T1没什么影响，但是对T2就不一样了。T2可能一直在进行这个if的测试，突然间发现b为true了，而a还没来得及被赋值呢，就进入了T2的if语句中，则此时的c就读不到a的值（1）了。</p>
<blockquote>
<p>当代码中存在控制依赖的时候，会影响指令序列执行的并行度。为此，编译器和处理器会采用<code>猜测执行</code>来克服控制相关性对并行度的影响。比如可以提前读取变量，计算，将计算结果临时保存起来，当条件为真的时候，把临时变量写入真的变量中。这个猜测执行其实就是对指令进行了重排序，此处的重排序是破坏了多线程程序的语义的。</p>
</blockquote>
<h2 id="happens-before-重点"><a href="#happens-before-重点" class="headerlink" title="happens-before - 重点"></a>happens-before - 重点</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/201812083001.png" alt="img"></p>
<ul>
<li><strong>JMM把happens- before要求禁止的重排序分为了下面两类：</strong></li>
</ul>
<ol>
<li><p><strong>会改变</strong>程序执行<strong>结果</strong>的重排序，JMM要求编译器和处理器<strong>必须禁止</strong>这种重排序。</p>
</li>
<li><p><strong>不会改变</strong>程序执行<strong>结果</strong>的重排序，JMM对编译器和处理器<strong>不作要求</strong>（JMM<strong>允许</strong>这种重排序）。</p>
<p>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。</p>
<p>比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。</p>
<p>再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。</p>
</li>
</ol>
<p><strong>这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</strong></p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li><strong>happens-before原则定义</strong></li>
</ul>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。 <a href="#可见性">关于可见性</a></li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ol>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li><strong>happens-before规则</strong></li>
</ul>
<ol>
<li><p><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<blockquote>
<p>一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对【单线程】有效，在【多线程】环境下无法保证正确性。</p>
</blockquote>
</li>
<li><p><strong>锁定规则</strong>：一个unLock操作<mark>先行发生</mark>于后面对同一个锁的Lock操作</p>
<blockquote>
<p>这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p>
</blockquote>
</li>
<li><p><strong>volatile变量规则</strong>：对一个volatile变量的<mark>写操作</mark>先行发生于后面（时间上）对这个变量的<mark>读操作</mark></p>
<blockquote>
<p>这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before(先行)于读操作的。</p>
</blockquote>
</li>
<li><p><strong>传递规则</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<blockquote>
<p>提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p>
</blockquote>
</li>
<li><p><strong>线程</strong></p>
<ol>
<li><p><strong>启动规则</strong>：Thread对象的<code>start()</code>方法先行发生于此线程的每个一个动作；</p>
<blockquote>
<p>假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p>
</blockquote>
</li>
<li><p><strong>中断规则</strong>：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
</li>
<li><p><strong>终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行；</p>
<blockquote>
<p>假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p>
</li>
</ol>
<p><mark>简单来说</mark> </p>
<blockquote>
<p>程序顺序规则： 对于单个线程中的每个操作，前继操作happens-before于该线程中的任意后续操作。<br>监视器锁规则： 对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则： 对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>传递性： 如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</blockquote>
<ul>
<li><strong>以上为原生Java满足Happens-before关系的规则，可引申推导出其他六条</strong>：</li>
</ul>
<ol>
<li>将一个元素<mark>放入</mark>一个线程安全的队列的操作Happens-Before从队列中<mark>取出</mark>这个元素的操作</li>
<li>将一个元素<mark>放入</mark>一个线程安全容器的操作Happens-Before从容器中<mark>取出</mark>这个元素的操作</li>
<li>在CountDownLatch上的<mark>倒数操作</mark>Happens-Before 于CountDownLatch<mark>#await()</mark>操作</li>
<li><mark>释放</mark>Semaphore许可的操作Happens-Before<mark>获得</mark>许可操作</li>
<li><strong>Future</strong>表示的<strong>任务的</strong><mark>所有操作</mark>Happens-Before Future<mark>#get()</mark>操作</li>
<li>向Execut<mark>提交</mark>一个Runnable或Callable的操作Happens-Before任务<mark>开始执行</mark>操作</li>
</ol>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>下面还是以书中的实例(计算圆的面积)进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;           <span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;            <span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;    <span class="comment">// C![]</span></span><br></pre></td></tr></table></figure>

<p>上面3个操作的数据依赖关系如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190227104137511.png" alt="img"></p>
<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面(因为C排到A和B的前面，程序的结果将会被改变)。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p>
<p>该程序的两种可能执行顺序：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190227104236982.png" alt="img"></p>
<blockquote>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。<br>as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><strong>jvm运行时刻内存的分配</strong></li>
</ul>
<hr>
<p><strong>前言：一定要注意！Java内存区域(运行时数据区 )<mark>不等于</mark>Java内存模型(JMM)</strong></p>
<p><strong>Java内存区域是指JVM运行时数据分区域存储，而Java内存模型是定义了线程和主内存之间的抽象关系！</strong></p>
<hr>
<p>根据[JMM](#JMM（Java Memory Model)我们可以知道线程与主内存之间还存在着一个<strong>本地内存（工作内存）</strong>，在这个内存中保存着变量的副本。</p>
<p>同样的，以类比的思想，jvm运行时刻内存的分配中，有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个<strong>线程栈</strong>。</p>
<blockquote>
<p>线程的工作内存与java的堆、栈并不是一个层次上的内存划分，如果非要类比的话工作内存对应虚拟机栈的部分区域 —— 《深入理解java虚拟机》</p>
</blockquote>
<p>线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存中的变量的具体值<code>load</code>到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/11172340-1b4ffc1abd6047798761edf5c5070ec1.jpg" alt="img"></p>
<ul>
<li><strong>问题引入</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest vt = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        vt.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        vt.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;stope&quot;</span> + vt.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行流程：</p>
<ol>
<li>首先创建 VolatileTest vt = new VolatileTest();</li>
<li>然后启动线程 vt.start();</li>
<li>暂停主线程2秒（Main） Thread.sleep(2000);</li>
<li>这时的vt线程已经开始执行，进行i++;</li>
<li>主线程暂停2秒结束以后将 vt.flag = true;</li>
<li>打印语句 System.out.println(“stope” + vt.i); 在此同时由于vt.flag被设置为true,所以vt线程在进行下一次while判断 while (!flag) 返回假 结束循环 vt线程方法结束退出！</li>
<li>主线程结束</li>
</ol>
<p>然而输出结果是：<code>stope1620137804</code>,并且程序不会退出。也就是说我们在主线程设置的 vt.flag = true;没有起作用</p>
<ul>
<li><strong>问题解决 理解</strong></li>
</ul>
<p>问题：主线程中设置<code>flag = true</code>,然而子线程并未获取到修改后的值，进行判断时的flag仍然为false。</p>
<p>需要结合<strong>jvm运行时刻内存的分配</strong>去理解</p>
<p><strong>子线程执行过程</strong></p>
<ol>
<li><p>首先子线程（vt线程）运行时，将*<em>变量 flag 与 i *</em>从 <mark>主内存</mark> 拷贝到 <mark>线程栈内存（即线程工作内存）</mark></p>
</li>
<li><p>接着执行while循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>while (!flag)</strong> 进行判断的flag 是在<mark>线程工作内存</mark>当中获取，而不是从 <mark>主内存 </mark>中获取。</p>
<p><strong>i++;</strong> 将<mark>线程工作内存</mark>中的i++; 加完以后将结果写回至 <mark>主内存</mark>，如此重复。</p>
</li>
</ol>
<p><strong>主线程执行过程</strong></p>
<ol>
<li><p>创建子线程</p>
</li>
<li><p>启动子线程</p>
</li>
<li><p>主线程sleep</p>
</li>
<li><p><code>vt.flag = true;</code>（重点）</p>
<ol>
<li>主线程将vt.flag的值从<mark>主内存</mark>中拷贝到自己的<mark>线程工作内存</mark></li>
<li>然后修改flag=true. </li>
<li>然后再将新值回到<mark>主内存</mark>。</li>
</ol>
<blockquote>
<p>这就解释了为什么在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false。那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！</p>
</blockquote>
</li>
</ol>
<p><strong>问题解决</strong></p>
<p>我们在上面主线程的第四步发现了问题了，是由于子线程的取值并不是在主内存中进行，而是在自己的工作内存中获取的，因此，要想解决这个问题也很简单：<strong>让vt线程每次判断flag的时候都强制它去主内存中取值</strong></p>
<p>这就是<strong>volatile关键字</strong>的作用：被加了这个关键字的数据，在被线程修改后，会从本地工作内存被强制的刷新回主内存，也就是让主内存中的变量值变成最新的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VolatileTest vt = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        vt.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        vt.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;stope&quot;</span> + vt.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stope1662380642</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>程序能够正常退出了。</p>
<ul>
<li><strong>bonus</strong></li>
</ul>
<p>例子：现在让线程1去修改data为1，然而线程2由于可见性问题，并不能读取到变更后的data（也就是线程2读取到的data一直是工作内存中的data（即为0）。因此就需要使用<strong>volatile</strong>去解决了。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVqMXSxviaaZibG2aSGUTcWOJJ8X025g88RRicic9TDjfj5oic0TicUOU1Am0Sw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<p><strong>而volatile关键字除了能够让本地工作内存中的数据被强制的刷新回主内存外，还有着别的作用</strong></p>
<ol>
<li><p>如果此时别的线程的工作内存中有这个data变量的本地缓存，也就是一个变量副本的话，那么会强制让其他线程的工作内存中的data变量缓存直接失效过期，不允许再次读取和使用了</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVq3n1gLtNhBMfdEiaMic4icZcWVD95shDdwib3WKC4xge12SqdPapZJPOwxA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
</li>
<li><p>如果线程2在代码运行过程中再次需要读取data变量的值，此时尝试从本地工作内存中读取，就会发现这个data = 0已经过期了！</p>
<p>此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这个最新的值了！</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZicI3B23mHahdibYiaRKicYVVqHCIS4F18UGeSroHvicdUKDf0XkWWmgfftENvjHMU9kP4bnkfQEQ2WDg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
</li>
</ol>
<ul>
<li><strong>总结</strong></li>
</ul>
<p><strong>volatile主要作用是保证可见性以及有序性。</strong></p>
<p>但是内存模型三大要素缺漏了一个：<strong>原子性</strong>，也就是说，volatile关键字并不能保证原子性</p>
<p>结合线程理解就是：</p>
<ol>
<li>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</li>
<li>多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题</li>
</ol>
<p>原子性的问题需要去结合<strong>锁机制</strong>去解决。</p>
<h1 id="Java并发机制底层实现"><a href="#Java并发机制底层实现" class="headerlink" title="Java并发机制底层实现"></a>Java并发机制底层实现</h1><ul>
<li>前言</li>
</ul>
<p>在OS学习中，我们学习了<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1">线程同步</a>的相关知识。</p>
<p>其中有一个<strong>临界区</strong>的概念</p>
<blockquote>
<p>临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。</p>
</blockquote>
<p>在OS中，我们使用了信号量、管程等方法去实现同步。现在学习了Java，就需要用Java中类似的机制去实现。</p>
<p>Java提供了同步机制。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区；如果已有线程进入了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入<strong>临界区</strong>的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。</p>
<h2 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h2><p>在前面<a href="#volatile">volatile</a> 部分中，学习了volatile的基本概念，但是没有去学习其底层实现，下面就来看看volatile是如何保证可见性与有序性的</p>
<h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515164459977.png" alt="image-20210515164459977"></p>
<p>如图所示，CPU中高速缓存内部结构是一个拉链散列表（与HashMap的底层结构以及原理十分相似）。它分为若干桶，每个桶是一个链表，包含若干缓存条目，每个缓存条目就是一个cache line（64 bytes）。</p>
<p>作用是什么呢？假设程序中读取某一个int变量，CPU并不是只从主存中读取4个字节，而是会一次性读取64个字节，然后放到cpu cache中。因为往往紧挨着的数据，更有可能在接下来会被使用到。</p>
<blockquote>
<p>这里类似于IO的磁盘读取，应用到了时间和空间局部性原理</p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。<br>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。比如循环、递归、方法的反复调用等。<br>空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。</p>
</blockquote>
<ul>
<li>进一步可分为三部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190418185737219.png" alt="在这里插入图片描述"><br>CPU访问内存时，会通过内存地址解码的三个数据：index（桶编号）、tag（缓存条目的相对编号）、offset（变量在缓存条目中的位置偏移）来获取高速缓存中对应的数据。</p>
<p>这时候可以看到Flag这个标识了，然后就可以引出了状态值的概念，然后就可以引出我们所说的MSEI协议了。</p>
<h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>E（独占）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515165217310.png" alt="image-20210515165217310"></p>
<p>只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。</p>
<ul>
<li>S（共享）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113707384.png" alt="在这里插入图片描述"></p>
<p>3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。</p>
<ul>
<li>M（修改）状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113533520.png" alt="在这里插入图片描述"></p>
<p>Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态</p>
<ul>
<li>I状态</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190419113533520.png" alt="在这里插入图片描述"></p>
<p>在一个Core修改x后，相应的，其他Core对应的Cache line变成了I(Invalid)状态。</p>
<ul>
<li>状态的改变</li>
</ul>
<p>cache line存在四种状态，状态是动态的，肯定是有一定的操作使得状态发生了改变，那么操作是什么呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190418194836533.png" alt="在这里插入图片描述"></p>
<ol>
<li>Local Read表示本内核读本Cache中的值</li>
<li>Local Write表示本内核写本Cache中的值</li>
<li>Remote Read表示其它内核读其它内核Cache中的值</li>
<li>Remote Write表示其它内核写其它内核Cache中的值</li>
</ol>
<ul>
<li>总结</li>
</ul>
<p>MESI协议为了保证多个CPU cache中共享数据的一致性，定义了cache line的四种状态，而CPU对cache的4种操作可能会产生不一致状态，因此cache控制器监听到本地操作和远程操作的时候，需要对地址一致的cache line状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。</p>
<h3 id="写缓存-Store-Buffer"><a href="#写缓存-Store-Buffer" class="headerlink" title="写缓存 - Store Buffer"></a>写缓存 - Store Buffer</h3><ul>
<li><strong>场景引入</strong></li>
</ul>
<p>有一个变量在多个核中的缓存存在，那么这个缓存的状态是<strong>S（shared）共享</strong>的，现在核A想要<mark>修改</mark>这个变量，首先核A会向所有拥有相同缓存的其他核发送一个请求，告诉其他核中的缓存是<strong>I（Invalid）无效</strong>的，其他核收到这个信息将自己核中的缓存状态设置为无效之后，返回一个设置完成的消息，这个核A收到这个无效状态修改的消息后，再把自己的状态改为<strong>E（Exclusive）独享</strong>的，然后修改为<strong>M（Modified）</strong>进行缓存修改。</p>
<p>思考下：在核A等待其他核返回无效状态修改的消息返回的时候它做了什么？它什么都没做，一直处于阻塞状态。</p>
<p>因此，设计者引入了写缓存（Store Buffer）的无效化队列（Invalidate Queue）来解决这个问题。</p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>写缓存是一个容量极小的高速存储部件，每个核都有自己的写缓存，而且一个核不能够读取到其他核的写缓存（Store Buffer）的内容，相当于一个自己的本地缓存。</p>
<p>如上面的场景，核A修改共享的缓存，先将这个修改操作放入到写缓存（Store Buffer）中，再告诉其他核中的缓存失效了，然后核A继续执行其他指令操作，当接受到了其他核返回无效状态修改的消息之后，才将写缓存（Store Buffer）中的操作写入到核A中的缓存中，这时写操作才算完成。</p>
<p>这样就解决了等待阻塞所带来的性能问题，减少了延时，提高了执行效率。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515201924136.png" alt="image-20210515201924136"></p>
<h3 id="无效化队列-Invalidate-Queue"><a href="#无效化队列-Invalidate-Queue" class="headerlink" title="无效化队列 - Invalidate Queue"></a>无效化队列 - Invalidate Queue</h3><p>修改方为了能够快速进行回应所以，先将无效的操作放到队列里面去，并立刻返回无效状态修改的消息，等当前的操作执行完再回来真正的把缓存里面的值标识为I状态，这个存放无效操作的队列就叫做<strong>无效化队列</strong>。同时可能也是考虑到了写缓存（Store Buffer）是比较小的高速缓存，如果不能够及时返回会造成写缓存满了，还是需要等待无效状态修改的消息的返回才能继续进行后续的指令，所以就出现了无效化队列和写缓存配合使用。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205726015.png" alt="image-20210515205726015"></p>
<h3 id="写缓存与无效化队列的不足性"><a href="#写缓存与无效化队列的不足性" class="headerlink" title="写缓存与无效化队列的不足性"></a>写缓存与无效化队列的不足性</h3><ul>
<li>单核情况</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515203558901.png" alt="image-20210515203558901"></p>
<p>令b=x+1，因为x已经在缓存中读到的为0，b为1，所以判断是false，虽然后来Store Buffer后来将x的值刷新到了缓存中，但是已经晚了</p>
<p>所以为了避免这个问题，Store Buffer设计了一种策略叫做Store Forwarding。就是说核A在读取数据的时候会先看Store Buffer中的数据，如果Store Buffer中有数据，直接使用Store Buffer中的，从而避免使用错误数据。</p>
<ul>
<li>多核情况</li>
</ul>
<ol>
<li><p>情况一</p>
<p>核B在进行判断的时候发现在自己的缓存存在x=0，就直接+1进行了赋值判断，但此时核A刚刚将x=2的操作放到Store Buffer中，所以由于Store Buffer的存在导致多核下不能获取到最新值，所以产生了错误的结果。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205858812.png" alt="image-20210515205858812"></p>
<p>所以为了解决上面的问题出现了<strong>写屏障</strong>，写屏障的出现保证屏障两边写的执行是分开的，也就是说需要先将之前Store Buffer中的所有写指令都刷新到缓存之后，才执行后面的写指令。<br><strong>具体实现方法</strong>是，【先将屏障之前的<strong>Store Buffer中所有操作</strong>都刷新到缓存中】，将屏障后的所有指令操作也同样放到Store Buffer中，不管后续的操作是什么都往里面放，这样可以提高CPU的执行效率，都通过Store Buffer刷新到了缓存中,达到了数据来源的统一性。</p>
</li>
<li><p>情况二</p>
<p>核B在进行判断的时候发现在自己的缓存存在x=0，就直接+1进行了赋值判断，但此时核B刚刚将x的无效操作放到Invalidate Queue中，所以由于Invalidate Queue的存在导致多核下不能获取到最新值，所以产生了错误的结果。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515205805900.png" alt="image-20210515205805900"></p>
<p>所以为了解决上面的问题出现了读屏障，读屏障的出现保证屏障两边读的执行是分开的，也就是说需要先将之前Invalidate Queue中的所有指令处理完之后，才执行后面的指令，保证下一次读取共享变量的时候读到的是最新的变量。</p>
</li>
</ol>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>通过上面对错误情况的分析可以知道，内存屏障的出现就是为了解决因为Store Buffer和Invalidate Queue所带来的数据可见性问题，也就是读和写不能实时更新到其他核的问题。内存屏障同时还具备强制将Store Buffer的内容刷到缓存中，强制将Invalidate Queue中的内容设置完毕的作用。</p>
<ul>
<li>硬件层的内存屏障分为两种：<code>Load (Memory) Barrier读屏障</code> 和 <code>Store (Memory) Barrier写屏障</code></li>
<li>内存屏障有两个作用：</li>
</ul>
<blockquote>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
</blockquote>
<ul>
<li><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</p>
<p>或者说： 强制将Invalidate Queue中的内容处理完毕，也被称之为smp_rmb</p>
</li>
<li><p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
<p>或者说：强制将Store Buffer中的内容写入到缓存中或者将该指令之后的写操作写入store buffer直到之前的内容被刷入到缓存中，也被称之为smp_wmb</p>
</li>
</ul>
<h4 id="内存屏障分类"><a href="#内存屏障分类" class="headerlink" title="内存屏障分类"></a>内存屏障分类</h4><ol>
<li><p><strong>按照可见性保障来划分</strong><br>内存屏障可分为：<strong>加载屏障（Load Barrier）和存储屏障（Store Barrier）</strong>。</p>
<p>加载屏障：<mark>StoreLoad屏障</mark>可充当加载屏障，作用是刷新处理器缓存，即清空无效化队列，使处理器在读取共享变量时，先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中</p>
<p>存储屏障：<mark>StoreLoad屏障</mark>可充当存储屏障，作用是冲刷处理器缓存，即将写缓冲器内容写入高速缓存中，使处理器对共享变量的更新写入高速缓存或者主内存中<br>这两个屏障一起保证了数据在多处理器之间是可见的。</p>
</li>
<li><p><strong>按照有序性保障来划分</strong><br>内存屏障分为：<strong>获取屏障（Acquire Barrier）和释放屏障（Release Barrier）</strong>。</p>
<p>获取屏障：相当于<mark>LoadLoad屏障与LoadStore屏障</mark>的组合。在读操作后插入，禁止该读操作与其后的任何读写操作发生重排序；</p>
<p>释放屏障：相当于<mark>LoadStore屏障与StoreStore屏障</mark>的组合。在一个写操作之前插入，禁止该写操作与其前面的任何读写操作发生重排序。</p>
<p>这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外。</p>
</li>
</ol>
<h4 id="Java内存屏障"><a href="#Java内存屏障" class="headerlink" title="Java内存屏障"></a>Java内存屏障</h4><ul>
<li><p>Java四种屏障其实是<strong>Load Barrier</strong>与<strong>Store Barrier</strong>的两两组合（2 × 2 = 4）</p>
<p>此处提及的【load → 加载】和【store → 写入】</p>
<ul>
<li><p><mark>LoadLoad</mark>：对于语句 <code>Load1; 【LoadLoad】; Load2</code>，这个屏障的作用是确保在Load2加载代码在要读取的数据之前，保证Load1加载代码要从主内存里面读取的数据读取完毕。</p>
<blockquote>
<p>即：该屏障保证了在屏障前的读取操作效果先于屏障后的读取操作效果发生。在各个不同平台上会插入的编译指令不相同，可能的一种做法是插入也被称之为smp_rmb指令，强制处理完成当前的invalidate queue中的内容</p>
</blockquote>
</li>
<li><p><mark>StoreStore</mark>：对于语句<code>Store1; 【StoreStore】; Store2</code>，这个屏障的作用是保证在Store2存储代码进行写入操作执行前，保证Store1的写入操作已经把数据写入到主内存里面，确认Store1的写入操作对其它处理器可见。</p>
<blockquote>
<p>即：该屏障保证了在屏障前的写操作效果先于屏障后的写操作效果发生。可能的做法是使用smp_wmb指令，而且是使用该指令中，将后续写入数据先写入到store buffer的那种处理方式。因为这种方式消耗比较小</p>
</blockquote>
</li>
<li><p><mark>LoadStore</mark>：对于语句<code>Load1; 【LoadStore】; Store2</code>，这个屏障的作用是保证在Store2存储代码进行写入操作执行前，保证Load1加载代码要从主内存里面读取的数据读取完毕。</p>
<blockquote>
<p>即：该屏障保证了屏障前的读操作效果先于屏障后的写操作效果发生。</p>
</blockquote>
</li>
<li><p><mark>StoreLoad</mark>：对于语句<code>Store1; StoreLoad; Load2</code>，这个屏障的作用是保证load2从主内存里加载数据之前，store1的写入操作已经把数据写入到内存中，确认store1的写入操作对其他处理器可见</p>
<blockquote>
<p>即：该屏障保证了屏障前的写操作效果先于屏障后的读操作效果发生。可能的做法就是插入一个smp_mb指令来完成。StoreLoad屏障是开销最昂贵的一种屏障，其中一部分原因是因为他需要把写缓冲区的所有数据全部刷新到内存</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><blockquote>
<p>可见性的实现依靠了：lock前缀指令 + MESI缓存一致性协议</p>
</blockquote>
<h4 id="实现原理-Lock前缀"><a href="#实现原理-Lock前缀" class="headerlink" title="实现原理 - Lock前缀"></a>实现原理 - Lock前缀</h4><p>被volatile修饰的字段会在其对应的汇编操作指令上加个<strong>lock前缀指令</strong>，这个指令就可以解决可见性问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改了共享变量flag的值&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其执行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/67587e41ea3db7fca75c01ac163d66d6.png" alt="在这里插入图片描述"></p>
<p>lock前缀的指令在多核处理器下会引发两件事情</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但是操作完了不知道什么时候写回内存。而对声明了volatile关键字的变量进行写操作，JVM会向处理器发送一条lock前缀的指令，将这个变量所在的缓存行立即写回系统内存。并且为了保证各个处理器的缓存是一致的，实现了<code>缓存一致性协议</code>，各个处理通过<code>嗅探</code>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，那么下次对这个数据进行操作，就会重新从系统内存中获取最新的值。对应JMM来说就是：</p>
<ol>
<li>Lock前缀的指令让线程工作内存中的值写回主内存中；</li>
<li>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</li>
<li>其他线程会重新从主内存中获取最新的值；</li>
</ol>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><blockquote>
<p>可靠性的实现依靠了：内存屏障，禁止了重排序</p>
</blockquote>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515162606107.png" alt="image-20210515162606107"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210515162606107.png" alt></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h3><p>使用锁时，线程获取锁是一种<strong>悲观锁策略</strong>，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种<strong>乐观锁策略</strong>，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。</p>
<p>因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用<strong>CAS(compare and swap / 比较与替换)</strong>又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。</p>
<ul>
<li>悲观锁：会阻塞其他线程</li>
<li>乐观锁：不会阻塞其他线程，如果发生冲突，采用死循环的方式一直重试，直到更新成功。</li>
</ul>
<p>是一种<strong>无锁算法</strong></p>
<h3 id="CAS操作过程"><a href="#CAS操作过程" class="headerlink" title="CAS操作过程"></a>CAS操作过程</h3><p>CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：<strong>V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值</strong>。</p>
<ul>
<li>当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。</li>
<li>反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程</li>
</ul>
<p>CAS的实现需要硬件指令集的支撑，在JDK1.5后虚拟机才可以使用处理器提供的<strong>CMPXCHG</strong>指令实现。</p>
<blockquote>
<p>Synchronized VS CAS</p>
</blockquote>
<p>元老级的Synchronized(未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而CAS并不是武断的间线程挂起，当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。</p>
<h3 id="CAS应用场景"><a href="#CAS应用场景" class="headerlink" title="CAS应用场景"></a>CAS应用场景</h3><p>在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现。具体实现后续详细聊；</p>
<h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><p><strong>1. ABA问题</strong><br>因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3C。java这么优秀的语言，当然在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的。</p>
<p><strong>2. 自旋时间过长</strong></p>
<p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。</p>
<p><strong>3. 只能保证一个共享变量的原子操作</strong></p>
<blockquote>
<p>原子性：原子性问题指的是多线程并发的情况下，当我们要进行数据的读取与修改时，可能会因为线程同时读取数据，导致进行了重复修改的情况，但是我们希望每个线程进行读取修改操作是连贯的、原子性的，在A线程进行读取修改的时候，不允许其他线程进行读取修改，而一定要等到A线程完成修改后，其他线程再去进行读取修改。比如我们要将数字0累加到10，在多线程的情况下，可能会因为线程A在读完数字但是还没有进行修改的时候，线程B也来读了数字，导致线程A的原子性被打破，使得它们累加后得到的数据是一样的，这就破坏了原子性。</p>
</blockquote>
<p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p>
<h2 id="Java对象头-monitor"><a href="#Java对象头-monitor" class="headerlink" title="Java对象头 monitor"></a>Java对象头 monitor</h2><blockquote>
<p> Java对象头和monitor是实现synchronized的基础</p>
</blockquote>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210426161645623.png" alt="image-20210426161645623"></p>
<ul>
<li><p>实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
</li>
<li><p>对齐填充：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐</p>
</li>
<li><p>对象头</p>
<ul>
<li><p>普通对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200903143715550.png" alt="在这里插入图片描述"></p>
</li>
<li><p>数组对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200903143731342.png" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h4 id="对象头的组成"><a href="#对象头的组成" class="headerlink" title="对象头的组成"></a>对象头的组成</h4><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><blockquote>
<p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等</p>
</blockquote>
<ul>
<li>32位JVM 的Mark Word的默认存储结构</li>
</ul>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190308094615410.png" alt="img"></p>
<ul>
<li><p>具体结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200225114028735.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>锁标记位（lock）</strong>：该标记的值不同，则Mark word表示的含义不同</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200225113633471.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>无锁：</strong>无锁状态时，存储的是对象的hashcode值</li>
<li><strong>偏向锁</strong>：偏向锁时，<strong>前23位存储偏向的线程ID</strong>，并将倒数第三位置为1，表示偏向锁。</li>
<li><strong>轻量级锁</strong>：轻量级锁时，存储的是 <strong>指向JVM栈中的锁记录Lock Record的指针</strong></li>
<li><strong>重量级锁</strong>：当自旋次数超过10次时，将转换成重量级锁，重量级锁存储的是 <strong>指向重量级锁Monitor的指针</strong></li>
</ul>
</li>
<li><p><strong>是否为偏向锁（biased_lock）</strong>：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。</p>
</li>
<li><p><strong>对象分代年龄（age）</strong>：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为15的原因。</p>
</li>
<li><p><strong>identity_hashcode</strong>： 25位的对象标识<mark>Hash码</mark>，采用延迟加载技术。调用方法<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。</p>
</li>
<li><p><strong>thread</strong>： 持有偏向锁的线程ID。</p>
</li>
<li><p><strong>epoch</strong>：偏向时间戳。</p>
</li>
<li><p><strong>ptr_to_lock_record</strong>：指向栈中锁记录的指针。</p>
</li>
<li><p><strong>ptr_to_heavyweight_monitor</strong>：指向管程Monitor的指针。</p>
</li>
</ul>
<h5 id="class-pointer"><a href="#class-pointer" class="headerlink" title="class pointer"></a>class pointer</h5><blockquote>
<p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。</p>
</blockquote>
<p>为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。</p>
<h5 id="array-length"><a href="#array-length" class="headerlink" title="array length"></a>array length</h5><p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。</p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><blockquote>
<p>monitor是什么？它是一个同步工具，是一种同步机制，通常被描述为一个【对象】；</p>
<p>monitor概念其实我们早就接触过了，它就是OS中的【管程】；</p>
</blockquote>
<p>Monitor是一个对象，这代表着什么？在Java世界中，一切皆对象，那么所有的Java对象其实都是monitor，或者说所有的对象都可以去关联一个<strong>Monitor</strong>对象。（这也是为什么上面需要学习Java对象头，因为结合monitor我们就可以通过设置标识位做到线程同步了）</p>
<ul>
<li><strong>Monitor概念</strong></li>
</ul>
<p>Monitor 是<mark><strong>线程私有</strong></mark>的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个<strong>全局的可用列表</strong>。</p>
<p>每一个被锁住的对象都会和一个monitor关联（对象头<strong>的MarkWord</strong>中的<strong>LockWord</strong>指向<strong>monitor的起始地址</strong>）</p>
<p>同时monitor中有一个<strong>Owner字段</strong>存放拥有<strong>该锁的线程的唯一标识</strong>，表示该锁被这个线程占用</p>
<ul>
<li><strong>Monitor结构图</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170205214544590" alt="这里写图片描述"></p>
<ol>
<li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li><strong>Nest</strong>:用来实现重入锁的计数。</li>
<li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ol>
<h2 id="synchronized（内置锁）"><a href="#synchronized（内置锁）" class="headerlink" title="synchronized（内置锁）"></a>synchronized（内置锁）</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Java中最常用的同步机制就是<strong>synchronized关键字</strong>，它是一种基于语言的<strong>粗略锁</strong>（也就是说本质其实也是一把锁），能够作用于<strong>对象、函数、Class</strong>上。</p>
<p>synchronized是一种<strong>互斥锁</strong>：意味着一次只能允许一个线程进入被锁住的代码块</p>
<p>synchronized是一种<strong>内置锁/监视器锁</strong>：Java中每个对象都有一个<strong>内置锁（监听器monitor，可理解为锁标记）</strong>，synchronized就是通过使用<strong>对象的内置锁（监听器）</strong>来将代码块（方法）锁定的。（这部分内容结合monitor的相关知识好理解一点）</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ul>
<li>synchronized保证了线程的<strong>原子性</strong>。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</li>
<li>synchronized还保证了<strong>可见性</strong>。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</li>
</ul>
<p>Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了<strong>对变量操作的原子性和其他线程对变量的可见性</strong>，从而确保了并发情况下的线程安全。</p>
<p>一句话来说：</p>
<blockquote>
<p>synchronized修饰的区域看作是一个临界区，临界区内只能有一个线程在访问，当访问线程退出临界区，另一个线程才能访问临界区资源。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>synchronized原理 - 指令层面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method 1 start&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160414215316020-1963237484.png" alt="img"></p>
<hr>
<p>这里出现了两个关键指令【monitorenter】和【monitorexit】</p>
<p>【monitorenter】</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权（类似于操作系统中的<strong>P操作</strong>），过程如下：</p>
<ol>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li>
</ol>
<p>【monitorexit】</p>
<p>注意：执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>该指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。（类似于OS中的<strong>V操作</strong>）其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
<hr>
<p>结合这两个指令的含义，我们能够推断出Synchronized的实现原理：Synchronized的语义底层是通过一个monitor的对象来完成类似于OS中的PV操作，达到线程同步。</p>
<ul>
<li><strong>synchronized实现原理 - 底层/字节码层面</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/820406-20160418202553429-1642545018.png" alt="img"></p>
<p>从字节码中可以看出，synchronized修饰的方法并没有<strong>monitorenter指令和monitorexit指令</strong>，取得代之的确实是<mark>ACC_SYNCHRONIZED标识</mark>，该标识指明了该方法是一个同步方法，JVM通过该<mark>ACC_SYNCHRONIZED标识</mark>访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</p>
<p>具体实现：</p>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><strong>使用synchronized实现同步</strong></li>
</ul>
<p>使用synchronized关键字声明的方法 成为了 临界区。这样做，就使得临界区被创建出来了，由之前所学可以知道，同一个对象的临界区，在同一时间只有一个允许被访问。</p>
<blockquote>
<p>用synchronized关键字声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的synchronized方法，其中一个是静态方法，一个是非静态方法</p>
</blockquote>
<h4 id="synchronized作用于实例方法"><a href="#synchronized作用于实例方法" class="headerlink" title="synchronized作用于实例方法"></a>synchronized作用于实例方法</h4><blockquote>
<p>修饰实例方法，作用于当前【实例对象】加锁，进入同步代码前要获得当前【实例对象】的锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 2000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>我们使用<strong>static关键字</strong>构造了一个临界资源：<code>static int i=0;</code></p>
<p>同时，构建了一个实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>i++</code>的操作并不具备<strong>原子性</strong>（先读i的值，对i进行++操作，后写回新值），如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。</p>
<p><code>synchronized</code>修饰的是实例方法<code>increase()</code>，即：当前线程上的锁作用于<strong>实例对象instance</strong></p>
<p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法。</p>
<hr>
<p>如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncBad</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>代码解释</strong>：</p>
<p>这段代码中创建了两个新实例：AccountingSyncBad</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new新实例</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line"><span class="comment">//new新实例</span></span><br><span class="line">Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br></pre></td></tr></table></figure>

<p>然后启动两个不同的线程对共享变量i进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        increase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但结果却不会是<mark>2000000</mark>，因为虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的</p>
<p><strong>解决方案：</strong></p>
<p>将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。</p>
<hr>
<h4 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h4><blockquote>
<p>修饰静态方法，作用于当前【类对象/class对象】加锁，进入同步代码前要获得当前【类对象/class对象】的锁</p>
</blockquote>
<p>果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，是因为：</p>
<ul>
<li><p>访问<strong>静态 synchronized 方法</strong>占用的<strong>锁</strong>是<strong>当前类的class对象</strong></p>
</li>
<li><p>而访问<strong>非静态 synchronized 方</strong>法占用的<strong>锁</strong>是当前<strong>实例对象（this）</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用于静态方法,锁是当前class对象,也就是</span></span><br><span class="line"><span class="comment">     * AccountingSyncClass类对应的class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态,访问时锁不一样不会发生互斥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase4Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>由于<strong>synchronized关键字</strong>修饰的是<code>静态increase</code>方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的<code>increase4Obj方法</code>是<strong>实例方法</strong>，其对象锁是<strong>当前实例对象</strong>，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题（操作了共享静态变量i）。</p>
<hr>
<h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><blockquote>
<p>修饰代码块，指定加锁对象，对【给定对象（括号中的对象）】加锁，进入同步代码库前要获得【给定对象（括号中的对象）】的锁</p>
</blockquote>
<ul>
<li><strong>使用场景</strong></li>
</ul>
<p>在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>代码解释：</p>
<p>将synchronized作用于一个给定的<strong>实例对象instance</strong>，即当前实例对象就是锁对象，每次当线程进入<strong>synchronized</strong>包裹的代码块时就会要求当前线程持有<strong>instance实例对象锁</strong>，如果当前有其他线程正持有<strong>该对象锁</strong>，那么新到的线程就必须<strong>等待</strong>，这样也就保证了每次只有一个线程执行<code>i++;</code>操作。</p>
<hr>
<p>另外一种写法，用<code>this对象</code>（代表当前实例）或者直接用当前类的class对象作为锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this,当前实例对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(AccountingSync.class)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁-锁优化"><a href="#锁-锁优化" class="headerlink" title="锁/锁优化"></a>锁/锁优化</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。</p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，这种策略是为了提高获得锁和释放锁的效率</p>
</blockquote>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由<strong>同一线程</strong>多次获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">&quot;test:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了<code>synchronized</code>的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作。</p>
<p>因此为了<strong>减少同一线程获取锁（会涉及到一些CAS操作,耗时）的代价</strong>，或者说为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，我们引入了<mark>偏向锁</mark>。</p>
<ul>
<li><strong>思想</strong></li>
</ul>
<p>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能</p>
<ul>
<li><strong>具体执行</strong></li>
</ul>
<ol>
<li><p><strong>对象创建</strong></p>
<p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（默认所有class的偏向模式都是是开启的，可通过参数关闭），那<strong>新创建对象</strong>的<code>mark word</code>将是<mark>可偏向状态</mark>，此时<code>mark word中</code>的<strong>thread id</strong>为<strong>0</strong>：表示未偏向任何线程，也叫做<strong>匿名偏向（anonymously biased）</strong>。</p>
</li>
<li><p><strong>加锁/获取锁过程</strong></p>
<ol>
<li><p>检测Mark Word是否为<mark>可偏向状态</mark>。即访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p>
</li>
<li><p>假如是<mark>可偏向状态</mark>，则测试<strong>线程ID是否指向当前线程</strong>，如果是，会往当前线程的栈中添加一条<code>Displaced Mark Word</code>为空的<code>Lock Record</code>中，进入步骤（5）；如果<strong>线程ID不指向当前线程</strong>，则进入步骤（3）。</p>
<p>（当该对象<strong>第一次</strong>被线程获得锁的时候，发现是<strong>匿名偏向状态（即thread id = 0）</strong>，则会用CAS指令，将<code>mark word</code>中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。在以后只要不发生竞争，这个对象就归该线程所持有。失败的话，进入步骤（4））</p>
<blockquote>
<p>当被偏向的线程再次进入同步块时，操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，<code>synchronized</code>关键字带来的性能开销基本可以忽略</p>
</blockquote>
</li>
<li><p>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID（<strong>竞争成功的线程将获得偏向锁的所有权</strong>），然后执行（5）；如果竞争失败，执行（4）。</p>
</li>
<li><p>【<mark><strong>进行撤销偏向锁的操作</strong></mark>】通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达<strong>全局安全点（safepoint）</strong>，之前<strong>获得偏向锁</strong>的线程被<strong>挂起</strong>，对该线程进行状态判断。</p>
<ol>
<li>若线程仍存活且还在同步块：锁升级为轻量级锁。</li>
<li>如果偏向的线程已经不存活或者不在同步块中：则将对象头的<code>mark word</code>改为无锁状态（unlocked），偏向锁不升级，并且环形</li>
</ol>
</li>
<li><p>执行同步代码块</p>
</li>
</ol>
<p>由此可见：偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>解锁/偏向锁释放过程</strong></p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点<code>safe point</code>（在这个时间点上没有字节码正在执行）</p>
<ol>
<li>它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>偏向锁的获取/解锁流程图解</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429174346151.png" alt="image-20210429174346151"></p>
<ul>
<li><strong>锁状态的转换流程</strong></li>
</ul>
<p><img src="https://camo.githubusercontent.com/a63795e864c710178fada8ddc8748c064185bd474fe0f4d2254dfc4e708305ff/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32382f313637353964643162323739343633623f773d35393826683d32383526663d706e6726733d3232323430" alt="img"></p>
<p>1）一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p>
<p>2） 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了。检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程。如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁；如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p>
<p>3）轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>
<h4 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h4><ul>
<li><strong>概述</strong></li>
</ul>
<p>对于偏向锁的加锁解锁过程，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到<code>safe point</code>时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。</p>
<p>想一想，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降，那么有没有一种方法可以改变这种情况呢？JVM替我们想到了这个问题的解决方案 —— 引入了批量重偏向/撤销的机制。</p>
<ul>
<li><strong>批量重偏向</strong></li>
</ul>
<blockquote>
<p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。</p>
</blockquote>
<p>举个例子：在不存在锁竞争的条件下，如果同一个类有50个对象偏向线程t1，而线程t2又分别对这50个对象进行循环加锁，此时t2加锁的<strong>前19个对象</strong>会膨胀为<strong>轻量锁</strong>，等到<strong>第20个对象</strong>时，JVM会预测这个类后面的所有对象都要偏向t2，所以再加锁时，就不会执行锁膨胀了，而是<strong>重偏向到线程t2</strong>。</p>
<p><strong>具体实现</strong></p>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到<strong>重偏向阈值（默认20）</strong>时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的<code>epoch</code>字段，每个处于偏向锁状态对象的<code>mark word中</code>也有该字段，其初始值为创建该对象时，class中的<code>epoch</code>的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其<code>epoch</code>字段改为新值。下次获得锁时，发现当前对象的<code>epoch</code>值和class的<code>epoch</code>不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其<code>mark word</code>的Thread Id 改成当前线程Id。</p>
<ul>
<li><strong>批量撤销（批量撤销偏向锁）</strong></li>
</ul>
<blockquote>
<p>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p>
</blockquote>
<p>举个例子：</p>
<ul>
<li><p>假设有80个A类的对象实例，开始时全部偏向线程t1，然后t2线程对第1-40个对象又进行了加锁处理</p>
<ul>
<li><p>此时根据批量重定向机制，<strong>1-19</strong>个对象先是会膨胀为轻量级锁，退出同步块后变为无锁；</p>
</li>
<li><p>而第<strong>20-40</strong>个对象会因为触发批量重定向，锁状态变为偏向t2线程的偏向锁。</p>
</li>
<li><p>这时t3线程来了，它对第21-43个对象进行加锁处理（注意t3线程的前20个对象不能跟t2线程的前20个对象重合），这时由于t2线程撤销偏向锁撤销了19次（JVM会按20次计算），t3线程撤销偏向锁撤销了19次（JVM会按20次计算），总共撤销的次数达到了40的阈值</p>
<p>此时JVM会判定为这个A类的对象有问题（不断的切换偏向线程会降低执行效率），从第21-43，都会变为轻量级锁，不再进行重偏向操作，而且会对这个A类的对象关闭偏向的设置，即往后再newA类的对象时，不会进入偏向锁状态，只能走<code>无锁 - 轻量级锁 - 重量级锁</code>的膨胀过程。所以批量撤销全称应该为：<strong>批量撤销偏向锁</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1558028-20191201175406151-122576693.png" alt="img"></p>
<p>一言蔽之：当达到重偏向阈值（20）后，若class计数器还在继续增长，那么其达到批量撤销的阈值后（默认40），JVM认为该class的使用场景是存在<strong>多线程竞争</strong>的，就标记该class为<mark>不可偏向</mark>，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul>
<li><strong>背景</strong></li>
</ul>
<p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在<strong>竞争</strong>的，即不同的线程交替的执行同步块中的代码。我们应该减少传统的重量级锁带来的性能消耗（重量级锁使用操作系统互斥量去实现同步）。</p>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁将会导致<strong>偏向锁</strong>升级为<strong>轻量级锁</strong></p>
<ul>
<li><strong>Lock Record</strong></li>
</ul>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个<code>Lock Record</code>，其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为<code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428201217469.png" alt="image-20210428201217469"></p>
<ul>
<li><strong>加锁过程</strong></li>
</ul>
<p>下列代码中：有2个方法同步代码块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> ( obj ) &#123;</span><br><span class="line">         <span class="comment">//同步块A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">         <span class="comment">//do something...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428203105992.png" alt="image-20210428203105992"></p>
</li>
<li><p>执行到<code>synchronized ( obj )</code>后</p>
<ol>
<li>让<code>锁记录（Lock Record）</code>中的Object reference指向锁对象（Object）</li>
<li>JVM利用CAS去操作尝试用<code>Displaced Mark Word</code>去替换对象头中的<code>Mark Word</code>如果成功了，就表示竞争到锁了，标志位从<strong>01</strong>更新为<strong>00</strong>（表示此对象处于轻量级锁状态）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428203519196.png" alt="image-20210428203519196"></p>
<p>下图为CAS替换成功后的状态，对象头中存储了<strong>锁记录地址和状态 00</strong>，表示由该线程给对象加锁</p>
<p><img src="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210428204323729.png" alt="image-20210428204323729"></p>
</li>
<li><p>假如CAS替换失败，则表示两种情况</p>
<ol>
<li><p>若是其他线程已经持有了该<strong>Object</strong>的轻量级锁，就代表着有竞争，下面就进入<mark>锁膨胀过程</mark></p>
</li>
<li><p>若是自己执行了<code>Synchronized锁重入</code>，就设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用（即添加一条Lock Record作为重入的计数）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428204857790.png" alt="image-20210428204857790"></p>
</li>
</ol>
<p>此时，将会发生<strong>锁膨胀</strong>（轻量级锁 升级为 重量级锁）</p>
</li>
</ol>
<ul>
<li><strong>解锁过程</strong></li>
</ul>
<ol>
<li><p>首先.遍历线程栈,找到所有<code>obj</code>字段等于当前锁对象的<code>Lock Record</code>。</p>
</li>
<li><p>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>为null，代表这是一次重入，就重置锁记录（将<code>obj</code>设置为null），表示重入计数 -1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428205823619.png" alt="image-20210428205823619"></p>
</li>
<li><p>如果<code>Lock Record</code>的<code>Displaced Mark Word</code>不为null，则利用CAS指令将<strong>对象头</strong>的<code>mark word</code>恢复成为<code>Displaced Mark Word</code>。</p>
<p>（这里也可以解释，为什么获得锁时，我们将<code>Lock Record</code>中的<code>Displaced Mark Word</code>与对象头中的<code>Mark Word</code>进行交换操作了，在解锁的时候可以还原状态嘛）</p>
<ol>
<li>如果成功，则表示解锁成功</li>
<li>如果失败，说明轻量级锁进行锁膨胀/已经升级为重量级锁，就不能按照轻量级锁去办事，下面就会进入重量级锁解锁过程</li>
</ol>
</li>
</ol>
<ul>
<li><strong>轻量级锁的获取和释放过程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429180918744.png" alt="image-20210429180918744"></p>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>在上述轻量级锁的获取步骤中，我们提及了一个锁膨胀的概念，其发生在其他线程为相同对象加上了<strong>轻量级锁</strong>，这个时候就需要进行<mark>锁膨胀</mark>了，即将轻量级锁升级为重量级锁</p>
<blockquote>
<p>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</p>
<p>而最为我们所熟知的重量级锁就是Synchronized了</p>
</blockquote>
<ul>
<li><strong>引入</strong></li>
</ul>
<p>如下图所示，T1想要对对象进行轻量级加锁时，发现T0先它一步，已经给该对象加上了轻量级锁（发现后两位是00）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428211813089.png" alt="image-20210428211813089"></p>
<ul>
<li><strong>锁膨胀过程</strong></li>
</ul>
<p>以上述情况为例</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>为Objcet对象申请<code>Monitor</code>锁(最后两位改成10），让Object指向重量级锁的地址</p>
</li>
<li><p>接着T1线程进入<code>Monitor</code>的*<em>EnrtyList *</em>发生阻塞</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210428212641730.png" alt="image-20210428212641730"></p>
</li>
</ol>
<p><strong>释放锁</strong></p>
<p>当T0退出同步块进行解锁的时候，会使用<strong>CAS</strong>将<code>Displaced Mark Word</code>的值还原给对象头，但这一步能成功吗？不能，因为此时对象的后两位是10，是重量级锁。之前轻量级锁那一套在这里不管用了，接下来就会进入重量级锁的解锁流程</p>
<ol>
<li>首先按照Monitor的地址找到Monitor对象</li>
<li>设置Owner为Null</li>
<li>唤醒<strong>EnrtyList</strong>中阻塞的线程</li>
</ol>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>由于线程的<strong>阻塞和唤醒</strong>需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。而同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的——因此我们引入了<strong>自旋锁</strong></p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>所谓<strong>自旋锁</strong>，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p>
<p>使用场景：当重量级锁竞争的时候可以使用自旋进行优化处理，如果<strong>当前线程</strong>自旋成功了（即这时候<strong>持锁的线程</strong>已经退出了同步块，释放了锁 ），这个时候<strong>当前的线程</strong>就可以避免阻塞，减少CPU切换，提高系统并发性。</p>
<ul>
<li><strong>自旋成功情况</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429154732197.png" alt="image-20210429154732197"></p>
<ul>
<li><strong>自旋失败情况</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210429154840307.png" alt="image-20210429154840307"></p>
<ul>
<li><strong>注意点</strong></li>
</ul>
<p><strong>自旋等待不能替代阻塞</strong>。虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作。（占有处理器，却不做任何事）。这会带来性能上的浪费。</p>
<p>因此，<strong>自旋不能无限自旋</strong>，自旋的次数必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>自旋是会占用处理机的时间的，自旋的思想是先等待一下，让执行同步块的线程跑一下，看看自旋后的线程能不能过会能不能用上处理机，因此单核CPU使用自旋有意义吗？没有。<strong>因此单核CPU自旋就是浪费，只有多核CPU自旋才能够发挥优势</strong></p>
<p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整</p>
<h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>在学习自旋锁相关知识时，我们发现：如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），这种情况就显得我们很蠢。</p>
<p>于是JDK1.6引入<strong>自适应的自旋锁</strong>，让虚拟机会变得越来越聪明。</p>
<ul>
<li><strong>概述</strong></li>
</ul>
<p>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h3 id="锁转换流程图"><a href="#锁转换流程图" class="headerlink" title="锁转换流程图"></a>锁转换流程图</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200728235120589.png" alt="img"></p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到<strong>不可能存在共享数据竞争</strong>，这是JVM会对这些同步锁进行锁消除；</p>
<ul>
<li><strong>依据</strong></li>
</ul>
<p>锁消除的依据是<strong>逃逸分析</strong>的数据支持。这也是jvm的语法糖的一种，是编译器的一种优化措施。</p>
<p>锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定。</p>
<ul>
<li><strong>例子</strong></li>
</ul>
<p>有时候，我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><ul>
<li><strong>概述</strong></li>
</ul>
<p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小，即仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。</p>
<ul>
<li><strong>例子</strong></li>
</ul>
<p>类似锁消除的<code>concatString()</code>方法。如果<code>StringBuffer sb = new StringBuffer();</code>定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把<strong>加锁同步的范围</strong>扩展到整个操<strong>作序列的外部</strong>，即扩展到【<strong>第一个append()操作之前和最后一个append()操作之后</strong>】，这样的一个锁范围扩展的操作就称之为<mark>锁粗化</mark>。</p>
<p>用上述的锁消除的代码为例的话：</p>
<p>JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<blockquote>
<p>将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
</blockquote>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final基础"><a href="#final基础" class="headerlink" title="final基础"></a>final基础</h3><p>final基础在java基础部分有学习过：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#final">https://uesugier11.gitee.io/uesugi-er11/2020/11/14/Java%E5%9F%BA%E7%A1%80/#final</a></p>
<h3 id="多线程中的final"><a href="#多线程中的final" class="headerlink" title="多线程中的final"></a>多线程中的final</h3><h4 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h4><h5 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h5><p>先看一段示例性的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">//普通域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">//final域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1. 写普通域</span></span><br><span class="line">        b = <span class="number">2</span>; <span class="comment">// 2. 写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">        <span class="keyword">int</span> a = demo.a;    <span class="comment">//4.读普通域</span></span><br><span class="line">        <span class="keyword">int</span> b = demo.b;    <span class="comment">//5.读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A在执行writer()方法，线程B执行reader()方法。</p>
<blockquote>
<p><strong>写final域重排序规则</strong></p>
</blockquote>
<p>写final域的重排序规则<strong>禁止对final域的写重排序到构造函数之外</strong>，这个规则的实现主要包含了两个方面：</p>
<ol>
<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>
<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障（关于内存屏障可以看<a target="_blank" rel="noopener" href="https://juejin.im/post/5ae6d309518825673123fd0e">这篇文章</a>）。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>
</ol>
<p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p>
<ol>
<li>构造了一个FinalDemo对象；</li>
<li>把这个对象赋值给成员变量finalDemo。</li>
</ol>
<p>我们来画下存在的一种可能执行时序图，如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-9e3937df955a9862.png" alt="final域写可能的存在的执行时序"></p>
<p>由于a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p>
<p>因此，写final域的重排序规则可以确保：<strong>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障</strong>。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。</p>
<blockquote>
<p><strong>读final域重排序规则</strong></p>
</blockquote>
<p>读final域重排序规则为：<strong>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</strong>（注意，这个规则仅仅是针对处理器），处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
<p>read()方法主要包含了三个操作：</p>
<ol>
<li>初次读引用变量finalDemo;</li>
<li>初次读引用变量finalDemo的普通域a;</li>
<li>初次读引用变量finalDemo的final域b;</li>
</ol>
<p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-2a93b67948d7fc64.png" alt="final域读可能存在的执行时序"></p>
<p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p>
<p>读final域的重排序规则可以确保：<strong>在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</strong></p>
<h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><p>我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了？如果是<strong>引用数据类型</strong>呢？我们接着继续来探讨。</p>
<blockquote>
<p><strong>对final修饰的对象的成员域写操作</strong></p>
</blockquote>
<p>针对引用数据类型，final域写针对编译器和处理器重排序<strong>增加了这样的约束</strong>：在构造函数内对<strong>一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量</strong>，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">            <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论（耐心看完才有收获）。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-1f5f0a39a3f6977e.png" alt="写final修饰引用类型数据可能的执行时序"></p>
<p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<blockquote>
<p><strong>对final修饰的对象的成员域读操作</strong></p>
</blockquote>
<p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>
<blockquote>
<p><strong>关于final重排序的总结</strong></p>
</blockquote>
<p>按照final修饰的数据类型分类：</p>
<p>基本数据类型:</p>
<ol>
<li>final域写：禁止<strong>final域写</strong>与<strong>构造方法</strong>重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li>
<li>final域读：禁止初次<strong>读对象的引用</strong>与<strong>读该对象包含的final域</strong>的重排序。</li>
</ol>
<p>引用数据类型：</p>
<p>额外增加约束：禁止在构造函数对<strong>一个final修饰的对象的成员域的写入</strong>与随后将<strong>这个被构造的对象的引用赋值给引用变量</strong> 重排序</p>
<h3 id="final实现原理"><a href="#final实现原理" class="headerlink" title="final实现原理"></a>final实现原理</h3><p>上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</p>
<p>很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以<strong>StoreStore屏障可以省略</strong>。由于<strong>不会对有间接依赖性的操作重排序</strong>，所以在X86处理器中，读final域需要的<strong>LoadLoad屏障也会被省略掉</strong>。也就是说，<strong>以X86为例的话，对final域的读/写的内存屏障都会被省略</strong>！具体是否插入还是得看是什么处理器</p>
<h3 id="为什么final引用不能从构造函数中-“逸出”"><a href="#为什么final引用不能从构造函数中-“逸出”" class="headerlink" title="为什么final引用不能从构造函数中 “逸出”"></a>为什么final引用不能从构造函数中 “逸出”</h3><p>这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：<strong>在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”</strong>。以下面的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">//1</span></span><br><span class="line">        referenceDemo = <span class="keyword">this</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> temp = referenceDemo.a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的执行时序如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-e020492056ee1242.png" alt="final域引用可能的执行时序"></p>
<p>假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p>
<h1 id="Lock体系"><a href="#Lock体系" class="headerlink" title="Lock体系"></a>Lock体系</h1><h2 id="cocurrent包结构层次"><a href="#cocurrent包结构层次" class="headerlink" title="cocurrent包结构层次"></a>cocurrent包结构层次</h2><p>在针对并发编程中，Doug Lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-da951eb99c5dabfd.png" alt="concurrent目录结构.png"></p>
<p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors,这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及CAS，从整体上来看concurrent包的整体实现图如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-24da822ddc226b03.png" alt="concurrent包实现整体示意图.png"></p>
<h2 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h2><p>我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</p>
<p>在Lock接口出现之前，java程序主要是靠<code>synchronized</code>关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。</p>
<p><strong>虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</strong>通常使用显示使用lock的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<strong>synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁</strong>。</p>
<h2 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h2><p>我们现在就来看看lock接口定义了哪些方法：</p>
<blockquote>
<p>void lock(); //获取锁<br>void lockInterruptibly() throws InterruptedException；//获取锁的过程能够响应中断<br>boolean tryLock();//非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle<br>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//超时获取锁，在超时内或者未中断的情况下能够获取锁<br>Condition newCondition();//获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</p>
</blockquote>
<p>上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的ReentrantLock说起。</p>
<blockquote>
<p>public class ReentrantLock implements <strong>Lock</strong>, java.io.Serializable</p>
</blockquote>
<p>很显然ReentrantLock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。</p>
<p>当你查看源码时你会惊讶的发现ReentrantLock并没有多少代码，另外有一个很明显的特点是：<strong>基本上所有的方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而Sync类继承了<code>AbstractQueuedSynchronizer（AQS）</code></strong>。</p>
<p>可以看出要想理解ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer（简称同步器）的理解。</p>
<h2 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><strong>AQS - 抽象 队列 同步器；简称同步器</strong></li>
</ul>
<p>关于AQS在源码中有十分具体的解释：</p>
<pre><code>Provides a framework for implementing blocking locks and related
synchronizers (semaphores, events, etc) that rely on
first-in-first-out (FIFO) wait queues.  This class is designed to
be a useful basis for most kinds of synchronizers that rely on a
single atomic &#123;@code int&#125; value to represent state. Subclasses
must define the protected methods that change this state, and which
define what that state means in terms of this object being acquired
or released.  Given these, the other methods in this class carry
out all queuing and blocking mechanics. Subclasses can maintain
other state fields, but only the atomically updated &#123;@code int&#125;
value manipulated using methods &#123;@link #getState&#125;, &#123;@link
#setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect
to synchronization.

&lt;p&gt;Subclasses should be defined as non-public internal helper
classes that are used to implement the synchronization properties
of their enclosing class.  Class
&#123;@code AbstractQueuedSynchronizer&#125; does not implement any
synchronization interface.  Instead it defines methods such as
&#123;@link #acquireInterruptibly&#125; that can be invoked as
appropriate by concrete locks and related synchronizers to
implement their public methods.</code></pre><p>同步器是用来构建锁和其他同步组件的基础框架</p>
<ul>
<li><strong>它的实现方式（同步状态 + 等待队列）</strong><ul>
<li>依赖一个int成员变量来表示同步状态</li>
<li>再通过一个<mark>FIFO队列构成等待队列</mark>。</li>
</ul>
</li>
</ul>
<p>它的<strong>子类必须重写AQS的几个protected修饰的用来改变同步状态的方法</strong>，其他方法主要是实现了排队和阻塞机制。</p>
<p><strong>状态的更新使用getState,setState以及compareAndSetState（也就是我们常说的<mark>CAS</mark>）这三个方法</strong>。</p>
<p>子类被<strong>推荐定义为自定义同步组件的静态内部类</strong>，同步器自身<strong>没有实现</strong>任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<ul>
<li><strong>理解二者的关系</strong></li>
</ul>
<p><strong>锁是面向【使用者】，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的【实现者】，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作</strong>。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p>
<h3 id="AQS模板方法设计模式"><a href="#AQS模板方法设计模式" class="headerlink" title="AQS模板方法设计模式"></a>AQS模板方法设计模式</h3><ul>
<li>AQS的设计是使用【<mark>模板方法设计模式</mark>】，它将<strong>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</strong></li>
</ul>
<p>举个例子，AQS中需要重写的方法tryAcquire：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock中NonfairSync（继承AQS，本质是一个锁）会重写该方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而AQS中的模板方法acquire():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式，在弄懂这点后会lock的实现理解有很大的提升。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p>可以归纳总结为这么几点：</p>
<ol>
<li>同步组件（这里不仅仅指锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState(),setState(),compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
<p>AQS可重写的方法如下图（摘自《java并发编程的艺术》一书）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-214b5823e76f8eb0.png" alt="AQS可重写的方法.png"></p>
<p>在实现同步组件时AQS提供的模板方法如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-214b5823e76f8eb0.png" alt="AQS提供的模板方法.png"></p>
<p>AQS提供的模板方法可以分为3类：</p>
<ol>
<li>独占式获取与释放同步状态；</li>
<li>共享式获取与释放同步状态；</li>
<li>查询同步队列中等待线程情况；</li>
</ol>
<p>同步组件通过AQS提供的模板方法实现自己的同步语义。</p>
<h3 id="AQS底层细节"><a href="#AQS底层细节" class="headerlink" title="AQS底层细节"></a>AQS底层细节</h3><h4 id="AQS模板方法"><a href="#AQS模板方法" class="headerlink" title="AQS模板方法"></a>AQS模板方法</h4><p>在同步组件的实现中，AQS是核心部分，同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对<strong>同步状态的管理，以及对阻塞线程进行排队，等待通知</strong>等等一些底层的实现处理。</p>
<p>AQS的核心也包括了这些方面:<strong>同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现</strong>，而这些实际上则是AQS提供出来的模板方法，归纳整理如下：</p>
<p><strong>独占式锁：</strong></p>
<blockquote>
<p>void acquire(int arg)：独占式获取同步状态，如果获取失败则插入同步队列进行等待；<br>void acquireInterruptibly(int arg)：与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；<br>boolean tryAcquireNanos(int arg, long nanosTimeout)：在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;<br>boolean release(int arg)：释放同步状态，该方法会唤醒在同步队列中的下一个节点</p>
</blockquote>
<p><strong>共享式锁：</strong></p>
<blockquote>
<p>void acquireShared(int arg)：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；<br>void acquireSharedInterruptibly(int arg)：在acquireShared方法基础上增加了能响应中断的功能；<br>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在acquireSharedInterruptibly基础上增加了超时等待的功能；<br>boolean releaseShared(int arg)：共享式释放同步状态</p>
</blockquote>
<p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。在学习这些模板方法之前，我们得首先了解下AQS中的同步队列是一种什么样的数据结构，因为同步队列是AQS对同步状态的管理的基石。</p>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。</p>
<p>就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是<strong>通过链式方式</strong>进行实现。接下来，很显然我们至少会抱有这样的疑问：</p>
<ol>
<li><strong>节点的数据结构是什么样的？</strong></li>
<li><strong>是单向还是双向？</strong></li>
<li><strong>是带头结点的还是不带头节点的？</strong></li>
</ol>
<ul>
<li><strong>Node类 属性</strong></li>
</ul>
<p>在AQS有一个静态内部类Node，其中有这样一些属性：</p>
<blockquote>
<p>volatile int waitStatus //节点状态<br>volatile Node prev //当前节点/线程的前驱节点<br>volatile Node next; //当前节点/线程的后继节点<br>volatile Thread thread;//加入同步队列的线程引用<br>Node nextWaiter;//等待队列中的下一个节点</p>
</blockquote>
<ul>
<li><strong>节点状态</strong></li>
</ul>
<p>节点的状态有以下这些：</p>
<blockquote>
<p>int CANCELLED =  1//节点从同步队列中取消<br>int SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；<br>int CONDITION = -2//当前节点进入等待队列中<br>int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去<br>int INITIAL = 0;//初始状态</p>
</blockquote>
<p>现在我们知道了节点的数据结构类型，并且每个节点拥有其前驱和后继节点，很显然这是<strong>一个双向队列</strong>。</p>
<p>同样的我们可以用一段demo看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//调用lock方法</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//别忘了解锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例代码中开启了5个线程，先获取锁之后再睡眠10S中，实际上这里让线程睡眠是想模拟出当线程无法获取锁时进入同步队列的情况。</p>
<p>通过debug，当Thread-4（在本例中最后一个线程）获取锁失败后进入同步时，AQS时现在的同步队列如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-d05d3f44ce4c205a.png" alt="LockDemo debug下 .png"></p>
<p>Thread-0先获得锁后进行睡眠，其他线程（Thread-1,Thread-2,Thread-3,Thread-4）获取锁失败进入同步队列，同时也可以很清楚的看出来每个节点有两个域：<strong>prev(前驱)和next(后继)</strong>，并且每个节点用来保存获取同步状态失败的线程引用以及等待状态等信息。</p>
<p>另外AQS中有两个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<p>也就是说AQS实际上通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-d05d3f44ce4c205a.png" alt="队列示意图.png"></p>
<p>通过对源码的理解以及做实验的方式，现在我们可以清楚的知道这样几点：</p>
<ol>
<li><strong>节点的数据结构，即AQS的静态内部类Node,节点的等待状态等信息</strong>；</li>
<li><strong>同步队列是一个双向队列，AQS通过持有头尾指针管理同步队列</strong>；</li>
</ol>
<p>那么，节点如何进行入队和出队是怎样做的了？实际上这对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。</p>
<h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><h5 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h5><p>在上面的demo中我们使用了<code>Lock.lock()</code>上了锁，其本质是获取<strong>独占锁</strong>，获取失败就将当前线程加入同步队列，成功则线程执行</p>
<p>lock()方法实际上会调用AQS的<strong>acquire()</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span></span><br><span class="line">		<span class="comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire根据当前获得同步状态成功与否做了两件事情：</p>
<ol>
<li>成功，则方法结束返回</li>
<li>失败，则先调用addWaiter()然后在调用acquireQueued()方法。</li>
</ol>
<blockquote>
<p><strong>获取同步状态失败，入队操作</strong></p>
</blockquote>
<p>当线程获取独占式锁失败后就会将当前线程加入同步队列，那么加入队列的方式是怎样的了？</p>
<p>我们接下来就应该去研究一下addWaiter()和acquireQueued()。addWaiter()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 将当前线程构建成Node类型</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 2. 当前尾节点是否为null？</span></span><br><span class="line">		Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 2.2 将当前节点尾插入的方式插入同步队列中</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可以看上面的注释。程序的逻辑主要分为两个部分：</p>
<p><strong>1. 当前同步队列的尾节点为null，调用方法enq()插入;</strong></p>
<p><strong>2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail（）方法）的方式入队。</strong></p>
<p>另外还会有另外一个问题：如果 <code>if (compareAndSetTail(pred, node))</code>为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环）进行重试。</p>
<p>因此，经过我们这样的分析，enq()方法可能承担两个任务：</p>
<ol>
<li><strong>处理当前同步队列尾节点为null时进行入队操作；</strong></li>
<li><strong>如果CAS尾插入节点失败后负责自旋进行尝试。</strong></li>
</ol>
<ul>
<li>enq()源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">			<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">				<span class="comment">//1. 构造头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 2. 尾插入，CAS操作失败自旋尝试</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的分析中我们可以看出在第1步中会先创建头结点，说明同步队列是<strong>带头结点的链式存储结构</strong>。</p>
<ul>
<li><strong>带头结点与不带头结点区别</strong></li>
</ul>
<p>带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。</p>
<ul>
<li><strong>队列初始化时机</strong></li>
</ul>
<p>那么带头节点的队列初始化时机是什么？自然而然是在<strong>tail为null时，即当前线程是第一次插入同步队列</strong>。compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，如果CAS操作失败会在<code>for (;;)</code>for死循环中不断尝试，直至成功return返回为止。</p>
<ul>
<li><strong>enq方法总结</strong></li>
</ul>
<p>因此，对enq()方法可以做这样的总结：</p>
<ol>
<li><strong>在当前线程是第一个加入同步队列时，调用compareAndSetHead(new Node())方法，完成链式队列的头结点的初始化</strong>；</li>
<li><strong>自旋不断尝试CAS尾插入节点直至成功为止</strong>。</li>
</ol>
<p>现在我们已经很清楚获取独占式锁失败的线程包装成Node然后插入同步队列的过程了。</p>
<p>那么紧接着会有下一个问题 —— 在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁呢？</p>
<p>带着这样的问题我们就来看看<code>acquireQueued()</code>方法，从方法名就可以很清楚，这个方法的作用就是排队获取锁的过程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">				<span class="comment">// 1. 获得当前节点的先驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">				<span class="comment">// 2. 当前节点能否获取独占式锁					</span></span><br><span class="line">				<span class="comment">// 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">					<span class="comment">//队列头指针用指向当前节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">					<span class="comment">//释放前驱节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;;)），代码首先获取当前节点的先驱节点，<strong>如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head &amp;&amp; tryAcquire(arg))），当前节点所指向的线程能够获取锁</strong>。</p>
<p>反之，获取锁失败进入等待状态。整体示意图为下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-3fe83cfaf03a02c8.png" alt="自旋获取锁整体示意图.png"></p>
<blockquote>
<p><strong>获取锁成功，出队操作</strong></p>
</blockquote>
<p>获取锁的节点出队的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头结点引用指向当前节点</span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">//释放前驱节点</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br></pre></td></tr></table></figure>

<p>setHead()方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前节点通过setHead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用，这样做方便GC时能够将内存进行回收。示意图如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-3fe83cfaf03a02c8.png" alt="当前节点引用线程获取锁，当前节点设置为队列头结点.png"></p>
<p>那么当获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法，看看他们做了什么事情。</p>
<p>shouldParkAfterFailedAcquire()方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法逻辑</strong></li>
</ul>
<p>shouldParkAfterFailedAcquire()方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由INITIAL设置成SIGNAL，表示当前线程阻塞。</p>
<p>当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire方法返回false，然后会在acquireQueued()方法中for (;;)死循环中会继续重试，直至compareAndSetWaitStatus设置节点状态位为SIGNAL时shouldParkAfterFailedAcquire返回true时才会执行方法<code>parkAndCheckInterrupt()</code>方法</p>
<p>该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使得该线程阻塞</span></span><br><span class="line">		LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的关键是会调用LookSupport.park()方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的。因此到这里就应该清楚了，acquireQueued()在自旋过程中主要完成了两件事情：</p>
<ol>
<li><strong>如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出</strong>；</li>
<li><strong>获取锁失败的话，先将节点状态设置成SIGNAL，然后调用LookSupport.park方法使得当前线程阻塞</strong>。</li>
</ol>
<ul>
<li>整体流程图</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="未命名文件 (1)"></p>
<h5 id="独占锁的释放"><a href="#独占锁的释放" class="headerlink" title="独占锁的释放"></a>独占锁的释放</h5><p>独占锁的释放就相对来说比较容易理解了，废话不多说先来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑就比较容易理解了，如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。</p>
<ul>
<li><strong>unparkSuccessor方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点的状态小于0，那么就用CAS去设置成0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取头节点的后继节点（也就是我们真正要去唤醒的节点）</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果后继结点为空 || 后继结点状态 &gt; 0 (为取消状态) 这两种都代表着后继结点都是无效的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//从尾结点开始查找状态不是取消的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//后继节点不为null时唤醒该线程，去竞争同步锁</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码的关键信息请看注释，首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark()方法，该方法会唤醒该节点的后继节点所包装的线程。因此，<strong>每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。</strong></p>
<p>到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。</p>
<ul>
<li><strong>独占锁总结</strong></li>
</ul>
<p>AQS的本质是去维护一个CLH同步队列，具体细节如下：</p>
<ol>
<li><strong>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试</strong>;</li>
<li><strong>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是<mark>头结点</mark>.并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞</strong>；</li>
<li><strong>释放锁的时候会唤醒后继节点；</strong></li>
</ol>
<p>总体来说：<strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p>
<blockquote>
<p><strong>独占锁特性学习</strong></p>
</blockquote>
<h5 id="可中断式获取锁（acquireInterruptibly方法）"><a href="#可中断式获取锁（acquireInterruptibly方法）" class="headerlink" title="可中断式获取锁（acquireInterruptibly方法）"></a>可中断式获取锁（acquireInterruptibly方法）</h5><p>我们知道lock相较于synchronized有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。</p>
<p>可响应中断式锁可调用方法<code>lock.lockInterruptibly();</code>而该方法其底层会调用AQS的<code>acquireInterruptibly</code>方法</p>
<ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">		<span class="comment">//线程获取锁失败</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在获取同步状态失败后就会调用<code>doAcquireInterruptibly</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//将节点插入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//获取锁出队</span></span><br><span class="line">			<span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">				<span class="comment">//线程中断抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键信息请看注释，现在看这段代码就很轻松了吧:),与acquire方法逻辑几乎一致、唯一的区别是当<strong>parkAndCheckInterrupt</strong>返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。</p>
<ul>
<li><strong>流程图</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210519202012102.png" alt="image-20210519202012102"></p>
<h5 id="超时等待式获取锁（tryAcquireNanos-方法）"><a href="#超时等待式获取锁（tryAcquireNanos-方法）" class="headerlink" title="超时等待式获取锁（tryAcquireNanos()方法）"></a>超时等待式获取锁（tryAcquireNanos()方法）</h5><p>通过调用lock.tryLock(timeout,TimeUnit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p>
<ol>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回false。</li>
</ol>
<p>我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用AQS的方法tryAcquireNanos(),源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">		<span class="comment">//实现超时等待的效果</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然这段源码最终是靠doAcquireNanos方法实现超时等待的效果，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//1. 根据超时时间和当前时间计算出截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">//2. 当前线程获得锁出队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 3.1 重新计算超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 3.2 已经超时返回false</span></span><br><span class="line">			<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// 3.3 线程阻塞等待 </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 3.4 线程被中断抛出被中断异常</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序逻辑如图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-a80779d4736afb87.png" alt="超时等待式获取锁（doAcquireNanos()方法）"></p>
<p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上：</p>
<ol>
<li>在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据<code>deadline = System.nanoTime() + nanosTimeout</code>计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。</li>
<li>然后根据<code>deadline - System.nanoTime()</code>就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，<code>deadline - System.nanoTime()</code>计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。</li>
<li>如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过<strong>LockSupport.parkNanos</strong>使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。</li>
</ol>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><h5 id="共享锁的获取（acquireShared-方法）"><a href="#共享锁的获取（acquireShared-方法）" class="headerlink" title="共享锁的获取（acquireShared()方法）"></a>共享锁的获取（acquireShared()方法）</h5><p>在聊完AQS对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireShared，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//获取锁失败，则自旋获取同步状态</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码的逻辑很容易理解，在该方法中会首先调用tryAcquireShared方法，tryAcquireShared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行<code>doAcquireShared</code>方法，</p>
<p>该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加共享模式节点到队列之中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前驱结点为head结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试去获取共享同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 返回值&gt;=0，表示获取同步锁成功了</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 当该节点的前驱节点是头结点且成功获取同步状态</span></span><br><span class="line">                    <span class="comment">// 那么接下来就会将把当前结点设置为头结点，释放共享同步状态，唤醒下一个节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享锁的获取逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件<strong>是当前节点的前驱节点是头结点并且tryAcquireShared(arg)返回值大于等于0（表示获得了锁）即能成功获得同步状态</strong>。</p>
<h5 id="共享锁的释放（releaseShared-方法）"><a href="#共享锁的释放（releaseShared-方法）" class="headerlink" title="共享锁的释放（releaseShared()方法）"></a>共享锁的释放（releaseShared()方法）</h5><ul>
<li><strong>背景</strong></li>
</ul>
<p>在<code>setHeadAndPropagate(node, r);</code>方法中，代码功能分为两部分：</p>
<ol>
<li>设置头结点</li>
<li>释放同步状态，唤醒下一个节点，其中的释放同步状态就使用了<code>releaseShared</code>方法</li>
</ol>
<p>共享锁的释放在AQS中会调用方法<code>releaseShared</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当成功释放同步状态之后即tryReleaseShared会继续执行doReleaseShared方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 自旋释放共享同步状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 若头结点不为空 且 头结点不等于尾结点 说明存在【有效】node节点 （因为我们是带头结点的链表）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 若头结点状态为signal，表示存在需要唤醒的后继结点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//将头结点状态更新为 0（初始值状态），因为头结点此时没用了，需要去释放同步锁了</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">// continue为了保证替换成功</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态为初始值状态0，那么久设置成PROPAGATE状态</span></span><br><span class="line">            <span class="comment">// 作用： 确保在释放同步状态的时候能去通知后继结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试。</p>
<h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock - 可重入锁"></a>ReentrantLock - 可重入锁</h2><h3 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h3><p>ReentrantLock重入锁，是基于<mark>AQS</mark>同时实现<mark>Lock接口</mark>的一个类，在并发编程的时候实现<strong>公平锁和非公平锁</strong>两种方式对共享资源进行同步。</p>
<p><strong>重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</strong></p>
<p>在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。</p>
<p>要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：</p>
<ol>
<li>重入性的实现原理</li>
<li>公平锁和非公平锁</li>
</ol>
<h3 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h3><p>要想支持重入性，就要解决两个问题：</p>
<p><strong>1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；</strong></p>
<p><strong>2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。</strong></p>
<p>通过[AQS](# AbstractQueuedSynchronizer（AQS)的学习，我们知道，同步组件主要是通过重写AQS的几个protected方法来表达自己的同步语义。针对第一个问题，我们来看看ReentrantLock是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为<code>nonfairTryAcquire</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state变量值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//占用锁成功,设置独占线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新state值为新的重入次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑也很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为tryRelease：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑看注释</p>
<ul>
<li><strong>注意点</strong></li>
</ul>
<p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。因此，return的值并不是代表有没有释放成功，而是代表有没有完全释放！</p>
<p>到现在我们可以理清ReentrantLock重入性的实现了，也就是理解了同步语义的第一条。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><ol>
<li>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<strong>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO</strong>。</li>
</ol>
<blockquote>
<p><strong>公平锁  VS  非公平锁</strong></p>
</blockquote>
<ol>
<li><p>公平锁每次获取到锁为同步队列中的第一个节点，<strong>保证请求资源时间上的绝对顺序</strong>，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</p>
</li>
<li><p>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</p>
</li>
</ol>
<blockquote>
<ul>
<li><strong>公平锁</strong>：按照请求锁的顺序分配，拥有稳定获得锁的机会，但是性能可能比非公平锁低</li>
<li><strong>非公平锁</strong>：不按照请求锁的顺序分配，不一定拥有获得锁的机会，但是性能可能比公平锁高</li>
</ul>
</blockquote>
<ul>
<li><strong>非公平锁源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过CAS获取锁（一次机会，并不是无限自旋获取）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// CAS获取失败了，则调用AQS的acquire方法获取锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用非公平锁，插队获取</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>公平锁源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类AQS的acquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ReentrantLock的构造方法无参时是构造<strong>非公平锁</strong>，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面非公平锁获取时（nonfairTryAcquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看<strong>公平锁</strong>的处理逻辑是怎样的，核心方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 锁状态空闲</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过CAS原子性更改state,更改成功，表示成功获取锁，将当前线程设置为独占线程</span></span><br><span class="line">        <span class="comment">// 判断当前同步队列中有没有排在当前线程之前的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁状态不空闲，再判断是不是独占线程（因为可能是一个线程多个锁，可重入锁嘛）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 进行状态的累加</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 判断重入次数，如果&lt;0，则表示超出次数了（int 最大值2147483647）</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑与nonfairTryAcquire基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。</p>
<p>如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。<strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong>。</p>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock - 读写锁"></a>ReentrantReadWriteLock - 读写锁</h2><h3 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//同步类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">       </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//调用同步器 获取共享锁</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">               <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> r = sync.getReadLockCount();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">               <span class="string">&quot;[Read locks = &quot;</span> + r + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h4><p>它的各种代码都与AQS的没太大变化，我们关心一下其独特的部分：<code>tryAcquireShared</code>方法</p>
<ul>
<li>源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        	<span class="comment">// 当前线程获取读锁失败返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 如果写锁没有被霸占，则将高16位移到低16位。</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);  c &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="comment">// !readerShouldBlock() 和写锁的逻辑一样（根据公平与否策略和队列是否含有等待节点）</span></span><br><span class="line">    <span class="comment">// 不能大于 65535，且 CAS 修改成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">		<span class="comment">//2. 当前线程获取读锁</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">		<span class="comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span></span><br><span class="line">		<span class="comment">//返回当前获取读锁的次数</span></span><br><span class="line">        <span class="comment">// 如果锁次数为0，表示读锁空闲，获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 把读锁交给当前线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 锁计数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果锁不是空闲的，且当前线程是第一个读线程，代表着重入；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 持有的读锁数量自增1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果都不是，就代表不是第一个节点</span></span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果最后一个线程计数器是 null 或者不是当前线程，那么就新建一个 HoldCounter 对象</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 给当前线程新建一个 HoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 如果不是 null，且 count 是 0，就将上个线程的 HoldCounter 覆盖本地的。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 对 count 加一</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回大于0的数，表示获取到了共享锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程：</p>
<ol>
<li>step1：如果写锁被获取，直接获取资源<code>acquire</code>失败（返回 -1）。</li>
<li>step2：写锁没被获取，则首先根据 <code>queue policy</code>（公平锁或非公平锁） 判断一下要不要阻塞。不需要阻塞则有其次，通过修改 原子<code>state</code> 来尝试获取资源，成功则要修改一下<strong>重入计数</strong>。</li>
<li>step3：上面的都失败了，则进入到<code>fullTryAcquireShared</code>中。</li>
</ol>
<ul>
<li><strong>exclusiveCount(c) 与 sharedCount(c)</strong></li>
</ul>
<p><code>exclusiveCount(c)</code>方法，其源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数表达的意思是：</p>
<p><code>c &amp; EXCLUSIVE_MASK != 0</code>，<code>c</code> 是我们的 原子<code>state</code>，如果 <code>c</code> 和 <code>EXCLUSIVE_MASK</code> 按位与后<strong>不为零</strong>，代表无权获取资源，即已经有线程持有了写锁。</p>
<p>其中<strong>EXCLUSIVE_MASK</strong>为:  <code>static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code>      EXCLUSIVE _MASK为1左移16位然后减1，即为0x0000FFFF（二进制的1111 1111，即十进制的255）。</p>
<p>而exclusiveCount方法是将同步状态（state为int类型）与0x0000FFFF相与，即取同步状态的低16位。那么低16位代表什么呢？根据exclusiveCount方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论<strong>同步状态的低16位用来表示写锁的获取次数</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/ba54d59b3442b6d10c38f7160456076b121.jpg" alt="位与图示"></p>
<p><strong>那么问题就来了，为什么高位不需要做判断呢？</strong>别急，往下看。</p>
<p><code>sharedCount(c)</code>方法，其源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure>

<p>该方法是获取读锁被获取的次数，是将同步状态（int c）右移16次，即取同步状态的高16位，现在我们可以得出另外一个结论<strong>同步状态的高16位用来表示读锁被获取的次数</strong>。读写锁是怎样实现分别记录读锁和写锁的状态的，现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-6af1818bbfa83051.png" alt="读写锁的读写状态设计.png"></p>
<blockquote>
<p><strong>读写锁共用一个 原子<code>state</code>，但读锁控制高 16 位，写锁控制低 16 位。</strong> 对于写锁来说，低 16 位都为 0 代表没有持锁，只要有一个 1 ，则代表某线程已经持有写锁。</p>
</blockquote>
<ul>
<li><strong>fullTryAcquireShared</strong>方法</li>
</ul>
<p>这个方法与<code>tryAcquireShared</code>高度类似，代码逻辑在注释中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这段代码与tryAcquireShared中的代码有部分重复，但整体更简单。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//判断是不是有线程持有写锁了</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若不是当前线程持有写锁，则获取读锁失败，反之，如果持有写锁的是当前线程，那么就会进入下面的逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果写锁空闲，且可以获取读锁。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 这里的代码逻辑是用于处理【读锁重入】的</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 从 ThreadLocal 中取出计数器。get方法会执行初始化</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                         <span class="comment">// 如果count == 0，表示是由上一行代码初始化的，进行remove操作</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// return -1，去排队</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果读锁次数达到 65535 ，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 尝试对 state 加 65536, 也就是设置读锁，实际就是对高16位加一。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁是空闲的</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置第一个读锁</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// 计数器为 1</span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果不是空闲的，查看第一个线程是否是当前线程。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// 这里代表着锁重入</span></span><br><span class="line">                firstReaderHoldCount++;<span class="comment">// 更新计数器</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">// cachedHoldCounter 代表的是最后一个获取读锁的线程的计数器。</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 如果最后一个读计数器所属线程不是当前线程。</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 自己创建一个，get方法会执行初始化</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 对计数器 ++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">// 更新缓存计数器。</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回大于0的数，表示获取到了锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>firstReader</code> 是获取读锁的第一个线程。如果只有一个线程获取读锁，很明显，使用这样一个变量速度更快。</li>
<li><code>firstReaderHoldCount</code>是 <code>firstReader</code>的计数器。同上。</li>
<li><code>cachedHoldCounter</code>是最后一个获取到读锁的线程计数器，每当有新的线程获取到读锁，这个变量都会更新。这个变量的目的是：当最后一个获取读锁的线程重复获取读锁，或者释放读锁，就会直接使用这个变量，速度更快，相当于缓存。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>图解流程</strong></p>
<p>发现了没？我们获取读锁的时候根本不关心读锁有没有被获取，因此从这点也可以知道读锁的共享锁，也就是允许 读 - 读 的场景，而不允许 读 -写 的场景。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/4236553-c747934c55844272.png" alt="img"></p>
<h4 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h4><p>读锁释放的实现主要通过方法<code>tryReleaseShared</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 前面还是为了实现getReadHoldCount等新功能</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">//如果计数器等于1，那么此次解锁之后就不会再持有锁了</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// firstReader 置为null，留给后面的线程用</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果不为1，表示被重入了，就减-1</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 判断 cachedHoldCounter 中是否缓存的是当前线程，不是的话就需要用get，到ThreadLoacl中获取</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 ThreadLoacl remove掉，防止内存泄漏，因为此时当前线程已经不再持有锁了</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 防止有些人lock一次，unlock很多次，导致count变为负数</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程持有读锁的数量 - 1</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">		<span class="comment">// 读锁释放 将同步状态减去读状态即可</span></span><br><span class="line">        <span class="comment">// 即：nextc 为 state高16位减1 后的值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="comment">// nextc == 0，表示state 32位全部为0 ，表示读锁写锁全为空</span></span><br><span class="line">            <span class="comment">// 若返回true，则帮助唤醒后继节点中获取写锁的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回想一下重入锁，重入锁每次释放资源使得 原子<code>state</code> - -，当 原子<code>state</code> 为零时，则唤醒队列中下一个等待的线程。</p>
<p>读锁实际上也是如此，但要注意读锁是有两个状态来维护锁的层级和持有共享锁的线程数量的：</p>
<ul>
<li>一个是 <code>HoldCounter</code> 负责重入计数，</li>
<li>一个是 原子<code>state</code>高位，负责记录有多少个线程持有了共享锁。</li>
</ul>
<p>也就是说，我们释放资源<code>release</code>时，需要首先使得 <code>HoldCounter--</code>，直到其为零，再去操作 原子<code>state</code>高位。</p>
<p>最后，直到原子<code>state</code>高位归零了，就去唤醒下一个等待的线程。</p>
<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread o = sync.getOwner();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + ((o == <span class="keyword">null</span>) ?</span><br><span class="line">                                   <span class="string">&quot;[Unlocked]&quot;</span> :</span><br><span class="line">                                   <span class="string">&quot;[Locked by thread &quot;</span> + o.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 1. 获取写锁当前的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="comment">// 2. 获取写锁获取的次数,即state中写锁（状态）的值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 翻译：state不为0，写状态为0，则表示读状态不为0，表示读锁已被获取</span></span><br><span class="line">		<span class="comment">// 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话（判断是不是重入的）防止 读 - 写，和写 - 写</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">         <span class="comment">// 当前线程获取写锁失败，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁拥有的是state的【低16位】，这里进行校验是否大于其16位能表示的数据范围</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 代码进行到这里，能保证写锁状态不为0，且当前线程是已经获取写锁的线程，即支持可重入</span></span><br><span class="line">		<span class="comment">// 3.2 当前线程获取写锁，支持可重复加锁</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// writerShouldBlock 非公平锁永远返回false，即可以插入获取，不必阻塞</span></span><br><span class="line">    <span class="comment">// 而公平锁则需要检验前一个节点是否为头结点</span></span><br><span class="line">	<span class="comment">// 3.3 写锁未被任何线程获取，当前线程可获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 设置为当前线程持有</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们回过头来看写锁获取方法tryAcquire，其主要逻辑为：<strong>当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。</strong></p>
<h4 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁的释放是线程安全的，因为写锁是独占锁，具有排他性（一次只能有一个线程拥有）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="comment">//1. 同步状态减去写状态</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">	<span class="comment">//2. 当前写状态是否为0，为0则释放写锁（这里的 0,是包括可重入的，即所有的写锁都是被释放了的</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//3. 不为0则更新同步状态</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="comment">// 返回 true的话，会进行唤醒后继节点的操作</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，减少写状态<code>int nextc = getState() - releases;</code>只需要用<strong>当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的</strong>。</p>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><ul>
<li><p><strong>锁降级指的是写锁降级成为读锁</strong>。</p>
<ul>
<li>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程<mark>不能</mark>称之为锁降级。</li>
<li><strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></li>
</ul>
<p>(有锁降级，那有没有锁升级呢？答案是没有的)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;  <span class="comment">// update使用volatile修饰，使得其他线程均能实时访问</span></span><br><span class="line">        <span class="comment">// 必须先释放读锁（如果不释放读锁就去获取写锁就会发生死锁）</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 然后获取写锁(锁降级从获取写锁开始)</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123; </span><br><span class="line">                <span class="comment">// 准备数据的流程(略)</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();  <span class="comment">// 持有写锁的同时，获取读锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ֵ使用数据的流程(略)</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>细节解析：</p>
<ol>
<li>update变量用volatile修饰，使得所有访问 processData() 方法的线程都能够感知到变化，保证了可见性</li>
<li>只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。</li>
<li>当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。</li>
</ol>
<ul>
<li><p>问题：</p>
<ul>
<li><p>锁降级中的读锁的获取是否是必须？</p>
</li>
<li><p>是必须的，为了保证数据的可见性。怎么保证呢？假如现在有一个线程A他拥有写锁，现在要释放该写锁。但他不先去获得读锁，就直接释放了写锁。这就导致了一个问题，有另一个线程B，它获取了你释放掉的写锁，去修改了数据，但A线程是无法感知到这个数据被修改了的，就会导致一些错误。</p>
<p>但假如遵循锁降级步骤，释放写锁前获得了读锁，那么线程B在获取该写锁的时候就会阻塞，直到线程A把数据处理完了，真正释放了读锁后，才能轮到线程B去进行相应的写锁获取流程。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><strong>Condition用途</strong></li>
</ul>
<p>当多个线程需要访问一个共享资源时，需要给共享资源加锁。 当一个线程释放锁时，所有等待锁的线程都会尝试去获取锁。 但是如果想只让部分等待锁的线程去获取锁时，就需要用到<strong>Condition</strong>。</p>
<ul>
<li><strong>整体分析</strong></li>
</ul>
<p>从整体上来看<strong>Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。</p>
<p>Condition具体实现在AbstractQueuedSynchronizer类中。这个类中管理了一个阻塞队列和N多个条件队列。</p>
<p>阻塞队列记录了等待获取锁的线程，头结点记录了当前正在运行的线程。</p>
<p>条件队列记录了由Condition.await()阻塞的线程，一个Lock可以有多个Condition,每个Condition是一个队列。</p>
<p>Condition是AbstractQueuedSynchronizer的一个内部类ConditionObject,所以创建的Condition对象是可以访问整个AbstractQueuedSynchronizer对象的属性的，通过这样将Condition与Lock相关联。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><ul>
<li><strong>前言</strong></li>
</ul>
<p>Condition是AQS的内部类，准确的来说创建一个condition对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会new出一个<strong>ConditionObject</strong>对象，而这个<strong>ConditionObject</strong>对象是AQS的一个内部类。</p>
<blockquote>
<p>前面我们说过，Condition是要和lock配合使用的也就是condition和Lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。</p>
</blockquote>
<ul>
<li><strong>等待队列</strong></li>
</ul>
<p>每个Condition对象都包含一个条件队列 (等待队列)。</p>
<p><strong>等待队列是一个FIFO的队列</strong>，在队列中的每个节点Node都包含了一个线程引用，该线程就是在Condition对象上等待的线程。</p>
<p>详细来说的话：如果是独占式锁的话，所有获取锁失败的线程的尾插入到<strong>同步队列</strong>，同样的，Condition内部也是使用同样的方式，内部维护了一个 <strong>等待队列</strong>，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。</p>
<ul>
<li><strong>ConditionObject中两个成员变量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以看出来ConditionObject通过持有等待队列的头尾指针来管理等待队列。</p>
<ul>
<li><strong>等待队列为单向队列</strong></li>
</ul>
<p>值得注意的是Node类复用了在AQS中的Node类，而Node类有这样一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后继节点</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>这说明 ，<strong>等待队列是一个单向队列</strong>，而学习AQS的时候我们学习到了，<strong>同步队列是双向队列</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210522212045608.png" alt="image-20210522212045608"></p>
<ul>
<li><strong>一个Lock可以持有多个等待队列</strong></li>
</ul>
<p>我们可以多次调用lock.newCondition()方法创建多个condition对象，<strong>也就是一个lock可以持有多个等待队列</strong>。而在之前利用Object的方式实际上是指在<strong>对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列</strong>。</p>
<p>需要注意概念混淆的问题：同步队列是在同步的环境下才有的概念，一个对象（即一个锁）永远只对应一个同步队列。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-6621181fc19603c2.png" alt="AQS持有多个Condition.png"></p>
<p>如图所示，ConditionObject是AQS的内部类，因此每个ConditionObject能够访问到AQS提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<p>那么为什么每个并发包的同步器需要有多个等待队列呢？有什么作用呢？</p>
<p>因为AQS可以实现排他锁（ReentrantLock）和非排他锁（ReentrantReadWriteLock——读写锁），读写锁就是一个需要多个等待队列的锁。等待队列（Condition）用来保存被阻塞的线程的。因为读写锁是一对锁，所以需要两个等待队列来分别保存被阻塞的读锁和被阻塞的写锁。</p>
<h4 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h4><ul>
<li><strong>await流程</strong></li>
</ul>
<p><strong>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，并且释放锁</strong>。</p>
<blockquote>
<p>注意点：当该方法返回时，当前线程一定获取了同步状态（锁）；</p>
<p>具体原因是当通过<code>signal()等系列方法</code>，线程才会从<code>await()</code>方法返回，而唤醒该线程后会加入同步队列</p>
</blockquote>
<ul>
<li><strong>await源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//当前线程如果中断抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">	<span class="comment">// 1. 将当前线程包装成Node，尾插入到等待队列中 - 这里的等待队列是一个【单向链表】</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">	<span class="comment">// 2. 释放当前线程所占用的lock（用await之前当前线程是占有锁的）</span></span><br><span class="line">    <span class="comment">// 在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// isOnSyncQueue用于判断线程是否在同步队列中，第一次判断为false,因为线程已经释放了</span></span><br><span class="line">	<span class="comment">// 释放完毕后,遍历AQS队列,看当前节点是否在同步队列中,</span></span><br><span class="line">	<span class="comment">// 如果不在,说明它还没有竞争锁的资格,继续等待 ;直到被加入到队列(singal)</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">		<span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 线程被挂起,阻塞在这个位置</span></span><br><span class="line">　　	   <span class="comment">// 判断线程被打断后,退出循环。</span></span><br><span class="line">	    <span class="comment">// 该方法的返回值代表当前线程是否在 park 的时候被中断唤醒</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="comment">// 下面是细节：</span></span><br><span class="line">    <span class="comment">//被唤醒后,重新开始正式竞争锁,如果竞争不到还是会将自己沉睡,等待唤醒重新开始竞争</span></span><br><span class="line">	<span class="comment">//acquireQueued: 该方法的功能是循环的尝试获取锁, 如果返回false就表示拿到锁了	</span></span><br><span class="line">	<span class="comment">// interruptMode !=THROW_IE 表示这个线程没有成功将node入队，但signal执行了enq方法让其入队了 ,将这个变量设置成 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果 node 的下一个等待者不是 null, 则进行清理,清理 Condition 队列上的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">	<span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码整体流程：</p>
<p><strong>当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong>。</p>
<ul>
<li><strong>细节/问题</strong></li>
</ul>
<p>那么关于这个实现过程我们会有这样几个问题：</p>
<ol>
<li>是怎样将当前线程添加到等待队列中去的？</li>
<li>释放锁的过程？</li>
<li>怎样才能从await方法退出？</li>
</ol>
<p>要回答这几个问题，我们就需要去注意这几个方法：</p>
<p><code>addConditionWaiter</code> <code>unlinkCancelledWaiters()</code> <code>fullyRelease(Node node)</code> <code>isOnSyncQueue(Node node)</code></p>
<ul>
<li><strong>addConditionWaiter方法 - 线程添加到等待队列</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 翻译：如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清空所有等待队列中 状态不为Condition的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 将最新的尾结点赋值</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">	<span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的流程是：</p>
<p>首先判断尾结点状态，如果尾结点已经中断的话，那么我们就不应该把当前线程包装成节点，接在它的后面，因此需要调用<code>unlinkCancelledWaiters</code>去剔除等待队列中所有的已经中断或已经释放同步状态的线程节点。</p>
<p>接着，将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node，</p>
<p>否则，更新lastWaiter(尾节点)即可,即<strong>通过尾插入的方式将当前线程封装的Node插入到等待队列中即可</strong>，同时可以看出等待队列是一个<strong>不带头结点的链式队列</strong>，之前我们学习AQS时知道同步队列<strong>是一个带头结点的链式队列</strong>，这是两者的一个区别。</p>
<p>将当前节点插入到等待对列之后，会使当前线程释放lock，由<code>fullyRelease</code>方法实现</p>
<ul>
<li><strong>unlinkCancelledWaiters()方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//获取等待队列中的头节点</span></span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//遍历等待队列，将已经中断的线程节点从等待队列中移除。</span></span><br><span class="line">          <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//重新定义lastWaiter的指向</span></span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>方法流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-fd08ef7d8f05fbe5.png" alt="img"></p>
<ul>
<li><strong>fullyRelease方法 - 释放锁的方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">			<span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑：</p>
<p><strong>调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</strong>，如果释放成功则正常返回，若失败的话就抛出异常。</p>
<ul>
<li><strong>isOnSyncQueue(Node node)</strong></li>
</ul>
<p>该方法主要用于判断当前线程节点是否在【同步队列】中。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断当前节点 waitStatus ==Node.CONDITION或者当前节点上一节点为空,则不在同步队列中</span></span><br><span class="line">      <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//如果当前节点拥有下一个节点，则在同步队列中。</span></span><br><span class="line">      <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//如果以上条件都不满足，则遍历同步队列。检查是否在同步队列中。</span></span><br><span class="line">      <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果你还记得AQS中的同步队列，那么你应该知道同步队列中的Node节点才会使用其内部的<code>pre</code>与<code>next</code>字段，那么在同步队列中因为只使用了<code>nextWaiter</code>字段，所以我们就能很简单的通过这两个字段是否为<code>==null</code>，来判断是否在同步队列中。</p>
<p>当然也有可能有一种特殊情况：有可能需要阻塞的线程节点还没有加入到同步队列中，那么这个时候我们需要遍历同步队列来判断是该线程节点是否已存在。</p>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node p = tail;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (p == node)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           p = p.prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里为什么是从尾结点向前遍历呢？思考一下，这个方法是用于找哪种线程节点的呢？是找那种还没有加入到同步队列中的线程，这种线程是独立的一个节点，它并没有被连接在任何一个在同步队列中的线程后面，因此，我们需要从后往前找，找到一个<code>node.next == null</code>的，就代表他不在同步队列中，反之，他在同步队列中。</p>
<ul>
<li><strong>如何从await方法退出</strong></li>
</ul>
<p>学习了上面几个方法，我们也可以回答这第三个问题了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">	<span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：</p>
<p><strong>1. 逻辑走到break退出while循环；</strong></p>
<p><strong>2. while循环中的逻辑判断为false</strong>。</p>
<p>那么下面就分点讨论这两种情况该如何实现：</p>
<ol>
<li>当前等待的线程被中断后，代码就会走到 <code>break</code>处退出</li>
<li>当前节点被移动到了<strong>【同步队列】</strong>中（即另外线程调用的condition的signal或者signalAll方法），此时while循环中判断结果就会为false，结束循环</li>
</ol>
<p>总结下，就是<strong>当前线程被中断或者调用condition.signal/condition.signalAll方法当前节点移动到了同步队列后</strong> ，这是当前线程退出await方法的前提条件。当退出while循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在<strong>自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）</strong>。这样也说明了<strong>退出await方法必须是已经获得了condition引用（关联）的lock</strong>。</p>
<ul>
<li><strong>图解阻塞流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-fbdd2f637ac198f9.png" alt="img"></p>
<ol>
<li>将该线程节点从同步队列中移除，并释放其同步状态。</li>
<li>构造新的阻塞节点，加入到等待队列中。</li>
</ol>
<h4 id="signal-signalAll实现原理"><a href="#signal-signalAll实现原理" class="headerlink" title="signal/signalAll实现原理"></a>signal/signalAll实现原理</h4><p><strong>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。</strong></p>
<p>按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。</p>
<p><code>signal</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 先检测当前线程是否已经获取lock</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//2. 获取等待队列中第一个节点，将其移入同步队列，接着对该结点进行操作</span></span><br><span class="line">	Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了两个方法：</p>
<ol>
<li><strong>isHeldExclusively()方法</strong></li>
<li><strong>doSignal(first)方法</strong></li>
</ol>
<p>下面对这两个方法进行学习</p>
<ul>
<li><strong>isHeldExclusively()方法</strong></li>
</ul>
<p><code>isHeldExclusively()</code>方法是AQS中的方法，默认交给其子类实现，主要用于判断当前调用<code>singal()</code>方法的线程，是否在同步队列中，且已经获取了同步状态。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>doSignal(first)方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">//（1）将等待队列中的首节点从等待队列中移除，并重新制定firstWaiter的指向</span></span><br><span class="line">           <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">               lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">           first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">       <span class="comment">//（2）将等待队列中的首节点，加入同步队列中，并重新唤醒该节点</span></span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将等待队列中的首节点从等待队列中移除，并设置firstWaiter的指向为首节点的下一个节点</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-416aebe1f25d17f0.png" alt="img"></p>
</li>
<li><p>通过 <code>transferForSignal(Node node)</code>方法，将等待队列中的首节点，加入到同步队列中去，然后重新唤醒该线程节点。</p>
</li>
</ol>
<ul>
<li><h5 id="transferForSignal-Node-node-方法"><a href="#transferForSignal-Node-node-方法" class="headerlink" title="transferForSignal(Node node)方法"></a>transferForSignal(Node node)方法</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//（1）将该线程节点的状态设置为初始状态，如果失败则表示当前线程已经中断了</span></span><br><span class="line">    <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//（2）将该节点放入同步队列中，</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//（3）获取当前节点的状态并判断，尝试将该线程节点状态设置为Singal，如果失败则唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键逻辑请看注释，这段代码主要做了两件事情</p>
<ol>
<li>将头结点的状态更改为CONDITION；</li>
<li>调用enq方法，将该节点尾插入到同步队列中；</li>
<li>当将该线程节点放入同步队列后，获取当前节点的状态并判断，如果该节点的<code>waitStatus&gt;0</code>或者通过<code>compareAndSetWaitStatus(ws, Node.SIGNAL)</code>将该节点的状态设置为Singal，如果失败则通过<code>LockSupport.unpark(node.thread)</code>唤醒线程。</li>
</ol>
<ul>
<li><strong>结论</strong></li>
</ul>
<p><strong>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出</strong>。</p>
<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2824145-694a82e957dce046.png" alt="img"></p>
<h4 id="await与signal结合"><a href="#await与signal结合" class="headerlink" title="await与signal结合"></a>await与signal结合</h4><p>await和signal和signalAll方法就像一个开关控制着线程A（等待方）和线程B（通知方）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-02449dc316fe1de6.png" alt="condition下的等待通知机制.png"></p>
<p>如图，<strong>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列</strong>。</p>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread waiter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> waiter());</span><br><span class="line">        waiter.start();</span><br><span class="line">        Thread signaler = <span class="keyword">new</span> Thread(<span class="keyword">new</span> signaler());</span><br><span class="line">        signaler.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前条件不满足等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;接收到通知条件满足&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">signaler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<blockquote>
<p>Thread-0当前条件不满足等待<br>Thread-0接收到通知，条件满足</p>
</blockquote>
<ul>
<li><strong>代码流程</strong></li>
</ul>
<p>开启了两个线程waiter和signaler，waiter线程开始执行的时候由于条件不满足，执行condition.await方法使该线程进入等待状态同时释放锁，signaler线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter线程获取到锁，并由于signaler线程更改了条件此时相对于waiter来说条件满足，继续执行。</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Cannot be instantiated.</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象。</span></span><br><span class="line"><span class="comment">     * 如果该调用不受阻塞，则返回 null。</span></span><br><span class="line"><span class="comment">     * 返回的值只是一个瞬间快照，即由于未解除阻塞或者在不同的 blocker 对象上受阻而具有的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果给定线程的许可尚不可用，则使其可用。</span></span><br><span class="line"><span class="comment">     * 如果线程在 park 上受阻塞，则它将解除其阻塞状态。</span></span><br><span class="line"><span class="comment">     * 否则，保证下一次调用 park 不会受阻塞。</span></span><br><span class="line"><span class="comment">     * 如果给定线程尚未启动，则无法保证此操作有任何效果。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread: 要执行 unpark 操作的线程；该参数为 null 表示此操作没有任何效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了线程调度，在许可可用之前阻塞当前线程。 </span></span><br><span class="line"><span class="comment">     * 如果许可可用，则使用该许可，并且该调用立即返回；</span></span><br><span class="line"><span class="comment">     * 否则，为线程调度禁用当前线程，并在发生以下三种情况之一以前，使其处于休眠状态：</span></span><br><span class="line"><span class="comment">     *  1. 其他某个线程将当前线程作为目标调用 unpark</span></span><br><span class="line"><span class="comment">     *  2. 其他某个线程中断当前线程</span></span><br><span class="line"><span class="comment">     *  3. 该调用不合逻辑地（即毫无理由地）返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，不过增加了等待的相对时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>)</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，不过增加了等待的绝对时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和park()方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parkNanos(long nanos)方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            setBlocker(t, blocker);</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">            setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parkUntil(long deadline)方法类似，只不过增加了暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blocker 导致此线程暂停的同步对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextSecondarySeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> ((r = UNSAFE.getInt(t, SECONDARY)) != <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((r = java.util.concurrent.ThreadLocalRandom.current().nextInt()) == <span class="number">0</span>)</span><br><span class="line">            r = <span class="number">1</span>; <span class="comment">// avoid zero</span></span><br><span class="line">        UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;parkBlocker&quot;</span>));</span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSeed&quot;</span>));</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomProbe&quot;</span>));</span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">&quot;threadLocalRandomSecondarySeed&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap简介"><a href="#ConcurrentHashMap简介" class="headerlink" title="ConcurrentHashMap简介"></a>ConcurrentHashMap简介</h3><p>在使用HashMap时在多线程情况下扩容会出现CPU接近100%的情况，因为Hashmap并不是线程安全的，通常我们可以使用在java体系中古老的hashtable类，该类基本上所有的方法都采用synchronized进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。</p>
<p>另外一种方式通过Collections的<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code>将hashmap包装成一个线程安全的map。比如SynchronzedMap的put方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上SynchronizedMap实现依然是采用synchronized独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。</p>
<p>相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中<strong>利用了锁分段的思想提高了并发度</strong>。</p>
<ul>
<li><strong>JDK 1.6版本关键要素</strong></li>
</ul>
<ol>
<li>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；</li>
<li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。</li>
</ol>
<ul>
<li><strong>JDK 1.8版本关键要素</strong></li>
</ul>
<p>1.8版本舍弃了segment，并且大量使用了synchronized，以及CAS无锁操作以保证ConcurrentHashMap操作的线程安全性。</p>
<p>至于为什么不用ReentrantLock而是Synchronzied呢？实际上，synchronzied做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用synchronized相较于ReentrantLock的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。</p>
<p>另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。（之前是数组 + 链表的形式）</p>
<h3 id="关键属性-amp-类"><a href="#关键属性-amp-类" class="headerlink" title="关键属性 &amp; 类"></a>关键属性 &amp; 类</h3><p>在了解ConcurrentHashMap的具体方法实现前，我们需要系统的来看一下几个关键的地方。</p>
<blockquote>
<p><strong>ConcurrentHashMap的关键属性</strong></p>
</blockquote>
<ol>
<li><p><strong>table</strong><br>volatile Node&lt;K,V&gt;[] table://装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</p>
</li>
<li><p><strong>nextTable</strong><br>volatile Node&lt;K,V&gt;[] nextTable; //扩容时使用，平时为null，只有在扩容的时候才为非null</p>
</li>
<li><p><strong>sizeCtl</strong><br><code>volatile int sizeCtl;</code></p>
<blockquote>
<p>（Ctl的意思Control，从sizeControl也可以明白这个变量的作用了）</p>
<p><code>sizeCtl</code>为0，代表数组未初始化， 且数组的初始容量为16</p>
<p><code>sizeCtl</code>为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值（数组的初始容量*0.75【加载因子】）</p>
<p><code>sizeCtl</code>为-1，表示数组正在进行初始化，如果为-N则表示当前正有N-1个线程进行扩容操作；</p>
<p><code>sizeCtl</code>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操作</p>
</blockquote>
</li>
<li><p><strong>sun.misc.Unsafe U</strong><br>在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而CAS操作依赖于现代处理器指令集，通过底层<strong>CMPXCHG</strong>指令实现。CAS(V,O,N)核心思想为：<strong>若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，在进行重试</strong>。而在大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">		.......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p><strong>ConcurrentHashMap中关键内部类</strong></p>
</blockquote>
<ol>
<li><p><strong>Node</strong><br>Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。</p>
<ol start="2">
<li><p><strong>TreeNode</strong><br>树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeBin</strong><br>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ForwardingNode</strong><br>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p><strong>CAS关键操作</strong></p>
</blockquote>
<p>在上面我们提及到在ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作。因此，在理解ConcurrentHashMap的方法前我们需要了解下面几个常用的利用CAS算法来保障线程安全的操作。</p>
<ol>
<li><p><strong>tabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用来获取table数组中索引为i的Node元素。</p>
</li>
<li><p><strong>casTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 利用CAS操作设置table数组中索引为i的元素</p>
</li>
<li><p><strong>setTabAt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 该方法用来设置table数组中索引为i的元素</p>
</li>
</ol>
<h3 id="容器初始化方法"><a href="#容器初始化方法" class="headerlink" title="容器初始化方法"></a>容器初始化方法</h3><h4 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h4><blockquote>
<p>在jdk8的ConcurrentHashMap中一共有5个构造方法，这四个构造方法中都没有对内部的数组做初始化， 只是对一些变量的初始值做了处理</p>
<p>jdk8的ConcurrentHashMap的数组初始化是在第一次添加元素时完成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity) </span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无参构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有维护任何变量的操作，如果调用该方法，数组长度默认是16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带参构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递进来一个初始容量，ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量</span></span><br><span class="line"><span class="comment">// 比如你传32，右移1位（除以2）得到16，最后的sizeCtl = （32 + 16 + 1）→ 向上取最近的2的n次方 = 49 → 向上取最近的2的n次方 = 64</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    	<span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，调用这个方法，得到的初始容量和我们之前讲的HashMap以及jdk7的ConcurrentHashMap不同，即使你传递的是一个2的幂次方数，该方法计算出来的初始容量依然是比这个值大的2的幂次方数</p>
</blockquote>
<ul>
<li><strong>tableSizeFor源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment"> * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。</p>
<p>另外，需要注意的是，<strong>调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作</strong>。</p>
<ul>
<li><strong>带加载因子构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用四个参数的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给定一个Map构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于一个Map集合，构建一个ConcurrentHashMap</span></span><br><span class="line"><span class="comment">//初始容量为16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>给定Map大小，加载因子以及并发度构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一个大于或者等于给定的容量值，该值是2的幂次方数作为初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化或者说正在扩容， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//n的值： sizeCtl为0，取默认长度16， 否则取sizeCtl的值</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//传给成员变量table: tansient volatile Node&lt;K, V&gt;[] table;</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc 【sc = 0.75n】  </span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                <span class="comment">// 此时的sizeCtl就记录了扩容阈值了</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码逻辑</strong></li>
</ul>
<p>由于有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化：</p>
<ol>
<li>首先通过if进行判断，若当前已经有一个线程正在初始化即sizeCtl值变为-1，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片</li>
<li>正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。</li>
</ol>
<p>如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h3 id="添加（put）方法"><a href="#添加（put）方法" class="headerlink" title="添加（put）方法"></a>添加（put）方法</h3><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的本质是调用<code>putVal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="comment">//这个值一定为一个正数，方便后面添加元素判断该节点的类型</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">	    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="comment">// （tabAt方法用于获取角标对应的值） </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED（-1），证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="comment">//（这里涉及到了多线程的协助扩容相关知识点）</span></span><br><span class="line">        <span class="comment">// 第一次初始化肯定是不走这里的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//第一次初始化会走这个分支</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 防止树化之后 元素位置</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// hash值一样</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    <span class="comment">//旧值覆盖掉</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 尾插到链表</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="comment">//ps：并不是大于8了，就一定会树化，在树化前再进行一次判断，如果是小于64的，则不会树化，而是扩容</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作(根据临界值（实际大小*加载因子）与实际大小进行判断)</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码细节-amp-逻辑分析"><a href="#代码细节-amp-逻辑分析" class="headerlink" title="代码细节 &amp; 逻辑分析"></a>代码细节 &amp; 逻辑分析</h4><p>下图为ConcurrentHashMap的数据结构形式，为一个哈希桶数组；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-1884312328f221e7.png" alt="ConcurrentHashMap散列桶数组结构示意图"></p>
<p>如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是<strong>标准的链地址的解决方式</strong>，将hash值相同的节点构成链表的形式，称为“拉链法”。</p>
<p>另外，在1.8版本中为了防止拉链过长，当链表的长度大于8（其实是大于64，在8 - 64之间只会扩容）的时候会将链表转换成红黑树。table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入table数组的索引i处。</p>
<blockquote>
<p>引申出来一个问题：如何计算得出索引？</p>
<p>回答：通过key的HashCode值</p>
</blockquote>
<p>如何计算呢？</p>
<ul>
<li><strong>spread()重哈希，以减小Hash冲突</strong></li>
</ul>
<p>对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。</p>
<p>因此通过<strong><code>spread</code></strong>方法进行了一次重hash从而大大减小哈希冲突的可能性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"><span class="comment">// HASH_BITS为0x7FFFFFFF,是除了首位为0，其余都是1的十六进制数;</span></span><br><span class="line"><span class="comment">// 首位为0表示为正数，这是最大的整形数int</span></span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。</p>
<ul>
<li><strong>初始化table</strong></li>
</ul>
<p>这里会判断table是否是经过初始化的，没有的话，就调用<code>initTable</code>进行初始化；</p>
<ul>
<li><strong>判断是否正在扩容</strong></li>
</ul>
<p>如果当前节点不为null，且该节点为特殊节点（forwardingNode）的话，就说明当前concurrentHashMap正在进行扩容操作，关于扩容操作，之后会详细讲述。</p>
<p>那么怎样确定当前的这个Node是不是特殊的节点了？是通过判断该节点的hash值是不是等于-1（MOVED）,代码为<code>(fh = f.hash) == MOVED</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="put方法图解"></p>
<hr>
<h3 id="取出（get）方法"><a href="#取出（get）方法" class="headerlink" title="取出（get）方法"></a>取出（get）方法</h3><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">	<span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a><strong>代码逻辑</strong></h4><p>首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<ul>
<li><strong>图解</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png" alt="get方法图解"></p>
<h3 id="扩容（-transfer）方法"><a href="#扩容（-transfer）方法" class="headerlink" title="扩容（ transfer）方法"></a>扩容（ transfer）方法</h3><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果是扩容线程，此时新数组为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">//两倍扩容创建新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable记录新的数组 </span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移</span></span><br><span class="line">        <span class="comment">//tansferIndex记录当前旧数组的size</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">//进行迁移任务的分配工作</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i：记录当前正在迁移桶位的索引值</span></span><br><span class="line">            <span class="comment">//bound/nextBound：记录下一次任务迁移的开始桶位</span></span><br><span class="line">            <span class="comment">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//计算下一次任务迁移的开始桶位，并将这个值赋值给nextBound </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//扩容任务线程数减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class="line">                <span class="comment">// != 表示没扩容完， == 表示扩容完;</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//所有扩容线程都执行完，标识结束</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//当前节点已经被迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class="line">            <span class="comment">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// fh &gt;= 0:处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                         <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理当前节点是TreeBin时的情况，操作和上面的类似</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码流程-细节"><a href="#代码流程-细节" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h4><p>代码逻辑请看注释,整个扩容操作分为<strong>两个部分</strong>：</p>
<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p>
<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>
<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-f82d0791c6493019.png" alt="ConcurrentHashMap扩容示意图"></p>
<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/nnn.png" alt="transfer方法图解"></p>
<h3 id="协助扩容（helpTransfer）方法"><a href="#协助扩容（helpTransfer）方法" class="headerlink" title="协助扩容（helpTransfer）方法"></a>协助扩容（helpTransfer）方法</h3><p>在<code>putVal</code>处，有<code>helpTransfer</code>方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现此处为fwd节点，协助扩容，扩容结束后，再循环回来添加元素</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//扩容，传递一个不是null的nextTab</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合长度累计方式"><a href="#集合长度累计方式" class="headerlink" title="集合长度累计方式"></a>集合长度累计方式</h3><h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><blockquote>
<p><strong>① CounterCell数组不为空，优先利用数组中的CounterCell记录数量</strong></p>
<p><strong>② 如果数组为空，尝试对baseCount进行累加，失败后，会执行fullAddCount逻辑</strong></p>
<p><strong>③ 如果是添加元素操作，会继续判断是否需要扩容</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//当CounterCell数组不为空，则优先利用数组中的CounterCell记录数量</span></span><br><span class="line">    <span class="comment">//或者当baseCount的累加操作失败，会利用数组中的CounterCell记录数量</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//标识是否有多线程竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//当as数组为空</span></span><br><span class="line">        <span class="comment">//或者当as长度为0</span></span><br><span class="line">        <span class="comment">//或者当前线程对应的as数组桶位的元素为空</span></span><br><span class="line">        <span class="comment">//或者当前线程对应的as数组桶位不为空，但是累加失败</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a =  as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//以上任何一种情况成立，都会进入该方法，传入的uncontended是false</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//计算元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//当元素个数达到扩容阈值</span></span><br><span class="line">        <span class="comment">//并且数组不为空</span></span><br><span class="line">        <span class="comment">//并且数组长度小于限定的最大值</span></span><br><span class="line">        <span class="comment">//满足以上所有条件，执行扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//这个是一个很大的正数</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//sc小于0，说明有线程正在扩容，那么会协助扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//扩容结束或者扩容线程数达到最大值或者扩容后的数组为null或者没有更多的桶位需要转移，结束操作</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//扩容线程加1，成功后，进行协助扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容，newTable不为null</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有其他线程在进行扩容，达到扩容阈值后，给sizeCtl赋了一个很大的负数</span></span><br><span class="line">            <span class="comment">//1+1=2 --》 代表此时有一个线程在扩容</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//rs &lt;&lt; RESIZE_STAMP_SHIFT)是一个很大的负数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//扩容，newTable为null</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h4><blockquote>
<p><strong>① 当CounterCell数组不为空，优先对CounterCell数组中的CounterCell的value累加</strong></p>
<p><strong>② 当CounterCell数组为空，会去创建CounterCell数组，默认长度为2，并对数组中的CounterCell的value累加</strong></p>
<p><strong>③ 当数组为空，并且此时有别的线程正在创建数组，那么尝试对baseCount做累加，成功即返回，否则自旋</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//获取当前线程的hash值</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标识是否有冲突，如果最后一个桶不是null，那么为true</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//数组不为空，优先对数组中CouterCell的value累加</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//线程对应的桶位为null</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//创建CounterCell对象</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">//利用CAS修改cellBusy状态为1，成功则将刚才创建的CounterCell对象放入数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//桶位为空， 将CounterCell对象放入数组</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">//表示放入成功</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created) <span class="comment">//成功退出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//桶位已经被别的线程放置了已给CounterCell对象，继续循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//桶位不为空，重新计算线程hash值，然后继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//重新计算了hash值后，对应的桶位依然不为空，对value累加 这里的x = 1 </span></span><br><span class="line">            <span class="comment">//成功则结束循环</span></span><br><span class="line">            <span class="comment">//失败则继续下面判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//数组被别的线程改变了，或者数组长度超过了可用cpu大小，重新计算线程hash值，否则继续下一个判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//当没有冲突，修改为有冲突，并重新计算线程hash，继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果CounterCell的数组长度没有超过cpu核数，对数组进行两倍扩容</span></span><br><span class="line">            <span class="comment">//并继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 下面进行的是对counterCells数组进行初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CounterCell数组为空，并且没有线程在创建数组，修改标记，并创建数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组为空，并且有别的线程在创建数组，那么尝试对baseCount做累加，成功就退出循环，失败就继续循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>图解流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210529160604963.png" alt="image-20210529160604963"></p>
<h3 id="集合长度获取方式"><a href="#集合长度获取方式" class="headerlink" title="集合长度获取方式"></a>集合长度获取方式</h3><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sumCount方法"><a href="#sumCount方法" class="headerlink" title="sumCount方法"></a>sumCount方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">//获取baseCount的值</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组，累加每一个CounterCell的value值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这个方法并不是线程安全的</p>
</blockquote>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>在多线程编程中通常解决线程安全的问题我们会利用synchronzed或者lock控制线程对临界区资源的同步顺序从而解决线程安全的问题，但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。</p>
<p><strong>线程安全问题的核心在于多个线程会对同一个临界区共享资源进行操作</strong>，那么，如果每个线程都使用自己的“共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，这样就不会出现线程安全的问题。</p>
<p>ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一乐ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，如下图所示</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1368768-20190613220434628-1803630402.png" alt="img"></p>
<p>从<strong>ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争</strong>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>学习实现原理主要根据：set get  remove 三个方法入手</strong></p>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><blockquote>
<p><strong>set方法设置在当前线程中threadLocal变量的值</strong></p>
</blockquote>
<h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程实例对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//3.如果Map不为null,则以当前threadLocl实例为key,值为value进行存入</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//4.map为null,则新建ThreadLocalMap并存入value</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码流程-细节-1"><a href="#代码流程-细节-1" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><p>方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道value是存放在了ThreadLocalMap里了，当前先把它理解为一个普普通通的map即可，也就是说，<strong>数据value是真正的存放在了ThreadLocalMap这个容器中了，并且是以当前threadLocal实例为key</strong>。</p>
<p>先简单的看下ThreadLocalMap是什么，有个简单的认识就好，下面会具体说的。</p>
<p><strong>首先ThreadLocalMap是怎样来的</strong>？源码很清楚，是通过<code>getMap(t)</code>进行获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法直接返回的就是当前线程对象t的一个成员变量threadLocals：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说<strong>ThreadLocalMap的引用是作为Thread的一个成员变量，被Thread进行维护的</strong>。</p>
<p>回过头再来看看set方法，当map为Null的时候会通过<code>createMap(t，value)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法就是<strong>new一个ThreadLocalMap实例对象，然后同样以当前threadLocal实例作为key,值为value存放到threadLocalMap中，然后将当前线程对象的threadLocals赋值为threadLocalMap</strong>。</p>
<h5 id="图解流程"><a href="#图解流程" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210529172329653.png" alt="image-20210529172329653"></p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><h5 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h5><p><strong>get方法是获取当前线程中threadLocal变量的值</strong></p>
<ul>
<li><strong>get方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程的实例对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">//2. 获取当前线程的threadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//3. 获取map中当前threadLocal实例为key的值的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			<span class="comment">//4. 当前entitiy不为null的话，就返回相应的值value</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>setInitialValue方法源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="代码流程-细节-2"><a href="#代码流程-细节-2" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><blockquote>
<p><strong>通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回<mark>null</mark>。</strong></p>
</blockquote>
<h5 id="图解流程-1"><a href="#图解流程-1" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/get%E6%96%B9%E6%B3%95.png" alt="get方法"></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><blockquote>
<p><strong>remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</strong></p>
</blockquote>
<h5 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 获取当前线程的threadLocalMap</span></span><br><span class="line">	ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> 	<span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">		<span class="comment">//2. 从map中删除以当前threadLocal实例为key的键值对</span></span><br><span class="line">		m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码流程-细节-3"><a href="#代码流程-细节-3" class="headerlink" title="代码流程/细节"></a>代码流程/细节</h5><p><strong>删除数据是从map中删除数据，先获取与当前线程相关联的threadLocalMap然后从map中删除该threadLocal实例为key的键值对即可。</strong></p>
<p>如下图所示：每个线程内部有一个名为threadLocals的成员变量，该变量的类型为ThreadLocal.ThreadLocalMap类型（类似于一个HashMap），其中的key为当前定义的ThreadLocal变量的this引用，value为我们使用set方法设置的值。每个线程的本地变量存放在自己的本地内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量就会一直存在（所以可能会导致内存溢出），因此使用完毕需要将其remove掉。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1368768-20190614011044060-2111473950.png" alt="img"></p>
<h5 id="图解流程-2"><a href="#图解流程-2" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210530164606712.png" alt="image-20210530164606712"></p>
<h3 id="ThreadLoacl底层细节"><a href="#ThreadLoacl底层细节" class="headerlink" title="ThreadLoacl底层细节"></a>ThreadLoacl底层细节</h3><h4 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h4><blockquote>
<p>ThreadLocalMap是threadLocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadLocalMap内部维护了一个Entry类型的table数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two</span></span><br><span class="line"><span class="comment"> * table数组的长度必须为2的幂次方.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内部源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>细节</strong></li>
</ul>
<p>　在上面的代码中，我们可以看出，当前ThreadLocal的引用k被传递给WeakReference的构造函数，<strong>所以ThreadLocalMap中的key为ThreadLocal的弱引用</strong></p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2021/03/29/JVM/#%E5%BC%B1%E5%BC%95%E7%94%A8">弱引用</a>的相关知识在这</p>
</blockquote>
<p>每个线程实例中可以通过threadLocals获取到threadLocalMap，而threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry数组。当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210530172556140.png" alt="image-20210530172556140"></p>
<p>这就可能会导致一个问题：<strong>内存泄漏</strong>（这里是初步涉及一下，后面再重点学习）</p>
<p>考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在，即存在一条这样的链路：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>而这个value是无法被回收的，这就可能造成内存泄漏（因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)</p>
<p><strong>解决办法：使用线程池去维护线程的创建和复用，或及时使用remove方法</strong></p>
<h4 id="set方法细节"><a href="#set方法细节" class="headerlink" title="set方法细节"></a>set方法细节</h4><h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-bf2dfb86819f6823.png" alt="理想散列表的一个示意图"></p>
<p>在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。</p>
<p>为了解决散列冲突，主要采用下面两种方式：</p>
<ul>
<li>分离链表法（separate chaining）</li>
<li>开放定址法（open addressing）</li>
</ul>
<h5 id="分离链表法-与-开放定址法"><a href="#分离链表法-与-开放定址法" class="headerlink" title="分离链表法 与 开放定址法"></a>分离链表法 与 开放定址法</h5><ul>
<li><strong>分离链表法</strong></li>
</ul>
<p>分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素，典型实现为hashMap，concurrentHashMap的拉链法。下面是一个示意图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-32b422909f2f933c.gif" alt="分离链表法示意图"></p>
<ul>
<li><strong>开放定址法</strong></li>
</ul>
<p>开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 —— 线性探测法。</p>
<p>线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-0d85565e94c4bd6b.jpg" alt="开放定址法示意图"></p>
<blockquote>
<p><strong>ThreadLocalMap 中使用开放地址法来处理散列冲突</strong></p>
<p><strong>HashMap 中使用的分离链表法</strong></p>
</blockquote>
<p>究其原因在于：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。</p>
<h5 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">	<span class="comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用开放地址法，hash冲突的时候使用线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">//覆盖旧Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当key为null时，说明threadLocal外部强引用已经被释放掉，那么就无法</span></span><br><span class="line">		<span class="comment">//再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//用当前插入的值替换掉这个key为null的“脏”entry</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//新建entry并插入table中i处</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">	<span class="comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h5><blockquote>
<p>ThreadLoacl的HashCode如何确定？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =<span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以清楚的看到threadLocal实例的hashCode是通过nextHashCode()方法实现的，<strong>该方法实际上总是用一个AtomicInteger加上0x61c88647来实现的</strong>；那么这个<mark>0x61c88647</mark>是什么呢？他其实是：<code>Fibonacci Hashing</code>，能够保证hash表的每个散列桶能够均匀的分布</p>
<blockquote>
<p>怎样确定新值插入到哈希表中的位置？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据threadLocal的hashCode确定Entry应该存放的位置</span></span><br><span class="line">   <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>本质方法：利用当前key(即threadLocal实例)的hashcode与哈希表大小相与；</p>
<p>因为哈希表大小总是为2的幂次方，所以相与等同于一个取模的过程，这样就可以通过Key分配到具体的哈希桶中去。</p>
<p>采取相与而非与运算，因为位运算效率更高</p>
<blockquote>
<p>怎样解决hash冲突？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不断向后线性探测，到达末尾时再回到0重新开始，呈一个环形。</p>
<blockquote>
<p>怎样解决“脏”Entry？</p>
</blockquote>
<p>在分析threadLocal,threadLocalMap以及Entry的关系的时候，我们已经知道使用threadLocal有可能存在内存泄漏（对象创建出来后，在之后的逻辑一直没有使用该对象，但是垃圾回收器无法回收这个部分的内存），在源码中针对这种key为null的Entry称之为“stale entry”，直译为不新鲜的entry，我把它理解为“脏entry”，</p>
<p>针对这种情况，在set方法的for循环中寻找和当前Key相同的可覆盖entry的过程中通过<strong>replaceStaleEntry</strong>方法解决脏entry的问题。如果当前table[i]为null的话，直接插入新entry后也会通过<strong>cleanSomeSlots</strong>来解决脏entry的问题</p>
<blockquote>
<p>如何进行扩容？</p>
</blockquote>
<ul>
<li><strong>扩容阈值threshold</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 初始大小为16</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">       <span class="comment">// 创建初始大小为16的threadLoaclMap</span></span><br><span class="line">       table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">       <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">       table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">       size = <span class="number">1</span>;</span><br><span class="line">       setThreshold(INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 将threshold值设置成当前哈希数组长度的2/3</span></span><br><span class="line">       threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码流程</strong></li>
</ul>
<p>根据源码可知，在第一次为threadLocal进行赋值的时候会创建初始大小为16的threadLocalMap,并且通过setThreshold方法设置threshold，其值为当前哈希数组长度乘以（2/3），可以理解为<strong>加载因子为2/3</strong></p>
<blockquote>
<p><strong>加载因子是衡量哈希表密集程度的一个参数，如果加载因子越大的话，说明哈希表被装载的越多，出现hash冲突的可能性越大，反之，则被装载的越少，出现hash冲突的可能性越小。同时如果过小，很显然内存使用率不高，该值取值应该考虑到内存使用率和hash冲突概率的一个平衡，如hashMap,concurrentHashMap的加载因子都为0.75</strong></p>
</blockquote>
<p>这里<strong>threadLocalMap初始大小为16</strong>，<strong>加载因子为2/3</strong>，所以哈希表可用大小为：16*2/3=10，即哈希表可用容量为10。</p>
<ul>
<li><strong>扩容resize</strong></li>
</ul>
<p>当我们的hash表size值大于阈值threshold，将触发resize方法，进行扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">	<span class="comment">//新数组为原数组的2倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">			<span class="comment">//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//重新确定entry在新数组的位置，然后进行插入</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置新哈希表的threshHold和size属性</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ol>
<li>新建一个大小为原来数组长度的两倍的数组</li>
<li>遍历旧数组中的entry并将其插入到新的hash数组中</li>
</ol>
<p><strong>注意点：在扩容的过程中针对脏entry的话会令value为null，以便能够被垃圾回收器能够回收，解决隐藏的内存泄漏的问题</strong></p>
<h4 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h4><h5 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 确定在散列数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2. 根据索引i获取entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">	<span class="comment">//3. 满足条件则返回该entry</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//4. 未查找到满足条件的entry，额外在做的处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法逻辑"><a href="#方法逻辑" class="headerlink" title="方法逻辑"></a>方法逻辑</h5><p>若能当前定位的entry的key和查找的key相同的话就直接返回这个entry，否则的话就是在set的时候存在hash冲突的情况，需要通过getEntryAfterMiss做进一步处理</p>
<ul>
<li><strong>getEntryAfterMiss源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">			<span class="comment">//找到和查询的key相同的entry则返回</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">//解决脏entry的问题</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="comment">//继续向后环形查找</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法同样很好理解，通过nextIndex往后环形查找，如果找到和查询的key相同的entry的话就直接返回，如果在查找过程中遇到脏entry的话使用expungeStaleEntry方法进行处理</p>
</blockquote>
<h5 id="图解流程-3"><a href="#图解流程-3" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210531203747470.png" alt="image-20210531203747470"></p>
<h4 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h4><h5 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 获取索引i，即key在数组中位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历table中每个entry</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 找到要移除的key：</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">			<span class="comment">//将entry的key置为null</span></span><br><span class="line">            e.clear();</span><br><span class="line">			<span class="comment">//将该entry的value也置为null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><p>通过传入的key获取索引i，环形遍历表中的entry，如果找到与指定key相同的entry，先通过clear方法将key置为null后，使其转换为一个脏entry，然后调用expungeStaleEntry方法将其value置为null，以便垃圾回收时能够清理，同时将table[i]置为null。</p>
<h5 id="图解流程-4"><a href="#图解流程-4" class="headerlink" title="图解流程"></a>图解流程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210531205253033.png" alt="image-20210531205253033"></p>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><ul>
<li><strong>引入</strong></li>
</ul>
<p>在[内存泄漏初认识](# Entry数据结构)处，我们已经初步知道了什么是内存泄漏；接下来就学习下如何去解决这个问题</p>
<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>在上面的set方法中，我们遇到了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replaceStaleEntry(key, value, i);</span><br><span class="line">cleanSomeSlots(i, sz);</span><br></pre></td></tr></table></figure>

<p>这两个方法用于处理<strong>【脏Entry】 —— key 为 null的Entry</strong></p>
<ol>
<li>出现hash冲突的时候，或是遇到脏数据的时候，使用<code>replaceStaleEntry</code>进行处理</li>
<li>在插入了新的Entry后，会调用<code>cleanSomeSlots</code>去检测并清除脏数据</li>
</ol>
<h5 id="cleanSomeSlots方法"><a href="#cleanSomeSlots方法" class="headerlink" title="cleanSomeSlots方法"></a>cleanSomeSlots方法</h5><ul>
<li><p>cleanSomeSlots方法用于检测，清除【脏Entry】</p>
</li>
<li><p><strong>源码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @param i a position known NOT to hold a stale entry. The</span></span><br><span class="line"><span class="comment"> * scan starts at the element after i.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param n scan control: &#123;@code log2(n)&#125; cells are scanned,</span></span><br><span class="line"><span class="comment"> * unless a stale entry is found, in which case</span></span><br><span class="line"><span class="comment"> * &#123;@code log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class="line"><span class="comment"> * When called from insertions, this parameter is the number</span></span><br><span class="line"><span class="comment"> * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class="line"><span class="comment"> * table length. (Note: all this could be changed to be either</span></span><br><span class="line"><span class="comment"> * more or less aggressive by weighting n instead of just</span></span><br><span class="line"><span class="comment"> * using straight log n. But this version is simple, fast, and</span></span><br><span class="line"><span class="comment"> * seems to work well.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 向后线性探测</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取i索引处的Entry</span></span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">//遇到了脏Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// n=当前Hash表长</span></span><br><span class="line">            n = len;</span><br><span class="line">            <span class="comment">// 标志为removed</span></span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理脏Entry</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="expungeStaleEntry方法"><a href="#expungeStaleEntry方法" class="headerlink" title="expungeStaleEntry方法"></a>expungeStaleEntry方法</h6><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.清除当前脏entry</span></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 置桶中的value为null</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 置桶位为null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 表长减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 2.往后环形继续查找,直到遇到table[i]==null时结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">// 3. 如果在向后搜索过程中再次遇到脏entry，同样将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//处理rehash的情况</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法逻辑</strong></li>
</ul>
<ol>
<li>清理当前脏entry，即将其value引用置为null，并且将table[staleSlot]也置为null。value置为null后该value域变为不可达，在下一次gc的时候就会被回收掉，同时table[staleSlot]为null后以便于存放新的entry;</li>
<li>从当前staleSlot位置向后环形（nextIndex）继续搜索，直到遇到哈希桶（tab[i]）为null的时候退出；</li>
<li>若在搜索过程再次遇到脏entry，继续将其清除。</li>
</ol>
<p>也就是说该方法，<strong>清理掉当前脏entry后，并没有闲下来继续向后搜索，若再次遇到脏entry继续将其清理，直到哈希桶（table[i]）为null时退出</strong></p>
<blockquote>
<p>方法执行后结果： <strong>从当前脏entry（staleSlot）位到返回的i位，这中间所有的entry不是脏entry</strong></p>
</blockquote>
<blockquote>
<p>为什么是遇到null时退出？原因是存在脏entry的前提条件是 <strong>当前哈希桶（table[i]）不为null</strong>,只是该entry的key域为null。如果遇到哈希桶为null，代表着其根本就不是一个键值对Entry，那更不可能是一个脏的Entry</p>
</blockquote>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul>
<li><strong>运行流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-176285739b74da18.png" alt="cleanSomeSlots示意图.png"></p>
<ol>
<li>从当前位置i处（位于i处的entry一定不是脏entry）为起点在初始小范围（log2(n)，n为哈希表已插入entry的个数size）开始向后搜索脏entry，若在整个搜索过程没有脏entry，方法结束退出</li>
<li>如果在搜索过程中遇到脏entryt通过expungeStaleEntry方法清理掉当前脏entry，并且该方法会返回下一个哈希桶(table[i])为null的索引位置为i。这时重新令搜索起点为索引位置i，n为哈希表的长度len，再次扩大搜索范围为log2(n’)继续搜索。</li>
</ol>
<ul>
<li><strong>例子</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-217512cee7e45fc7.png" alt="cleanSomeSlots执行情景图.png"></p>
<ol>
<li><p>如图当前n等于hash表的size即n=10，i=1,在第一趟搜索过程中通过nextIndex,i指向了索引为2的位置，此时table[2]为null，说明第一趟未发现脏entry,则第一趟结束进行第二趟的搜索。</p>
</li>
<li><p>第二趟所搜先通过nextIndex方法，索引由2的位置变成了i=3,当前table[3]!=null但是该entry的key为null，说明找到了一个脏entry，<strong>先将n置为哈希表的长度len,然后继续调用expungeStaleEntry方法</strong>，该方法会将当前索引为3的脏entry给清除掉（令value为null，并且table[3]也为null）,但是<strong>该方法可不想偷懒，它会继续往后环形搜索</strong>，往后会发现索引为4,5的位置的entry同样为脏entry，索引为6的位置的entry不是脏entry保持不变，直至i=7的时候此处table[7]位null，该方法就以i=7返回。至此，第二趟搜索结束；</p>
</li>
<li><p>由于在第二趟搜索中发现脏entry，n增大为数组的长度len，因此扩大搜索范围（增大循环次数）继续向后环形搜索；</p>
</li>
<li><p>直到在整个搜索范围里都未发现脏entry，cleanSomeSlot方法执行结束退出。</p>
</li>
</ol>
<h5 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h5><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param  key the key</span></span><br><span class="line"><span class="comment"> * @param  value the value to be associated with key</span></span><br><span class="line"><span class="comment"> * @param  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment"> *         searching for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向前找到第一个脏entry</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">1.</span>          slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果在向后环形查找过程中发现key相同的entry就覆盖并且和脏entry进行交换</span></span><br><span class="line"><span class="number">2.</span>            e.value = value;</span><br><span class="line"><span class="number">3.</span>            tab[i] = tab[staleSlot];</span><br><span class="line"><span class="number">4.</span>            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">			<span class="comment">//如果在查找过程中还未发现脏entry，那么就以当前位置作为cleanSomeSlots</span></span><br><span class="line">			<span class="comment">//的起点</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">5.</span>                slotToExpunge = i;</span><br><span class="line">			<span class="comment">//搜索脏entry并进行清理</span></span><br><span class="line"><span class="number">6.</span>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">		<span class="comment">//如果向前未搜索到脏entry，则在查找过程遇到脏entry的话，后面就以此时这个位置</span></span><br><span class="line">		<span class="comment">//作为起点执行cleanSomeSlots</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line"><span class="number">7.</span>            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">	<span class="comment">//如果在查找过程中没有找到可以覆盖的entry，则将新的entry插入在脏entry</span></span><br><span class="line"><span class="number">8.</span>    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">9.</span>    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line"><span class="number">10.</span>    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">		<span class="comment">//执行cleanSomeSlots</span></span><br><span class="line"><span class="number">11.</span>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue - 阻塞队列"></a>BlockingQueue - 阻塞队列</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>最常用的”<strong>生产者-消费者</strong>“问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p>
<p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。</p>
<blockquote>
<p><strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</strong></p>
</blockquote>
<h3 id="基本操作-接口"><a href="#基本操作-接口" class="headerlink" title="基本操作 - 接口"></a>基本操作 - 接口</h3><p>BlockingQueue基本操作总结如下（此图来源于JAVA API文档）：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-19d06e0ba334fe52.png" alt="BlockingQueue基本操作.png"></p>
<ul>
<li><strong>BlockingQueue继承于Queue接口，因此，对数据元素的基本操作有：</strong></li>
</ul>
<blockquote>
<p>插入元素</p>
</blockquote>
<ol>
<li>add(E e) ：往队列插入数据，当队列满时，插入元素时会抛出IllegalStateException异常；</li>
<li>offer(E e)：当往队列插入数据时，插入成功返回<code>true</code>，否则则返回<code>false</code>。当队列满时不会抛出异常；</li>
</ol>
<blockquote>
<p>删除元素</p>
</blockquote>
<ol>
<li>remove(Object o)：从队列中删除数据，成功则返回<code>true</code>，否则为<code>false</code></li>
<li>poll：删除数据，当队列为空时，返回null；</li>
</ol>
<blockquote>
<p>查看元素</p>
</blockquote>
<ol>
<li>element：获取队头元素，如果队列为空时则抛出NoSuchElementException异常；</li>
<li>peek：获取队头元素（不会删除头结点），如果队列为空则抛出NoSuchElementException异常</li>
</ol>
<ul>
<li><strong>BlockingQueue具有的特殊操作：</strong></li>
</ul>
<blockquote>
<p>插入数据：</p>
</blockquote>
<ol>
<li>put：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；</li>
<li>offer(E e, long timeout, TimeUnit unit)：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与put方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；</li>
</ol>
<blockquote>
<p>删除数据</p>
</blockquote>
<ol>
<li>take()：当阻塞队列为空时，获取队头数据的线程会被阻塞；</li>
<li>poll(long timeout, TimeUnit unit)：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出（该方法可以获取队列的头结点，且会删除此结点）</li>
</ol>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20181026185652119.png" alt="在这里插入图片描述"></p>
<ul>
<li>阻塞队列分别为：<ul>
<li><strong>ArrayBlockingQueue - 有界队列（数组）</strong></li>
<li>*<em>LinkedBlockingQueue - 有界队列（链表） *</em></li>
<li><strong>PriorityBlockingQueue - 无界（优先）阻塞队列（数组）</strong></li>
<li><strong>SynchronousQueue -  同步队列</strong></li>
<li><strong>LinkedTransferQueue - 无界阻塞队列（链表）</strong></li>
<li><strong>LinkedBlockingDeque - 有界阻塞双端队列（链表）</strong></li>
<li><strong>DelayQueue - 延时无界阻塞队列（数组）</strong></li>
</ul>
</li>
</ul>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><blockquote>
<p>ArrayBlockingQueue</p>
</blockquote>
<p><strong>ArrayBlockingQueue</strong>是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。</p>
<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p>ArrayBlockingQueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue。而非公平性则是指访问ArrayBlockingQueue的顺序不是遵守严格的时间顺序，有可能存在，一旦ArrayBlockingQueue可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。</p>
<p><strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的ArrayBlockingQueue，可采用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="comment">//保存队列元素的数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line">    <span class="comment">//取出元素的位置 - 队列头的位置</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line">   <span class="comment">//添加元素的位置 - 队列尾的位置</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Number of elements in the queue */</span></span><br><span class="line">   <span class="comment">//队列中元素的数量</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment">     * found in any textbook.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="comment">//锁对象 用来保证多线程操作共享变量的安全问题</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">  	<span class="comment">/** 当队列为空时，就会调用notEmpty的wait方法，让当前线程等待 */</span></span><br><span class="line">  	<span class="comment">/** 当生产者生产了一个产品后,调用notEmpty的signal方法，唤醒消费者 */</span></span><br><span class="line"> 	 <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">  	<span class="comment">/** 当队列为满时，就会调用notFull的wait方法，让当前线程等待 */</span></span><br><span class="line">  	<span class="comment">/** 当消费者消费了一个产品后,调用notFull的signal方法，唤醒生产者 */</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared state for currently active iterators, or null if there</span></span><br><span class="line"><span class="comment">     * are known not to be any.  Allows queue operations to update</span></span><br><span class="line"><span class="comment">     * iterator state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h5><table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>队列满时处理方式</th>
<th>方法返回值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>add(E e)</td>
<td>抛出“Queue full”异常</td>
<td>boolean</td>
</tr>
<tr>
<td>2</td>
<td>offer(E e)</td>
<td>返回false</td>
<td>boolean</td>
</tr>
<tr>
<td>3</td>
<td>put(E e)</td>
<td>线程阻塞，直到中断或被唤醒</td>
<td>void</td>
</tr>
<tr>
<td>4</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
<td>在规定时间内重试，超过规定时间返回false</td>
<td>boolean</td>
</tr>
</tbody></table>
<ul>
<li><strong>add方法、offer方法与enqueue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用AbstractQueue父类中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过调用offer来时实现</span></span><br><span class="line">  <span class="keyword">if</span> (offer(e))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列末尾新添加元素。返回true表示添加成功，false表示添加失败，不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断添加的数据是否为空</span></span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 队列已满，添加元素失败，返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (count == items.length)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用enqueue方法将元素插入队列中</span></span><br><span class="line">      enqueue(e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add方法 → offer方法 → enqueue方法，因此本质是调用<mark>enqueue</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"> <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line"> <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"> items[putIndex] = x; <span class="comment">//通过 putIndex 对数据赋值</span></span><br><span class="line"> <span class="keyword">if</span> (++putIndex == items.length) <span class="comment">// 当putIndex 等于数组长度时，将 putIndex 重置为 0</span></span><br><span class="line">   putIndex = <span class="number">0</span>;</span><br><span class="line"> count++;<span class="comment">//记录队列元素的个数</span></span><br><span class="line"> notEmpty.signal();<span class="comment">//唤醒处于等待状态下的线程，表示当前队列中的元素不为空,如果存在消费者线程阻塞，就可以开始取出元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解流程的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210603160048623.png" alt="image-20210603160048623"></p>
<ul>
<li><strong>put方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁，如果线程中断了抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果数组满了，使用notFull等待</span></span><br><span class="line">        <span class="comment">// notFull等待的意思是说现在队列满了</span></span><br><span class="line">        <span class="comment">// 只有取走一个元素后，队列才不满</span></span><br><span class="line">        <span class="comment">// 然后唤醒notFull，然后继续现在的逻辑</span></span><br><span class="line">        <span class="comment">// 这里之所以使用while而不是if</span></span><br><span class="line">        <span class="comment">// 是因为有可能多个线程阻塞在lock上</span></span><br><span class="line">        <span class="comment">// 即使唤醒了可能其它线程先一步修改了队列又变成满的了</span></span><br><span class="line">        <span class="comment">// 这时候需要再次等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出来，区别于<strong>add方法</strong>的地方在于：如果队列满时，是使用<code>notFull.await();</code>进行等待，而<strong>add方法</strong>会抛出异常</p>
<h5 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h5><table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>队列空时处理方式</th>
<th>方法返回值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>remove()</td>
<td>抛出异常</td>
<td>E</td>
</tr>
<tr>
<td>2</td>
<td>poll()</td>
<td>返回null</td>
<td>E</td>
</tr>
<tr>
<td>3</td>
<td>take()</td>
<td>线程阻塞，指定中断或被唤醒</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>poll(long timeout, TimeUnit unit)</td>
<td>在规定时间内重试，超过规定时间返回null</td>
<td>E</td>
</tr>
</tbody></table>
<ul>
<li><strong>remove方法、poll方法与dequeue()方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用poll()方法出队</span></span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果有元素出队就返回这个元素</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果没有元素出队就抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除队列第一个元素(即队列头)，并返回它。如果队列是空的，它不会抛出异常，而是会返回null。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果count == 0，列表为空，就返回null，否则调用dequeue方法，返回列表头元素</span></span><br><span class="line">      <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove方法 → poll方法 → dequeue方法，因此本质是调用<mark>dequeue</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除队列头的元素，返回它</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">  <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="comment">// 得到当前队列头的元素</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  E x = (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将当前队列头位置设置为null</span></span><br><span class="line">  items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当takeIndex 等于数组长度时，将 takeIndex 重置为 0</span></span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列数量减一</span></span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">    itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 因为删除了一个元素，那么队列肯定不满了，那么唤醒在notFull条件下等待的一个线程</span></span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于itrs.elementDequeued()：ArrayBlockingQueue 中，实现了迭代器的功能，也就是可以通过迭代器来遍历阻塞队列中的元素<br>所以 itrs.elementDequeued() 是用来更新迭代器中的元素数据的</p>
</blockquote>
<p>同样，图解流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210603162413042.png" alt="image-20210603162413042"></p>
<ul>
<li><strong>take方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">		<span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出来，区别于<strong>remove方法</strong>的地方在于：如果队列空时，是使用<code>notEmpty.await();</code>进行等待，而<strong>remove方法</strong>会抛出异常</p>
<h5 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用AbstractQueue父类中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  E x = peek();</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看队列头元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 使用lock来保证，多线程修改成员属性的安全</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前队列头的元素</span></span><br><span class="line">    <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><h5 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表头</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take锁，执行take, poll等操作时候需要获取该锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// notEmpty条件</span></span><br><span class="line"><span class="comment">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//put执行put, offer等操作时候需要获取该锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// notFull条件</span></span><br><span class="line"><span class="comment">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="入队方法-1"><a href="#入队方法-1" class="headerlink" title="入队方法"></a>入队方法</h5><blockquote>
<ul>
<li><p>void put(E e)； 如果队列满了，一直阻塞，直到队列不满了或者线程被中断–&gt;阻塞</p>
</li>
<li><p>boolean offer(E e)；如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞</p>
</li>
<li><p>boolean offer(E e, long timeout, TimeUnit unit); 在队尾插入一个元素,，如果队列已满，则进入等待，直到出现以下三种情况：–&gt;阻塞</p>
<ul>
<li>被唤醒</li>
<li>等待时间超时</li>
<li>当前线程被中断</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>put（E e）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取锁中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满，如果已满阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把node放入队列中</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 再次判断队列是否有可用空间，如果有唤醒下一个线程进行添加操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一条数据，唤醒消费线程进行消费</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑：</p>
<ol>
<li>队列已满，阻塞等待。</li>
<li>队列未满，创建一个node节点放入队列中，如果放完以后队列还有剩余空间，继续唤醒下一个添加线程进行添加。如果放之前队列中没有元素，放完以后要唤醒消费线程进行消费。</li>
</ol>
<ul>
<li><strong>offer(E e)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 如果队列满了 返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 包装结点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 设置put锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列有可用空间，放入node节点，判断放入元素后是否还有可用空间，</span></span><br><span class="line">        <span class="comment">// 如果有，唤醒下一个添加线程进行添加操作。</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与put方法相同，区别在于：当队列没有可用元素的时候，不同于put方法的阻塞等待，offer方法直接方法false</p>
<ul>
<li><strong>signalNotEmpty方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑：获取了take锁，先上锁，然后唤醒消费者线程，最后释放锁；</p>
<ul>
<li><strong>enqueue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links node at end of queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">// 这里分为两步:</span></span><br><span class="line">    <span class="comment">// 1.last.next = node</span></span><br><span class="line">    <span class="comment">// 2.last = last.next</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="出队方法-1"><a href="#出队方法-1" class="headerlink" title="出队方法"></a>出队方法</h5><blockquote>
<ul>
<li>E take(); 如果队列空了，一直阻塞，直到队列不为空或者线程被中断–&gt;阻塞</li>
<li>E poll(); 如果没有元素，直接返回null；如果有元素，出队</li>
<li>E poll(long timeout, TimeUnit unit); 如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况：<ul>
<li>被唤醒</li>
<li>等待时间超时</li>
<li>当前线程被中断</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>take方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 队列中还有元素，唤醒下一个消费线程进行消费</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除元素之前队列是满的，唤醒生产线程进行添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑：</p>
<ol>
<li>队列为空，阻塞等待。</li>
<li>队列不为空，从队首获取并移除一个元素，如果消费后还有元素在队列中，继续唤醒下一个消费线程进行元素移除。如果放之前队列是满元素的情况，移除完后要唤醒生产线程进行添加元素。</li>
</ol>
<ul>
<li><strong>poll方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与take方法相同，只是在队列满的时候，take方法进行阻塞等待，poll方法会return null；</p>
<ul>
<li><strong>signalNotFull方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Signals a waiting put. Called only from take/poll.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑：获取了put锁，先上锁，然后唤醒生产者线程，最后释放锁；</p>
<ul>
<li><strong>dequeue方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到head节点</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取到head节点指向的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// head节点指向自己等待下次gc回收</span></span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// head节点指向新的节点</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 获取到新的head节点的item值</span></span><br><span class="line">    E x = first.item;</span><br><span class="line">    <span class="comment">// 新head节点的item值设置为null</span></span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayBlockingQueue与LinkedBlockingQueue对比"><a href="#ArrayBlockingQueue与LinkedBlockingQueue对比" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue对比"></a>ArrayBlockingQueue与LinkedBlockingQueue对比</h4><ul>
<li>ArrayBlockingQueue：<ul>
<li>一个对象数组+一把锁+两个条件</li>
<li>入队与出队都用同一把锁</li>
<li>在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高</li>
<li>采用了数组，必须指定大小，即容量有限</li>
</ul>
</li>
<li>LinkedBlockingQueue：<ul>
<li>一个单向链表+两把锁+两个条件</li>
<li>两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。</li>
<li>在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多</li>
<li>采用了链表，最大容量为整数最大值，可看做容量无限</li>
</ul>
</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p><strong>为什么要使用线程池？</strong></p>
<p>在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用<strong>线程池</strong>来管理线程，使用线程池管理</p>
</li>
</ul>
<blockquote>
<p>假设一个服务器完成一项任务所需时间为：T1创建线程时间，T2在线程中执行任务的时间，T3销毁线程时间。如果：T1+T3远大于T2，则可以采用线程池，实现对线程的复用，以提高服务器性能。</p>
</blockquote>
<p>线程主要有如下好处：</p>
<ol>
<li><strong>降低资源消耗</strong>。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；</li>
<li><strong>提升系统响应速度</strong>。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</li>
</ol>
<ul>
<li><strong>线程池继承关系</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2269232-a162703262424ec6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/465/format/webp" alt="img"></p>
<ul>
<li><strong>线程池的组成部分</strong></li>
</ul>
<blockquote>
<ul>
<li><strong>线程池管理器</strong>：创建并管理线程池。例如创建线程池、销毁线程池、添加新任务等等。</li>
<li><strong>工作线程</strong>：线程池中的工作线程。空闲时处于空闲状态，可以循环的执行任务。</li>
<li><strong>任务接口</strong>：每个任务必须实现任务接口，以供工作线程调度任务的执行。</li>
<li><strong>任务队列</strong>：存放待处理任务的队列。</li>
</ul>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-2d3eb90c8e2cf51f.jpg" alt="线程池执行流程图.jpg"></p>
<p>从图可以看出，线程池执行所提交的任务过程主要有这样几个阶段：</p>
<ol>
<li>先判断线程池中<strong>核心线程池</strong>所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步；</li>
<li>判断当前<strong>阻塞队列</strong>是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；</li>
<li>判断<strong>线程池中所有的线程</strong>是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理</li>
</ol>
<h2 id="线程池-创建"><a href="#线程池-创建" class="headerlink" title="线程池 - 创建"></a>线程池 - 创建</h2><h3 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h3><ul>
<li><strong>线程池构造方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 池内核心线程数量, 超出数量的线程会进入阻塞队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize 最大可创建线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime 线程存活时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 存活时间的单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue 线程溢出后的阻塞队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 饱和策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>对于各个参数的说明：</p>
<table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池核心线程数（平时保留的线程数），创建后不会关闭的线程数量，如果设置了<code>allowCoreThreadTimeout</code>后，空闲时间超时后还是会关闭。执行任务时，没有达到核心线程数的话，是会直接创建新的线程。</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>规定线程池最多只能有多少个线程（worker）在执行。当核心线程数和任务队列也都满了，不能添加任务的时候，这个参数才会生效。如果当前有效工作线程数量小于最大线程数量，会再创建新的线程。</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>超出corePoolSize数量的线程的保留时间。</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime的时间单位。</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列，为阻塞队列<code>BlockingQueue</code>的实现。线程池会先满足<code>corePoolSize</code>的限制，在核心线程数满了后，将任务加入队列。但队列也满了后，线程数小于<code>maximumPoolSize</code>，线程池继续创建线程。</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程创建工厂，可以用来配置线程的命名、是否是守护线程、优先级等等。</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝处理器，为<code>RejectedExecutionHandler</code>的实现类。当任务队列满负荷，已经达到最大线程数，把新加入的任务交给这个handler 进行处理。线程池默认使用<code>AbortPolicy</code>（直接抛弃）策略，直接抛出异常。</td>
</tr>
<tr>
<td>allowCoreThreadTimeout</td>
<td>核心线程的空闲时间也要进行超时限制，也就是<code>keepAliveTime</code>的限制。如果配置为true后，所有的线程空闲时间超时后，都会进行线程退出操作。</td>
</tr>
</tbody></table>
<ul>
<li><strong>关于四种拒绝处理器饱和策略：</strong></li>
</ul>
<blockquote>
<p>AbortPolicy（中止策略）：直接抛弃。</p>
<p>CallerRunsPolicy（调用者运行策略）：用调用者的线程执行任务。</p>
<p>DiscardPolicy（丢弃策略）：抛弃当前任务。</p>
<p>DiscardOldestPolicy（弃老策略）：抛弃队列中最久的任务。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210605204529008.png" alt="线程池参数说明"></p>
<h2 id="线程池-提交"><a href="#线程池-提交" class="headerlink" title="线程池 - 提交"></a>线程池 - 提交</h2><p>线程池创建之后，后面就是要提交任务执行了，通常是使用使用线程池自带的<strong>submit或者excute方法</strong>，然后用lambda表达式传入函数体后，就可以执行任务了</p>
<p>而<strong>submit</strong>的方法本质上也是调用的<strong>execute</strong>方法，因此只需要学习<strong>execute</strong>方法即可</p>
<ul>
<li><strong>使用Thread创建启动线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Executor启动线程执行任务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">executor.execute(t);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
</blockquote>
<h3 id="execute源码"><a href="#execute源码" class="headerlink" title="execute源码"></a>execute源码</h3><p><strong>execute方法主要含义：通过调用这个方法可以向线程池提交一个任务，交由线程池去执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要执行的任务command为空，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *执行的流程实际上分为三步</span></span><br><span class="line"><span class="comment">    *1、如果运行的线程小于corePoolSize，以用户给定的Runable对象新开一个线程去执行</span></span><br><span class="line"><span class="comment">    *  并且执行addWorker方法会以原子性操作去检查runState和workerCount，以防止当返回false的</span></span><br><span class="line"><span class="comment">    *  时候添加了不应该添加的线程</span></span><br><span class="line"><span class="comment">    *2、 如果任务能够成功添加到队列当中，我们仍需要对添加的线程进行双重检查，有可能添加的线程在前</span></span><br><span class="line"><span class="comment">    *  一次检查时已经死亡，又或者在进入该方法的时候线程池关闭了。所以我们需要复查状态，并有必</span></span><br><span class="line"><span class="comment">    *  要的话需要在停止时回滚入列操作，或者在没有线程的时候新开一个线程</span></span><br><span class="line"><span class="comment">    *3、如果任务无法入列，那我们需要尝试新增一个线程，如果新建线程失败了，我们就知道线程可能关闭了</span></span><br><span class="line"><span class="comment">    *  或者饱和了，就需要拒绝这个任务</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池的控制状态 （runState和workerCount）</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过workCountOf方法得到当前活动的线程数，</span></span><br><span class="line">    <span class="comment">// 当前活动线程数小于corePoolSize，新建一个线程放入线程池中；</span></span><br><span class="line">    <span class="comment">// addWorker(): 在线程池中创建一个新的线程并且执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//添加任务到worker集合 - 线程池当中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) </span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//成功返回</span></span><br><span class="line">        <span class="comment">//失败的话再次获取线程池的控制状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *判断线程池是否正处于RUNNING状态,并且往工作队列中添加该任务</span></span><br><span class="line"><span class="comment">    *是的话添加Runnable对象到workQueue队列当中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再次检查状态</span></span><br><span class="line">        <span class="comment">//线程池不处于RUNNING状态，将任务从任务队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">           * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">           * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">           * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">           * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//workerCount等于0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  <span class="comment">// 4</span></span><br><span class="line">            <span class="comment">//添加worker</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入阻塞队列失败，则尝试以线程池最大线程数新开线程去执行该任务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))  <span class="comment">// 5 </span></span><br><span class="line">        <span class="comment">//执行失败则拒绝任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execute执行流程"><a href="#execute执行流程" class="headerlink" title="execute执行流程"></a>execute执行流程</h3><ul>
<li><strong>执行流程</strong></li>
</ul>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>这里要注意一下<code>addWorker(null, false);</code>，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false);</code>也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p>
<ul>
<li><strong>图解方法流程</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/a7edb97ea88e40b19b758f475fa4c70b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><ul>
<li>作用：<strong>addWorker方法的主要工作是在线程池中创建一个新的线程并执行</strong>=</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//外部循环标记</span></span><br><span class="line">          retry:</span><br><span class="line">          <span class="comment">//外层死循环</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">//获取线程池控制状态</span></span><br><span class="line">              <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">              <span class="comment">//获取runState运行状态</span></span><br><span class="line">              <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">      ​</span><br><span class="line">              <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 这个if判断</span></span><br><span class="line"><span class="comment">                 * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">                 * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">                 * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">                 * 2. firsTask为空</span></span><br><span class="line"><span class="comment">                 * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">                 * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">                 * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">                 * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">              <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;  <span class="comment">//runState大于等于SHUTDOWN,初始位RUNNING</span></span><br><span class="line">                  ! (rs == SHUTDOWN &amp;&amp;  <span class="comment">//runState等于SHUTDOWN</span></span><br><span class="line">                     firstTask == <span class="keyword">null</span> &amp;&amp;  <span class="comment">//firstTask为null</span></span><br><span class="line">                     ! workQueue.isEmpty()))  <span class="comment">//workQueue任务队列不为空</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      ​</span><br><span class="line">              <span class="comment">//内层死循环</span></span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  <span class="comment">//获取线程池的workerCount数量</span></span><br><span class="line">                  <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                  <span class="comment">//如果workerCount超出最大值或者大于corePoolSize/maximumPoolSize</span></span><br><span class="line">                  <span class="comment">//返回false</span></span><br><span class="line">                  <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                      wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  <span class="comment">//通过CAS操作，使workerCount数量+1，成功则跳出循环，回到retry标记</span></span><br><span class="line">                  <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                      <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//CAS操作失败，再次获取线程池的控制状态</span></span><br><span class="line">                  c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                  <span class="comment">//如果当前runState不等于刚开始获取的runState，说明状态被改变了，则跳出内层循环，继续外层循环</span></span><br><span class="line">                  <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                      <span class="keyword">continue</span> retry;</span><br><span class="line">                  <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">                  <span class="comment">//CAS由于更改workerCount而失败，继续内层循环</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">//通过以上循环，能执行到这是workerCount成功+1了</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//worker开始标记</span></span><br><span class="line">          <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//worker添加标记</span></span><br><span class="line">          <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//初始化worker为null</span></span><br><span class="line">          Worker w = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//初始化一个当前Runnable对象的worker对象</span></span><br><span class="line">              w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">              <span class="comment">//获取该worker对应的线程</span></span><br><span class="line">              <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">              <span class="comment">//如果线程不为null</span></span><br><span class="line">              <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//初始线程池的锁</span></span><br><span class="line">                  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                  <span class="comment">//获取锁</span></span><br><span class="line">                  mainLock.lock();</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                      <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                      <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                      <span class="comment">//获取锁后再次检查，获取线程池runState</span></span><br><span class="line">                      <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">      </span><br><span class="line">                      <span class="comment">//当runState小于SHUTDOWN或者runState等于SHUTDOWN并且firstTask为null</span></span><br><span class="line">                      <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                          (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">//线程已存活</span></span><br><span class="line">                          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                              <span class="comment">//线程未启动就存活，抛出IllegalThreadStateException异常</span></span><br><span class="line">                              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                          <span class="comment">//将worker对象添加到workers集合当中</span></span><br><span class="line">                          workers.add(w);</span><br><span class="line">                          <span class="comment">//获取workers集合的大小</span></span><br><span class="line">                          <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                          <span class="comment">//如果大小超过largestPoolSize</span></span><br><span class="line">                          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                              <span class="comment">//重新设置largestPoolSize</span></span><br><span class="line">                              largestPoolSize = s;</span><br><span class="line">                          <span class="comment">//标记worker已经被添加</span></span><br><span class="line">                          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//释放锁</span></span><br><span class="line">                      mainLock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果worker添加成功</span></span><br><span class="line">                  <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                      <span class="comment">//启动线程</span></span><br><span class="line">                      t.start();</span><br><span class="line">                      <span class="comment">//标记worker已经启动</span></span><br><span class="line">                      workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//如果worker没有启动成功</span></span><br><span class="line">              <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                  <span class="comment">//workerCount-1的操作</span></span><br><span class="line">                  addWorkerFailed(w);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回worker是否启动的标记</span></span><br><span class="line">          <span class="keyword">return</span> workerStarted;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，其中<strong>firstTask参数</strong>指定的是新线程需要执行的第一个任务，<strong>core参数</strong>决定于活动线程数的比较对象是corePoolSize还是maximumPoolSize。</p>
<p>根据传进来的参数首先对线程池和队列的状态进行判断，满足条件就新建一个Worker对象，并实例化该对象的线程，最后启动线程。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-f4682a62cbff2231.jpg" alt="addWorker.jpg"></p>
<h4 id="runworker"><a href="#runworker" class="headerlink" title="runworker"></a>runworker</h4><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">//获取worker里的任务</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      <span class="comment">//将worker实例的任务赋值为null</span></span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      *unlock方法会调用AQS的release方法</span></span><br><span class="line"><span class="comment">      *release方法会调用具体实现类也就是Worker的tryRelease方法</span></span><br><span class="line"><span class="comment">      *也就是将AQS状态置为0，允许中断</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">      <span class="comment">//是否突然完成</span></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//worker实例的task不为空，或者通过getTask获取的不为空</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//获取锁</span></span><br><span class="line">              w.lock();</span><br><span class="line">              <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">              <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">              <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">              <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              *获取线程池的控制状态，至少要大于STOP状态</span></span><br><span class="line"><span class="comment">              *如果状态不对，检查当前线程是否中断并清除中断状态，并且再次检查线程池状态是否大于STOP</span></span><br><span class="line"><span class="comment">              *如果上述满足，检查该对象是否处于中断状态，不清除中断标记</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                   (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                  !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">//中断改对象</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//执行前的方法，由子类具体实现</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//执行任务</span></span><br><span class="line">                      task.run();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//执行完后调用的方法，也是由子类具体实现</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;<span class="comment">//执行完后</span></span><br><span class="line">                  <span class="comment">//task设置为null</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">//已完成任务数+1</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">//释放锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//处理并退出当前worker</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong></li>
</ul>
<blockquote>
<ol>
<li>首先在方法一进来，就执行了w.unlock()，这是为了将AQS的状态改为0，因为只有getState() &gt;= 0的时候，线程才可以被中断；</li>
<li>判断firstTask是否为空，为空则通过getTask()获取任务，不为空接着往下执行</li>
<li>判断是否符合中断状态，符合的话设置中断标记</li>
<li>执行beforeExecute()，task.run()，afterExecute()方法</li>
<li>任何一个出异常都会导致任务执行的终止；进入processWorkerExit来退出任务</li>
<li>正常执行的话会接着回到步骤2</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-23abafc5e23fb5c2.jpg" alt="runWorker.jpg"></p>
<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标志是否获取任务超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取线程池的控制状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取线程池的runState</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *判断线程池的状态，出现以下两种情况</span></span><br><span class="line"><span class="comment">        *1、runState大于等于SHUTDOWN状态</span></span><br><span class="line"><span class="comment">        *2、runState大于等于STOP或者阻塞队列为空</span></span><br><span class="line"><span class="comment">        *将会通过CAS操作，进行workerCount-1并返回null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取线程池的workerCount</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *allowCoreThreadTimeOut：是否允许core Thread超时，默认false</span></span><br><span class="line"><span class="comment">        *workerCount是否大于核心核心线程池</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *1、wc大于maximumPoolSize或者已超时</span></span><br><span class="line"><span class="comment">        *2、队列不为空时保证至少有一个任务</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *通过CAS操作，workerCount-1</span></span><br><span class="line"><span class="comment">            *能进行-1操作，证明wc大于maximumPoolSize或者已经超时</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//-1操作成功，返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//-1操作失败，继续循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *wc大于核心线程池</span></span><br><span class="line"><span class="comment">            *执行poll方法</span></span><br><span class="line"><span class="comment">            *小于核心线程池</span></span><br><span class="line"><span class="comment">            *执行take方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="comment">//判断任务不为空返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//获取一段时间没有获取到，获取超时</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong></li>
</ul>
<blockquote>
<ol>
<li>获取线程池控制状态和runState，判断线程池是否已经关闭或者正在关闭，是的话则workerCount-1操作返回null</li>
<li>获取workerCount判断是否大于核心线程池</li>
<li>判断workerCount是否大于最大线程池数目或者已经超时，是的话workerCount-1，-1成功则返回null，不成功则回到步骤1重新继续</li>
<li>判断workerCount是否大于核心线程池，大于则用poll方法从队列获取任务，否则用take方法从队列获取任务</li>
<li>判断任务是否为空，不为空则返回获取的任务，否则回到步骤1重新继续</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/5814285-32d0795e439afc03.jpg" alt="getTask.jpg"></p>
<h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><p>从名称来看 Process Worker Exit：任务过程 退出，当任务执行完或者出现异常中断执行，强制被退出的时候，会有相应的操作，这个方法就是这个【相应的操作】</p>
<ul>
<li><strong>源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。 </span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池-关闭"><a href="#线程池-关闭" class="headerlink" title="线程池 - 关闭"></a>线程池 - 关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是<strong>shutdown()</strong>和<strong>shutdownNow()</strong>：</p>
<ul>
<li><strong>shutdown方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态</span></span><br><span class="line"> advanceRunState(SHUTDOWN);</span><br><span class="line"><span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 清理一些资源</span></span><br><span class="line">        onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池 - 使线程池的状态设置为TERMINATED。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>shutdownNow方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试结束线程池 - 使线程池的状态设置为TERMINATED。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池-监控"><a href="#线程池-监控" class="headerlink" title="线程池 - 监控"></a>线程池 - 监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li><strong>getTaskCount</strong>：线程池已经执行的和未执行的任务总数；</li>
<li><strong>getCompletedTaskCount</strong>：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li><strong>getLargestPoolSize</strong>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li><strong>getPoolSize</strong>：线程池当前的线程数量；</li>
<li><strong>getActiveCount</strong>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><ul>
<li><p>博客</p>
<ul>
<li><p>（java并发理论）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5374810.html">https://www.cnblogs.com/paddix/p/5374810.html</a></p>
</li>
<li><p>（java并发理解）<a target="_blank" rel="noopener" href="https://blog.csdn.net/jackfrued/article/details/44499227">https://blog.csdn.net/jackfrued/article/details/44499227</a></p>
</li>
<li><p>（可见性解释）<a target="_blank" rel="noopener" href="https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430">https://blog.csdn.net/duyabc/article/details/110946997?utm_term=java%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-9-110946997&amp;spm=3001.4430</a></p>
</li>
<li><p>（指令重排）<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018909340">https://segmentfault.com/a/1190000018909340</a></p>
</li>
<li><p>（Java内存模型）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanfy008/p/9252555.html">https://www.cnblogs.com/yuanfy008/p/9252555.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/konck/p/9292584.html">https://www.cnblogs.com/konck/p/9292584.html</a></p>
<p>（Java内存模型和JVM内存管理）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjd_hycf_space/p/7505372.html">https://www.cnblogs.com/yjd_hycf_space/p/7505372.html</a></p>
</li>
<li><p>(happens-before) <a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=2102">http://cmsblogs.com/?p=2102</a></p>
</li>
<li><p>（volatile关键字的应用）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/daxin/p/3364014.html">https://www.cnblogs.com/daxin/p/3364014.html</a></p>
<p>（volatile解决了什么问题？）<a target="_blank" rel="noopener" href="https://blog.csdn.net/duqi_2009/article/details/94939145">https://blog.csdn.net/duqi_2009/article/details/94939145</a></p>
</li>
<li><p>（线程同步 - synchronized与锁） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/uodut/p/6775419.html">https://www.cnblogs.com/uodut/p/6775419.html</a></p>
</li>
<li><p>（深入分析Synchronized实现原理） <a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/54883355">https://blog.csdn.net/chenssy/article/details/54883355</a></p>
</li>
<li><p>（Java并发 -对象头）<a target="_blank" rel="noopener" href="https://blog.csdn.net/cold___play/article/details/104494045">https://blog.csdn.net/cold___play/article/details/104494045</a></p>
</li>
<li><p>（Synchronized实现原理与应用） <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012465296/article/details/53022317">https://blog.csdn.net/u012465296/article/details/53022317</a></p>
</li>
<li><p>（深入理解Java并发之synchronized实现原理）<a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p>
</li>
<li><p>（synchronized的三种应用方式） <a target="_blank" rel="noopener" href="https://blog.csdn.net/Kurry4ever_/article/details/109560858">https://blog.csdn.net/Kurry4ever_/article/details/109560858</a></p>
</li>
<li><p>（简单描述一下synchronized三种应用方法） <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44040505/article/details/102731061">https://blog.csdn.net/weixin_44040505/article/details/102731061</a></p>
</li>
<li><p>（Synchronized底层实现 - 概论、偏向锁、轻量级锁和重量级锁） <a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
</li>
<li><p>（锁膨胀原理分析 基于JDK6后） <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33762302/article/details/114297801">https://blog.csdn.net/qq_33762302/article/details/114297801</a></p>
</li>
<li><p>（synchronized关键字深度解析 - 批量重定向/撤销） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzq6032010/p/11967179.html">https://www.cnblogs.com/zzq6032010/p/11967179.html</a></p>
</li>
<li><p>（锁粗化与锁消除技术演示分析） <a target="_blank" rel="noopener" href="https://www.cnblogs.com/webor2006/p/11448673.html">https://www.cnblogs.com/webor2006/p/11448673.html</a></p>
</li>
<li><p>（内存屏障） <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ab5e3d7e510">https://www.jianshu.com/p/2ab5e3d7e510</a></p>
</li>
<li><p>（volatile 可见性 有序性 - 内存层面上实现）<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014830955">https://segmentfault.com/a/1190000014830955</a></p>
</li>
<li><p>（内存屏障 - 分类）<a target="_blank" rel="noopener" href="https://blog.csdn.net/z55887/article/details/80836313">https://blog.csdn.net/z55887/article/details/80836313</a></p>
</li>
<li><p>（写缓存Store Buffer 与 无效化队列）<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44936828/article/details/89430358">https://blog.csdn.net/weixin_44936828/article/details/89430358</a></p>
</li>
<li><p>（可见性与有序性问题 volatile底层细节）<a target="_blank" rel="noopener" href="https://www.freesion.com/article/9021645644/">https://www.freesion.com/article/9021645644/</a></p>
</li>
<li><p>（可见性与有序性问题）<a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/239766">https://bbs.huaweicloud.com/blogs/239766</a></p>
</li>
<li><p>（synchronized学习 - 实现原理 - 优化 -例子）<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903600334831629">https://juejin.cn/post/6844903600334831629</a></p>
</li>
<li><p>（深入理解AQS）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc308d82cc71">https://www.jianshu.com/p/cc308d82cc71</a></p>
</li>
<li><p>（AQS）<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903601538596877">https://juejin.cn/post/6844903601538596877</a></p>
</li>
<li><p>（ReentanLock底层理解）<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuyuwei2015/article/details/83719444">https://blog.csdn.net/fuyuwei2015/article/details/83719444</a></p>
</li>
<li><p>（从底层深入解析读写锁）<a target="_blank" rel="noopener" href="https://blog.csdn.net/chongshizhuo8736/article/details/101042514">https://blog.csdn.net/chongshizhuo8736/article/details/101042514</a></p>
</li>
<li><p>（读锁源码分析）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cd485e16456e">https://www.jianshu.com/p/cd485e16456e</a></p>
</li>
<li><p>（死磕Java并发 读写锁源码分析）<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137797509">https://zhuanlan.zhihu.com/p/137797509</a></p>
</li>
<li><p>（例子讲解锁降级）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/takemybreathaway/articles/9399914.html">https://www.cnblogs.com/takemybreathaway/articles/9399914.html</a></p>
</li>
<li><p>（详解等待队列和同步队列的关系）<a target="_blank" rel="noopener" href="https://www.freesion.com/article/6246850783/">https://www.freesion.com/article/6246850783/</a></p>
</li>
<li><p>（LockSupport）<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1036645146/article/details/105635421">https://blog.csdn.net/a1036645146/article/details/105635421</a></p>
</li>
<li><p>（ThreadLoacl）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html#_label0">https://www.cnblogs.com/fsmly/p/11020641.html#_label0</a></p>
</li>
<li><p>（关于Hash）<a target="_blank" rel="noopener" href="http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm">http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm</a></p>
</li>
<li><p>（详解ThreadLoacl）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html">https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html</a></p>
</li>
<li><p>（ArrayBlockingQueue实现原理1）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/teach/p/10665199.html">https://www.cnblogs.com/teach/p/10665199.html</a></p>
</li>
<li><p>（LinkedBlockingQueue）<a target="_blank" rel="noopener" href="https://blog.csdn.net/tonywu1992/article/details/83419448">https://blog.csdn.net/tonywu1992/article/details/83419448</a></p>
</li>
<li><p>（详细分析Java并发集合ArrayBlockingQueue用法 - 这个确实讲的可以）<a target="_blank" rel="noopener" href="https://www.jb51.net/article/137750.htm">https://www.jb51.net/article/137750.htm</a></p>
</li>
<li><p>（LinkedBlockingQueue源码解析）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-zhao/p/5135958.html">https://www.cnblogs.com/java-zhao/p/5135958.html</a></p>
</li>
<li><p>（线程池）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c99ae559bdf7">https://www.jianshu.com/p/c99ae559bdf7</a></p>
</li>
</ul>
</li>
<li><p>书籍文献</p>
<ul>
<li>《java并发编程的艺术》</li>
<li>《疯狂java讲义》</li>
</ul>
</li>
<li><p>视频</p>
<ul>
<li>（AQS底层原理）<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zz4y197iF?t=624">https://www.bilibili.com/video/BV1Zz4y197iF?t=624</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/" data-id="ckppikufi0058p0wicfpr22av" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/29/JVM/" class="article-date">
  <time datetime="2021-03-29T07:51:18.960Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>大的来说：Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<p>细的来说：JVM是运行在操作系统之上的，它与硬件没有直接的交互。Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS）</p>
<p>说了那么多，究竟JVM的核心特性是什么呢？是使用相同的字节码，它们都会给出相同的结果。</p>
<p>FYI，达到的核心目的：<mark>实现了跨平台</mark></p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>一次编写，到处运行（java跨平台的原因）</li>
<li>自动内存管理，<strong>垃圾回收机制</strong></li>
<li>数组<strong>下标越界</strong>检查</li>
<li>多态</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>JVM JRE JDK</strong>的区别（一层封装接一层封装 JVM是最里面的 与OS打交道）</p>
<ul>
<li><p><mark>JDK</mark></p>
<p>Java Development Kit 用作开发, 包含了JRE, 编译器和其他的工具(比如: JavaDoc，Java调试器), 可以让开发者开发、编译、执行Java应用程序.</p>
</li>
<li><p><mark>JRE</mark></p>
<p>Java 运行时环境是将要执行 Java 程序的 Java 虚拟机, （运行Java程序的用户使用的软件）可以想象成它是一个容器, JVM 是它的内容.</p>
<p>JRE = JVM + Java Packages Classes(like util, math, lang, awt,swing etc)+runtime libraries.</p>
</li>
<li><p><mark>JVM</mark></p>
<p>Java virtual machine (Java 虚拟机) 是一个可以执行 Java 编译产生的 Java class 文件 (bytecode) 的虚拟机进程, 是一个纯的运行环境.</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150422.png" alt="img"></p>
<h2 id="常见JVM"><a href="#常见JVM" class="headerlink" title="常见JVM"></a>常见JVM</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327170325065.png" alt="image-20210327170325065"></p>
<h1 id="内存结构-运行时数据区域"><a href="#内存结构-运行时数据区域" class="headerlink" title="内存结构 - 运行时数据区域"></a>内存结构 - 运行时数据区域</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327171507549.png" alt="image-20210327171507549"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul>
<li>程序计数器 - Program Counter Register</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>程序计数器是一块较小的<strong>内存空间</strong>，给<mark>字节码解释器</mark>服务。是当前线程锁执行的字节码的<strong>行号指示器</strong></li>
</ul>
<p>读完上面这段文字，是不是感觉很抽象？我们结合下面的这幅图理解</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327172341180.png" alt="image-20210327172341180"></p>
<p>右侧是java的代码，左边是二进制字节码，代表着一些jvm指令；</p>
<p>然而左侧指令能交由CPU直接执行么？答案是否定的，需要经由：指令 → 【解释器】 → 机器码 → CPU</p>
<p>这个解释器是怎么工作的呢？是通过改变<strong>程序计数器</strong>的值来选取下一跳需要执行的字节码指令！</p>
<p>还记得程序计数器的作用么？是的，它记住了下一条jvm指令的执行地址，因此就可以配合解释器去进行程序流程控制了</p>
<p>在物理上，这个程序计数器是通过<strong>寄存器</strong>实现的</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>线程私有</p>
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码（也就是一个确定的时刻，一个处理器都只会去执行一条线程中的指令）</li>
<li>为了线程 恢复正确的执行位置：<strong>每条线程需要有一个<mark>独立的程序计数器</mark></strong></li>
<li>各线程之间计数器互不影响，独立存储，称这类内存区域为：<strong>线程私有的内存</strong></li>
</ul>
<p>可以结合我们的寄存器与PCB之间的关系去理解</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">CPU中有个东西</span> <span class="string">叫做寄存器。它们有不同的功能，比如可以存放下一条指令地址，也可以存放正在执行的指令，也可以保存暂时运算得到的结果；</span></span><br><span class="line"></span><br><span class="line"><span class="string">然而我们知道寄存器并不是很专一的，他有可能会随时被其他的进程使用，那我们之前运算的结果啊，什么保存的指令啊，岂不是都不见了吗？</span></span><br><span class="line"></span><br><span class="line"><span class="string">这个时候就会用到我们的PCB了，它能够保持关键的一些信息，也就是运行环境，这样等我们的寄存器又空闲下来了的时候，我们就可以继续我们未完成的指令啦。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不会存在内存溢出：是<code>唯一一个</code>在《Java虚拟机规范》中没有规定任何<strong>OutOfMemoryError（内存溢出）</strong>情况的区域</p>
</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>Java虚拟机栈 - Java Virtual Machine Stack</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成（存储局部变量表、操作数栈、动态连接、方法出口等信息），对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>。</li>
<li>每一个方法被调用直至执行完毕的过程，就对应着一个<strong>栈帧</strong>在<strong>虚拟机栈</strong>中入栈到出栈的过程</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327175412940.png" alt="image-20210327175412940"></p>
<p>ps：虚拟机栈是线程私有的，没有线程安全问题。</p>
<h3 id="代码流程演示"><a href="#代码流程演示" class="headerlink" title="代码流程演示"></a>代码流程演示</h3><ul>
<li><p>Code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = a + b;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p>main先进栈 然后是method1进栈 最后method2进栈</p>
<p>而释放（出栈）则是反过来。</p>
<p>在顶部活动的栈帧，称之为：<strong>活动栈帧</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327180817345.png" alt="image-20210327180817345"></p>
</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>垃圾回收是否涉及栈内存？</p>
<ul>
<li><p><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧（一次次的方法调用）组成的，在方法执行完毕后，对应的栈帧就会被自动的被弹出栈，被自动回收掉；</p>
<p>因此无需通过垃圾回收机制去回收内存。</p>
</li>
</ul>
</li>
<li><p>栈内存的分配越大越好吗？</p>
<ul>
<li><p>首先需要明白栈内存是运行代码时通过虚拟机参数指定</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327181945387.png" alt="image-20210327181945387"></p>
</li>
<li><p>线程是存放在物理内存中的，假如栈内存分配过大，线程就会过大，一个物理内存能够承载的线程数量就会减少；</p>
<p>栈内存的分配大了，导致的是支持更多的<strong>递归调用</strong>，然而可以执行的线程数量却不会增多，反而减少。</p>
</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212734640.png" alt="image-20210327212734640"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327212704950.png" alt="image-20210327212704950"></p>
<p>下面分析三段代码，你是否能判断出各段代码是否是线程安全的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：只有m1是安全的，m2、m3都不是安全的；</p>
<p>为什么呢？m1中的sb为线程中局部变量，是线程私有的，其他线程无法访问；</p>
<p>m2中的sb虽然作为局部变量，但是最后会<code>return sb;</code> 导致别的线程可以得到这个变量，因此也不是线程私有的；</p>
<p>m3中的sb作为的是方法的参数，意味着别的可能可以访问到，因此不是线程私有的（想要安全，就应该改成String</p>
<p>Buffer）</p>
<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h3 id="栈内存异常"><a href="#栈内存异常" class="headerlink" title="栈内存异常"></a>栈内存异常</h3><h4 id="StackOverFlow"><a href="#StackOverFlow" class="headerlink" title="StackOverFlow"></a>StackOverFlow</h4><ul>
<li>栈内存溢出StackOverFlow：假如线程请求的栈深度大于虚拟机所允许的深度，则会抛出该异常；</li>
</ul>
<p>导致的原因：</p>
<ol>
<li><p>栈帧过多导致栈内存溢出（无限递归）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220740850.png" alt="image-20210327220740850"></p>
</li>
<li><p>栈帧过大导致栈内存溢出</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210327220755869.png" alt="image-20210327220755869"></p>
</li>
</ol>
<h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><ul>
<li><p>内存溢出OutOfMemoryError如果Java虚拟机栈容量可以<strong>动态扩展</strong>，而当栈扩展到<strong>W伏案申请到足够内存</strong>的时候抛出</p>
<p>ps：一个线程java栈的大小由-Xss设置决定</p>
</li>
<li><p>HotSpot虚拟机栈是无法动态扩展的</p>
</li>
</ul>
<h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><h4 id="CPU占用过高"><a href="#CPU占用过高" class="headerlink" title="CPU占用过高"></a>CPU占用过高</h4><ul>
<li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>
<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><strong>ps H -eo pid, tid</strong>（线程id）, <strong>%cpu | grep</strong> 去定位刚才通过top查到的进程号，再通过ps命令进一步查看是哪个线程占用CPU过高</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>进制需要转换</strong></li>
</ul>
<p>比如 62665进程 对应的 7f99进程</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131631397.png" alt="image-20210329131631397"></p>
<p>第8行：一个while true循环导致进程占用过高</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329131624431.png" alt="image-20210329131624431"></p>
</li>
</ul>
<h4 id="程序运行长时间得不到结果"><a href="#程序运行长时间得不到结果" class="headerlink" title="程序运行长时间得不到结果"></a>程序运行长时间得不到结果</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132108123.png" alt="image-20210329132108123"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329132146310.png" alt="image-20210329132146310"></p>
<p>分析一下这段代码：</p>
<p>现在有a b两个对象，第一个线程锁住了对象a，然后休眠2000ms（2s），醒过来后尝试去锁对象b；而在第一个线程休眠的过程中，有一个新的线程创建了，它锁住了对象b，并尝试去锁对象a，而对象a此时已经被第一个线程锁住了，因此就必须等待第一个线程释放a对象。接着第一个线程休眠时间到了，醒过来后尝试去获得b对象的锁，然而b对象早已被第二个线程锁住了，因此不可得。这样的结果就导致第一个线程等待第二个线程去释放b的锁，第二个线程等待第一个线程释放a的锁 ——死锁了；</p>
<h2 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h2><ul>
<li>本地方法区（本地方法栈）：Native Method Stacks</li>
</ul>
<p>与虚拟机栈作用相似，区别在于：</p>
<p>虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈是为虚拟机使用到的本地（Native）方法服务</p>
<p>简单来说：指的是被native修饰的方法，即非Java代码。</p>
<p>下图中getClass（）没有方法体，是由Java的底层的C/C++来实现的。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/v2-7c34658ce6ef846c31593d479db89a94_hd.jpg" alt="img"></p>
<p>ps：本地方法栈也是由线程独享的，没有线程安全问题。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>堆Heap：是存放对象实例的区域，是垃圾收集器管理的内存区域（因此一些资料中称之为GC【Garbage Collected】堆）</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存，java世界中“几乎”所有的<strong>对象实例</strong>都在这里分配<strong>内存</strong></p>
<p>（为什么说是几乎？由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致了一些微妙的变化悄然发生了，因此说Java对象实例都分配在堆上也渐渐变得不是那么绝对了 —— 《深入理解JVM虚拟机》）</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有<mark>(重点）垃圾回收机制</mark></li>
</ul>
<h3 id="堆分配"><a href="#堆分配" class="headerlink" title="堆分配"></a>堆分配</h3><p>如果从分配内存的角度这去看，所有线程共享的<strong>Java堆</strong>是可以划分出多个<strong>线程私有的</strong><mark>分配缓冲区（Thread Local Allocation Buffer，TLAB）</mark>的，用以提升对象分配时的效率；</p>
<p>然而无论用什么角度，无论怎么划分，Java堆都只能存储<strong>对象的实例</strong>，堆划分目的是为了：更好回收内存or更快分配内存</p>
<p>同时，根据《Java虚拟机规范》规定，Java堆是可以处于<strong>物理上不连续</strong>的内存空间中的，但是在逻辑上应被视为<strong>连续</strong>，但对于大对象（如 数组对象），为了存储高效、实现简单，往往要求连续的内存空间（类似于磁盘吧？）</p>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><ul>
<li>虽然说堆中存在<mark>垃圾回收机制</mark>，但是回收的对象是我们认定为<strong>垃圾</strong>的数据，也就是不再使用的对象，但假如一直有对象在创建，且一直有被使用的情况，那堆内存肯定不够用，就会导致<strong>堆内存溢出</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示堆内存溢出 java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * -Xmx8m 使用Xmx进行堆空间大小的控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a); <span class="comment">// hello, hellohello, hellohellohellohello ...</span></span><br><span class="line">                a = a + a;  <span class="comment">// hellohellohellohello</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329140851007.png" alt="image-20210329140851007"></p>
<h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><p>诊断工具：</p>
<ul>
<li><p>jps工具</p>
<p>命令行形式，查看当前系统中有哪些java进程</p>
</li>
<li><p>jmap工具</p>
<p>命令行形式，查看堆内存占用情况</p>
</li>
<li><p>jconsole工具</p>
<p>图形界面形式，多功能的检测工具，可以进行连续监测</p>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>图中的常量池为【运行时常量池】</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329143315393.png" alt="image-20210329143315393"></p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>方法区Method Area：与Java堆一样，是<mark>各线程共享的内存区域</mark>。用于存储<strong>已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。《Java虚拟机规范》将方法区描述为堆的一个逻辑部分，但方法区还有一个别名叫<strong>非堆（Non-Heap）</strong>,用于与Java堆区分开（说人话就是方法区只是一个逻辑上概念，具体怎么实现是可以不同处理的）</li>
</ul>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><ul>
<li>在JDK 8之前，许多Java程序员习惯在<strong>HotSpot</strong>虚拟机上开发、部署程序，许多人去把<strong>方法区</strong>称为<strong>永久代</strong>，然而这两者并不是等价的；<ul>
<li>那为什么要这么称呼呢？是因为当时的<strong>HotSpot</strong>虚拟机设计团队把<strong>收集器的分代设计</strong>扩展到了<mark>方法区</mark>，或者说使用<strong>永久代</strong>去实现了<mark>方法区</mark>。</li>
<li>那好处是什么呢？使得垃圾收集器能够像管理Java堆一样去管理这部分的内存了，省去了专门为方法区编写内存管理代码的工作了</li>
</ul>
</li>
<li>然而对于其他虚拟机，不一定有着<strong>永久代</strong>这个概念；</li>
<li>JDK 6的时候，<strong>HotSpot</strong>开发团队就有放弃<strong>永久代</strong>，逐步改为采用<strong>本地内存</strong>去实现方法区的计划</li>
<li>JDK 7的时候，就把原本放在<strong>永久代</strong>的<strong>字符串常量池、静态变量</strong>移出</li>
<li>JDK 8的时候，完全废除了永久代，改用了在本地内存中实现的<mark>元空间Meta-Space</mark>去代替，并把JDK 7中<strong>永久代</strong>剩余的内容（主要是类型信息）全部移到了<strong>元空间</strong>中</li>
</ul>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul>
<li>类创建过多，导致方法区内存溢出，想一想我们什么场景会遇到？</li>
<li>没错，我们的Spring Mybatis中有着许许多多的代理对象创建，bean注入等情况，少不了类的创建，那就十分有可能出现这个问题</li>
</ul>
<h4 id="永久代-内存溢出"><a href="#永久代-内存溢出" class="headerlink" title="永久代 - 内存溢出"></a>永久代 - 内存溢出</h4><ul>
<li>使用JDK 1.6</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示永久代内存溢出  java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment"> * -XX:MaxPermSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo1_8 test = <span class="keyword">new</span> Demo1_8();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++, j++) &#123;</span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145942295.png" alt="image-20210329145942295"></p>
<h4 id="元空间-内存溢出"><a href="#元空间-内存溢出" class="headerlink" title="元空间 - 内存溢出"></a>元空间 - 内存溢出</h4><ul>
<li>使用JDK 1.8</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; <span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo1_8 test = <span class="keyword">new</span> Demo1_8();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329145612278.png" alt="image-20210329145612278"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>为了学习运行时常量池，必须先明白什么是常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制字节码（类基本信息，常量池，类方法定义 - 包含了虚拟机指令）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述代码来说，其字节码包含的信息会保存在常量池中；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151426081.png" alt="image-20210329151426081"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151456843.png" alt="image-20210329151456843"></p>
<p>根据常量池查表，最后可以翻译出指令：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329151617194.png" alt="image-20210329151617194"></p>
<p>因此简单来说，常量池就是一张表，虚拟机指令根据这张长凉飙去找到要执行的类名、方法名、参数类型和字面量、等信息（或者说用于存放编译期生成的各种字面量与符号引用）</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li><p>运行时常量池 Runtime Constant Pool 是方法去的一部分。Class文件中除了类基本信息:版本号， public， 类名, 包名, 父类， 接口</p>
<p>还有方法等描述信息外，还有一项就是我们上述学习的<strong>常量池表</strong>，这部分的内容会在类加载后存放到方法区的<strong>运行时常量池</strong>中</p>
<p>（说那么多，其实运行时常量池就是常量池在程序运行时的称呼啦）</p>
</li>
<li><p>运行时常量池具有动态性。也就是在方法区中的运行时常量池是可以发生变化的。</p>
<p>（也就是说，并非预置入Class文件中常量池的内容才能进入方法区<strong>运行时常量池</strong>，在运行其间也可以将新的常量放入池中。String类的<mark>intern()</mark>方法便利用了这一个特性）</p>
<p>而常量池就不行，它是静态的，当编译生成字节码文件直接就不变了。</p>
</li>
</ul>
<h4 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h4><p>StringTable一些特性：</p>
<ol>
<li>常量池中的字符串是<strong>符号</strong>，不是<strong>对象</strong>，只有第一次使用到的时候才是<strong>对象</strong></li>
<li>可以利用串池的机制，避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是 <mark>StringBuilder</mark>(1.8)</li>
<li>字符串常量拼接的原理是<strong>编译期优化</strong></li>
<li>可以使用<mark>intern方法</mark>，主动的去将串池中还没有的<strong>字符串对象</strong>放入串池</li>
</ol>
<h5 id="StringTable-常量池与串池关系"><a href="#StringTable-常量池与串池关系" class="headerlink" title="StringTable - 常量池与串池关系"></a>StringTable - 常量池与串池关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串串池：StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_22</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span></span><br><span class="line">    <span class="comment">// 等到真正执行了指令才会转成对象，如下：</span></span><br><span class="line">    <span class="comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;] </span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329153609323.png" alt="image-20210329153609323"></p>
<p>下图的意思表示：</p>
<p>到常量池 #2号位置 加载一个信息（在这里是字符串对象a），接着把这个对象加载到局部变量表的一号Slot中，以此类推后续操作…</p>
<ul>
<li>ps:字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</li>
</ul>
<h5 id="StringTable-字符串变量拼接"><a href="#StringTable-字符串变量拼接" class="headerlink" title="StringTable - 字符串变量拼接"></a>StringTable - 字符串变量拼接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>; </span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2; <span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//这段代码执行过后，字符串常量池中会有 a b 但不会有ab</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	 Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: return</span><br></pre></td></tr></table></figure>

<p>根据反编译的指令，我们可以看出来字符串被创建的过程：</p>
<p><code>StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code></p>
<p>首先初始化了StringBuilder 然后添加字符串a，添加字符串b，最后调用toString()方法。之后使用astore 4，也就是放入局部变量表中的4号slot中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329210714606.png" alt="image-20210329210714606"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 懒惰的</span><br><span class="line">    String s2 &#x3D; &quot;b&quot;;</span><br><span class="line">    &#x2F;&#x2F;ab字符串</span><br><span class="line">    String s3 &#x3D; &quot;ab&quot;;</span><br><span class="line">    &#x2F;&#x2F;拼接后的字符串</span><br><span class="line">    String s4 &#x3D; s1 + s2; </span><br><span class="line">    </span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这段代码打印结果是什么呢？答案是：false</p>
<p>根据上面的分析，我们知道了s4的构建过程，是由字符串a b拼接而成，最终通过toString()方法锁返回的一个对象，既然是对象就存在于<strong>堆内存中</strong></p>
<p>而s3本身就是一个”ab“完整的字符串，存在于串池之中；</p>
<p>因此字符串的<strong>值</strong>相同，但却是完全不同（地址不同/内存位置不同）的两个字符串，而 <code>==</code> 恰好比较的就是内存位置，故为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 懒惰的</span><br><span class="line">    String s2 &#x3D; &quot;b&quot;;</span><br><span class="line">    String s3 &#x3D; &quot;ab&quot;;</span><br><span class="line">    String s4 &#x3D; s1 + s2; &#x2F;&#x2F; new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br><span class="line">    String s5 &#x3D; &quot;a&quot; + &quot;b&quot;;  &#x2F;&#x2F; javac 在编译期间的优化，结果已经在编译期确定为ab</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">    System.out.println(s3 &#x3D;&#x3D; s5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们修改一下，不使用s1 + s2将变量拼接在一起的写法了，直接将常量拼接在一起，答案还会是false吗？</p>
<p>我们看看反编译后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 	  Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;6, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        &#x2F;&#x2F;ab3初始化时直接从串池中获取字符串</span><br><span class="line">        29: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">        31: astore        5</span><br><span class="line">        33: return</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210329212803232.png" alt="image-20210329212803232"></p>
<p>我们根据运行流程：在第6行指令中，程序进行到这想去串池中寻找<strong>ab对象</strong>，发现没有这对象，就根据ab符号创建了一个ab对象，放入串池，程序继续执行，直到29行指令，依旧想去串池寻找<strong>ab对象</strong>，而此时这个对象是存在的，因此不会创建一个新的，故这两个对象是同一个对象</p>
<p>因此答案是 true</p>
<p>其本质是javac 在编译期间的一个优化，由于我们的“a”和“b”是两个常量，因此在编译期间的时候就可以写死，确定结果为”ab“了</p>
<p>然而s4不是这样，s4是变量的拼接，变量的值是有可能修改的，因此其结果只能在运行期间用<mark>StringBuilder</mark>动态的去确定结果</p>
<p>（这也可以解释为什么答案是true：因为前面创建ab的时候（s3）在<strong>串池</strong>中放入了“ab”这个对象了，因此我们的s5可以直接从串池获取结果，故s5 = s3，为true）；</p>
<h5 id="intern方法-JDK-8"><a href="#intern方法-JDK-8" class="headerlink" title="intern方法(JDK 8)"></a>intern方法(JDK 8)</h5><p>技术参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/be66e22f5fc8">https://www.jianshu.com/p/be66e22f5fc8</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiullan/article/details/65936959">https://blog.csdn.net/qiullan/article/details/65936959</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lcsy000/article/details/82782864">https://blog.csdn.net/lcsy000/article/details/82782864</a></p>
<p><code>public native String intern();</code></p>
<p>作用：将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池；</p>
<p>而无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><mark>FYI</mark>:此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p>使用场景：</p>
<p>现在我们<code>Sting str1 = new String(&quot;ABC&quot;);</code>，根据之前学习我们知道这个<strong>str1</strong>的实例保存于<strong>堆</strong>中，假如我们创建一个字符串</p>
<p><code>String str2 = &quot;ABC&quot;</code>,JVM会在字符串常量池/串池中创建这个<strong>String</strong>的实例，再将池中的实例的引用返回给<strong>str2</strong>。</p>
<p>那么假如想让第一个new出来的String也保存在字符串常量池中，该怎么办呢？可以使用<mark>String.intern()</mark>,将字符串<strong>放到常量池</strong>中，返回在常量池中的引用；</p>
<p>关于这个intern方法有个细节，在jdk1.7之后，假如我们的字符串在字符串常量池中<strong>没有出现过</strong>，那么就会在字符串常量池中保存一个<strong>引用</strong>，指向谁呢？指向<strong>堆</strong>中这个字符串的实例。而假如字符串在常量池中出现过了，就直接返回常量池中的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    String s2 = s.intern(); </span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s == s2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面来逐行分析一下每一行代码所带来的影响：</p>
<ol>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>  将字符串”a“和”b“放入串池中，现在串池中状态为：[“a”, “b”]s存在于堆中；</li>
<li><code>String s2 = s.intern();</code>  由于串池中没有ab，因此会把“ab”串放入串池（此时的串池状态为[“a”, “b”, “ab”]），再返回这个“ab”在串池中的引用</li>
<li><code>System.out.println(s2 == &quot;ab&quot;);</code> s2是“ab”这个串在池中的引用，因此与池中的“ab”为同一个ab 答案为true</li>
<li><code>System.out.println(s == &quot;ab&quot;);</code>s在堆内存中，与串池中“ab”为同一个ab，答案为true</li>
<li><code>System.out.println(s == s2);</code> s2是“ab”串在池中引用，与堆内存中的s（ab）为同一个对象</li>
</ol>
<p>下面我们改动一些地方，结果却是不一样的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);   </span><br><span class="line">    String s2 = s.intern(); <span class="comment">// 这里由于串池有了“ab”串，因此不会放入串池，返回的s2是串池中的ab，而s依旧不变，为堆中ab</span></span><br><span class="line">    </span><br><span class="line">     System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//true</span></span><br><span class="line">     System.out.println( s2 == x);<span class="comment">//true</span></span><br><span class="line">     System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//false</span></span><br><span class="line">     System.out.println( s == x );<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><code>String x = &quot;ab&quot;;</code>首先存放一个“ab”串到串池中，现在串池为[“ab”]</li>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 将“a” 和 “b”放入串池。同时创建出“ab”对象，这个对象存在于堆中，不是串池中,s指向的是”ab“的对象引用，与串池中的不是同一个ab。这步过后，串池情况： [“ab”, “a”, “b”]</li>
<li><code>String s2 = s.intern();</code>由于串池有了“ab”串，因此不会放入串池，返回的s2是串池中的ab，而s依旧不变，为堆中ab</li>
<li><code>System.out.println(s2 == &quot;ab&quot;);</code>：s2是串池中的ab，故为true</li>
<li><code>System.out.println( s2 == x);</code>:同上</li>
<li><code>System.out.println(s == &quot;ab&quot;);</code>:s是堆中的“ab”，不是串池中的ab，答案为false</li>
<li><code>System.out.println( s == x );</code>:同上</li>
</ol>
<h5 id="intern方法-JDK-6"><a href="#intern方法-JDK-6" class="headerlink" title="intern方法(JDK 6)"></a>intern方法(JDK 6)</h5><p>作用：调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><MARK>FYI:此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></MARK></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">String s2 = s.intern(); </span><br><span class="line">String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println( s2 == x);<span class="comment">//true</span></span><br><span class="line">System.out.println( s == x );<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p>分析：</p>
<ol>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>将“a” 和 “b”放入串池。同时创建出“ab”对象，这个对象存在于堆中。这步过后，串池情况： [“a”, “b”]</li>
<li><code>String s2 = s.intern();</code>由于串池没有”ab“，因此尝试将”ab“放入串池的同时，拷贝了一份放入串池，而拷贝的这个”ab“与堆中的”ab“并不是相同的对象。之后返回结果，s2是串池中的”ab“</li>
<li><code>String x = &quot;ab&quot;;</code>由于串池中有了”ab“了，不会创建新的字符串放入串池，而是直接沿用串池的”ab“</li>
<li><code>System.out.println( s2 == x);</code> s2与x都是串池中的“ab”，因此结果是true</li>
<li><code>System.out.println( s == x );</code>s是堆中的“ab”，而x是串池中”ab“，结果为false</li>
</ol>
<p>这段代码放在JDK 8运行结果为：true true；原因是放入串池的字符串对象不是拷贝出来的对象，而是自己这个字符串的引用，为相同对象。因此结果为true；</p>
<h5 id="StringTable位置"><a href="#StringTable位置" class="headerlink" title="StringTable位置"></a>StringTable位置</h5><ul>
<li>1.6中 StringTable位于方法区中</li>
<li>1.8中 StringTable位于堆中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220051576.png" alt="image-20210330220051576"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 在jdk8下设置 -Xmx10m -XX:-UseGCOverheadLimit</span><br><span class="line">* 在jdk6下设置 -XX:MaxPermSize&#x3D;10m</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOutPositionOfStringTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在jdk 6 中出现问题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220606611.png" alt="image-20210330220606611"></p>
<p>在jdk 8中出现问题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210330220707797.png" alt="image-20210330220707797"></p>
<h5 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h5><ul>
<li>StringTable的底层实现是使用<strong>HashTable</strong></li>
</ul>
<p>字符串存在于<strong>堆内存</strong>中，只有当内存紧张的时候，才会触发垃圾回收；</p>
<p><code>-Xmx10m -XX+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx10m</td>
<td>堆空间大小</td>
</tr>
<tr>
<td>-XX+PrintStringTableStatistics</td>
<td>打印串池统计信息</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印GC日志详情</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>打印GC日志</td>
</tr>
</tbody></table>
<p>首先进行一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 1388K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 67% used [0x00000007bfd00000,0x00000007bfe5b100,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 2927K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 319K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 &#x3D;    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     11756 &#x3D;    282144 bytes, avg  24.000</span><br><span class="line">Number of literals      :     11756 &#x3D;    455312 bytes, avg  38.730</span><br><span class="line">Total footprint         :           &#x3D;    897544 bytes</span><br><span class="line">Average bucket size     :     0.587</span><br><span class="line">Variance of bucket size :     0.587</span><br><span class="line">Std. dev. of bucket size:     0.766</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :       831 &#x3D;     19944 bytes, avg  24.000</span><br><span class="line">Number of literals      :       831 &#x3D;     56304 bytes, avg  67.755</span><br><span class="line">Total footprint         :           &#x3D;    556352 bytes</span><br><span class="line">Average bucket size     :     0.014</span><br><span class="line">Variance of bucket size :     0.014</span><br><span class="line">Std. dev. of bucket size:     0.118</span><br><span class="line">Maximum bucket size     :         2</span><br></pre></td></tr></table></figure>

<p>我们查看我们关心的<mark>StringTable</mark>信息：</p>
<p>我们的串池本质结构是HashTable，它的本质是一个Map，其中的存储结构使用的是数组的方式，每一个bucket为一个数组结构，数字代表其中存储的字符串个数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :       831 &#x3D;     19944 bytes, avg  24.000</span><br><span class="line">Number of literals      :       831 &#x3D;     56304 bytes, avg  67.755</span><br></pre></td></tr></table></figure>



<p>下面写入10万个字符，来强制触发GC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100000</span>;j++)&#123;</span><br><span class="line">             String.valueOf(j).intern();</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;504K(9728K), 0.0015310 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2544K-&gt;512K(2560K)] 2552K-&gt;528K(9728K), 0.0010023 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2560K-&gt;480K(2560K)] 2576K-&gt;520K(9728K), 0.0013527 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">100000</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 1295K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 39% used [0x00000007bfd00000,0x00000007bfdcbc60,0x00000007bff00000)</span><br><span class="line">  from space 512K, 93% used [0x00000007bff00000,0x00000007bff78020,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 7168K, used 40K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf60a000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3095K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 339K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 &#x3D;    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     12129 &#x3D;    291096 bytes, avg  24.000</span><br><span class="line">Number of literals      :     12129 &#x3D;    467440 bytes, avg  38.539</span><br><span class="line">Total footprint         :           &#x3D;    918624 bytes</span><br><span class="line">Average bucket size     :     0.606</span><br><span class="line">Variance of bucket size :     0.606</span><br><span class="line">Std. dev. of bucket size:     0.778</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 &#x3D;    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :     15285 &#x3D;    366840 bytes, avg  24.000</span><br><span class="line">Number of literals      :     15285 &#x3D;    866120 bytes, avg  56.665</span><br><span class="line">Total footprint         :           &#x3D;   1713064 bytes</span><br><span class="line">Average bucket size     :     0.255</span><br><span class="line">Variance of bucket size :     0.267</span><br><span class="line">Std. dev. of bucket size:     0.516</span><br><span class="line">Maximum bucket size     :         4</span><br></pre></td></tr></table></figure>

<p>我们发现日志显示发生了三次Yong gc（新生代GC），Number of entries 是15285，没有达到10万，说明了我们的串池是会发生GC的。</p>
<h5 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h5><p>由于<strong>StringTable</strong>的本质是一个<strong>HashTable</strong>,那我们调优的思路就是：减少hash碰撞，加快查找速度；</p>
<ul>
<li><p>减少hash碰撞的方法，就是通过<strong>增加HashTable桶的个数</strong>去减少字符串放入串池所需时间</p>
<p>方法参数：<code>-XX:StringTableSize=xxxx</code></p>
</li>
<li><p>另一种调优思路，由于有许多字符串是重复的，并不是都要放入串池中，因此可以通过<mark>intern()</mark>方法去减少重复入池</p>
</li>
</ul>
<h3 id="方法区-堆-JV栈间关系"><a href="#方法区-堆-JV栈间关系" class="headerlink" title="方法区 堆 JV栈间关系"></a>方法区 堆 JV栈间关系</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200718171257640.jpg" alt="img"></p>
<p>如上图一条Java新建对象实例语句：</p>
<ol>
<li>第一个Person是<strong>变量类型</strong>，所以存放在方法区（变量的类型，类的信息，等等）中</li>
<li>第二个person是<strong>局部变量引用</strong>，在一个方法中写的，所以放在JVM栈中</li>
<li>第三个new Person()；是一个<strong>实例化对象</strong>，所以放在Java堆中</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200718171302947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA1MDg1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>JVM栈中为局部变量的引用，实际上是指向Java堆中的对象实例，然后对象实例又指向方法区中的对象类型。</strong></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li><p>直接内存（Direct Memory）并<strong>不是</strong>运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，属于操作系统直接管理</p>
</li>
<li><p>JDK 1.4中引入了NIO类（New Input/Output）类，引入了一种基于<strong>通道</strong>与<strong>缓冲区（Buffer）</strong>的IO方式，可以使用<strong>Native函数库</strong>直接的去分配<strong>堆外内存</strong>，接着通过一个存储在<strong>Java堆</strong>中的<code>DirectByteBuffer</code>对象去作为<strong>这块内存（也就是所分配的堆外内存）</strong>的引用进行操作。这样在一些场景中就能显著的提高性能，为什么呢？因为避免了在<strong>Java堆</strong>和<strong>Native堆</strong>中来回复制数据</p>
<p>（我们可以结合下面的文件读写部分进行理解）</p>
</li>
</ul>
<h3 id="文件读写的流程"><a href="#文件读写的流程" class="headerlink" title="文件读写的流程"></a>文件读写的流程</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210331222026374.png" alt="image-20210331222026374"></p>
<p>Java语言本身并没有读写磁盘文件的能力，想要去读写文件需要依靠<strong>操作系统</strong>为我们提供的函数。因此需要用户态切换到内核态</p>
<p><img src="https://www.pianshen.com/images/752/e1021c66ff23345c1b990f6edae93b10.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>在内核态时，需要内存如上两个图所示。也就是先把磁盘文件读到系统内存中的<strong>系统缓冲区</strong>，再读到Java堆内存中的<strong>java缓冲区byte[]</strong>。</p>
<p>使用IO，这里需要两份内存存储重复数据，效率低；</p>
</li>
</ul>
<p>而是用了<code>DirectByteBuffer</code>后呢？</p>
<p>我们多出来一块：<strong>direct memory（直接内存）</strong>，使得磁盘文件可和java内存都可以直接读到这里面，省了一次缓冲区的复制操作，这样子的特性适合大文件的读写操作。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401155032539.png" alt="image-20210401155032539"></p>
<p><img src="https://www.pianshen.com/images/766/fa8aecd7819647645d2f83ee72d3db5e.png" alt="在这里插入图片描述"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p> 虽然本机<strong>直接内存</strong>的分配并不会受到<strong>Java堆</strong>的大小限制。However，既然是内存肯定就会受到<strong>本机的总内存（物理内存、SWAP分区or分页文件</strong>的大小以及<strong>处理器寻址空间</strong>的限制！</p>
<p>有时候我们管理实际内存去设置<code>-Xmx</code>等参数信息，却往往省略掉了去管理直接内存，这就会导致：各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<strong><mark>OutOfMemoryError</mark></strong>异常</p>
<h3 id="直接内存释放"><a href="#直接内存释放" class="headerlink" title="直接内存释放"></a>直接内存释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -XX:+DisableExplicitGC 显式的 让显示的垃圾回收无效（小tips）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕...&quot;</span>);</span><br><span class="line">        System.in.read();<span class="comment">//控制台随便摁一下 模拟一个空隙</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放...&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 显式的垃圾回收，Full GC</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行后，我们能看到进程分配了1个G内存</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161651540.png" alt="image-20210401161651540"></p>
<p>接着byteBuffer指空，被回收</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401161711251.png" alt="image-20210401161711251"></p>
<p>那我们可不可以理解成是使用了<code>System.gc()</code>导致直接内存被回收了呢？但垃圾回收是JVM的内容，JVM不是不会管理直接内存么？</p>
<p>其实他是使用了<code>unsafe.freeMemory();</code>进行释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放前：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163229697.png" alt="image-20210401163229697"></p>
<p>释放后：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401163240449.png" alt="image-20210401163240449"></p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>我们点进<code>allocateDirect</code>这个方法，它内部是使用了<code>DirectByteBuffer(capacity)</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectByteBuffer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，我们发现它底层调用的其实就是<code>unsafe</code>类</p>
<p>同时需要留意一行代码：<code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code></p>
<p>解读：Cleaner是虚引用类型，特点：关联的对象被回收时，会调用Cleaner的clean方法（在这里的this → DirectByteBuffer)</p>
<p>下面就来看看clean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的thunk指的是任务对象，执行其run方法，去真正的进行内存释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;<span class="comment">//任务对象 在这里指的是：new Deallocator(base, size, cap) </span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质执行的就是下面这段代码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用了<strong>Unsafe</strong>类来完成直接内存的分配回收，回收需要主动调用<strong>freeMemory</strong>方法</li>
<li>ByteBuffer的实现内部使用了<strong>Cleaner（虚引用）</strong>来检测<strong>ByteBuffer</strong>。一旦<strong>ByteBuffer</strong>被垃圾回收，那么会由<strong>ReferenceHandler</strong>来调用<strong>Cleaner</strong>的<mark>clean</mark>方法调用<mark>freeMemory</mark>来释放内存</li>
</ul>
<h1 id="※垃圾回收※"><a href="#※垃圾回收※" class="headerlink" title="※垃圾回收※"></a>※垃圾回收※</h1><p>引言：Java与C++之间有一堵由内存动态分配和垃圾收集技术所围起的高墙，墙外的人想进去，墙里的人却想出来</p>
<h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><p>大致思路：由于堆中存放着Java世界中几乎所有的<strong>对象实例</strong>，垃圾收集器在对堆进行回收前，首先要判断哪些是“垃圾”，怎么定义“垃圾”呢？那就是通过判断对象的“死活”，也就是判断哪些对象还<mark>存活</mark>着，而哪些已经<mark>死去</mark>了（死去：即不可能再被任何途径使用的对象）</p>
<p>AKA，我们能够判断哪些对象死去了，就能够判断该对象是否能被回收了，下面介绍几种能达到这效果的算法。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>思路：在<strong>对象</strong>中添加一个<strong>引用计数器</strong>，每当有一个地方引用它的时候，<strong>计数器值+1</strong>；而当引用失效的时候，<strong>计数器值-1</strong>；任何时刻<strong>计数器值 = 0</strong>的对象就代表着是不可能再被使用的。</li>
</ul>
<p>这种算法看似简单，但需要大量额外处理才能保证正确地工作，譬如简简单单一个<strong>引用计数法</strong>就很难解决对象之间的<mark>循环引用问题</mark></p>
<p>如下图：对象<strong>objA</strong>和对象<strong>objB</strong>间有字段<code>instance</code>，我们下面进行赋值</p>
<p>令：<code>objA.instance = objB</code>和<code>objB.instan = objA</code></p>
<p>同时，这两个对象没有别的引用了，按照定义来说，这两个对象是不可能被访问的了，但由于他们互相引用对方，导致了他们的<strong>引用计数器值</strong>不为0，而我们也就无法按照引用计数算法去回收他们；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401170801241.png" alt="image-20210401170801241"></p>
<h3 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h3><ul>
<li><p>思路：通过一系列称为<mark>GC Roots</mark>的根对象作为<strong>起始字节集</strong>，从这些节点开始，根据<strong>引用关系</strong>去向下搜索，搜索过程中我们走过的路径称之为：<strong>引用链（Reference Chain）</strong>，如果某个对象到<mark>GC Roots</mark>间没有任何的<strong>引用链</strong>相连，用图论的话就是：从<mark>GC Roots</mark>到这个对象是<strong>不可达</strong>的时候，就证明这个对象是不可能再被使用的；</p>
<p>（其实就是当时学数据结构说的图，然后判断可达性的算法啦）</p>
</li>
</ul>
<p>eg：下图</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401172719840.png" alt="image-20210401172719840"></p>
<h4 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h4><p>通过上面对于可达性算法的学习，确定<mark>GC Roots</mark>根对象就显得尤为重要了，那么哪些类可以作为根对象呢？</p>
<ol>
<li><p>在虚拟机栈（栈帧中的本地变量表）中<strong>引用的对象</strong>，神神叨叨的，什么意思呢？其实就是各线程被调用的<strong>方法堆栈</strong>中使用到的<strong>参数、局部变量、临时变量等</strong></p>
</li>
<li><p>在方法区中<strong>类静态属性</strong>所引用的对象，such as：Java类的引用类型静态变量</p>
</li>
<li><p>在方法区中<strong>常量</strong>引用的对象，such as：字符串常量池中的引用</p>
</li>
<li><p>在本地方法栈中<strong>JNI（也就是,NATIVE方法）</strong>引用的对象</p>
</li>
<li><p>在<strong>Java虚拟机内部</strong>的引用，such as：基本数据类型对应的Class对象，一些常驻的异常对象（NullPointException，OutOfMemoryError）等，以及系统类加载器</p>
</li>
<li><p>所有被<strong>同步锁（synchronized关键字）</strong>持有的对象</p>
</li>
<li><p>反应Java虚拟机内部情况的<strong>JMXBean、JVMTI</strong>中注册的回调、本地代码缓存等</p>
</li>
<li><p>根据<strong>垃圾收集器和当前回收区域</strong>的不同，还可能临时加入其它GC Roots。</p>
<p>比如：分代收集和局部回收，这个区域的对象完全可能被其他区域对象所引用，例如老年代的对象引用与年轻代的对象实例。</p>
<p><strong>在新生代建立一个全局数据结构“记忆集”。这个结构把老年代划分为若干小块，标识出哪一块会出现跨代引用。此后发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入GC Roots进行扫描。该方法需要在对象改变引用关系时维护记录数据的正确性。</strong></p>
</li>
</ol>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>可达性算法的两个要求：根对象 + 引用，上面讲完了根对象，接下来来学习<strong>引用</strong></p>
<ul>
<li>Java中对于引用的概念：如果<code>reference</code>类型的数据中<strong>存储的数值</strong>代表的是<strong>另一块内存的起始地址</strong>，就称该<code>reference</code>数据是代表<strong>某块内存、某个对象</strong>的<mark>对象</mark>（其实就是指针的概念吧？)</li>
</ul>
<h5 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h5><p>然而如果我们对于一个对象只定义：被引用了、未被引用。那我们就无法描述一些留在内存中有点没必要，但丢了又有点浪费（食之无味，弃之可惜？）的对象了不是吗？因此，就对引用的概念进行扩充，将引用分为：<strong>强引用、软引用、弱引用和虚引用</strong></p>
<p>（下图中，实线代表强引用，虚线代表软、弱、虚）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401181412932.png" alt="image-20210401181412932"></p>
<p>概述：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211909934.png" alt="image-20210401211909934"></p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><ul>
<li>强引用（Strongly Reference）</li>
</ul>
<p>其实就是最传统的关于<code>引用</code>的定义，指的是代码中普遍存在的<strong>引用赋值</strong>，即：<code>Object obj = new Object();</code></p>
<p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><ul>
<li>软引用（Soft Reference）</li>
</ul>
<p>描述一些还有用，但不是必须的对象</p>
<p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<ul>
<li><p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
</li>
<li><p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">		<span class="comment">//list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line">        <span class="comment">//list对SoftReference为强引用，而SoftReference对byte[]则是弱引用</span></span><br><span class="line">        <span class="comment">//list先引用软引用对象 再间接引用byte数组</span></span><br><span class="line">		List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过软引用对象创建数组</span></span><br><span class="line">		SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref= <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4M]);</span><br><span class="line">        <span class="comment">//将该软引用对象加入list中</span></span><br><span class="line">        list.add(ref);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而软引用本身也要占有一部分内存（虽然很小），如果想把这部分清除掉，需要配合<strong>引用队列</strong>去清理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同样 构建list --&gt; SoftReference --&gt; byte[]三者关系</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构建了引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//模拟存储5个 4MB的byte[]数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//构建SoftReference软引用对象</span></span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            <span class="comment">//加入list</span></span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="comment">//遍历引用队列 直到不为空</span></span><br><span class="line">        <span class="keyword">while</span>( poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//移除</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">//移动到队列中的下个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401213735454.png" alt="image-20210401213735454"></p>
</li>
</ul>
<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><ul>
<li>弱引用（Weak Reference）</li>
</ul>
<p>描述非必须对象，且强度比软引用更弱一些。</p>
<p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<ul>
<li><p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  list --&gt; WeakReference --&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; w : list) &#123;</span><br><span class="line">                System.out.print(w.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体上来说和软引用差不多，只是将<strong>SoftReference 换为了 WeakReference</strong></p>
</li>
</ul>
<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401182820987.png" alt="image-20210401182820987"></p>
<p>上面我们其实在学习直接内存的内存管理部分有接触过虚引用（Cleaner就是个虚引用）</p>
<p>使用场景：假如有一个ByteBuffer被垃圾回收后，留下来的直接内存是不会被回收掉的，因此就需要使用到虚引用，由于虚引用指向直接内存的地址，则可以通过unsafe.freeMemory去释放直接内存。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401183107197.png" alt="image-20210401183107197"></p>
<h6 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h6><ul>
<li>终结器引用（FinalReference）</li>
</ul>
<p>我们知道，所有的类都继承自<strong>Object类</strong>，<strong>Object类</strong>有一个<mark>finalize</mark>方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的<mark>finalize</mark>方法。调用以后，下一次GC时，该对象的内存就可以被回收掉了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401211654862.png" alt="image-20210401211654862"></p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>上面讲述了如何判断对象是不是垃圾，接下来章节就要学习如何进行垃圾回收了。</p>
<p>垃圾回收算法可划分为两大部分：<strong>引用计数式垃圾收集（Reference CountingGC）</strong>和<strong>追踪式垃圾收集（Tracing GC）</strong>两大类，这两类也分别被称为：<strong>直接垃圾收集</strong>和<strong>间接垃圾收集</strong></p>
<p>下面所介绍的算法均属于：<strong>追踪式垃圾收集（间接垃圾收集）</strong>范畴</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><ul>
<li><p>标记 - 清除（Mark-Sweep）：这是最早也是最基础的垃圾回收算法，顾名思义，该算法分为<strong>【标记】</strong>和<strong>【清除】</strong>两个阶段</p>
<ul>
<li>首先标记<strong>所有</strong>需要回收的对象</li>
<li>在标记完成之后，统一回收到<strong>所有</strong>被标记的对象</li>
</ul>
<p>也可以反过来操作</p>
<ul>
<li>首先标记<strong>存活的对象</strong></li>
<li>统一回收没有被标记的对象</li>
</ul>
<p>标记的过程即判断对象是否为垃圾的过程；</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401220030117.png" alt="image-20210401220030117"></p>
<p>需要注意的是，清除并不是将内存中的字节清零，而是记录了内存的起始结束地址，在下次分配内存的时候，如果该块内存大小合适，则直接覆盖；</p>
<p>这部分的内容和操作系统中的内存管理很像，只不过这里好像不合并空闲的内存块，进而会产生内部碎片，产生内部碎片了，就无法满足大对象的内存分配啦，那jvm就不得不进行垃圾回收，那程序就不得不暂停，应用就不得不变慢</p>
<p>操作系统中关于内存管理部分笔记：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D</a> </p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><ul>
<li>标记 - 整理（Mark - Compact）算法：标记过程与<strong>标记 - 清除算法</strong>是相同的，而后续步骤就有些不一样了。</li>
</ul>
<p>我们知道，标记 - 清除算法有可能会产生大量的内部碎片，因此，标记 - 整理算法就是在这一点对标记 - 清除算法进行了优化。</p>
<p>它是怎么做的呢？它让所有存活的对象都向内存空间的一端进行移动，然后直接清除掉边界以外的内存。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210401221929519.png" alt="image-20210401221929519"></p>
<p>那难道这个算法就是完美的了吗？显然不是。</p>
<p>移动存活的对象，尤其是在<strong>老年代</strong>这种每次回收都有大量对象存活的区域，移动存活对象并且更新所有引用这些对象的地方将会是一种极为繁琐的操作。而且，对象在移动的时候，用户应用程序是必须暂停的（ps：这种停顿被最初的虚拟机设计者称为：“Stop The World” ）</p>
<p>然而，结合OS的学习我们知道，我们完全可以不移动和整理存活对象的内存。可以依靠<strong>内存分配器和内存访问器</strong></p>
<p>such as：使用<strong>分区空闲分配链表</strong>，关于这部分的内容，我的博客有记载：<a target="_blank" rel="noopener" href="https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95">https://uesugier11.gitee.io/uesugi-er11/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95</a></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h3><ul>
<li>标记 - 复制算法被简称为<strong>复制算法</strong>。它的本质是利用了【半区复制】：将可用的内存按照容量划分成了<strong>大小相等的两块</strong>，每次只去使用其中的一块。当这一块内存用完了，就把还存活着的对象复制到另一块上面，再将已经使用过的内存空间一次清理。</li>
<li>优点：虽然说如果内存中多数对象是存活的时候，需要产生大量的内存间复制的开销；但如果大多数对象都是可以回收的话，算法需要复制的就是这部分少数的存活对象了。且这种算法无需考虑有空间碎片的复杂情况，只需要移动<strong>堆顶指针</strong>，按照顺序去分配就好了</li>
<li>缺点：这种算法会将可用的内存变为原来的一半（一半真实投入利用，一半等着放入存活对象）</li>
</ul>
<p>首先标记垃圾，然后将存活的对象复制到另一块上</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></p>
<p>接着清空垃圾</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164402777.png" alt="image-20210402164402777"></p>
<p>接着交换两块的位置，FROM→TO，TO→FROM</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402164522414.png" alt="image-20210402164522414"></p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><h3 id="分代垃圾回收理论"><a href="#分代垃圾回收理论" class="headerlink" title="分代垃圾回收理论"></a>分代垃圾回收理论</h3><p> 当前大多数商业虚拟机的GC，大都遵循“分代收集”设计。</p>
<p>它建立在了两个分代假说之上</p>
<ol>
<li>弱分代假说（Weak Generatjional Hypothesis）：绝大多数的对象都是<strong>朝生夕死</strong>的</li>
<li>强分代假说（Strong Generatjional Hypothesis）：熬过越多次垃圾回收过程的对象就<strong>越难以消亡</strong></li>
</ol>
<p>基于这两个假说，垃圾收集器的设计就有了原则：垃圾收集器应该将<strong>Java堆</strong>划分出不同的区域，然后将回收对象按照<strong>年龄</strong>（对象熬过垃圾回收过程的次数）为依据，分配到不同的区域的存储；</p>
<p>这样做有什么好处呢？好处在于，各分区内的对象具有的特点很明显，虚拟机就能依据其特点去回收了，能提高效率；</p>
<p><strong>Java堆</strong>划分出不同区域后，垃圾收集器才能每次只回收其中某一个/某一些区域，因此也才衍生了：<mark>Minor GC、Major GC、Full GC</mark>这样的回收类型划分，进而，也才能够针对<strong>不同的区域</strong>安排与<strong>里面所存储的对象的特征</strong>相匹配的GC算法 —— 上面提到的那些算法。</p>
<p>一般来说，会把<strong>Java堆</strong>划分为：<mark>新生代（Young Generation）</mark>和<mark>老年代（Old Generation）</mark>.</p>
<ul>
<li>新生代：特点在于每次垃圾收集时都有大量的对象死去</li>
<li>老年代：从每次回收中存活下来的对象都存储在这</li>
</ul>
<h3 id="分代垃圾回收过程"><a href="#分代垃圾回收过程" class="headerlink" title="分代垃圾回收过程"></a>分代垃圾回收过程</h3><p>首先要明确，新对象会在伊甸园中产生。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150939.png" alt="img"></p>
<p>此时，伊甸园已满，没有办法存储新的对象，则触发了一次GC</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150946.png" alt="img"></p>
<p>会将存活的对象复制到<strong>幸存区TO</strong>中，由于捱过了一次垃圾回收，因此寿命+1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608150955.png" alt="img"></p>
<p>同时白板FROM与幸存区TO交换内存</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151002.png" alt="img"></p>
<p>此时假如伊甸园满了，而恰巧又创建了个新对象，那此时会再次触发<strong>Minor GC</strong>，这次会把<strong>伊甸园中</strong>和<strong>幸存区</strong>中的垃圾都回收了，除此之外，其他操作和上述基本相同；</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402215216638.png" alt="image-20210402215216638"></p>
<p>我们注意到，我们的老年代一直是空着的，那难道他是没有用处的嘛？还记得我们说的关于老年代的特点吗？他是存储经历了多次<strong>Minor GC</strong>但仍存活下来的对象的。那我们怎么判断一个对象存活的次数够不够多呢？通常来说就会设置一个<strong>阈值（最大为15,4bit）</strong>，达到了，就会放入老年代中。（当然，如果内存实在是紧张有时候不会去管那个阈值，直接将对象移入老年代）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220116879.png" alt="image-20210402220116879"></p>
<p>假如，我们的老年代也放满了，那<strong>Minor GC</strong>就无法达到内存回收了，此时就会触发<strong>Full GC</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220402831.png" alt="image-20210402220402831"></p>
<h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402220907130.png" alt="image-20210402220907130"></p>
<h3 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h3><p>正常来说，当新的对象创建，进行GC，放入伊甸园，走一个这样完整的流程；</p>
<p>但如果我们创建的对象过于大，导致新生代无法容纳，那么就会把这个对象直接放入老年代；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210402222723556.png" alt="image-20210402222723556"></p>
<ul>
<li>线程内存溢出问题</li>
</ul>
<p>假如某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h2 id="HotSpot算法细节-概念辨析"><a href="#HotSpot算法细节-概念辨析" class="headerlink" title="HotSpot算法细节 - 概念辨析"></a>HotSpot算法细节 - 概念辨析</h2><p>由于我们接下来会引用到一些专用名词：三色标记法、增量更新、记忆集、卡表等，因此我们需要对这几个名词的出现场景以概念进行一定的理解；</p>
<h3 id="分代收集理论扩展"><a href="#分代收集理论扩展" class="headerlink" title="分代收集理论扩展"></a>分代收集理论扩展</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>记不记得我们的<strong>分代垃圾回收理论</strong>部分立下了2条假说/法则？</p>
<ol>
<li>弱分代假说（Weak Generatjional Hypothesis）：绝大多数的对象都是<strong>朝生夕死</strong>的</li>
<li>强分代假说（Strong Generatjional Hypothesis）：熬过越多次垃圾回收过程的对象就<strong>越难以消亡</strong></li>
</ol>
<p>现在我们引入了第三条法则：</p>
<ul>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>有什么用呢？别急，下面来进行解释：</p>
<p>首先需要明白在分代收集部分并非只是简单划分一下内存区域那么简单的，它存在一个明显的困难：对象之间并不是孤立的，对象之间会存在<strong>跨代引用</strong>，什么意思呢？</p>
<p>假如现在进行一次只局限于新生代区域内的收集（即Minor GC），但是新生代的对象有没有可能被老年代所引用呢？完全有这个可能。而为了找出该区域中的存活对象，就不得不在固定的<strong>GC Roots</strong>之外，额外去遍历整个<strong>老年代中</strong>所有对象去确保可达性分析结果的正确性（翻译大白话就是：找出新生代中对象被哪些老年代引用了），这种方案会为内存的回收带来极大的性能负担，因此就需要我们的第三条法则了。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>这个理论的本质，或者说我们该怎么去理解呢？</p>
<ul>
<li>存在相互引用关系的两个对象，是倾向于同时生存或者同时消亡的。</li>
</ul>
<p>eg：一个新生代对象存在跨代引用（一个老年代对象引用了该对象），由于老年代对象难以消亡，这份引用（羁绊）会使得新生代对象在GC的时候得以存活，这样时间久了，新生代会晋升到老年代中，此时就不存在<strong>跨代引用</strong>了</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>根据这条假说，既然这种跨代引用为少数情况，则我们不该为了这少量的跨代引用去扫描<strong>整个老年代</strong>，也不必去浪费空间去专门记录每一个对象是否存在哪些跨代引用了，就只需要在新生代上建立一个全局的数据结构（即<strong>记忆集</strong>），该结构将<strong>老年代</strong>划分成若干小块，并且标识出了老年代中哪块内存会存在<strong>跨代引用</strong>。</p>
<p>这样之后发生Minor GC的时候，只有这部分的小块内存中对象才会被加入到<mark>GC Roots</mark>进行扫描。Although，这种方法需要在对象改变引用关系（或将自己或某个属性赋值）时，维护记录数据的正确性，增加了一些运行的开销，但比起之前说的扫描整个老年代来说肯定是划算不少了。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h4><p>上面提到了记忆集这个数据结构，下面就来详解一下：</p>
<ul>
<li><p>记忆集是一种用于记录从<strong>非收集区域</strong>指向<strong>收集区域</strong>的<strong>指针集合</strong>的<strong>抽象数据结构</strong>，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构(下列代码为用对象指针去实现的记忆集)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class RememberedSet &#123;Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节</p>
<p>那设计者在实现记忆集的时候，便可以选择更为“粗犷”的<strong>记录粒度</strong>来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范围以外的的记录精度</p>
<ol>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ol>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>上述的卡精度的具体实现，是使用了一种叫<strong>卡表（Card Table）</strong>的方式去实现的记忆集，也是目前最常用的一种记忆集的实现形式（一些资料中甚至直接把它和记忆集混为一谈）</p>
<p>怎么理解卡表呢？记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。（用HashMap和Map的关系去理解吧）</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>卡表最简单的形式可以只是一个字节数组（之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是最小按字节寻址的， 没有直接存储一个bit的指令，所以要用bit的话就不得不多消耗几条shift+mask指令。）</p>
<p>即：<code>CARD_TABLE [this address &gt;&gt; 9] = 0</code> 表示的是HotSpot默认的卡表标记逻辑</p>
<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个 内存块被称作<mark>“卡页”（Card Page）</mark>。</p>
<p>一般来说，卡页大小都是以<strong>2的N次幂的字节数</strong>，通过上面代码可 以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如 果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了 地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块，如下图所示：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405180124566.png" alt="image-20210405180124566"></p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，<strong>称为这个元素变脏（Dirty，脏表</strong>），没有则标识为0。</p>
<p>在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入<mark>GC Roots</mark>中一并扫描。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>我们可以顺便来梳理一下：分代收集理论存在跨代引用问题 → 使用记忆集卡表进行解决 → 卡表何时变脏？谁来把他们变脏？</p>
<p>这留下来了两个疑问。有问题就得解决</p>
<ol>
<li>卡表元素何时变脏？有其他分代区域中对象引用了本区域对象时，其对应的 卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻</li>
<li>如何变脏，即如何在对象赋值的那一刻去更新维护卡表？假如是<strong>解释执行的字节码</strong>，那相对好处理，虚拟 机负责每条字节码指令的执行，有充分的介入空间；但在<strong>编译执行</strong>的场景中呢？经过即时编译后的代 码已经是纯粹的机器指令流了，这就必须找到一个在<mark>机器码层面</mark>的手段，把维护卡表的动作放到每一 个赋值操作之中。 </li>
</ol>
<h4 id="写屏障-1"><a href="#写屏障-1" class="headerlink" title="写屏障"></a>写屏障</h4><p>下面就对第二个问题进行更深一步理解：</p>
<p>在HotSpot虚拟机里是通过<mark>写屏障（Write Barrier）技术</mark>维护卡表状态的。</p>
<ul>
<li>ps：写屏障（Write Barrier）≠ 内存屏障（Memory Barrier），后者的目的是为了指令不因编译优化、CPU执行优化等原因 而导致乱序执行，它也是可以细分为仅确保读操作顺序正确性和仅确保写操作顺序正确性的内存屏障 的</li>
</ul>
<p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的<strong>AOP切面</strong>（有没有觉得很熟悉？没错，就是Spring中的那个），在引用对象赋值时会产生一个<strong>环形（Around）通知</strong>，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。</p>
<p>在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值 后的则叫作写后屏障（Post-Write Barrier）。</p>
<p>下面是一段写后屏障更新卡表的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 引用字段赋值操作</span></span><br><span class="line">*field = new_value;</span><br><span class="line"><span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">post_write_barrier(field, new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然应用这种技术后，只要对引用更新，就会产生额外的开销，但这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
<p>除了开销外还有一个问题：卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</p>
<p>伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != <span class="number">0</span>)</span><br><span class="line">CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>我们可以使用一个新的参数<code>+UseCondCardMark</code>，去决定是否开启卡表更新的条件判断，开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡</p>
<h3 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h3><p>使用三色标记：</p>
<ul>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201052497.png" alt="image-20210405201052497"></p>
<p>在上图中，最后一种情况会发生“对象消失”的问题，即原本应该是黑色的对象被标注为白色，导致被误认为是垃圾回收掉了</p>
<p>本质上来说，当且仅当以下两个条件同时满足时，这种情况会发生：</p>
<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
<p>因此衍生了</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="总概述"><a href="#总概述" class="headerlink" title="总概述"></a>总概述</h3><p>垃圾回收算法是内存回收的方法论，垃圾回收器则为内存回收的实践者。（下图为HotSpot虚拟机的垃圾回收器，连线表示可以搭配使用）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404145418336.png" alt="image-20210404145418336"></p>
<p>那么我们如何评判一个垃圾回收器好不好呢？需要什么指标呢？</p>
<p>一般来说我们从这三个方面入手去评判</p>
<ol>
<li><p><mark>吞吐量</mark>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
</li>
<li><p><mark>暂停时间</mark>：STW发生的时间</p>
</li>
<li><p><mark>内存占用</mark>：Java堆区所占的内存大小</p>
<p>注重吞吐量（做的事多），每次STW时间长，总时长短</p>
<p>注重低延迟（用户交互性好，不卡），每次STW间隔短，总时长长</p>
</li>
</ol>
<p><strong>现在的垃圾回收器标准：在满足最大吞吐量优先的情况下，降低停顿时间。</strong></p>
<h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li>串行垃圾回收器适用场景<ul>
<li>单线程</li>
<li>内存小，多用于个人电脑（CPU核数较少）</li>
</ul>
</li>
</ul>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul>
<li>Serial（串行），从名字看出来这是一个单线程工作收集器，其潜在意义是：在进行GC的时候，会强制暂停其他所有的工作进程。</li>
<li>参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103523827.png" alt="在这里插入图片描述"></p>
<ul>
<li>特点<ul>
<li>简单而高效：Serial收集器没有线程交互的开销，专心做GC回收，因此可以获得最高的单线程收集效率</li>
<li>额外内存消耗较小</li>
</ul>
</li>
</ul>
<p>基于以上特点，Serial收集器适用于运行在客户端模式下的虚拟机</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul>
<li>ParNew收集器：本质是<strong>Serial收集器</strong>的多线程并行版本</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103529454.png" alt="在这里插入图片描述"></p>
<ul>
<li>特点<ul>
<li>支持多线程并行收集</li>
<li>只有这个收集器能够和<strong>CMS收集器</strong>配合工作（CMS收集器是HotSpot虚拟机中第一款支持并发的垃圾收集器，首次实现了让垃圾收集线程和用户线程（基本上）同时工作。</li>
<li>ParNew收集器较Serial在多核cpu上效率更高。</li>
</ul>
</li>
<li>并发与并行区别<ul>
<li><strong>并发</strong>：并发描述的是垃圾收集器线程和用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程序都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量会受到一定影响。</li>
<li><strong>并行</strong>：并行描述的是多条垃圾收集器之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程处于等待状态</li>
</ul>
</li>
</ul>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul>
<li>吞吐量优先垃圾回收器适用场景<ul>
<li>多线程</li>
<li>堆的内存较大，多核CPU</li>
</ul>
</li>
<li>特点<ul>
<li>在单位的时间内，STW的时间最短</li>
<li>是<strong>JDK 1.8</strong>默认使用的垃圾回收器</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404152959054.png" alt="image-20210404152959054"></p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scanvenge收集器：是一款新生代收集器，同样基于<strong>标记-复制算法</strong>，能够实现并行收集。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png" alt="image-20210404154734362"></p>
<ul>
<li><p>特点：MDS等收集器的关注点是在于尽可能缩短<strong>STW</strong>时间，而这款收集器注重于达到一个<strong>可控制的吞吐量</strong></p>
</li>
<li><p>由于该款收集器注重于控制吞吐量，因此我们需要留意这 2个参数</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154222616.png" alt="image-20210404154222616"></p>
</li>
<li><p>GC自使用调节策略（与ParNew收集器最重要的一个区别）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154248333.png" alt="image-20210404154248333"></p>
</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><ul>
<li>Parallel Old收集器：是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，是基于标记 - 整理算法实现的</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154734362.png" alt></p>
<ul>
<li>特点：在注重吞吐量，或者处理器资源较为稀缺的场合，优先考虑<strong>Parallel Scavenge收集器 + Parallel Old收集器</strong>这个组合</li>
</ul>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210404154955660.png" alt="image-20210404154955660"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><ul>
<li>CMS收集器（Concurrent Mark Sweep）：一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</li>
</ul>
<p>使用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<ul>
<li><p>特点</p>
<ul>
<li>基于<strong>标记-清除算法</strong>实现。</li>
<li>从总体来说，内存回收过程能与用户线程一起并发执行</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p><strong>处理器资源敏感</strong>。特别是核心数少的处理器，因为GC占用线程，所以总吞吐量降低。</p>
</li>
<li><p><strong>难以应对“浮动垃圾”（即在标记完成后出现的新垃圾）</strong>，因为有并发标记的阶段，所以这阶段产生的垃圾不会被标记，这些垃圾只能等到下一次垃圾收集时清理。</p>
<p> 同时，CMS不能等到老年代几乎填满后再启动，因为他必须留下足够的内存，在垃圾收集的同时给用户线程使用。预留过多会造成内存浪费以及回收频繁；预留过少会造成“并发失败”，并发失败发生后虚拟机会调用Serial Old重新收集，会使性能下降。</p>
</li>
<li><p>由于标记-清除算法，而产生的<strong>空间碎片化</strong>问题，甚至可能会进行一次Full GC。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719103534693.png" alt="在这里插入图片描述"></p>
<ul>
<li>运作过程：<ul>
<li>初始标记（initial mark）：仅标记一下<strong>GC Roots</strong>能直接关联到的<strong>对象</strong>，追求时间效率，避免用户久等。</li>
<li>并发标记（cocurrent mark）：从<strong>GC Roots直接关联对象开始遍历整个对象图（所有的可达的对象）</strong>，这个过程耗时长但不需要<strong>停顿用户线程</strong>，此过程可以与<strong>垃圾回收线程</strong>一起<mark>并发</mark>运行</li>
<li>重新标记（remark）：为了修正<strong>并发标记</strong>期间，用户程序继续运作而导致标记变动的那部分对象的<strong>标记记录</strong>（这是在并发可达性分析中，增量更新部分的内容），此阶段的停顿时间通常比<strong>初始标记阶段</strong>时间长一点，但也远比<strong>并发标记</strong>阶段时间短</li>
<li>并发清除（concurrent sweep）：清除删除掉<strong>标记阶段</strong>中判断出来的已经死亡的对象，此阶段可以与用户线程<strong>同时并发</strong></li>
</ul>
</li>
</ul>
<h3 id="G1-Garabage-First-收集器"><a href="#G1-Garabage-First-收集器" class="headerlink" title="G1(Garabage First)收集器"></a>G1(Garabage First)收集器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>之前的收集器是以分代为衡量标准进行GC，而G1是面向<strong>堆内存任何部分组成回收集</strong>，衡量标注是哪块内存中存放的垃圾数量最多，则回收受益最大。</p>
<ul>
<li><p><strong>Region</strong>： G1在组建回收集时，不再根据新生代老年代衡量。而是把java堆划分为多个大小相等的<strong>Region</strong>，每个Region根据需要可以扮演<strong>新生代的Eden、Survivor存活区域或老年代区域</strong>。</p>
</li>
<li><p><strong>特点</strong>：既兼顾低延迟，也针对大吞吐量。</p>
</li>
<li><p><strong>Humongous区域</strong>：收集器再对不同Region采用不同策略进行收集。Humongous区域专门用来存放大对象（即超过Region一半大小的对象）。对于超过整个Region的对象，用多个连续Humongous存储。G1大多数行为将其视为<strong>老年代</strong>。</p>
</li>
<li><p><strong>注意点</strong>：G1仍保有新生代老年代概念，是一系列区域（不需要为连续的）的<mark>动态集合</mark>。G1将<strong>Region</strong>作为最小回收单元，因此停顿时间可预测（即每次手机的内存空间为<strong>Region</strong>大小整数倍，可以有计划的避免在这个Java堆尽心全区域的垃圾回收）</p>
<ul>
<li>具体实现：通过跟踪每个Region的回收价值大小（即回收所获得空间和回收所需时间的经验值），并<strong>维护一个优先级列表</strong>。回收时根据用户设定允许的回收停顿时间，优先处理价值高的Region。（这也是为什么说停顿时间是可预测的原因）</li>
</ul>
</li>
<li><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
</li>
</ul>
<h4 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151109.png" alt="img"></p>
<p>总的一个流程：</p>
<p>新生代伊甸园垃圾回收（Young Collection）—–&gt;内存不足，新生代回收+并发标记（Young Collection + Concurrent Mark）—–&gt;回收新生代伊甸园、幸存区、老年代内存（Mixed Collection）——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h5 id="Young-Collection-Minor-GC"><a href="#Young-Collection-Minor-GC" class="headerlink" title="Young Collection/Minor GC"></a>Young Collection/Minor GC</h5><p>即新生代收集：目标只是新生代的垃圾收集</p>
<ul>
<li>E：伊甸园</li>
<li>S：幸存区</li>
<li>O：老年代</li>
</ul>
<p>这个回收会发生：STW</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165247574.png" alt="image-20210405165247574"></p>
<p>新生代回收会将幸存对象以<strong>拷贝算法</strong>放入幸存区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165320293.png" alt="image-20210405165320293"></p>
<p>接着，当幸存区中对象过多，或者是年龄达到了<strong>阈值</strong>，则这部分对象会晋升到<strong>老年代</strong>，不够年龄的则拷贝到别处幸存区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165454440.png" alt="image-20210405165454440"></p>
<h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p><strong>CM并发标记</strong>：从<strong>GC Roots直接关联对象开始遍历整个对象图（所有的可达的对象）</strong></p>
<ul>
<li><p>在 <mark>Young GC</mark> 时会<strong>对 GC Root 进行初始标记</strong></p>
</li>
<li><p>在老年代<strong>占用堆内存的比例</strong>达到<strong>阈值</strong>时，对进行并发标记（不会STW），阈值可以根据参数：<code>-XX:InitiatingHeapOccupancyPercent=percent (默认45%)</code>去决定</p>
</li>
<li><p>E：伊甸园</p>
</li>
<li><p>S：幸存区</p>
</li>
<li><p>O：老年代</p>
</li>
</ul>
<p>如下图，当老年代（O，橙色部分）占用堆 空间比例达到我们设置的阈值的时候，会进行<strong>并发标记</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405165830879.png" alt="image-20210405165830879"></p>
<h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>混合收集：目标是收集整个新生代以及<strong>部分</strong>老年代的垃圾收集（目前只有G1收集器会有该行为）</p>
<p>在该阶段，会对E S O（具体含义看以下解释）进行全面的垃圾回收</p>
<ul>
<li>E：伊甸园</li>
<li>S：幸存区</li>
<li>O：老年代</li>
</ul>
<p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p>
<ul>
<li><p>回收过程：</p>
<ul>
<li><p>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍然遗留下来的最后那少量的SATB记录</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）：负责更新<strong>Region</strong>的统计数据，对各个Region的回收价值和成本进行排序（其实就是维护一个优先级列表啦），然后结合用户设置的停顿时间去制定一个回收计划，可自由的选择任意多个Region去构成一个<strong>回收集</strong>，然后把决定回收的那一部分Region的存活对象复制到空的Region，然后直接清理整个旧Region的全部空间。</p>
<p>由于这部分的操作设计到了存活对象的移动，因此是<strong>必须暂停用户线程的</strong>，由多条收集器线程<strong>并行完成</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170011836.png" alt="image-20210405170011836"></p>
<p>我们观察上图，发现并不是所有的老年代区域（O）都被复制到了新的老年代区域，是因为G1是根据我们上面的参数 —— 最大暂停时间，<strong>有选择</strong>的进行回收。也就是一开始我们的<mark>注意点</mark>部分中的：维护一个优先级列表，从列表中优先回收价值最高的区域。</p>
<p>从这个阶段，也能够体现出<strong>Garbage First</strong>的含义了。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ol>
<li>Full GC（整堆收集）：收集整个Java堆和方法区的垃圾收集</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405170927035.png" alt="image-20210405170927035"></p>
<p>对于G1算法来说，它老年代内存不足时需要分类讨论：</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h4 id="Young-Collection跨代引用"><a href="#Young-Collection跨代引用" class="headerlink" title="Young Collection跨代引用"></a>Young Collection跨代引用</h4><ul>
<li>这部分内容在HotSpot算法细节 - 概念辨析部分中有具体理解。</li>
</ul>
<p>跨代引用：老年代引用新生代</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151211.png" alt="img"></p>
<p>主要是通过了记忆集卡表去进行问题的解决。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151222.png" alt="img"></p>
<ul>
<li>在引用变更时通过post-write barried（写屏障） + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set（记忆集）</li>
</ul>
<h4 id="Remark-重新标记"><a href="#Remark-重新标记" class="headerlink" title="Remark - 重新标记"></a>Remark - 重新标记</h4><p>这部分内容使用到了<strong>三色标记</strong>，具体可以查看并发可达性分析部分的内容</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></p>
<p>这是一个GC Roots的图</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405201808678.png" alt="image-20210405201808678"></p>
<p>考虑这么个情况：假如C被判断成一个无引用的（白色）过后，A又去引用了C，那C应该是有引用的，那就不应该被回收掉，但是A又是黑色的，是已经检查过的元素，那在整个并发标记的过程结束后，我们仍然判断C为白色（应该被回收的对象），那这样就不对的了；</p>
<p>因此就需要对引用的对象进行二次检查，即重新标记Remark</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405202602146.png" alt="image-20210405202602146"></p>
<p>具体实现：</p>
<p>当对象的引用发生改变时，引用关系的插入与删除会通过写屏障去实现。</p>
<p>比如本例中，A引用C，则会把C加入到一个队列中，并改变其为灰色（没有被处理完），等整个并发标记阶段结束后，进入重新标记阶段，发生STW，将该队列中的对象拿出来重新进行检查，若是有引用的，则置为黑色，就不会被回收掉了</p>
<h4 id="G1-字符串去重"><a href="#G1-字符串去重" class="headerlink" title="G1-字符串去重"></a>G1-字符串去重</h4><ul>
<li>JDK 8U20 字符串去重</li>
</ul>
<p>提到字符串去重，除了之前提到的String方法中的<code>intern</code>方法外，G1还提供了另外一种方法</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>优点：节省了大量内存</li>
<li>缺点：新生代回收时间略微增加，导致略微多占用CPU</li>
<li>与String.intern()区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<h4 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h4><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<p><code>-XX:+ClassUnloadingWithConcurrentMark</code> 默认开启</p>
<h4 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h4><ul>
<li><p>一个对象大于region的一半时，就称为巨型对象</p>
</li>
<li><p>G1不会对巨型对象进行<strong>拷贝</strong>（因为代价太高了）</p>
</li>
<li><p>回收时被优先考虑</p>
</li>
<li><p>G1会跟踪老年代所有<strong>incoming</strong>引用（卡表），如果老年代<strong>incoming</strong>引用为0（卡表为0）的巨型对象就可以在新生代垃圾回收时处理掉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210405203350365.png" alt="image-20210405203350365"></p>
</li>
</ul>
<h4 id="JDK-9并发标记起始时间调整"><a href="#JDK-9并发标记起始时间调整" class="headerlink" title="JDK 9并发标记起始时间调整"></a>JDK 9并发标记起始时间调整</h4><ul>
<li><p>并发标记必须在<strong>堆</strong>空间占满之前完成，否则退化为 FullGC</p>
</li>
<li><p>JDK 9之前需要使用<code>-XX:InitiatingHeapOccupancyPercent</code></p>
</li>
<li><p>JDK 9之后可动态调整</p>
<ul>
<li><code>-XX:InitatingHeapOccupancyPercent</code>去设置初始值</li>
<li>进行数据采样并且动态调整</li>
<li>会添加一个安全的空档空间</li>
</ul>
<h2 id="GC-垃圾回收-调优"><a href="#GC-垃圾回收-调优" class="headerlink" title="GC(垃圾回收)调优"></a>GC(垃圾回收)调优</h2></li>
</ul>
<p>关于这部分内容，感觉是项大工程，之后系统的学习一下，不能囫囵吞枣，先把后续部分学了；</p>
<h1 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><ul>
<li><p>类字节码文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>类文件的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 			   magic;&#x2F;&#x2F;魔数</span><br><span class="line">    u2             minor_version;&#x2F;&#x2F;小版本号</span><br><span class="line">    u2             major_version;&#x2F;&#x2F;主版本号   </span><br><span class="line">    u2             constant_pool_count;&#x2F;&#x2F;常量池信息</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池信息</span><br><span class="line">    u2             access_flags;&#x2F;&#x2F;访问标志：返回一些信息（是类还是接口啊，是公共还是私有等)   </span><br><span class="line">    u2             this_class;&#x2F;&#x2F;类包名    </span><br><span class="line">    u2             super_class;&#x2F;&#x2F;父类信息   </span><br><span class="line">    u2             interfaces_count;&#x2F;&#x2F;接口信息    </span><br><span class="line">    u2             interfaces[interfaces_count];&#x2F;&#x2F;接口信息   </span><br><span class="line">    u2             fields_count;&#x2F;&#x2F;变量信息    </span><br><span class="line">    field_info     fields[fields_count];&#x2F;&#x2F;变量信息   </span><br><span class="line">    u2             methods_count;&#x2F;&#x2F;方法信息    </span><br><span class="line">    method_info    methods[methods_count];&#x2F;&#x2F;方法信息    </span><br><span class="line">    u2             attributes_count;&#x2F;&#x2F;附加属性信息   </span><br><span class="line">    attribute_info attributes[attributes_count];&#x2F;&#x2F;附加属性信息 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个Class文件的头4个字节被称为<strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。</p>
<p>如：0000000 <mark>ca fe ba be</mark> 00 00 00 34 00 23 0a 00 06 00 15 09 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic;&#x2F;&#x2F;魔数</span><br></pre></td></tr></table></figure>

<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>紧接着魔数的4个字节存储的是<strong>Class文件的版本号</strong>：第5和第6个字节是<strong>次版本号（Minor Version）</strong>第7和第8个字节是<strong>主版本号（Major Version）</strong></p>
<p>如：0000000 ca fe ba be <mark>00 00 00 34</mark> 00 23 0a 00 06 00 15 09 </p>
<p>此处的00 34中的34表示的是十六进制，即十进制的52：表示的是java8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;&#x2F;&#x2F;小版本号</span><br><span class="line">u2             major_version;&#x2F;&#x2F;主版本号   </span><br></pre></td></tr></table></figure>



<h3 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主、次版本号之后的是<strong>常量池</strong>入口，常量池可以比喻为Class文件里的<strong>资源仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;&#x2F;&#x2F;常量池信息</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池信息</span><br></pre></td></tr></table></figure>

<p>如：0000000 ca fe ba be 00 00 00 34 <mark>00 23 0a 00 06 00 15 09</mark></p>
<p>mark标记的是完整的常量池信息，我们通常拆分成小段去理解：</p>
<ul>
<li><p>0000000 ca fe ba be 00 00 00 34 <mark>00 23</mark> 0a 00 06 00 15 09 ：表示常量池的长度，00 23（35），表示常量池有#1~#34项，容量计数 从1而不是从0开始；空出来的原因：如果后面某些指向常量池的索引值的数据在特定情况下需要表达：”不引用任何一个常量池项目”的含义，就可以把索引值设置成0；</p>
</li>
<li><p>0000000 ca fe ba be 00 00 00 34 00 23 <mark>0a 00 06 00 15</mark> 09：<strong>0a（十进制中的10）</strong>表示一个方法引用，<strong>00 06</strong>和<strong>00 15（21）</strong>表示引用了常量池中#6和#21项来获得这个方法的【所属类】和【方法名】</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406201628119.png" alt="image-20210406201628119"></p>
</li>
</ul>
<p>后续部分以此类推，可阅读《深入理解JVM虚拟机》一书进行学习。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><ul>
<li>用于识别一些类或 者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;&#x2F;&#x2F;访问标志：返回一些信息（是类还是接口啊，是公共还是私有等)   </span><br></pre></td></tr></table></figure>

<p>具体的标志位以及其对应的含义见下表：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406202510383.png" alt="image-20210406202510383"></p>
<h3 id="类索引、福类索引与接口索引集合"><a href="#类索引、福类索引与接口索引集合" class="headerlink" title="类索引、福类索引与接口索引集合"></a>类索引、福类索引与接口索引集合</h3><p><strong>类索引（this_class）</strong>和<strong>父类索引（super_class）</strong>都是一个<strong>u2</strong>类型的数据，而<strong>接口索引集合 （interfaces）</strong>是一组u2类型的数据的<strong>集合</strong>，Class文件中由这三项数据来确定该类型的继承关系。类索 引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;&#x2F;&#x2F;类包名    </span><br><span class="line">u2             super_class;&#x2F;&#x2F;父类信息   </span><br><span class="line">u2             interfaces_count;&#x2F;&#x2F;接口信息    </span><br><span class="line">u2             interfaces[interfaces_count];&#x2F;&#x2F;接口信息  </span><br></pre></td></tr></table></figure>



<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;&#x2F;&#x2F;变量信息    </span><br><span class="line">field_info     fields[fields_count];&#x2F;&#x2F;变量信息  </span><br></pre></td></tr></table></figure>

<ul>
<li>字段<ul>
<li>包括：括类级变量以及实例级变量</li>
<li>不包括：在方法内部声明的局部变量</li>
</ul>
</li>
</ul>
<p>在Java中，我们常见的描述字段的信息：</p>
<ol>
<li>字段的作用域（public、private、protected修饰 符）</li>
<li>实例变量还是类变量（static修饰符）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile修饰符，是否 强制从主内存读写）</li>
<li>可否被序列化（transient修饰符）</li>
<li>字段数据类型（基本类型、对象、数组）</li>
<li>字段名称</li>
</ol>
<p>上述这些信息，其修饰符是以<strong>布尔值</strong>形式存在，即：要么有，要么没有，适合使用标志位去表示；</p>
<p>而字段的名字，字段的数据类型都是不可以确定的，或者说不能用01去表示，因此就只能引用常量池中的常量去描述</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204514100.png" alt="image-20210406204514100"> <strong>字段修饰符</strong>放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如下图所示（可以看到我们熟悉的public private protected等）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406204617979.png" alt="image-20210406204617979"></p>
<p>name_index和descriptor_index是两项索引值，表示对常量池项的引用</p>
<ul>
<li><p>name_index：字段的简单名称</p>
</li>
<li><p>descriptor_index：字段和方法的描述符</p>
</li>
<li><p><strong>“简单名称” “描述符”“全限定名”</strong>这三种特殊字符串的概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.clazz;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全限定名：<mark>org/fenixsoft/clazz/TestClass”</mark>是这个类的全限定名，仅仅是把类全名中的<strong>“.”</strong>替换成了<strong>“/”</strong>而已，为了使连续的多个全限定名之间不产生混 淆，在使用时最后一般会加入一个<strong>“；”</strong>号表示全限定名结束。</p>
</li>
<li><p>简单名称:简单名称则就是指没有类型和参数修饰 的方法或者字段名称，这个类中的<strong>inc()方法和m字段</strong>的<mark>简单名称</mark>分别就是<strong>“inc”</strong>和<strong>“m”</strong>。</p>
</li>
<li><p>描述符：是用来描述字段 的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205720096.png" alt="image-20210406205720096"></p>
</li>
</ul>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括</p>
<ol>
<li><p>访问标志（access_flags）</p>
</li>
<li><p>名称索引（name_index）</p>
</li>
<li><p>描述符索引（descriptor_index）</p>
</li>
<li><p>属性表集合（attributes）</p>
<p> u2             methods_count;//方法信息<br> method_info    methods[methods_count];//方法信息<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205841685.png" alt="image-20210406205841685"></p>
</li>
</ol>
<p>对于方法表，其标志位与取值可参考下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406205930635.png" alt="image-20210406205930635"></p>
<p>我们需要注意的是，方法可以通过访问标志、名称索引、描述符索引来表达。但方法中的代码，会经过Javac编译器编译成字节码指令之 后，存放在<strong>方法属性表集合</strong>中一个名为<mark>Code</mark>的属性里面,属性表在下节进行讲解。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul>
<li><p>属性表（attribute_info）：Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息</p>
<p>  u2             attributes_count;//附加属性信息<br>  attribute_info attributes[attributes_count];//附加属性信息<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210522604.png" alt="image-20210406210522604"></p>
</li>
</ul>
<p>我们下面主要讲解一下Code属性：</p>
<p>我们上面说到：Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 </p>
<p>而Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如<strong>接口或者抽象类</strong>中的方法就不存在Code属性</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406210616293.png" alt="image-20210406210616293"></p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>相关指令对应的含义可参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></li>
</ul>
<p>Java虚拟机的指令由<strong>一个字节长度</strong>的、代表着<strong>某种特定操作含义</strong>的<mark>数字</mark>（称为<strong>操作码，Opcode</strong>） 以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数，Operand</strong>）构成。</p>
<p>而Java虚拟机中大多数指令都不包含操作数，只有一个操作码，指令参数存放在操作数栈中；</p>
<h3 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示 字节码指令 和 操作数栈 常量池的关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;        </span><br><span class="line">		<span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="keyword">int</span> c = a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>常量池载入运行时常量池</p>
<p>ps：运行时常量池属于方法区的一部分</p>
<p>Class文件常量池中的数据存储在运行时常量池，将来找方法引用等信息等就从这去找。</p>
<p>32768：是<code>Short.MAX_VALUE + 1</code>的结果，通常来说一些小的数字并不存储在常量池中，而是与方法字节码存储在一起，而较大一些的则放在常量池中。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406212905766.png" alt="image-20210406212905766"></p>
</li>
<li><p>方法字节码载入方法区</p>
<p>接着会将方法的字节码放入方法区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213536911.png" alt="image-20210406213536911"></p>
</li>
<li><p>main线程开始运行，分配栈帧内存</p>
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406213701389.png" alt="image-20210406213701389"></p>
</li>
<li><p>执行引擎开始执行字节码</p>
<ol>
<li><p>bipush 10 ：将一个 byte 压入操作数栈（其长度会补齐 4 个字节）</p>
<ul>
<li>下面是类似的指令：<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
</ul>
</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214624098.png" alt="image-20210406214624098"></p>
</li>
<li><p>istore 1（1代表的是1号槽位）</p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214735588.png" alt="image-20210406214735588"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406214755269.png" alt="image-20210406214755269"></p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>ldc #3</p>
<p>从常量池加载#3数据到操作数栈中</p>
<p>32768的计算是在<strong>编译期间</strong>计算好的（不是运行时期间）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215006674.png" alt="image-20210406215006674"></p>
</li>
<li><p>istore 2</p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151432.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151441.png" alt="img"></p>
</li>
<li><p>iload 1</p>
<p>由于 a + b操作是不能在局部变量表中执行，而是得在操作数栈中进行，因此 <strong>iload</strong>就是进行变量的读取操作</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215628748.png" alt="image-20210406215628748"></p>
</li>
<li><p>iload 2</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210406215649658.png" alt="image-20210406215649658"></p>
</li>
<li><p>iadd</p>
<p>操作数栈有a 和 b两个数据了，就要进行加法操作：将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151508.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151523.png" alt="img"></p>
</li>
<li><p>istore 3</p>
<p>将操作数栈中的32778取出来放入局部变量表三号槽位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200608151547.png" alt="img"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163256206.png" alt="image-20210409163256206"></p>
</li>
<li><p>getstatic #4</p>
<p>在运行时常量池中找到成员变量的引用，此处的#4指向的是存放在堆中的System.out对象</p>
<p>注意，此处并不会把<strong>该对象</strong>放入操作数栈中，而是将<strong>其引用</strong>放入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163623604.png" alt="image-20210409163623604"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163636859.png" alt="image-20210409163636859"></p>
</li>
<li><p>iload 3</p>
<p>将局部变量表中3号槽位的元素压入操作数栈中</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163904424.png" alt="image-20210409163904424"></p>
</li>
<li><p>invokevirtual #5</p>
<p>找到运行时常量池 #5 项，接着定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>虚拟机分配新的栈帧（分配 locals、stack等）</p>
<p>接着执行：传递参数，执行新栈帧中的字节码</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409163939850.png" alt="image-20210409163939850"></p>
<p>执行完毕，弹出栈帧</p>
<p>清除main操作数栈的内容</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210409164137353.png" alt="image-20210409164137353"></p>
</li>
<li><p>return</p>
<p>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
</li>
</ol>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>我们首先认识一下什么是类加载机制：</p>
<ul>
<li>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<strong>类加载机制</strong></li>
</ul>
<p>我们可以对这句话进行拆分：</p>
<p>描述类的数据是移动单位，出发点是Class文件，目的地是内存。在移动其间对该单位进行了三步：</p>
<ol>
<li>检验</li>
<li>转换解析</li>
<li>初始化</li>
</ol>
<p>移动的目的是为了能形成一个能被虚拟机直接使用的java类型（意思是一开始不行）</p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>一个类的生命周期从大的来说是从：被加载到虚拟机内存中开始，到卸载出内存为止</p>
<p>细分的话，在这个生命周期内会经历：</p>
<p>加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段</p>
<p>验证、准备、解析 这三个部分我们统称为：为连接（Linking）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410174849844.png" alt="image-20210410174849844"></p>
<p>值得注意的是：</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的（解析的顺序不确定）</p>
<p>因为解析阶段在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>
<p>这个过程表示的是按顺序开始，不是所谓的第一步、第二步、第三步的关系，而往往是交叉混合进行，在一个阶段中可能调用或者激活另一个过程。因此这个图只是一个大致的运行流程图罢了，不是一个真正的时序图。</p>
<p>是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行<strong>“初始化”</strong>（而加载、验证、准备自然需要在此之前开始，因为这五个阶段的顺序是确定的）</p>
<ol>
<li>遇到<strong>new、getstatic、putstatic或invokestatic</strong>这四条，<mark>字节码指令</mark>时，如果类型没有进行过初始 化，则需要先触发其初始化阶段，从<mark>Java代码</mark>的场景来说的话分为：<ol>
<li>使用<strong>new</strong>关键字实例化对象的时候。</li>
<li><strong>读取或设置</strong>一个类型的<strong>静态字段</strong>（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。</li>
<li><strong>调用</strong>一个类型的<strong>静态方法</strong>的时候</li>
</ol>
</li>
<li>使用java.lang.reflect包的方法对类型进行<strong>反射调用</strong>的时候，如果类型没有进行过初始化，则需 要先触发其初始化</li>
<li>当初始化类的时候，如果发现其<strong>父类</strong>还没有进行过初始化，则需要先触发其<strong>父类的初始化</strong>。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的<strong>主类</strong>（包含<strong>main()方法的那个类</strong>），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.<strong>MethodHandle</strong>实例最后的解 析结果为<strong>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</strong>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被<strong>default关键字修饰的接口方法</strong>）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>综上这六类场景中的行为我们称之为对一个类型进行<strong>主动引用</strong>（言外之意就是所有引用类型的方式都是不会触发初始化的，我们称之为<strong>被动引用</strong>）</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只会输出“SuperClass init！123”，而不会输出“SubClass init！</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210410181127638.png" alt="image-20210410181127638"></p>
<p>原因是：对于静态字段（static），只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化，因此子类的静态字段是没有被初始化的。</p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>加载（Loading）阶段</strong>是整个<mark>类加载（Class Loading）</mark>过程中的一个阶段</p>
<p>在此阶段，Java虚拟机完成了以下三件事</p>
<ol>
<li>通过一个类的<strong>全限定名</strong>来获取定义此类的<mark>二进制字节流</mark>。（实现这个动作的代码我们称之为：<strong>类加载器（Class Loader），这部分内容将在后面着重学习</strong>）</li>
<li>将这个<mark>字节流</mark>所代表的<strong>静态存储结构</strong>转化为<strong>方法区</strong>的<mark>运行时数据结构</mark></li>
<li>在<strong>堆内存</strong>中生成一个代表这个类的<mark>java.lang.Class对象</mark>，作为<strong>方法区</strong>这个类的<strong>各种数据</strong>的<mark>访问入口（外部接口）</mark>。</li>
</ol>
<p>第一条这个规则比较宽松，因此衍生了许多java技术（这个规则的实践）</p>
<ul>
<li>从ZIP压缩包中读取</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用 了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件</li>
<li>…</li>
</ul>
<p>值得注意的是：</p>
<p><mark>加载阶段与连接阶段</mark>的部分动作（如一部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，<strong>加载</strong>阶段尚未完成，<strong>连接</strong>阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部 分，这两个阶段的开始时间仍然保持着固定的先后顺序</p>
<p>(也就是大体上依旧保持着先后顺序，只是连接部分中的几步可能穿插在加载阶段)</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li><mark>验证阶段</mark>是连接阶段的第一步</li>
</ul>
<p>这一步的目的：从字面我们也能看出来，主要是进行Class文件的字节流中包含的信息的验证，确认符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致上会完成四个阶段的检验动作：<strong>文件格式验证、元数据验证、字节码验证和符号引用验证。</strong></p>
<p><em>文件格式验证</em>：验证字节流是否符合Class文件格式的规范并 验证其版本是否能被当前的jvm版本所处理。ok没问题后，字节流就可以进入内存的方法区进行保存了。后面的3个校验都是在方法区进行的。</p>
<p><em>元数据验证</em>：对字节码描述的信息进行语义化分析，保证其描述的内容符合java语言的语法规范。</p>
<p><em>字节码检验</em>：最复杂，对方法体的内容进行检验，保证其在运行时不会作出什么出格的事来。</p>
<p><em>符号引用验证</em>：来验证一些引用的真实性与可行性，比如代码里面引了其他类，这里就要去检测一下那些来究竟是否存在；或者说代码中访问了其他类的一些属性，这里就对那些属性的可以访问行进行了检验。（这一步将为后面的解析工作打下基础）</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li><mark>准备阶段</mark>是正式为类中定义的<strong>变量</strong>（即静态变量，被static修饰的变量）<strong>分配内存</strong>并<strong>设置类变量初始值（0 或者 null）</strong>的阶段</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>在准备阶段进行内存分配的仅包括<strong>类变量</strong>，而不包括<strong>实例变量</strong>，<strong>实例变量</strong>将会在<strong>对象实例化</strong>时随着对象一起分配在<strong>Java堆</strong>中</p>
<p>（实例变量就是对象变量，即没加static的变量。对应的 类变量，即静态变量，也就是变量前加了static的变量）</p>
</li>
<li><p>初始值“通常情况”下是数据类型的零值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>静态变量value在准备阶段后的初始值是0而不是123.（初始化阶段才会赋值）</p>
</li>
</ol>
<p>   但也有特殊情况，那就是加上了final关键字</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>   那么准备阶段 value 的值就被赋值为 123</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210412150411190.png" alt="image-20210412150411190"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>解析阶段是Java虚拟机将<strong>常量池</strong>内的<mark><strong>符号引用</strong></mark>替换为<mark><strong>直接引用</strong></mark>的过程</li>
</ul>
<p>符号引用，形如：CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局<strong>无关</strong>，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接<strong>相关</strong>的，同一个<strong>符号引用</strong>在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li>
</ul>
<p>举个例子来说的话：</p>
<p>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的<strong>偏移量</strong>就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>一句话来说：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>类的初始化阶段是类加载过程的最后一个步骤，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，只有在初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码（字节码），将主导权移交给应用程序</li>
<li>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,值得注意的是，<code>&lt;clinit&gt;()</code>方法并不是程序员在Java代码中直接编写的方法，是<strong>Javac编译器的自动生成物</strong></li>
</ul>
<p>类初始化条件：要对类进行<strong>初始化</strong>，代码上可以理解为<u><strong>‘为要初始化的类中的所有静态成员都赋予初始值、对类中所有静态块都执行一次，并且是按代码编写顺序执行’</strong></u>。</p>
<p><code>如下代码：输出的是‘1’。如果①和②顺序调换，则输出的是‘123’。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(Super.i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">  <span class="comment">//①</span></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i = <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//②</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">		System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类加载原理图解"><a href="#类加载原理图解" class="headerlink" title="类加载原理图解"></a>类加载原理图解</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-e5c0fc9fdbca7174.png" alt="img"></p>
<p><clinit>方法代码理解：</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>; </span><br><span class="line"> <span class="keyword">static</span>&#123;                            </span><br><span class="line"> A=<span class="number">2</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ---相当于----&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"> &lt;clinit&gt;()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">     A=<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>接口和类初始化过程的区别：</li>
</ul>
<ol>
<li>对于类，会生成<clinit>(){……}方法体：去包含静态变量的赋值和静态块代码</clinit></li>
<li>而对于接口，也会生成<clinit>(){……}方法体：去初始化接口中的成员变量</clinit></li>
</ol>
<p>类的初始化执行之前要求父类全部都初始化完成了，但接口的初始化貌似对父接口的初始化不怎么感冒，也就是说，子接口初始化的时候并不要求其父接口也完成初始化，只有在真正使用到父接口的时候它才会被初始化（比如引用接口上的常量的时候啦）</p>
<h3 id="代码体验"><a href="#代码体验" class="headerlink" title="代码体验"></a>代码体验</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第二句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是main方法，我输出Super的类变量i：&quot;</span>+Sub.i);</span><br><span class="line">      Sub sub  = <span class="keyword">new</span> Sub();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Super</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//第四句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super成员块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第六句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">int</span> j = <span class="number">123</span>;</span><br><span class="line">      <span class="comment">//第五句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super成员块中的变量j：&quot;</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      <span class="comment">//第一句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Super静态块&quot;</span>);</span><br><span class="line">      i = <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">extends</span> <span class="title">Super</span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      <span class="comment">//第三句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub静态块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//第八句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//第七句</span></span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">&quot;我是Sub成员块&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2369895-aa2a7c61bcc2c67f.png" alt="img"></p>
<p>说明：</p>
<ol>
<li><strong>对于同一个类：</strong>静态代码块和静态变量的赋值 是<strong>先于</strong>main方法的调用执行的。</li>
<li><strong>对于同一个类：</strong>静态代码块和静态变量的赋值是按顺序执行的。</li>
<li>子类调用父类的类变量成员，是不会触发子类本身的初始化操作的【所以我们调用 <code>Sub.i</code> ，<code>Sub.class</code>并没有被初始化和加载】。</li>
<li>使用new方式创建子类，对于类加载而言，是先加载父类、再加载子类（注意：此时由于父类已经在前面初始化了一次，所以，这一步，就只有子类初始化，父类不会再进行初始化）</li>
<li>不论成员块放在哪个位置，它都 <strong>先于</strong>类构造方法执行</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p><strong>类加载器就是根据一个全限定名加载class生成二进制流并转换为一个java.lang.Class对象实例</strong></p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<mark>唯一性</mark>，每 一个类加载器，都拥有一个独立的类名称空间/命名空间，因此，一旦一个类被加载如JVM中，同一个类就不会被再次载入了。</p>
<p>可以这么理解：</p>
<ul>
<li><strong>Java</strong>中，一个类用其全限定类名（包括包名和类名）作为标识</li>
<li><strong>JVM</strong>中，一个类用其全限定类名和其类加载器作为其唯一标识</li>
</ul>
<p>因此，这两个<strong>类</strong>来源于同一个 <strong>Class文件</strong>，被同一个<strong>Java虚拟机</strong>加载，但加载它们的<strong>类加载器</strong><mark>不同</mark>，那这两个类就必定<mark>不相等</mark></p>
<p>这里所指的“相等”，包括类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，也包括使用<code>instanceof()</code>关键字对做对象所属关系判定等情况</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>-从jvm的角度来讲，只存在以下两种不同的类加载器：  </p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分；</li>
<li>所有其他类的加载器，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ul>
<p>-从Java开发人员的角度看，类加载器可以划分成三大类：</p>
<ul>
<li><mark>启动类加载器（Bootstrap ClassLoader）</mark>： 此类加载器负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。<ul>
<li>启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。</li>
</ul>
</li>
<li><mark>扩展类加载器（Extension ClassLoader）</mark> ： 这个类加载器是由<code>ExtClassLoader（sun.misc.Launcher$ExtClassLoader）</code>实现的。它负责将<code>&lt;Java_Home&gt;/lib/ext</code>或者被 <code>java.ext.dir</code>系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li><Mark>应用程序类加载器（Application ClassLoader） ： 这个类加载器是由 <code>AppClassLoader（sun.misc.Launcher$AppClassLoader）</code>实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，因此一般称为系统类加载器。<ul>
<li>它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</Mark></li>
</ul>
<p>类加载器的关系：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d4af5df076ca1a8b46a275d62c9d919f_hd.jpg" alt="v2-d4af5df076ca1a8b46a275d62c9d919f_hd.jpg"></p>
<p>分层理解的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415212558624.png" alt="image-20210415212558624"></p>
<p>上图展示的类加载器之间的层次关系，称为类加载器的<strong>双亲委派模型（Parents Delegation Model）</strong>。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过<strong>组合（Composition）关系</strong>来实现，而不是通过<strong>继承（Inheritance）</strong>的关系实现。</p>
<ul>
<li>组合关系(has-a关系）：把该类当成另一个类的<strong>组合成分</strong>，从而允许新类直接复用该类的public方法</li>
</ul>
<h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当需要使用该类时，才会将它的class文件加载到内存生成class对象（按需加载），加载时，使用的是<strong>双亲委派模式</strong>：</p>
<ul>
<li><p>如果一个类加载器收到了类请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给【父加载器/上级加载器】去完成，每一层都是如此，因此所有类加载的请求最终都会传到启动类加载器，只有当父加载器无法完成该请求时，子加载器才去自己加载。（父加载器、子加载器：非继承关系，而是用<strong>组合模式</strong>来复用父加载器代码）</p>
</li>
<li><p>双亲委派的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 首先，检查请求的类是否已经被加载过了，加载了就直接返回</span></span><br><span class="line">	Class c = findLoadedClass(name);</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前类加载器的父加载器不为空，则委托父加载器去加载该类</span></span><br><span class="line">		<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">			c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">			c = findBootstrapClassOrNull(name);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">			<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">			<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">			c = findClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">		resolveClass(c);</span><br><span class="line">	&#125;<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码也看得来双亲委派的逻辑：</p>
<ol>
<li>先检查请求加载的类型是否已经被加载过<ol>
<li>若没有则调用父加载器的 <code>loadClass()</code>方法</li>
<li>若父加载器为空（找到顶了）则默认使用启动类加载器作为父加载器</li>
</ol>
</li>
<li>假如父类加载器加载失败， 抛出<code>ClassNotFoundException</code>异常的话，才调用自己的<code>findClass()</code>方法尝试进行加载</li>
</ol>
</li>
</ul>
<p>举个例子来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大家所熟知的Object类，直接告诉大家，Object默认情况下是启动类加载器进行加载的。假设我也自定义一个Object，并且制定加载器为自定义加载器。现在你会发现自定义的Object可以正常编译，但是永远无法被加载运行。</span><br><span class="line">这是因为申请自定义Object加载时，总是启动类加载器，而不是自定义加载器，也不会是其他的加载器。</span><br></pre></td></tr></table></figure>



<p>这样做有什么好处呢？</p>
<ol>
<li>避免类的重复加载。一旦一个类被父类加载器加载之后，就不会再被委派给子类进行加载。</li>
<li>保护程序安全，可以防止核心API被随意篡改</li>
</ol>
<ul>
<li><strong>沙箱安全机制</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang; <span class="comment">// 包命名为java.lang</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行main函数，需要加载Start，根据双亲委派机制，加载请求会被向上委派到引导类加载器（记住第1小节的工作原理图）；</p>
<p>引导类加载器一看，包是java.lang，所以是由它来进行加载。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415211657918.png" alt="image-20210415211657918"></p>
<p>但这个lang包已经在base包中被加载过了，因此会直接报错.</p>
<p>从这点我们体现出了沙箱安全机制作用：保护核心类，防止打破双亲委派机制，防篡改，如果重名的话就报异常，这里的重名指包名加类名都重复</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><h5 id="重写loadClass-方法破坏双亲委派模型"><a href="#重写loadClass-方法破坏双亲委派模型" class="headerlink" title="重写loadClass()方法破坏双亲委派模型"></a>重写loadClass()方法破坏双亲委派模型</h5><p>现在有个类 A</p>
<p>我们希望通过自定义加载器 直接从某个路径下读取A.class . 而不是说 通过自定义加载器 委托给 AppClassLoader ——&gt; ExtClassLoader —-&gt; BootClassLoader 这么走一遍，都没有的话，才让自定义加载器去加载 A.class . 这么一来 还是 双亲委派。</p>
<p>我们期望的是 A.class 及时在 AppClassLoader 中存在，也不要从<code>AppClassLoader</code> 去加载。</p>
<p>说白了，就是 直接让自定义加载器去直接加载A.class 而不让它取委托父加载器去加载，不要去走双亲委派那一套。</p>
<p>我们知道 双亲委派的机制是在<code>ClassLoader # loadClass</code>方法中实现的，打破双亲委派，那我们是不是可以考虑从这个地方下手呢？</p>
<p>因此我们就知道了，打破双亲委派方法是通过 —— 重写<code>ClassLoader # loadClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="comment">//自己的类路径下的对象走我自己的classLoader</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;com.xxx.xxx.Test&quot;</span>.equals(name)) &#123;</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 交由父加载器去加载</span></span><br><span class="line">                    c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h5><ul>
<li>这个类加载器能够通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。</li>
</ul>
<p>JNDI服务（是Java的标准服务）使用这个线程上下文类加载器去加载所需的SPI服务（即接口，Service Provider Interface，SPI）代码，这是一种父类加载器去请求子类加载器完成类加载的行为。按照之前所学的，这肯定是违背双亲委派模型的一般性原则。（留了个后门）</p>
<ul>
<li>应用</li>
</ul>
<p>在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，解决SPI的加载问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统加载方式 1</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统加载方式 2</span></span><br><span class="line">System.setProperty(<span class="string">&quot;jdbc.drivers&quot;</span>,<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPI加载方式</span></span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:33061/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>SPI加载机制中，不需要手动设置驱动为com.mysql.jdbc.Driver。</p>
<p>spi服务的模式原本过程</p>
<ol>
<li>从META-INF/services/java.sql.Driver文件中获取具体的实现类名：”com.mysql.jdbc.Driver”</li>
<li>加载这个类（使用<code>class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210415220215431.png" alt="image-20210415220215431"></p>
<p>使用了这个线程上下文后，mysql的驱动加载过程：</p>
<ol>
<li>从META-INF/services/java.sql.Driver文件中获取具体的实现类名：”com.mysql.jdbc.Driver”</li>
<li>加载这个类（使用<code>class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></li>
<li>使用线程上下文类加载器去加载Driver类，使得父级加载器可以加载子级类加载器路径中的类</li>
</ol>
<h1 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h1><p>Java技术中的编译器有多个过程：</p>
<ol>
<li>前端编译器（叫“编译器的前端”更准确一些）把<em>.java文件转变成</em>.class文件的过程</li>
<li>指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程</li>
<li>使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程 序编译成与目标机器指令集相关的二进制代码的过程</li>
</ol>
<p>对应这三类编译过程的三类比较有代表性的编译产品分别为：</p>
<ol>
<li><mark>前端编译器</mark>：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
<li><mark>即时编译器</mark>：HotSpot虚拟机的C1、C2编译器，Graal编译器</li>
<li><mark>提前编译器</mark>：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ol>
<h3 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h3><h4 id="编译期处理-语法糖"><a href="#编译期处理-语法糖" class="headerlink" title="编译期处理 - 语法糖"></a>编译期处理 - 语法糖</h4><h5 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>编译成class后的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123; </span><br><span class="line">	<span class="comment">// 这个无参构造是编译器帮助我们加上的 </span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">				<span class="keyword">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V </span></span><br><span class="line">		&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h5><p>基本类型和其包装类型的相互转换过程，称为<strong>拆装箱</strong></p>
<p>在<strong>JDK 5</strong>以后，它们的转换可以在编译期自动完成（也就是说第一段代码在JDK 5前无法编译通过，而第二段可以）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Integer x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实质的转换过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以明显看出来第二段代码比第一段代码麻烦很多，因此JVM提供了这么个糖给我们吃，省去不少麻烦</p>
<h5 id="【泛型-泛型擦除】"><a href="#【泛型-泛型擦除】" class="headerlink" title="【泛型  - 泛型擦除】"></a>【泛型  - 泛型擦除】</h5><ul>
<li>重点</li>
</ul>
<p>Java选择的泛型实现方式叫作<mark>“类型擦除式泛型”（Type Erasure Generics）</mark>,与之对应的是c#的<mark>是“具现化式泛型”（Reified Generics）</mark></p>
<p>（具现化和特化、偏特化这些名词最初都是源于C++模版语 法中的概念）</p>
<p>区别：</p>
<ol>
<li><p>道C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，<strong>List&lt; int &gt;与 List&lt; string &gt;</strong>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换 为原来的<strong>裸类型（Raw Type，</strong>稍后我们会讲解裸类型具体是什么）了，并且在相应的地方插入了<strong>强制转型代码</strong>。due to that,对于处在运行期的Java语言来说的话，<strong>List&lt; int &gt;与 List&lt; string &gt;</strong>其实是同一个类型的。</p>
<p>这也是 类型擦除中的擦除的含义</p>
</li>
</ol>
<p>上面都是一些概念类型的知识，下面用实例代码来体验一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  	List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"> 	  list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e) </span></span><br><span class="line"> 	  Integer x = list.get(<span class="number">0</span>); <span class="comment">// 实际调用的是 Object obj = List.get(int index); </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> cn.itcast.jvm.t3.candy.Candy();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/itcast/jvm/t3/candy/Candy3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; </span><br><span class="line">	descriptor: ([Ljava/lang/String;)V </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC </span><br><span class="line">  Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span> </span><br><span class="line">       -------<span class="keyword">new</span> ArrayList对象----------         </span><br><span class="line">       0: new #2   // class java/util/ArrayList </span><br><span class="line">       <span class="number">3</span>: dup </span><br><span class="line">       4: invokespecial #3 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">       <span class="number">7</span>: astore_1 </span><br><span class="line">                </span><br><span class="line">       <span class="number">8</span>: aload_1 </span><br><span class="line">       <span class="number">9</span>: bipush <span class="number">10</span> </span><br><span class="line">       11: invokestatic #4 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; </span><br><span class="line">       <span class="comment">//add方法的参数类型实际是Object类型</span></span><br><span class="line">       14: invokeinterface #5, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z </span><br><span class="line">       <span class="number">19</span>: pop </span><br><span class="line">       <span class="number">20</span>: aload_1 </span><br><span class="line">       <span class="number">21</span>: iconst_0 </span><br><span class="line">       <span class="comment">//get方法的参数类型实际是Object类型</span></span><br><span class="line">       22: invokeinterface #6, 2 // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object; </span><br><span class="line">       <span class="comment">//	强制类型转换         </span></span><br><span class="line">       27: checkcast #7 // class java/lang/Integer </span><br><span class="line">       <span class="number">30</span>: astore_2 </span><br><span class="line">       <span class="number">31</span>: <span class="keyword">return</span> </span><br><span class="line">       LineNumberTable:</span><br><span class="line">					line <span class="number">8</span>: <span class="number">0</span> </span><br><span class="line">          line <span class="number">9</span>: <span class="number">8</span> </span><br><span class="line">          line <span class="number">10</span>: <span class="number">20</span> </span><br><span class="line">          line <span class="number">11</span>: <span class="number">31</span> </span><br><span class="line">       LocalVariableTable:</span><br><span class="line">			  	Start Length Slot Name    Signature</span><br><span class="line">              <span class="number">0</span>   <span class="number">32</span>    <span class="number">0</span>   args      [Ljava/lang/String; </span><br><span class="line">              <span class="number">8</span>   <span class="number">24</span>    <span class="number">1</span>   list      Ljava/util/List;</span><br><span class="line">       LocalVariableTypeTable:</span><br><span class="line">					Start Length  Slot   Signature</span><br><span class="line">					    <span class="number">8</span>   <span class="number">24</span>     <span class="number">1</span>      Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>list.add 和 get 方法在bycecode层面上的参数类型都是Object类型，最后会执行checkcast指令进行类型转换为真实类型</li>
</ul>
<p>上面我们提及了，泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p>
<p>既然现在是Object类型的，而我们想去的值为Integer类型，就必须进行一次类型转换操作（在编译器真正生成字节码的过程中进行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer </span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>若x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作 </span></span><br><span class="line"><span class="keyword">int</span> x = ((Integer)list.get(<span class="number">0</span>)).intValue();</span><br></pre></td></tr></table></figure>



<ul>
<li><p>类型擦除把字节码上泛型信息（方法体内泛型信息）擦除了，但在<strong>LocalVariableTypeTable（局部变量类型表）</strong>保留了方法参数泛型信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  LocalVariableTypeTable:</span><br><span class="line">Start Length  Slot   Signature</span><br><span class="line">    <span class="number">8</span>   <span class="number">24</span>     <span class="number">1</span>      Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>虽然这个信息被保留了，但无法通过反射去获得</p>
<p>只有方法参数和返回值上带泛型信息，才能通过反射获取泛型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Method test = Candy3.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">        Type[] types = test.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="comment">//判断是不是参数化泛型类型</span></span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">                <span class="comment">//getActualTypeArguments()获取到的是&lt;&gt;中的参数</span></span><br><span class="line">                Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始类型 - interface java.util.List </span><br><span class="line">泛型参数[0] - class java.lang.String </span><br><span class="line">原始类型 - interface java.util.Map </span><br><span class="line">泛型参数[0] - class java.lang.Integer </span><br><span class="line">泛型参数[1] - class java.lang.Object</span><br></pre></td></tr></table></figure>



<h5 id="可变参数（变长参数）"><a href="#可变参数（变长参数）" class="headerlink" title="可变参数（变长参数）"></a>可变参数（变长参数）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String str : args)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>print(String... strs)</code> 中的 … 表示参数个数是可以不定的</p>
<p>上述代码 本质：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Varargs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="keyword">int</span> var2 = args.length;</span><br><span class="line">        <span class="comment">//增强for循环的数组实现方式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            String str = var1[var3];</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//变长参数转换为数组</span></span><br><span class="line">        print(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述代码来说，编译器会帮助我们转换为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是集合去使用了foreach的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其本质就是使用了<strong>迭代器Iterator</strong></p>
<p>因此，能够使用foreach去遍历的集合一定是实现了<strong>Iterator</strong>接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">//获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="switch-字符串"><a href="#switch-字符串" class="headerlink" title="switch 字符串"></a>switch 字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器实质进行的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Demo6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//通过字符串的hashCode+value来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">//hello的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">//再次比较，因为字符串的hashCode有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">//world的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用第二个switch在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从第二份代码我们可以看出，一个switch操作其实是由两个switch配合完成的</p>
<ol>
<li>第一个用来<strong>匹配字符串</strong>，并给x赋值，x才是最后用来决定走哪个方法的<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突</li>
</ul>
</li>
<li>使用第一步确定的x去决定输出</li>
</ol>
<h5 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">         <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="comment">//将对应位置枚举元素的值赋给x，用于case操作</span></span><br><span class="line">      <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">//对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">    	<span class="comment">//调用构造函数，传入枚举元素的值及ordinal</span></span><br><span class="line">    	MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   <span class="comment">//调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Demo8$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个额外的类，实现了Runnable接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如匿名内部类中引用了<mark>局部变量</mark>的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">//多创建了一个变量</span></span><br><span class="line">   <span class="keyword">int</span> val$x;</span><br><span class="line">   <span class="comment">//变为了有参构造器</span></span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h3><h4 id="前期知识储备（JVM-java编译器-java解释器）"><a href="#前期知识储备（JVM-java编译器-java解释器）" class="headerlink" title="前期知识储备（JVM java编译器 java解释器）"></a>前期知识储备（JVM java编译器 java解释器）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Ij2UZf.png" alt="img"></p>
<p><strong>JVM：</strong>JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。</p>
<p><strong>JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行</strong>。</p>
<p>JVM解释执行字节码文件：就是<strong>JVM操作Java解释器，将字节码翻译成机器码，然后执行的过程</strong></p>
<p><strong>Java编译器：</strong>将<mark>Java源文件（.java文件）</mark>编译成<mark>字节码文件</mark>（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的<strong>“机器语言”</strong>。 <strong>javac.exe</strong>可以简单看成是Java编译器。</p>
<p><strong>Java解释器：</strong>是JVM的一部分，用来解释执行Java编译器编译后的程序，即将<strong>字节码</strong>解释为<strong>机器码</strong>。<strong>java.exe</strong>可以简单看成是Java解释器。</p>
<p><em>注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！</em></p>
<p>个人理解：</p>
<p>解释器，翻译一点执行一点；</p>
<p>编译器是将源代码翻译成平台能理解的目标语言，然后交由平台直接执行。</p>
<h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="img"></p>
<p>程序语言 → 字节码 → 指令集。</p>
<p>运行java程序的过程是先用javac编译，然后用java解释。而一经编译成功后，就可以直接用java.exe随处解释运行了。</p>
<ul>
<li>前端编译器（编译器的前端）：<strong>主要是把*.java文件转变成*.class文件（特殊的二进制字节码文件）</strong></li>
<li>后端编译器<ul>
<li>JIT编译器（即时编译器）：字节码转化为本地机器代码</li>
<li>AOT编译器（提前编译器）：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码</li>
</ul>
</li>
<li>解释执行与编译执行<ul>
<li><mark>解释执行</mark>：需要执行什么代码，才对对应的源码进行翻译，将其变为机器码，因此也提高了启动时效率；<ul>
<li>优点：可以大大提高程序启动时的效率</li>
</ul>
</li>
<li><mark>编译执行</mark>：将中间代码（字节码）全部编译成了与机器相关的本地代码，并且在这一阶段，有些编译器还会对编译后的代码进行初步的优化，这也使得效率更加的优秀<ul>
<li>优点：可以获得更高的执行效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="即时编译器-JIT"><a href="#即时编译器-JIT" class="headerlink" title="即时编译器 JIT"></a>即时编译器 JIT</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><ul>
<li><p>概念：是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损</p>
</li>
<li><p>作用：改善虚拟机的性能</p>
</li>
<li><p>原本Java程序：经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢</p>
</li>
<li><p>引入了JIT后：在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用</p>
</li>
</ul>
<p>而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。</p>
<p>（虚拟机将这些运行频繁的方法/代码块认定为:<strong>热点代码</strong>）</p>
<p>它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。</p>
<h5 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h5><p>上面我们提到了“热点代码”这个概念，即频繁执行的代码块，那么JVM如何进行热点代码的判断呢？</p>
<ul>
<li><strong>基于采样</strong>：周期性的检查栈顶，如果一段代码频繁出现在栈帧顶部，那么就判断其是热点代码。<ul>
<li>优点：实现简单，快；</li>
<li>缺点：探测很容易收到线程阻塞的影响。例如一个方法因为线程阻塞，一直在栈顶，但其实其执行次数并不多，那么将其判定为热点代码就是不合理的。</li>
</ul>
</li>
<li><strong>基于计数器</strong>：为每个方法甚至是代码块建立计数器来统计执行次数，如果统计的次数达到了一定的条件则说明是热点代码<ul>
<li>优点：结果精确</li>
<li>缺点：实现就比较麻烦了，需要维护计数器</li>
</ul>
</li>
</ul>
<p>HotSpot 中采取的是第二种方案，因为频繁执行的代码有如下两种：</p>
<ul>
<li>方法的频繁执行</li>
<li>一段代码的频繁执行</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163733386.png" alt="image-20210417163733386"></p>
<h6 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h6><ul>
<li>回边计数器，它的作用是统计一个方法中循环体代码执行的次数[3]，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，很显然建立回边计数 器统计的目的是为了触发栈上的替换编译。</li>
</ul>
<p>工作流程：</p>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有 的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回 边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210417163939413.png" alt="image-20210417163939413"></p>
<h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h5><p>HotSpot 中的即时编译器有两种，分别称为 Client Complier客户端编译器 和 Server Complier服务端编译器，或者简称为 C1 和 C2，目前虚拟机一般采用解释器和一个即时编译器直接配合的方式来运行，这种模式称之为 <strong>混合模式</strong>。</p>
<p>既然是两者合作，那么久需要考虑一个调度的问题，即何时使用编译执行，何时采用解释执行，多少的比例可以获得最佳平衡，得到最高的效率。</p>
<p>在 HotSpot 中是通过 <strong>分层编译</strong> 的策略来达到最优解的。其本质的思想如下所示：</p>
<ul>
<li>第0层：程序解释执行，解释器不开启性能监控（Profiling），触发第一层；</li>
<li>第1层：C1 编译，将<strong>字节码</strong>编译为<strong>本地代码</strong>，进行简单、可靠的优化，不开启性能监控</li>
<li>第2层：C1编译，仅开启方法及回边次数统计等有限的性能监控功能</li>
<li>第3层：C1编译，，开启全部性能监控，除了第2层的统计信息外，还会收集如 分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层层：C2 编译，也是将<strong>字节码</strong>编译为<strong>本地代码</strong>，但其会启动一些耗时较长的<mark>优化</mark>，甚至会根据监控的信息采取一些激进（不可靠）的优化措施。</li>
</ul>
<p>这种分层编译的方式可以达到一定情况的最优解：用 C1 获取更快的<strong>编译速度</strong>，用 C2 获取更好的<strong>编译质量</strong>，解释执行的时候也无需增加性能监控的任务，反而拖累了启动效率。</p>
<h4 id="提前编译器-AOT"><a href="#提前编译器-AOT" class="headerlink" title="提前编译器 AOT"></a>提前编译器 AOT</h4><ul>
<li>AOT 编译器的<strong>基本思想</strong>是：在程序执行<strong>前</strong>生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。</li>
</ul>
<p>但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。</p>
<p>总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。</p>
<p>在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。</p>
<p>所以说，<strong>AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略</strong>。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。</p>
<h4 id="编译器总结"><a href="#编译器总结" class="headerlink" title="编译器总结"></a>编译器总结</h4><p>在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。</p>
<p>前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。而 AOT 编译器则能将源代码直接编译为本地机器码。这三种编译器的编译速度和编译质量如下：</p>
<ul>
<li>编译速度上，解释执行 &gt; AOT 编译器 &gt; JIT 编译器。</li>
<li>编译质量上，JIT 编译器 &gt; AOT 编译器 &gt; 解释执行。</li>
</ul>
<p>而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。</p>
<h4 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h4><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<ul>
<li><strong>JVM内联函数</strong></li>
</ul>
<p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// to do something  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123; </span><br><span class="line">		&#x2F;&#x2F;这里调用了add2方法</span><br><span class="line">        return add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private int add2(int x1, int x2) &#123;  </span><br><span class="line">        return x1 + x2;  </span><br><span class="line">    &#125;Copy</span><br></pre></td></tr></table></figure>

<p>方法调用被替换后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;  </span><br><span class="line">    	<span class="comment">//被替换为了方法本身</span></span><br><span class="line">        <span class="keyword">return</span> x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是将小段代码，直接复制到调用的方法里面，不去真实的进行方法调用</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><ul>
<li>方法逃逸：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部 方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸</li>
<li>线程逃逸：甚至还有可能被外部线程访 问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸</li>
</ul>
<p>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度</p>
<p>按照逃逸程度的高低，为对象的实例采取不同程度的优化，就是逃逸分析的优化基本原理。</p>
<h6 id="优化办法"><a href="#优化办法" class="headerlink" title="优化办法"></a>优化办法</h6><ul>
<li><p><strong>栈上分配（Stack Allocations）</strong>：我们知道，对象的分配是在<strong>堆</strong>上进行，而，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引 用，就可以访问到堆中存储的对象数据。在GC的时候：标记、回收、整理都要耗费大量资源。如果确定一个对 象不会逃逸出线程之外，那让这个对象在<strong>栈上分配内存</strong>岂不是很好？对象所占用的内存空间就可以随栈帧出栈而销毁。</p>
</li>
<li><p><strong>标量替换（Scalar Replacement）</strong>：</p>
<ul>
<li>标量：无法再分解为更小数据的数据，例如 JVM 中的原始数据类型（int、long、reference 等）。</li>
<li>聚合量：可以继续分解的数据，例如 Java 中的对象。</li>
</ul>
<p>所谓「标量替换（Scalar Replacement）」，就是根据实际访问情况，将一个对象“拆解”开，把用到的成员变量恢复为原始类型来访问。</p>
<p>简单来说，就是把聚合量替换为标量。</p>
<p>若一个对象不会逃逸出「方法」，且可以被拆散，那么程序真正执行时就可能不去创建这个对象，而是直接创建它的若干个被该方法使用的成员变量代替。将对象拆分后，除了可以让对象的成员变量在栈上 （栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件</p>
<p>（标量替换可以视作栈上分配的一种特例）</p>
</li>
<li><p>同步消除（Synchronization Elimination）：线程同步本身相对耗时，如果逃逸分析能够确定一个变量不会逃逸出线程，则该变量的读写就不会有线程安全问题，对该变量的同步措施就可以安全的消除了。</p>
<p>换句话说，如果对线程安全的数据（不会逃逸出该线程的数据）加了锁，JVM 就可以把它优化消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量 o 不会逃逸出线程。因此，对它加的锁就可以被消除</span></span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h6><p>原始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全未优化的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">Point p = <span class="keyword">new</span> Point(xx, <span class="number">42</span>);</span><br><span class="line"><span class="keyword">return</span> p.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将Point的构造函数和getX()方法进行内联优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：构造函数内联后的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">	Point p = point_memory_alloc(); <span class="comment">// 在堆中分配P对象的示意方法</span></span><br><span class="line">	p.x = xx; <span class="comment">// Point构造函数被内联后的样子</span></span><br><span class="line">	p.y = <span class="number">42</span></span><br><span class="line">	<span class="keyword">return</span> p.x; <span class="comment">// Point::getX()被内联后的样子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸， 这样可以对它进行标量替换优化，把其内部的x和y直接置换出来，分解为test()方法内的局部变量，从 而避免Point对象实例被实际创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ 步骤<span class="number">2</span>：标量替换后的样子</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xx = x + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> px = xx;</span><br><span class="line">	<span class="keyword">int</span> py = <span class="number">42</span></span><br><span class="line">	<span class="keyword">return</span> px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效 代码消除得到最终优化结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤3：做无效代码消除后的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h5><p>所谓公共子表达式，就是当有一个表达式 E 在以前被计算过，而且下次再遇到的时候 E 的所有变量都未改变，则这次 E 的出现就被称为「公共子表达式」。就像学习DP的时候，记忆集的概念。</p>
<p>根据作用域，公共子表达式的消除可分为两种：<strong>局部公共子表达式消除和全局公共子表达式消除</strong>。</p>
<ol>
<li>局部公共子表达式消除：优化仅限于程序基本块内</li>
<li>全局公共子表达式消除：优化的范围涵盖了多个基本块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> d = (c * b) * <span class="number">12</span> + a + (a + b * c);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码产生的字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  public int t1();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;4, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         # ...</span><br><span class="line">         6: iload_3</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: imul    # 计算 b*c</span><br><span class="line">         9: bipush        12</span><br><span class="line">        11: imul    # 计算 (c * b) * 12</span><br><span class="line">        12: iload_1</span><br><span class="line">        13: iadd    # 计算 (c * b) * 12 + a</span><br><span class="line">        14: iload_1</span><br><span class="line">        15: iload_2</span><br><span class="line">        16: iload_3</span><br><span class="line">        17: imul    # 计算 b*c</span><br><span class="line">        18: iadd    # 计算 (a + b * c)</span><br><span class="line">        19: iadd    # 计算 (c * b) * 12 + a + (a + b * c)</span><br><span class="line">        20: istore        4</span><br><span class="line">        22: iload         4</span><br><span class="line">        24: ireturn</span><br><span class="line">        # ...</span><br></pre></td></tr></table></figure>

<p>而相同的这段代码，进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c<em>b与b</em>c是一样的表达 式，而且在计算期间b与c的值是不变的</p>
<p>因此这条表达式就可能被视为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>

<p>此时，编译器还可能进行代数化简（Algebraic Simplification）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>



<h5 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h5><p>在遍历数组的时候：必须满足<code>i &gt;= 0 &amp;&amp; i &lt; arr.length</code>，否则就抛出异常：<code>java.lang.ArrayIndexOutOfBoundsException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// 数组越界</span></span><br><span class="line">  String s = array[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全起见，数组边界检查这件事是一定要做的，但是<strong>数组边界检查</strong>是不是一定得在运行期间发生就是不一定的了。</p>
<p>如果编译器只 要通过数据流分析（前端编译）就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可 以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><ul>
<li><p>JVM内存模型定义的是线程堆栈和堆之间的内存划分，它和Java内存模型是有区别的，参照《深入理解Java虚拟机》中的解释：</p>
<blockquote>
<p>这两者本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就是物理内存，而为了获取更好的执行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为运行时主要访问——读写的是工作内存。</p>
</blockquote>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/368583-20180711114821287-381545002.png" alt="img"></p>
<p>(Java内存模型JMM的相关知识，将在java并发部分进行学习)</p>
<h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><p>参考博客、书籍和视频：</p>
<ol>
<li><p>博客</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ace2aa692f96">https://www.jianshu.com/p/ace2aa692f96</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/103653184">https://blog.csdn.net/qq_34337272/article/details/103653184</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shan1393/p/8996954.html">https://www.cnblogs.com/shan1393/p/8996954.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38075425/article/details/81627349">https://blog.csdn.net/m0_38075425/article/details/81627349</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/looyee/articles/13954722.html">https://www.cnblogs.com/looyee/articles/13954722.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JRookie/p/11431784.html">https://www.cnblogs.com/JRookie/p/11431784.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jqhtml.com/49135.html">https://www.jqhtml.com/49135.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sword03/archive/2010/06/27/1766147.html">https://www.cnblogs.com/sword03/archive/2010/06/27/1766147.html</a></li>
</ul>
</li>
<li><p>书籍</p>
<ul>
<li>《深入理解JVM虚拟机》</li>
</ul>
</li>
<li><p>视频</p>
<ul>
<li>黑马程序员JVM</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/29/JVM/" data-id="ckppikuf50049p0widp58b2iu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringBoot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/" class="article-date">
  <time datetime="2021-03-21T11:04:51.373Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于Spring"><a href="#关于Spring" class="headerlink" title="关于Spring"></a>关于Spring</h1><ul>
<li><p>Spring官网：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></p>
</li>
<li><p>What can Spring do？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319222830164.png" alt="image-20210319222830164"></p>
</li>
</ul>
<h2 id="Spring生态"><a href="#Spring生态" class="headerlink" title="Spring生态"></a>Spring生态</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></li>
<li>生态覆盖以下几个部分<ul>
<li>web开发</li>
<li>数据访问</li>
<li>安全控制</li>
<li>分布式</li>
<li>消息服务</li>
<li>移动开发</li>
<li>批处理</li>
<li>and so on</li>
</ul>
</li>
</ul>
<h2 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h2><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319223341141.png" alt="image-20210319223341141"></p>
<h1 id="关于SpringBoot"><a href="#关于SpringBoot" class="headerlink" title="关于SpringBoot"></a>关于SpringBoot</h1><h2 id="Why-SpringBoot？"><a href="#Why-SpringBoot？" class="headerlink" title="Why SpringBoot？"></a>Why SpringBoot？</h2><ul>
<li><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>能<strong>快速</strong>创建出生产级别的Spring应用</p>
</li>
</ul>
<h2 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h2><ul>
<li><p>Create stand-alone Spring applications</p>
</li>
<li><ul>
<li>创建独立Spring应用</li>
</ul>
</li>
<li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p>
</li>
<li><ul>
<li>内嵌web服务器</li>
</ul>
</li>
<li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p>
</li>
<li><ul>
<li>自动starter依赖，简化构建配置</li>
</ul>
</li>
<li><p>Automatically configure Spring and 3rd party libraries whenever possible</p>
</li>
<li><ul>
<li>自动配置Spring以及第三方功能</li>
</ul>
</li>
<li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p>
</li>
<li><ul>
<li>提供生产级别的监控、健康检查及外部化配置</li>
</ul>
</li>
<li><p>Absolutely no code generation and no requirement for XML configuration</p>
</li>
<li><ul>
<li>无代码生成、无需编写XML</li>
</ul>
</li>
</ul>
<h1 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h1><p>基于微服务以及分布式</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li>微服务是一种架构风格</li>
<li>一个应用拆分为一组小型服务</li>
<li>每个服务运行在自己的进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级HTTP交互</li>
<li>服务围绕业务功能拆分</li>
<li>可以由全自动部署机制独立部署</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式的困难之处"><a href="#分布式的困难之处" class="headerlink" title="分布式的困难之处"></a>分布式的困难之处</h3><ul>
<li>远程调用</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>服务容错</li>
<li>配置管理</li>
<li>服务监控</li>
<li>链路追踪</li>
<li>日志管理</li>
<li>任务调度</li>
<li>…</li>
</ul>
<h3 id="分布式解决"><a href="#分布式解决" class="headerlink" title="分布式解决"></a>分布式解决</h3><ul>
<li>SpringBoot + SpringCloud</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320165046458.png" alt="image-20210320165046458"></p>
<h1 id="HelloSpringBoot"><a href="#HelloSpringBoot" class="headerlink" title="HelloSpringBoot"></a>HelloSpringBoot</h1><p>下面我们来体验一下SpringBoot开发吧</p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>首先创建maven工程，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现 仅仅导入这两个依赖 就有了大量的jar包</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320172235234.png" alt="image-20210320172235234"></p>
<h2 id="创建主程序"><a href="#创建主程序" class="headerlink" title="创建主程序"></a>创建主程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类;主配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编写业务"><a href="#编写业务" class="headerlink" title="编写业务"></a>编写业务</h2><p>这里的<code>@RestController</code>是我们之前所学的<code>@Controller</code>和<code>@ResponseBody</code>的合体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ResponseBody</span></span><br><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320172524663.png" alt="image-20210320172524663"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320175426700.png" alt="image-20210320175426700"></p>
<p>需要注意，我们的启动类需要和<strong>controller包</strong>放在相同跟目录</p>
<p>也就是，我们的启动类需要大于controller类，否则的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320175529771.png" alt="image-20210320175529771"></p>
<h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><h3 id="配置的进行"><a href="#配置的进行" class="headerlink" title="配置的进行"></a>配置的进行</h3><p>我们可以在resource的包下建立：<code>application.properties</code></p>
<p>在其中进行一些属性的设置（包括端口号等）</p>
<h3 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h3><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目可以被打包成jar包，放在目标服务器执行就可以</p>
<h1 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li><p>父项目进行了依赖管理，因此我们无需去关注版本号，自动进行了版本的仲裁</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>有的人会问了，那我就想用一个特定的版本怎么办？我们可以去修改默认的版本号（pom.xml中修改）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>同时，我们注意到一个细节，我们的引入的两个包都叫做<code>spring-boot-starter-xxx</code></p>
<p>这究竟是什么呢？我们称之为：<strong>应用程序启动器</strong>，我们要引入什么场景，就直接找这个starter然后引入就好了</p>
<p>SpringBoot支持的场景：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a> </p>
<p>而所有场景最基本的启动器是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>当我们成功运行了第一个SpringBoot程序的时候，我们肯定是很惊喜的。</p>
<p>天，我们之前不是还要配置Tomcat吗？我们不是还要配置UTF字符编码的过滤器吗？不是还要去配置SpringMVC的前端解析器之类的吗？</p>
<p>我们怎么跑了个main方法就直接能在服务器上出现效果了呢？这就多亏了SpringBoot的<strong>自动配置</strong></p>
<h3 id="依赖自动配置"><a href="#依赖自动配置" class="headerlink" title="依赖自动配置"></a>依赖自动配置</h3><ul>
<li><p>以Tomcat为例：</p>
</li>
<li><p>我们点开</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到这个web依赖中，可以发现，他确实帮我们配置了Tomcat。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同理，我们再看看SpringMVC的组件，发现他也帮我们引入了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>那我们就来验证一下看看SpringBoot有没有帮我们引入SpringMVC相关组件吧</p>
<p>我们编写一段代码，来看看其中的组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以从打印结果（截取了一部分）中看出来，确实，容器中的的确确有我们需要的组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">前端视图解析器</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletConfiguration</span><br><span class="line">dispatcherServlet</span><br><span class="line"></span><br><span class="line">视图解析器</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter</span><br><span class="line">defaultViewResolver</span><br><span class="line">viewResolver</span><br><span class="line"></span><br><span class="line">json相关</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration</span><br><span class="line">jsonComponentModule</span><br><span class="line"></span><br><span class="line">字符集过滤器</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">characterEncodingFilter</span><br><span class="line">localeCharsetMappingsCustomizer</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="包扫描自动配置"><a href="#包扫描自动配置" class="headerlink" title="包扫描自动配置"></a>包扫描自动配置</h3><ul>
<li><p>想一想，我们SSM开发中经常要进行一件什么事？给一个hint：<code>&lt;context:component-scan base-package=&quot;com.xxxx&quot; &gt;</code> 对的，我们要进行包的扫描说明；但我们上述并没有经过这一流程啊，SpringBoot又是怎么帮我们简化了这一步的呢？</p>
</li>
<li><p>原来啊，是SpringBoot规定了：主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来！因此无需进行包扫描配置啦</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320205221031.png" alt="image-20210320205221031"></p>
</li>
<li><p>那我们想要改变扫描路径又该怎么办呢？假如我们的主程序不符合上述包结构位置</p>
<p>我们就需要使用<code>@SpringBootApplication(scanBasePackages = &quot;&quot;)</code>进行扫描位置放大了</p>
<p>或者使用<code>@ComponentScan</code>指定扫描路径，但需要和另外2个注解配合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等价于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hpg.boot&quot;)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="默认值自动配置"><a href="#默认值自动配置" class="headerlink" title="默认值自动配置"></a>默认值自动配置</h3><ul>
<li><p>各种配置拥有默认值</p>
</li>
<li><ul>
<li>默认配置最终都是映射到某个类上，如：MultipartProperties</li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
</ul>
<h3 id="场景自动配置"><a href="#场景自动配置" class="headerlink" title="场景自动配置"></a>场景自动配置</h3><p>我其实一开始学习SpringBoot就有这个疑惑了，哇，我添加一个starter，他包含了这么多相关的依赖，那我开一个非常简单的程序，假如所有starter都启动，那不得卡死，但我写了第一个SpringBoot程序后发现并没有，速度很快。原来SpringBoot是有着<strong>按需加载自动配置项（starter）</strong>的性质的</p>
<p>SpringBoot的自动配置功能依赖于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h1><h2 id="回忆Spring"><a href="#回忆Spring" class="headerlink" title="回忆Spring"></a>回忆Spring</h2><p>回忆一下，没接触过SpringBoot之前，我们的组件（对象）是怎么交由Spring托管的呢？</p>
<p>我们创建了一个xml文件，然后在里面设置值，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Test1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Test2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Springboot实现"><a href="#Springboot实现" class="headerlink" title="Springboot实现"></a>Springboot实现</h2><h3 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><ul>
<li>作用：声明一个类为配置类</li>
</ul>
<p>下列代码的作用：就是告诉SpringBoot这个类是一个配置类啦，里面以后就需要写一些我们的数据连接池之类的配置文件啦。以后其作用等同于xm</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><ul>
<li><p>作用：声明在一个方法上面，用于给容器中添加组件，要注意：<strong>此时方法名就是组件的id，返回类型是组件类型，返回值为组件在容器中的实例！</strong></p>
<p>当然了如果不想让组件id为方法名的话，可以<code>@Bean(&quot;xxxx&quot;)</code>自己给它取一个</p>
</li>
</ul>
<p>下列方法的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> zhangsan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们打印一下容器中组件：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320213034969.png" alt="image-20210320213034969"></p>
<p>那我们再测试一下容器中的组件符合不符合我们之前学习的，要符合单例的原则呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210320213329404.png" alt="image-20210320213329404"></p>
<p>ok啦，是同一个。</p>
<p>那我们的配置类：<code>MyConfig.class</code>是不是一个组件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">System.out.println(bean);</span><br></pre></td></tr></table></figure>

<p>打印结果：com.hpg.boot.config.MyConfig$$EnhancerBySpringCGLIB$$5b53d985@10a95ae9</p>
<p>是的 他也是个组件</p>
<h5 id="proxyBeanMethods"><a href="#proxyBeanMethods" class="headerlink" title="proxyBeanMethods"></a>proxyBeanMethods</h5><p>在@Bean注解中有一个很有意思的属性：proxyBeanMethods = true/false</p>
<p>他有什么用呢？先不急，我们测试一段代码</p>
<ul>
<li>先置proxyBeanMethods = true</li>
</ul>
<p>作用是先获取一个配置类对象，再取配置类对象中的2个对象（与上面的取法是不同的，要注意）</p>
<p>接着判断这两个对象是否相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">User user = bean.user01();</span><br><span class="line">User user1 = bean.user01();</span><br><span class="line">System.out.println(user == user1);</span><br></pre></td></tr></table></figure>

<p>结果是：true，说明这两个user是同一个对象</p>
<p>而根据打印bean的语句：com.hpg.boot.config.MyConfig$$EnhancerBySpringCGLIB$$5b53d985@10a95ae9我们还发现我们bean对象是一个<strong>代理对象</strong></p>
<p>说明对象是同一个对象，也就是<strong>单例</strong>的；</p>
<ul>
<li>再置proxyBeanMethods = flase</li>
</ul>
<p>结果是false，说明并不是同一个对象</p>
<p>此时打印出来的bean：com.hpg.boot.config.MyConfig@304a9d7b</p>
<p>因此发现此时的bean对象并<mark>不是</mark>一个<strong>代理对象</strong>；</p>
<p>那么这个proxyBeanMethods有什么用呢？</p>
<p>我们在User类中添加Pet对象及其Getter Setter方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Pet pet;</span><br></pre></td></tr></table></figure>

<p>同时，我们在配置类中添加一下SetPet的环节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">    zhangsan.setPet(tomcatPet());</span><br><span class="line">    <span class="keyword">return</span> zhangsan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，我们进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line">System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br></pre></td></tr></table></figure>

<p>打印结果：<strong>用户的宠物：true</strong></p>
<p>而假如我们设置proxyBeanMethods = false</p>
<p>打印的结果：<strong>用户的宠物：false</strong></p>
<ul>
<li>Full(proxyBeanMethods = true)【保证每个@Bean方法被调用多少次返回的组件都是单实例的】</li>
<li>Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】</li>
<li>组件依赖必须使用<mark>Full模式</mark>默认。其他默认是否<mark>Lite模式</mark></li>
</ul>
<h4 id="Component、-Controller、-Service、-Repository"><a href="#Component、-Controller、-Service、-Repository" class="headerlink" title="@Component、@Controller、@Service、@Repository"></a>@Component、@Controller、@Service、@Repository</h4><p>这些注解依旧有用，这里不再复述各个注解的作用了</p>
<h4 id="ComponentScan-Import"><a href="#ComponentScan-Import" class="headerlink" title="@ComponentScan @Import"></a>@ComponentScan @Import</h4><ul>
<li>@ComponentScan：包扫描注解，这个是之前就讲过的，总的来说就是告诉Spring要在哪里找到Bean</li>
<li>@Import：给容器中自动创建出这对应类型的组件、默认组件的名字就是全类名</li>
</ul>
<p>测试一下@Import吧：</p>
<p>在MyConfig上添加：<code>@Import(&#123;User.class, DBHelper.class&#125;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5、获取组件</span></span><br><span class="line">String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line"><span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DBHelper bean1 = run.getBean(DBHelper.class);</span><br><span class="line">System.out.println(bean1);</span><br></pre></td></tr></table></figure>

<p>打印结果：<br>com.hpg.boot.bean.User</p>
<p>user01</p>
<p>ch.qos.logback.core.db.DBHelper@2aa27288</p>
<p>解释一下：第一个是通过@import注入的，而user01是通过@Bean组件注入的</p>
<h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><ul>
<li>条件装配：满足Conditional指定的条件，则进行组件注入</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1602835786727-28b6f936-62f5-4fd6-a6c5-ae690bd1e31d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="image.png"></p>
<p>下满测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件@ConditionalOnBean(name = &quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了一个条件注解：<code>@ConditionalOnBean(name = &quot;tom&quot;)</code></p>
<p>告诉容器中假如有一个tom组件的时候，下面的bean才都生效（注入）；</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> tom1 = run.containsBean(<span class="string">&quot;tom1&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;容器中tom1组件：&quot;</span>+tom1);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p>容器中Tom组件：false<br>容器中user01组件：false<br>容器中tom1组件：false</p>
<p>同样的，这个注解可以加在方法上，假如两个bean存在注入关系的话，同样适用；</p>
<ul>
<li><p>我们还可以使用@ConditionalOnMissingBean(name = “tom”)</p>
<p>表示如果不存在tom这个组件，就帮我们注入；</p>
</li>
</ul>
<p>打印结果是：</p>
<p>容器中Tom组件：false<br>容器中user01组件：true<br>容器中tom1组件：true</p>
<h3 id="原生配置文件引入"><a href="#原生配置文件引入" class="headerlink" title="原生配置文件引入"></a>原生配置文件引入</h3><p>假如有一些bean放在了xml文件中，我们怎么添加到容器中呢？</p>
<p>答案是通过<strong>@ImportResource()</strong>去引入</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321163955190.png" alt="image-20210321163955190"></p>
<p>比如有一个beans.xml在资源包下，我们可以通过<code>@ImportResource(&quot;classpath:beans.xml&quot;)</code>去引入</p>
<h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><p>想一想，我们如何使用Java去读取Properties文件中的内容封装到JavaBean中呢？</p>
<ol>
<li>new一个Properties类</li>
<li>将配置文件读成一个流的形式</li>
<li>通过这类的load方法导入流</li>
</ol>
<p>举个例子吧：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/xxxx</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块，类加载的时候就初始化啦</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//通过类加载器读取对应资源 反射 把资源以流的形式读出来</span></span><br><span class="line"><span class="comment">//        Class&lt;BaseDao&gt; baseDaoClass = BaseDao.class; 获得class文件</span></span><br><span class="line"><span class="comment">//        ClassLoader classLoader = baseDaoClass.getClassLoader();</span></span><br><span class="line"><span class="comment">//        InputStream resourceAsStream = classLoader.getResourceAsStream(&quot;db.properties&quot;);</span></span><br><span class="line">        InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为变量赋值</span></span><br><span class="line">        driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        username = properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Component-ConfigurationProperties"><a href="#Component-ConfigurationProperties" class="headerlink" title="@Component + @ConfigurationProperties"></a>@Component + @ConfigurationProperties</h4><p>有个Car类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在application.properties中有着两个属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mycar.brand</span>=<span class="string">BMW</span></span><br><span class="line"><span class="meta">mycar.price</span>=<span class="string">100000</span></span><br></pre></td></tr></table></figure>

<p>控制器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321165905163.png" alt="image-20210321165905163"></p>
<h4 id="EnableConfigurationProperties-ConfigurationProperties"><a href="#EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties + @ConfigurationProperties"></a>@EnableConfigurationProperties + @ConfigurationProperties</h4><p>我们可以在<strong>配置类</strong>中添加@EnableConfigurationProperties(目标类.class)的方式去取代<strong>@Component</strong></p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码的作用就是：</p>
<ol>
<li>开启Car配置绑定功能</li>
<li>把这个Car这个组件自动注册到容器中</li>
</ol>
<p>当然，别忘了，@ConfigurationProperties还是得老老实实的配好：<code>@ConfigurationProperties(prefix = &quot;mycar&quot;)</code> 不能忘掉</p>
<h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><p>学习嘛，不能只知道其用法，而不知道其原理，我们上述学习了多个自动配置的注解；</p>
<p>下面就来深入（？）得看看究竟这个神奇的自动配置是怎么实现的。</p>
<h2 id="自动配置【自动包扫描规则-自动类加载】"><a href="#自动配置【自动包扫描规则-自动类加载】" class="headerlink" title="自动配置【自动包扫描规则 + 自动类加载】"></a>自动配置【自动包扫描规则 + 自动类加载】</h2><ul>
<li><p>我们知道，我们的神奇的SpringBoot程序是由<mark>@SpringBootApplication</mark>注解去开启的，我们点开这个注解看看：</p>
<p>发现这个注解是一个<strong>【复合注解】</strong>，由</p>
<p>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan</p>
<p>这三个注解构成；（当然还有上面省略的一些啦）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了一些别的注解</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;<span class="comment">//省略其中内容&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述内容也证明了我们所说的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等价于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hpg.boot&quot;)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>下面就逐行分析，先分析第一个：<mark>@SpringBootConfiguration</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@Target({ElementType.TYPE})：注解的<mark>作用目标</mark>是<strong>接口、类、枚举</strong></p>
</li>
<li><p>@Retention(RetentionPolicy.RUNTIME)：告诉注解保留的位置，这里的参数是RUNTIME，说明的是：注解会在class字节码文件中存在，在运行时可以通过反射获取到</p>
</li>
<li><p>@Documented：说明该注解将被包含在javadoc中</p>
</li>
<li><p>@Configuration：这就是我们需要注意的了，这个注解的作用是声明当前的类是一个<strong>配置类</strong>。</p>
<p>其作用是：标注在类上，配置spring容器(应用上下文)。相当于把该类作为spring的xml配置文件中的<code>&lt;beans&gt;</code>。说人话，就是Spring将扫描加了<strong>@Configuration</strong>的类，读取其中配置信息；</p>
</li>
</ul>
<p>通过上述解读（其实最关键的就是最后一个注解），<strong>@SpringBootConfiguration</strong>就是<strong>@Configuration</strong>一个延伸，告诉这个类是<em>SpringBoot应用</em>配置类；</p>
<h3 id="EnableAutoConfiguration（关键）"><a href="#EnableAutoConfiguration（关键）" class="headerlink" title="@EnableAutoConfiguration（关键）"></a>@EnableAutoConfiguration（关键）</h3><p>我们点开这个注解，果不其然 又是一个<strong>【复合注解】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头四个注解我们已经说腻了，就不说了，重点关注后两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span> <span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Registrar给容器中导入一系列组件</span></span><br><span class="line"><span class="comment">//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</span></span><br></pre></td></tr></table></figure>

<p>我们关注一下，<code>@Import(AutoConfigurationPackages.Registrar.class)</code> 这行，@Import注解我们上面学过了，知道其作用是导入组件，在这里它导入的是一个叫<strong>Register</strong>class文件，这个<strong>Register</strong>又是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点关注一下这段代码做了什么事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>metadata</mark>是注解的元信息，包括注解作用的位置啊，类型等</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321180459815.png" alt="image-20210321180459815"></p>
<p><mark>registry</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321180533230.png" alt="image-20210321180533230"></p>
<p>是一个BeanFactory</p>
<p>那么register方法中的第二个参数：</p>
<p><code>new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])</code></p>
<p>这代表着什么呢？我们查找一下看看，发现其值是一个<strong>包名</strong>；</p>
<p>也就是把包名最终封装到了一个数组里面</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321180927478.png" alt="image-20210321180927478"></p>
<p>好啦，现在我们清楚了参数：一个是bean工厂，一个是包的数组</p>
<p>那么这个register方法做了什么事情呢？它进行了bean的注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN);</span><br><span class="line">        ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues();</span><br><span class="line">        constructorArguments.addIndexedArgumentValue(<span class="number">0</span>, addBasePackages(constructorArguments, packageNames));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(AutoConfigurationPackages.BasePackages.class);</span><br><span class="line">        beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, packageNames);</span><br><span class="line">        beanDefinition.setRole(<span class="number">2</span>);</span><br><span class="line">        registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们明白了@AutoConfigurationPackage的作用：</p>
<p>就是将指定的一个包下的所有组件导入进来。还记得我们在哪里用的这个注解吗？对的 MainApplication</p>
<p>这也就侧面说明了，为什么我们的启动类的位置必须是控制器等类所在包同级别的原因了！（因为要扫描包嘛）</p>
<h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>我们不关心@Import注解，只需要知道其作用是导入组件，因此我们就需要研究导入的：</p>
<p><code>AutoConfigurationImportSelector.class</code></p>
<p>究竟是何方神圣即可；</p>
<p>我们点进这个类，找到以下这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其作用是决定要给容器中导入哪些组件；它的返回值是通过</p>
<p><code>getAutoConfigurationEntry(annotationMetadata);</code> 这个方法去得到自动配置信息，再通过<code>getConfigurations()</code>方法去获取配置信息 转成数组形式返回 </p>
<p>因此，只要弄清楚<code>getAutoConfigurationEntry(annotationMetadata)</code>方法就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>获取到所有需要导入到容器中的配置类</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210321183437039.png" alt></p>
<p>我们Step in这个方法去看看是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个<code>loadFactoryNames</code>中其本质：是利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；</code>得到所有的组件</p>
<p>深究一下，资源文件的获取是通过获取的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也就是说：从<strong>META-INF/spring.factories</strong>位置来加载一个文件。</p>
<p>默认扫描我们当前系统里面所有<strong>META-INF/spring.factories</strong>位置的文件</p>
<p><strong>spring-boot-autoconfigure-2.3.4.RELEASE.jar</strong>包里面也有<strong>META-INF/spring.factories</strong></p>
<p>我们点进去这个facotories文件，找到自动配置相关信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件里面写死了spring-boot一启动就要给容器中加载的所有配置类</span><br><span class="line">位置：spring-boot-autoconfigure-2.3.4.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories</span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">还有很多，就不都放上来了</span><br></pre></td></tr></table></figure>

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200127171452941.png" alt="在这里插入图片描述"></p>
<p>在这注解中有这么一段话：</p>
<p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p>
<p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p>
<p>联想一下我们之前学习的，@SpringBootApplication注解所标注的就是main的启动项，扫描的话就会扫描这个类的包和其子包；再次证明了启动类所在的目录结构位置应该放在控制层等包之前；</p>
<h3 id="按需开启自动配置"><a href="#按需开启自动配置" class="headerlink" title="按需开启自动配置"></a>按需开启自动配置</h3><p>想一想，我们上面说的@import导入的包这么多，难道我们全都会自动配置上吗？</p>
<p>答案是否定的，利用了@Condition注解，我们能够按照条件装配规则进行按需配置</p>
<p>比如<code>AopAutoConfiguration</code>类中，就设定了一定要引入spring.aop场景，该配置才会生效；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.aop&quot;,</span></span><br><span class="line"><span class="meta">    name = &quot;auto&quot;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自动配置【自动配置流程】"><a href="#自动配置【自动配置流程】" class="headerlink" title="自动配置【自动配置流程】"></a>自动配置【自动配置流程】</h2><p>在这个包下有许多我们的功能组件</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322145020916.png" alt="image-20210322145020916"></p>
<p>我们找到<code>DispatcherServletAutoConfiguration</code>，以此为例来看看自动配置的运行流程</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322145254435.png" alt="image-20210322145254435"></p>
<p>这个类上有四个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(-2147483648)</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DispatcherServlet.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;<span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@AutoConfigureOrder(-2147483648)</code>:类生效顺序</li>
<li><code>@Configuration</code>:声明类为配置类</li>
<li><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code>判断应用为原生Servlet应用才生效</li>
<li><code>@ConditionalOnClass(&#123;DispatcherServlet.class&#125;)</code>:当存在DispatcherServlet类是生效，而当我们引入SpringMVC相关依赖时候，该类就会存在，当前配置才会生效</li>
<li><code>@AutoConfigureAfter(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)</code>:告诉该配置类，在括号内的类配置好了后才去配置当前类</li>
</ul>
<p>只有当上面的配置条件都满足了，才会往下走：</p>
<p>继续向下走，在这个类中有一个子类<code>DispatcherServletConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Conditional(&#123;DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;ServletRegistration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DispatcherServletConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">@Bean(</span></span><br><span class="line"><span class="meta">            name = &#123;&quot;dispatcherServlet&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DispatcherServlet <span class="title">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> </span>&#123;</span><br><span class="line">            DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">            dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">            dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">            dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">            dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">            dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">            <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">            name = &#123;&quot;multipartResolver&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>前几个注解上面说过了，这里有个<code>@EnableConfigurationProperties(&#123;WebMvcProperties.class&#125;)</code></p>
<p>它表示：开启<code>WebMvcProperties</code>类与<strong>配置文件</strong>的绑定功能，我们点进去看看与哪个配置文件进行了绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span></span></span><br></pre></td></tr></table></figure>

<p>喔，会和以<strong>spring.mvc</strong>为前缀的属性类进行绑定</p>
<p>既然我们绑定完了，以后我们的组件就会存在<code>WebMvcProperties</code>的组件了</p>
<p>接着@Bean，给容器中注册了组件，也就是<strong>dispatcherServlet</strong>，如何注册的呢？自己 new了一个<strong>DispatcherServlet</strong>,设置其中属性，然后return。相当于底层帮我们配置好了。</p>
<p>再来一个@Bean，又进行了<strong>文件上传功能</strong>组件的注册。</p>
<p>首先由注解进行了两个判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//容器中有这个组件</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span></span><br><span class="line">    <span class="comment">//容器中没有一个名字叫：multipartResolver的组件</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &#123;&quot;multipartResolver&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>接着去构造一个文件解析器注入容器</p>
<p>什么意思呢？其实说到底就是SpringMVC 防止有些用户配置的文件上传解析器不符合规范，给你写死了；</p>
<h3 id="小结-自定义配置"><a href="#小结-自定义配置" class="headerlink" title="小结 + 自定义配置"></a>小结 + 自定义配置</h3><ul>
<li>总结：</li>
</ul>
<ol>
<li><p>SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration</p>
</li>
<li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）</p>
</li>
<li><p>生效的配置类就会给容器中装配很多组件</p>
</li>
<li><p>只要容器中有这些组件，相当于这些功能就有了</p>
</li>
<li><p>定制化配置</p>
<ol>
<li><p>用户直接自己@Bean替换底层的组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户去看这个组件是获取的配置文件什么值就去修改。</p>
<p>去application.properties文件中</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.servlet.encoding.charset</span>=<span class="string">GBK</span></span><br></pre></td></tr></table></figure>

<p>再比如想修改缓存相关的，我们就点进自动配置类</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322154252027.png" alt="image-20210322154252027"></p>
<p>发现和<code>CacheProperties.class</code>相关的</p>
<p>点进这个类，发现前缀是<strong>spring.cache</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322154329185.png" alt="image-20210322154329185"></p>
<p>我们就能去到配置文件，进行修改</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322154415226.png" alt="image-20210322154415226"></p>
</li>
</ol>
</li>
</ol>
<p><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值 —-&gt; application.properties</strong></p>
<h1 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h1><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>作用：Lombok用标签方式代替构造器、getter/setter、toString()等</p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>搜索安装：File-&gt;Settings-&gt;Plugins→Lombok</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322200859451.png" alt="image-20210322200859451"></p>
<p>使用示例：</p>
<ul>
<li>eg1:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="comment">//@Data:@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor的集合</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>eg2:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">//无参构造器</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>  <span class="comment">//全参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h2><p>作用：实现<strong>热部署</strong>，Ctrl+F9就可以重启（如果只改变了静态页面的话以后就不用重启了，可以自动更新）</p>
<ul>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Spring-Initailizr"><a href="#Spring-Initailizr" class="headerlink" title="Spring Initailizr"></a>Spring Initailizr</h2><p><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initailizr</a>是创建Spring Boot工程向导。</p>
<p>在IDEA中，菜单栏New -&gt; Project -&gt; Spring Initailizr。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>Spring Boot弱化配置的特性让属性配置文件的使用也更加便捷，它默认支持对<mark>application.properties</mark>或<mark>application.yml</mark>属性配置文件处理，即在<mark>application.properties</mark>或<mark>application.yml</mark>文件中添加属性配置，可以使用<strong>@Value注解</strong>将属性值注入到<code>beans</code>中，或使用<strong>@ConfigurationProperties注解</strong>将属性值绑定到结构化的beans中</p>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>YAML是JSON的一个超集，是一种方便的定义层次配置数据的格式，结构层次上清晰明了，配置简单易读、易用。</p>
<p>要想使用YAML作为属性配置文件，需要将SnakeYAML库添加到classpath下，Spring Boot对SnakeYAML库也做了集成，例如使用<strong>spring-boot-starter-web</strong>或<strong>spring-boot-starter</strong>都会自动添加<strong>SnakeYAML</strong>库到classpath下。</p>
<p>举个例子,来感受一下YAML:</p>
<ul>
<li>之前的properties文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">http://dev.example.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">http://another.example.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在的YAML文档</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://dev.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://another.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果存在property键的话，之前的写法</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li>YAML lists会使用 - 表示键</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>key: value；kv之间有空格</p>
</li>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进不允许使用tab，只允许空格（然而IDEA支持tab）</p>
</li>
<li><p>缩进的空格数不重要，只要相同层级的元素左对齐即可</p>
</li>
<li><p>‘#’表示注释</p>
</li>
<li><p>字符串无需加引号（如果字符串为一段数字，该数字以零开头，必须添加上””  不然Springboot会将数字解析成八进制）</p>
<p>如果要加，’’与””表示字符串内容 会被 转义/不转义。（如\n，单引号中作为字符串输出，双引号会换行）</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">v</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例</p>
<ul>
<li><p>Java类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>YAML写法表示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="comment">#  单引号会将 \n作为字符串输出   双引号会将\n 作为换行输出</span></span><br><span class="line"><span class="comment">#  双引号不会转义，单引号会转义</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/9</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="comment">#  interests: [篮球,足球]</span></span><br><span class="line">  <span class="attr">interests:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">篮球</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">足球</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">animal:</span> [<span class="string">阿猫</span>,<span class="string">阿狗</span>]</span><br><span class="line"><span class="comment">#  score:</span></span><br><span class="line"><span class="comment">#    english: 80</span></span><br><span class="line"><span class="comment">#    math: 90</span></span><br><span class="line">  <span class="attr">score:</span> &#123;<span class="string">english:80</span>,<span class="string">math:90</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9999.98</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9999.99</span></span><br><span class="line">  <span class="attr">pet:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">阿狗</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">99.99</span></span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">阿狗</span>,<span class="attr">weight:</span> <span class="number">99.99</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">阿猫</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">88.88</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">阿虫</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">77.77</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">阿花</span>,<span class="attr">weight:</span> <span class="number">199.99</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">阿明</span>,<span class="attr">weight:</span> <span class="number">199.99</span>&#125;</span><br><span class="line">  <span class="attr">user-name:</span> <span class="string">zhangsan</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>## 配置提示

我们注意到在类上有时候会报以下问题：表示自定义的类和配置文件绑定一般没有提示。

![image-20210322204527901](https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322204527901.png)

想要有提示，需要引入依赖：

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

# Web开发

## SpringMVC自动配置概览

Spring Boot provides auto-configuration for Spring MVC that **works well with most applications.(大多场景我们都无需自定义配置)**

The auto-configuration adds the following features on top of Spring’s defaults:

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.

- - 内容协商视图解析器和BeanName视图解析器

- Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content))).

- - 静态资源（包括webjars）

- Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.

- - 自动注册 `Converter，GenericConverter，Formatter `

- Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters)).

- - 支持 `HttpMessageConverters` （后来我们配合内容协商理解原理）

- Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes)).

- - 自动注册 `MessageCodesResolver` （国际化用）

- Static `index.html` support.

- - 静态index.html 页支持

- Custom `Favicon` support (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon)).

- - 自定义 `Favicon`  

- Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer)).

- - 自动使用 `ConfigurableWebBindingInitializer` ，（DataBinder负责将请求数据绑定到JavaBean上）</code></pre><blockquote>
<p>If you want to keep those Spring Boot MVC customizations and make more <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<p><strong>不用@EnableWebMvc注解。使用</strong> <strong><code>@Configuration</code></strong> <strong>+</strong> <strong><code>WebMvcConfigurer</code></strong> <strong>自定义规则</strong></p>
</blockquote>
<blockquote>
<p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p>
<p><strong>声明</strong> <strong><code>WebMvcRegistrations</code></strong> <strong>改变默认底层组件</strong></p>
</blockquote>
<blockquote>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p><strong>使用</strong> <strong><code>@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC</code></strong></p>
</blockquote>
<h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><h3 id="静态资源的访问"><a href="#静态资源的访问" class="headerlink" title="静态资源的访问"></a>静态资源的访问</h3><h4 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h4><p>只要把<strong>静态资源</strong>放在类路径（resources包）下中 叫做 ： <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code>的包，就可以加载</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322210520362.png" alt="image-20210322210520362"></p>
<p>比如现在我们在static包下放了个</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322211029371.png" alt="image-20210322211029371"></p>
<p>我们访问一下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322211007644.png" alt="image-20210322211007644"></p>
<p>想一想，我明明放在了resources包下的static包中，为什么直接搜图片就能访问呢？</p>
<ul>
<li>原理： 静态映射/**。</li>
</ul>
<p>我们来进行一个测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/bug.jpg&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//request</span></span><br><span class="line">   	 	<span class="keyword">return</span> <span class="string">&quot;aaaa&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编写了一个controller，requestmapping指定的是：/bug.jpg；同时我们的静态资源中放入了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322211722982.png" alt="image-20210322211722982"></p>
<p>那我们现在访问这个路径，究竟是显示aaaa呢还是图片呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322211750084.png" alt="image-20210322211750084"></p>
<p>请求进来，先去找<strong>Controller</strong>看能不能处理。不能处理的所有请求又都交给<strong>静态资源处理器</strong>。静态资源也找不到则响应404页面。</p>
<h4 id="改变默认静态资源路径"><a href="#改变默认静态资源路径" class="headerlink" title="改变默认静态资源路径"></a>改变默认静态资源路径</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">static-locations:</span> [<span class="string">classpath:/test/</span>]</span><br></pre></td></tr></table></figure>

<p>作用就算将默认资源路径转为了：test</p>
<h4 id="改变静态资源访问前缀"><a href="#改变静态资源访问前缀" class="headerlink" title="改变静态资源访问前缀"></a>改变静态资源访问前缀</h4><p>默认的是无前缀的，但我们可以进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure>

<p>作用：当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<p>比如上例中我们就得找：locahost:8080/res/xxxx.jpg 了</p>
<h4 id="webjar"><a href="#webjar" class="headerlink" title="webjar"></a>webjar</h4><p>作用：可用jar方式添加css，js等资源文件，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322212609750.png" alt="image-20210322212609750"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210322212621826.png" alt="image-20210322212621826"></p>
<h3 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h3><ul>
<li><p>静态资源路径下 index.html。</p>
<ul>
<li><p>可以配置静态资源路径</p>
</li>
<li><p>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致welcome page功能失效</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>controller能处理/index</p>
</li>
</ul>
<h3 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h3><p>指网页标签上的小图标。</p>
<p>favicon.ico 放在静态资源目录下即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效</span></span><br></pre></td></tr></table></figure>

<h3 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h3><ul>
<li><p>首先SpringBoot启动默认加载了很多的自动配置类，也就是 <strong>xxxAutoConfiguration</strong>类</p>
</li>
<li><p>在自动配置类的包下中的servlet包下有着 <strong>WebMvcAutoConfiguration</strong> 这个类</p>
<p>这是SpringMVC功能相关的自动配置类（从名字也看的出来）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323195017180.png" alt="image-20210323195017180"></p>
</li>
<li><p>想要让他生效，其类前面的几个注解就必须满足一定的条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet应用</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//有Servlet、DispatcherServlet、WebMvc配置 三个类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span></span><br><span class="line"><span class="comment">//容器中没有 WebMvcConfigurationSupport 这个类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(-2147483638)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面假设满足条件了，那我们看看这个<strong>WebMvcAutoConfiguration</strong> 给容器中配了哪些组件</p>
</li>
</ul>
<ol>
<li><p>兼容REST风格的过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表单内容的过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;FormContentFilter.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc.formcontent.filter&quot;,</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedFormContentFilter <span class="title">formContentFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedFormContentFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>适配器（核心）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们留意到这里有着<code>@EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</code></p>
<p>说明这里进行了配置文件的绑定，那究竟和什么进行了绑定呢？我们点进去这两个类就可以知道了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConfigurationProperties</span>(</span></span><br><span class="line"><span class="class">    <span class="title">prefix</span> </span>= <span class="string">&quot;spring.resources&quot;</span>,</span><br><span class="line">    ignoreUnknownFields = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span></span></span><br></pre></td></tr></table></figure>

<p>显而易见：WebMvcProperties → <strong>spring.mvc</strong>； ResourceProperties → <strong>spring.resources</strong></p>
<ul>
<li><strong>有参构造器</strong></li>
</ul>
<p>接着分析，在这个类中只有一个有参构造器，下面看看这个类的值都与什么属性进行了赋值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebMvcAutoConfigurationAdapter</span><span class="params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取和spring.resources绑定的所有的值的对象</span></span><br><span class="line">    <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">    <span class="comment">//获取和spring.mvc绑定的所有的值的对象</span></span><br><span class="line">    <span class="keyword">this</span>.mvcProperties = mvcProperties;</span><br><span class="line">    <span class="comment">//Spring的beanFactory</span></span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    <span class="comment">//所有的 HttpMessageConverters</span></span><br><span class="line">    <span class="keyword">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line">    <span class="comment">//资源处理器的自定义器</span></span><br><span class="line">    <span class="keyword">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line">    <span class="comment">//dispatcherServlet的路径</span></span><br><span class="line">    <span class="keyword">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line">    <span class="comment">//给应用注册Servlet、Filter等用的</span></span><br><span class="line">    <span class="keyword">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="资源处理默认规则"><a href="#资源处理默认规则" class="headerlink" title="资源处理默认规则"></a>资源处理默认规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">        CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>逐行来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这行代码中的``this.resourceProperties `  我们知道，是spring.resources配置文件下绑定的所有配置属性</p>
<p> <code>isAddMappings()</code>是什么呢？假如是false，我们就只会走<code>logger.debug(&quot;Default resource handling disabled&quot;);</code></p>
<p>下面的代码就都不会走了，那我们true，我们就进入了else语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们进行的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如配的路径是 /webjars/** 的话，我们要走/META-INF/resources/webjars/去找资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而假如配的路径是其他的（我们配置的，默认的是/**)，那么这些请求就会走<code>resourceProperties.getStaticLocations()</code></p>
<p>也就是指定的路径：<strong>private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</strong>   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">           <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这也很好的解释了为什么我们的静态资源文件只要放在那四个指定的包下就可以找到的原因！</p>
<p>综上：也就表示着：<strong>静态资源的配置规则</strong></p>
<h5 id="静态资源的禁用方法"><a href="#静态资源的禁用方法" class="headerlink" title="静态资源的禁用方法"></a>静态资源的禁用方法</h5><p>可以靠设置下列配置文件，进行静态资源的禁用；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment">#禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure>



<h4 id="欢迎页处理规则"><a href="#欢迎页处理规则" class="headerlink" title="欢迎页处理规则"></a>欢迎页处理规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">    WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="keyword">this</span>.getWelcomePage(), <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(<span class="keyword">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">    welcomePageHandlerMapping.setCorsConfigurations(<span class="keyword">this</span>.getCorsConfigurations());</span><br><span class="line">    <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HandlerMapping：处理器映射器，保存了每个Handler能处理哪些请求</li>
</ul>
<p>这个类的构造方法中，我们注意到：<code>this.mvcProperties.getStaticPathPattern()</code> 这个参数 也就是我们的配置文件中的：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**</span></span><br></pre></td></tr></table></figure>

<p>我们进入它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line">    /</span><br><span class="line">    <span class="keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());</span><br><span class="line">        <span class="keyword">this</span>.setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern))</code></p>
<p>这句话表示：如果欢迎页存在，且/** 为访问路径前缀 才能走下面的方法（forward：index.html），这也就代表着前面我们欢迎页支持篇章学习的时候，为什么不能使用/res/** 为路径前缀的原因了。因为底层写死了已经。</p>
<p>如果我们的访问路径前缀不按照他的来，就会走下面的方法，调用Controller 去看看哪个方法能去找到/index</p>
<h1 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h1><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><h3 id="Rest风格映射原理"><a href="#Rest风格映射原理" class="headerlink" title="Rest风格映射原理"></a>Rest风格映射原理</h3><ul>
<li><p>@xxxMapping；</p>
</li>
<li><p>Rest风格支持（<em>使用*</em>HTTP*<em>请求方式动词来表示对资源的操作</em>）</p>
</li>
<li><ul>
<li><em>以前：/getUser</em>  <em>获取用户</em>   <em>/deleteUser</em> <em>删除用户</em>   <em>/editUser</em>  <em>修改用户</em>    <em>/saveUser</em> <em>保存用户</em></li>
<li><em>现在： /user</em>   <em>GET-获取用户</em>   <em>DELETE-删除用户</em>   <em>PUT-修改用户</em>    <em>POST-保存用户</em></li>
<li>核心Filter；HiddenHttpMethodFilter</li>
</ul>
</li>
</ul>
<p>怎么用呢？</p>
<ol>
<li><p>开启页面表单的Rest功能</p>
<p>理由：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启方式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面 form的属性method=post，隐藏域 _method=put、delete等（如果直接get或post，无需隐藏域）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/user&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;input value=<span class="string">&quot;REST-GET提交&quot;</span> type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;/user&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input value=<span class="string">&quot;REST-POST提交&quot;</span> type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;/user&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;_method&quot;</span> type=<span class="string">&quot;hidden&quot;</span> value=<span class="string">&quot;DELETE&quot;</span>/&gt;</span><br><span class="line">    &lt;input value=<span class="string">&quot;REST-DELETE 提交&quot;</span> type=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;/user&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;_method&quot;</span> type=<span class="string">&quot;hidden&quot;</span> value=<span class="string">&quot;PUT&quot;</span> /&gt;</span><br><span class="line">    &lt;input value=<span class="string">&quot;REST-PUT提交&quot;</span>type=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写请求映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323211855898.png" alt="image-20210323211855898"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323211903027.png" alt="image-20210323211903027"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323211910151.png" alt="image-20210323211910151"></p>
<p>Rest原理（表单提交要使用REST的时候）</p>
<ul>
<li><p>表单提交会带上<strong>_method=PUT</strong></p>
</li>
<li><p><strong>请求过来被</strong><mark>HiddenHttpMethodFilter</mark>拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpServletRequest requestToUse = request;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String paramValue = request.getParameter(<span class="keyword">this</span>.methodParam);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">            String method = paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">            <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                requestToUse = <span class="keyword">new</span> HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filterChain.doFilter((ServletRequest)requestToUse, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="java"><span class="keyword">if</span> (<span class="string">"POST"</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="string">"javax.servlet.error.exception"</span>) == <span class="keyword">null</span>)
&lt;!--code￼<span class="number">94</span>--&gt;

    获取到**_method**的值。

    &lt;!--code￼<span class="number">95</span>--&gt;

    转成大写的（无论一开始请求是不是大写的）

  - ```java
    <span class="keyword">if</span> (ALLOWED_METHODS.contains(method))
    &lt;!--code￼<span class="number">96</span>--&gt;

    原生request是**post**，使用了**包装模式requesWrapper**重写**了getMethod**方法，返回的是传入的值（delete，put等）。

  - ```java
    filterChain.doFilter((ServletRequest)requestToUse, response);
    &lt;!--code￼<span class="number">97</span>--&gt;
</code></pre>
</li>
</ul>
<p>如何自定义_method的名字呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h3><h2 id="常用参数注解"><a href="#常用参数注解" class="headerlink" title="常用参数注解"></a>常用参数注解</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li><code>@PathVariable</code> 路径变量</li>
<li><code>@RequestHeader</code> 获取请求头</li>
<li><code>@RequestParam</code> 获取请求参数（指问号后的参数，url?a=1&amp;b=2）</li>
<li><code>@CookieValue</code> 获取Cookie值</li>
<li><code>@RequestAttribute</code> 获取request域属性</li>
<li><code>@RequestBody</code> 获取请求体[POST]</li>
<li><code>@MatrixVariable</code> 矩阵变量</li>
<li><code>@ModelAttribute</code></li>
</ul>
<h4 id="测试-PathVariable："><a href="#测试-PathVariable：" class="headerlink" title="测试@PathVariable："></a>测试@PathVariable：</h4><p>前端页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;a href=&quot;car/3/owner/lisi&quot;&gt;car/&#123;id&#125;/owner/&#123;username&#125;&lt;/a&gt;</span><br><span class="line">    &lt;li&gt;@PathVariable（路径变量）&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;@RequestHeader（获取请求头）&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;@RequestParam（获取请求参数）&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;@CookieValue（获取cookie值）&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;@RequestBody（获取请求体[POST]）&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li&gt;@RequestAttribute（获取request域属性）&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;@MatrixVariable（矩阵变量）&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">   map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   map.put(<span class="string">&quot;pv&quot;</span>,pv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323220042584.png" alt="image-20210323220042584"></p>
<h4 id="测试-RequestHeader"><a href="#测试-RequestHeader" class="headerlink" title="测试@RequestHeader"></a>测试@RequestHeader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,id);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        map.put(<span class="string">&quot;pv&quot;</span>,pv);</span><br><span class="line">        map.put(<span class="string">&quot;userAgent&quot;</span>,userAgent);</span><br><span class="line">        map.put(<span class="string">&quot;headers&quot;</span>,header);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>渲染的数据：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323220633573.png" alt="image-20210323220633573"></p>
<p>F12查看的数据：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323220655237.png" alt="image-20210323220655237"></p>
<h4 id="测试-RequestParam"><a href="#测试-RequestParam" class="headerlink" title="测试@RequestParam"></a>测试@RequestParam</h4><p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">        map.put(<span class="string">&quot;inters&quot;</span>,inters);</span><br><span class="line">        map.put(<span class="string">&quot;params&quot;</span>,params);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323221051990.png" alt="image-20210323221051990"></p>
<h4 id="RequestParam和-PathVariable区别"><a href="#RequestParam和-PathVariable区别" class="headerlink" title="@RequestParam和@PathVariable区别"></a>@RequestParam和@PathVariable区别</h4><p><strong>@RequestParam</strong>与@<strong>PathVariable</strong>为spring的注解，都可以用于在Controller层接收前端传递的数据，不过两者的应用场景不同。</p>
<p>@PathVariable主要用于接收<code>http://host:port/path/&#123;参数值&#125;数据</code>。@RequestParam主要用于接收 <code>http://host:port/path?参数名=参数值数据</code>，这里后面也可以不跟参数值。</p>
<p>@RequestParam和@PathVariable这两者之间区别不大，主要是请求的URL不一样</p>
<p>用@RequestParam请求接口时,URL是: <code>http://www.test.com/user/getUserById?userId=1</code></p>
<p>用@PathVariable请求接口时,URL是: <code>http://www.test.com/user/getUserById/2</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@PathVariable用法</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">test</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>String id)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//@RequestParam用法,注意这里请求后面没有添加参数</span></span></span><br><span class="line"><span class="function">@<span class="title">RequestMapping</span><span class="params">(value = <span class="string">&quot;/test&quot;</span>,method = RequestMethod.POST)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">test</span><span class="params">(<span class="meta">@RequestParam(value=&quot;id&quot;,required=false,defaultValue=&quot;0&quot;)</span>String id)</span> </span></span><br><span class="line"><span class="function">注意上面@RequestParam用法当中的参数。</span></span><br></pre></td></tr></table></figure>

<p>value表示接收数据的名称。required表示接收的参数值是否必须，默认为true，既默认参数必须不为空，当传递过来的参数可能为空的时候可以设置required=false。此外还有一个参数defaultValue 表示如果此次参数未空则为其设置一个默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;getUserById/&#123;userId&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span></span></span><br><span class="line"><span class="function">@<span class="title">RequestMapping</span><span class="params">(value=<span class="string">&quot;getUserById&quot;</span>,method = RequestMethod.GET)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getUserById</span><span class="params">(<span class="meta">@RequestParam</span> String userId)</span> </span></span><br></pre></td></tr></table></figure>

<p><strong>@PathVariable主要应用场景：不少应用为了实现RestFul的风格，采用@PathVariable这种方式。</strong></p>
<h4 id="测试-CookieValue"><a href="#测试-CookieValue" class="headerlink" title="测试@CookieValue"></a>测试@CookieValue</h4><p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getCar</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable(&quot;username&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestHeader</span> Map&lt;String,String&gt; header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam(&quot;inters&quot;)</span> List&lt;String&gt; inters,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@RequestParam</span> Map&lt;String,String&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@CookieValue(&quot;_ga&quot;)</span> Cookie cookie</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">        map.put(<span class="string">&quot;inters&quot;</span>,inters);</span><br><span class="line">        map.put(<span class="string">&quot;params&quot;</span>,params);</span><br><span class="line">        map.put(<span class="string">&quot;_ga&quot;</span>,_ga);</span><br><span class="line">        System.out.println(cookie.getName()+<span class="string">&quot;===&gt;&quot;</span>+cookie.getValue());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323221741149.png" alt="image-20210323221741149"></p>
<h4 id="测试-RequestBody"><a href="#测试-RequestBody" class="headerlink" title="测试@RequestBody"></a>测试@RequestBody</h4><p>前端：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/save&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    测试@RequestBody获取数据 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>,content);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323221910743.png" alt="image-20210323221910743"></p>
<p>输入 apple 123</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210323221930129.png" alt="image-20210323221930129"></p>
<h4 id="测试-RequestAttribute和-SessionAttribute"><a href="#测试-RequestAttribute和-SessionAttribute" class="headerlink" title="测试@RequestAttribute和@SessionAttribute"></a>测试@RequestAttribute和@SessionAttribute</h4><p>新建一个项目<code>AttributeTest</code>,加入所需的<code>jar</code>文件,示例代码如下:</p>
<ul>
<li>index.jsp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;</span><br><span class="line">	pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;@RequestAttribute和@SessionAttribute测试&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h2&gt;@RequestAttribute和@SessionAttribute测试&lt;&#x2F;h2&gt;</span><br><span class="line">	&lt;a href&#x3D;&quot;attrbuteTest&quot;&gt;测试@RequestAttribute和@SessionAttribute&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<ul>
<li>AttributeController.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping(value = &quot;/attrbuteTest&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">attrbuteTest</span><span class="params">(ModelAndView mv)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;attributeTest方法被调用...&quot;</span>);</span><br><span class="line">		<span class="comment">// 客户端重定向到main请求，会被自定义过滤器拦截</span></span><br><span class="line">		mv.setViewName(<span class="string">&quot;redirect:main&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 该方法映射的请求为/main</span></span><br><span class="line"><span class="comment">	 * @RequestAttribute(&quot;name&quot;) String</span></span><br><span class="line"><span class="comment">	 * name会获取request作用范围中名为&quot;name&quot;的属性的值赋给方法的参数name</span></span><br><span class="line"><span class="comment">	 * @SessionAttribute(&quot;sex&quot;) String sex会获取session作用范围中名为&quot;sex&quot;的属性的值赋给方法的参数sex</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/main&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(<span class="meta">@RequestAttribute(&quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@SessionAttribute(&quot;sex&quot;)</span> String sex)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法被调用...&quot;</span>);</span><br><span class="line">		<span class="comment">// 输出@RequestAttribute获得的name</span></span><br><span class="line">		System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">		<span class="comment">// 输出@SessionAttribute获得的sex</span></span><br><span class="line">		System.out.println(<span class="string">&quot;sex: &quot;</span> + sex);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attributeTest</code>方法处理请求后重定向到<code>main</code>请求,<code>main</code>请求会被自定义过滤器拦截,在过滤器中会分别设置两个属性到<code>request</code>作用域和<code>session</code>作用域。在<code>main</code>方法中使用<code>@RequestAttribute</code>和<code>@SessionAttribute</code>进行赋值</p>
<ul>
<li>TestAttributeFilter.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fkit.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器拦截/main请求</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAttributeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;进入AuthFilter过滤器的doFilter方法&quot;</span>);</span><br><span class="line">		<span class="comment">// 将ServletRequest对象强转成HttpServletRequest对象</span></span><br><span class="line">		HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">		<span class="comment">// 在request作用范围域中设置一个name属性</span></span><br><span class="line">		httpRequest.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">		<span class="comment">// 在session作用范围域中设置一个sex属性</span></span><br><span class="line">		httpRequest.getSession().setAttribute(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">		<span class="comment">// 如果还有过滤器执行过滤器，否则进入请求处理方法</span></span><br><span class="line">		chain.doFilter(httpRequest, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestAttributeFilter</code>过滤器拦截<code>&quot;main&quot;</code>请求,在<code>dofilter</code>方法中分别设置两个属性到<code>request</code>作用域和<code>session</code>作用域。<br>部署<code>AttributeTest</code>这个<code>Web</code>应用,在浏览器中输入如下<code>URL</code>来测试应用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;AttributeTest&#x2F;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>单击测试<code>@RequestAttribute和@SessionAttribute&quot;</code>超链接发送请求,将调用<code>attrbuteTest</code>方法,然后经过过滤器,重定向到<code>main</code>方法,控制台输出结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attributeTest方法被调用...</span><br><span class="line">进入AuthFilter过滤器的doFilter方法</span><br><span class="line">main方法被调用...</span><br><span class="line">name: 小明</span><br><span class="line">sex: 男</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>浏览器显示内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:小明</span><br><span class="line">sex:男</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>可以看到, <code>request</code>作用域中的<code>name</code>的值被传递到请求处理方法<code>main</code>的<code>name</code>变量, <code>session</code>作用域中的<code>sex</code>的值被传递到请求处理方法<code>main</code>的<code>sex</code>变量,并输出打印在控制台。</p>
<h4 id="GetMapping、-PostMapping和-RequestMapping的区别"><a href="#GetMapping、-PostMapping和-RequestMapping的区别" class="headerlink" title="@GetMapping、@PostMapping和@RequestMapping的区别"></a>@GetMapping、@PostMapping和@RequestMapping的区别</h4><ul>
<li><p><mark>@GetMapping</mark></p>
<p>用于将HTTP GET请求映射到特定处理程序方法的注释。具体来说，@GetMapping是一个作为快捷方式的组合注释<br>是@RequestMapping(method = RequestMethod.GET)的缩写</p>
</li>
</ul>
<ul>
<li><p><mark>@PostMapping</mark></p>
<p>用于将HTTP POST请求映射到特定处理程序方法的注释。具体来说，@PostMapping是一个作为快捷方式的组合注释</p>
<p>是@RequestMapping(method = RequestMethod.POST)的缩写</p>
</li>
</ul>
<ul>
<li><mark>@RequestMapping</mark><br>一般情况下都是用@RequestMapping（method=RequestMethod.），因为@RequestMapping可以直接替代以上两个注解，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！</li>
</ul>
<p>类似的组合注解还有：<br>@PutMapping、@DeleteMapping、@PatchMapping</p>
<p>总结下来就是@PostMapping和@GetMapping都可以用@RequestMapping代替，如果读者怕在映射的时候出错，可以统一写@RequestMapping，当然这样写的话也有弊端，笼统的全用@RequestMapping, 不便于其他人对代码的阅读和理解！</p>
<h1 id="视图解析-hymeleaf"><a href="#视图解析-hymeleaf" class="headerlink" title="视图解析 - hymeleaf"></a>视图解析 - hymeleaf</h1><p>由于我们的SpringBoot默认不支持<strong>JSP</strong>，因此就需要引入<strong>第三方模板引擎技术</strong>去实现我们的页面渲染</p>
<ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自动配置Thymeleaf"><a href="#自动配置Thymeleaf" class="headerlink" title="自动配置Thymeleaf"></a>自动配置Thymeleaf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThymeleafProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动配置策略：</p>
<ol>
<li>所有thymeleaf的配置值都在 ThymeleafProperties</li>
<li>配置好了 <strong>SpringTemplateEngine</strong></li>
<li>配好了 <strong>ThymeleafViewResolver</strong></li>
<li>我们只需要直接开发页面</li>
</ol>
<p>我们开发的页面放在哪里呢？我们根据源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">&quot;classpath:/templates/&quot;</span>;<span class="comment">//模板放置处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">&quot;.html&quot;</span>;<span class="comment">//文件的后缀名</span></span><br></pre></td></tr></table></figure>

<p>得知，需要构造一个tempplates包，文件后缀为html</p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>下面来感受一下；</p>
<p>前端页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>nice<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;link&#125;&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.google.com&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/link&#125;&quot;</span>&gt;</span>去google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写一个控制层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//model中的数据会被放在请求域中 request.setAttribute(&quot;a&quot;,aa)</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;link&quot;</span>,<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210324212509079.png" alt="image-20210324212509079"></p>
<h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><table>
<thead>
<tr>
<th>表达式名字</th>
<th>语法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>变量取值</td>
<td>${…}</td>
<td>获取请求域、session域、对象等值</td>
</tr>
<tr>
<td>选择变量</td>
<td>*{…}</td>
<td>获取上下文对象值</td>
</tr>
<tr>
<td>消息</td>
<td>#{…}</td>
<td>获取国际化等值</td>
</tr>
<tr>
<td>链接</td>
<td>@{…}</td>
<td>生成链接</td>
</tr>
<tr>
<td>片段表达式</td>
<td>~{…}</td>
<td>jsp:include 作用，引入公共页面片段</td>
</tr>
</tbody></table>
<h3 id="设置属性-th：attr"><a href="#设置属性-th：attr" class="headerlink" title="设置属性 - th：attr"></a>设置属性 - th：attr</h3><ul>
<li><p>设置单个值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;subscribe.html&quot;</span> <span class="attr">th:attr</span>=<span class="string">&quot;action=@&#123;/subscribe&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Subscribe!&quot;</span> <span class="attr">th:attr</span>=<span class="string">&quot;value=#&#123;subscribe.submit&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置多个值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../images/gtvglogo.png&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">th:attr</span>=<span class="string">&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;prod : $&#123;prods&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.price&#125;&quot;</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;prod,iterStat : $&#123;prods&#125;&quot;</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.price&#125;&quot;</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;comments.html&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">th:href</span>=<span class="string">&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>User is an administrator<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;#&#123;roles.manager&#125;&quot;</span>&gt;</span>User is a manager<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>User is some other thing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="WEB实验开发"><a href="#WEB实验开发" class="headerlink" title="WEB实验开发"></a>WEB实验开发</h1><h2 id="基本功能实现"><a href="#基本功能实现" class="headerlink" title="基本功能实现"></a>基本功能实现</h2><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><ul>
<li><code>/static</code> 放置 css，js等静态资源</li>
<li><code>/templates/login.html</code> 登录页</li>
</ul>
<p>前端页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="comment">&lt;!-- 要加这玩意thymeleaf才能用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-signin&quot;</span> <span class="attr">action</span>=<span class="string">&quot;index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 消息提醒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;User ID&quot;</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-lg btn-login btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-check&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>主页的位置：/templates/main.html</li>
</ul>
<p>Thymeleaf的行内写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, [[$&#123;session.user.name&#125;]]!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="登录控制层"><a href="#登录控制层" class="headerlink" title="登录控制层"></a>登录控制层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 来登录页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &#123;&quot;/&quot;,&quot;/login&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loginPage</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(User user, HttpSession session, Model model)</span></span>&#123; <span class="comment">//RedirectAttributes</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasLength(user.getUserName()) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.getPassword()))&#123;</span><br><span class="line">            <span class="comment">//把登陆成功的用户保存起来</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,user);</span><br><span class="line">            <span class="comment">//登录成功重定向到main.html;  重定向防止表单重复提交</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;账号密码错误&quot;</span>);</span><br><span class="line">            <span class="comment">//回到登录页面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去main页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/main.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">mainPage</span><span class="params">(HttpSession session, Model model)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最好用拦截器,过滤器</span></span><br><span class="line">        Object loginUser = session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(loginUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//session过期，没有登陆过</span></span><br><span class="line">        	<span class="comment">//回到登录页面</span></span><br><span class="line">	        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请重新登录&quot;</span>);</span><br><span class="line">    	    <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><h2 id="数据库场景自动配置与整合"><a href="#数据库场景自动配置与整合" class="headerlink" title="数据库场景自动配置与整合"></a>数据库场景自动配置与整合</h2><h3 id="导入JDBC"><a href="#导入JDBC" class="headerlink" title="导入JDBC"></a>导入JDBC</h3><ul>
<li><p>JDBC依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>在这个包（<code>spring-boot-starter-data-jdbc</code>)中，我们导入了：</p>
<ol>
<li><p>spring-jdbc的包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>springboot-starter的包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>而在starter包中，引入三个重要的包：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1606366100317-5e0199fa-6709-4d32-bce3-bb262e2e5e6a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_YXRndWlndS5jb20g5bCa56GF6LC3%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="image.png"></p>
<p>然而我们发现，并没有我们之前去做JDBC必导的一个包——数据库驱动的包；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>为什么呢？因为官方让我们进行自行选择要连接的数据库；</p>
<p>下面我们以Mysql为例：</p>
<ul>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认版本 这是springboot版本仲裁后的版本：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不需要我们写版本 但假如写了 就会替换成写了的版本--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;version&gt;5.1.49&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">想要修改版本</span></span><br><span class="line"><span class="comment">1、直接依赖引入具体版本（maven的就近依赖原则）</span></span><br><span class="line"><span class="comment">2、重新声明版本（maven的属性的就近优先原则）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="分析自动配置"><a href="#分析自动配置" class="headerlink" title="分析自动配置"></a>分析自动配置</h3><h4 id="自动配置的类"><a href="#自动配置的类" class="headerlink" title="自动配置的类"></a>自动配置的类</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210325204624373.png" alt="image-20210325204624373"></p>
<ul>
<li><p><code>DataSourceAutoConfiguration</code>： 数据源的自动配置。</p>
<ul>
<li><p>修改数据源相关的配置 → 修改<code>spring.datasource</code>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.datasource&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库连接池的配置，是自己容器中没有DataSource才自动配置的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;DataSource.class, XADataSource.class&#125;)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PooledDataSourceConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>底层配置好的连接池是：<code>HikariDataSource</code>。</p>
</li>
</ul>
</li>
<li><p><code>DataSourceTransactionManagerAutoConfiguration</code>： 事务管理器的自动配置。</p>
</li>
<li><p><code>JdbcTemplateAutoConfiguration</code>： JdbcTemplate的自动配置，可以来对数据库进行CRUD。</p>
<ul>
<li><p>可以修改这个配置项<strong>@ConfigurationProperties(prefix = “spring.jdbc”)</strong> 来修改JdbcTemplate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.jdbc&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>JdbcTemplateConfiguration</code>类中放置了一个<code>JdbcTemplate</code>对象，该对象操作的是参数中的数据源，相关的设置可以在properties中修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function">JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource, JdbcProperties properties)</span> </span>&#123;</span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    Template template = properties.getTemplate();</span><br><span class="line">    jdbcTemplate.setFetchSize(template.getFetchSize());</span><br><span class="line">    jdbcTemplate.setMaxRows(template.getMaxRows());</span><br><span class="line">    <span class="keyword">if</span> (template.getQueryTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jdbcTemplate.setQueryTimeout((<span class="keyword">int</span>)template.getQueryTimeout().getSeconds());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>修改的方式：（设置了一个请求超时的时间）</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">query-timeout:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>JndiDataSourceAutoConfiguration</code>： JNDI的自动配置</p>
</li>
<li><p><code>XADataSourceAutoConfiguration</code>： 分布式事务相关的。</p>
</li>
</ul>
<h3 id="修改配置项"><a href="#修改配置项" class="headerlink" title="修改配置项"></a>修改配置项</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<h4 id="单元测试数据源"><a href="#单元测试数据源" class="headerlink" title="单元测试数据源"></a>单元测试数据源</h4><ul>
<li>Spring容器中有这个JdbcTemplate组件，使用@Autowired注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boot05WebAdminApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//用@org.junit.Test会报空指针异常，可能跟JUnit新版本有关</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)</span></span><br><span class="line"><span class="comment">//        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)</span></span><br><span class="line">        Long aLong = jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account_tbl&quot;</span>, Long.class);</span><br><span class="line">        log.info(<span class="string">&quot;记录总数：&#123;&#125;&quot;</span>,aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210325212829364.png" alt="image-20210325212829364"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210325212817558.png" alt="image-20210325212817558"></p>
<h2 id="Druid数据库连接池"><a href="#Druid数据库连接池" class="headerlink" title="Druid数据库连接池"></a>Druid数据库连接池</h2><p>虽然Springboot帮我们配置了数据源：HikariDataSource，但我们有时候就是想用Druid，那该怎么办呢？</p>
<p>（ps：有自定义配置方式，也就是不用starter的，但是那个之后再学习吧~）</p>
<ul>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="分析自动配置-1"><a href="#分析自动配置-1" class="headerlink" title="分析自动配置"></a>分析自动配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DruidDataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidSpringAopConfiguration.class, DruidStatViewServletConfiguration.class, DruidWebStatFilterConfiguration.class, DruidFilterConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceAutoConfigure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DruidDataSourceAutoConfigure.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DruidDataSourceAutoConfigure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(</span></span><br><span class="line"><span class="meta">        initMethod = &quot;init&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Init DruidDataSource&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSourceWrapper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="java"><span class="meta">@ConditionalOnClass</span>(&#123;DruidDataSource<span class="class">.<span class="keyword">class</span>&#125;)</span>
<span class="class">&lt;!--<span class="title">code</span>￼143--&gt;</span>
<span class="class"></span>
<span class="class">确保<span class="title">Druid</span>自动配置类的加载是在`<span class="title">DataSourceAutoConfiguration</span>`（大的自动配置类)配置前进行加载</span>
<span class="class"></span>
<span class="class">为什么是之前？</span>
<span class="class"></span>
<span class="class">因为我们<span class="title">Springboot</span>会先导入默认的<span class="title">Hikari</span>数据源，而这么做的后果就是：</span>
<span class="class"></span>
<span class="class">&lt;!--<span class="title">code</span>￼144--&gt;</span>
<span class="class">这个`@<span class="title">ConditionalOnMissingBean</span>`注解就不会生效了，进而导致我们的数据源不会进行配置啦！</span></code></pre>
</li>
<li><pre><code class="java"><span class="meta">@EnableConfigurationProperties</span>(&#123;DruidStatProperties<span class="class">.<span class="keyword">class</span>, <span class="title">DataSourceProperties</span>.<span class="title">class</span>&#125;)</span>
<span class="class">&lt;!--<span class="title">code</span>￼145--&gt;</span>
<span class="class"></span>
<span class="class"></span>
<span class="class"></span></code></pre>
</li>
</ul>
<ul>
<li><pre><code class="java"><span class="meta">@Import</span>(&#123;DruidSpringAopConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">DruidStatViewServletConfiguration</span>.<span class="title">class</span>, <span class="title">DruidWebStatFilterConfiguration</span>.<span class="title">class</span>, <span class="title">DruidFilterConfiguration</span>.<span class="title">class</span>&#125;)</span>
<span class="class">&lt;!--<span class="title">code</span>￼146--&gt;</span>
<span class="class"></span></code></pre>
</li>
</ul>
<h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>我们根据<strong>@EnableConfigurationProperties</strong> 和 <strong>@Import</strong>知道了Druid的属性与配置文件的哪些属性进行绑定了，接下来我们就能够自己去配置文件中修改属性了。下面就来试试</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">aop-patterns:</span> <span class="string">com.atguigu.admin.*</span>  <span class="comment">#监控SpringBean</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span>     <span class="comment"># 底层开启功能，stat（sql监控），wall（防火墙）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">stat-view-servlet:</span>   <span class="comment"># 配置监控页功能</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">resetEnable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">web-stat-filter:</span>  <span class="comment"># 监控web</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">urlPattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span>    <span class="comment"># 对上面filters里面的stat的详细配置</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">1000</span></span><br><span class="line">          <span class="attr">logSlowSql:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">wall:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">drop-table-allow:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><ul>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ps：从配置文件可以看出来这个starter是第三方的，怎么看出来的呢？</p>
<p>Springboot的starter：<code>spring-boot-starter-*</code></p>
<p>第三方的starter：<code>*-spring-boot-starter</code></p>
</li>
</ul>
<h3 id="整合Mybatis-配置版"><a href="#整合Mybatis-配置版" class="headerlink" title="整合Mybatis-配置版"></a>整合Mybatis-配置版</h3><p>回想一下之前学习SSM的时候Mybatis使用步骤:</p>
<ol>
<li>配置一个全局的配置文件</li>
<li>写接口</li>
<li>创建SqlSessionFactory</li>
<li>调用第三步创建SqlSession</li>
<li>通过SqlSession获取mapper</li>
<li>调用mapper方法</li>
</ol>
<p>现在进化了，使用了SpringBoot又该如何去实现呢？</p>
<p>Mybatis的自动配置功能将将SqlSessionFacrory自动配置好，注入到Bean中了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>

<p>而SqlSession也自动配置了<strong>SqlSessionTemplate 组合了SqlSession</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">return</span> executorType != <span class="keyword">null</span> ? <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个类中存在SqlSessionProxy - 真正CRUD的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Mapper扫描包的配置文件中，我们关注第二个注解：<code>@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span></span><br></pre></td></tr></table></figure>

<p>这个<code>AutoConfiguredMapperScannerRegistrar</code>是有什么用的呢？</p>
<p>在这个类中有一个方法，大意就是扫描全部带有<mark>@Mapper</mark>注解的接口，然后认为是用于操作Mybatis的接口；</p>
<p>因此，只要我们写的操作Mybatis的接口标注了<strong>@Mapper</strong>就会被自动扫描进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        MybatisAutoConfiguration.logger.debug(<span class="string">&quot;Searching for mappers annotated with @Mapper&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接着，我们就权当复习一下Mybatis，进行一下Mybatis的CRUD；</p>
<ol>
<li><p>首先创建bean：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210326170125809.png" alt></p>
</li>
<li><p>接着创建接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAcct</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写映射文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.admin.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    public Account getAcct(Long id); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAcct&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.admin.bean.Account&quot;</span>&gt;</span></span><br><span class="line">        select * from  account_tbl where  id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210326170125809.png" alt="image-20210326170125809"></p>
</li>
<li><p>接着：我们看看Mybatis的自动配置类，就可以知道我们接下来要干什么了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span> ： MyBatis配置项绑定类。</span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们找到了<code>@ConfigurationProperties(prefix = &quot;mybatis&quot;)</code>这条关键信息；</p>
<p>得知，我们可以通过修改配置文件以<mark>mybatis</mark>开头的属性了；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 1234</span><br><span class="line">    url: jdbc:mysql://localhost:3306/my</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># 配置mybatis规则</span><br><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml  #全局配置文件位置</span><br><span class="line">  mapper-locations: classpath:mybatis/*.xml  #sql映射文件位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置文件：mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 由于Spring Boot自动配置缘故，此处不必配置，只用来做做样。--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Service层和Controller层：</p>
<ol>
<li><p>Service层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Account <span class="title">getAcctByid</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAcctByid</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.getAcct(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Controller层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/acct&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Account <span class="title">getById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.getAcctByid(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>同时我们可以知道一点：</p>
<p>配置private Configuration configuration; 也就是配置mybatis.configuration相关的，就是相当于改mybatis全局配置文件中的值。（也就是说配置了mybatis.configuration，就不需配置mybatis全局配置文件了）<br>因此，对于mybatis的配置文件我们也可以写成：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 可以不写全局配置文件，所有全局配置文件的配置都放在configuration配置项中了。</span></span><br><span class="line">  <span class="comment"># config-location: classpath:mybatis/mybatis-config.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="整合Mybatis-注解配置混合版"><a href="#整合Mybatis-注解配置混合版" class="headerlink" title="整合Mybatis - 注解配置混合版"></a>整合Mybatis - 注解配置混合版</h3><h4 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h4><ul>
<li><p>首先还是得已进入Mybatis的Starter：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> city (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">state <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">country <span class="built_in">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="纯注解版本"><a href="#纯注解版本" class="headerlink" title="纯注解版本"></a>纯注解版本</h4><p>如果采用这种方式，就不用编写xml；</p>
<ul>
<li>Mapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into  city(`name`,`state`,`country`) values(#&#123;name&#125;,#&#123;state&#125;,#&#123;country&#125;)&quot;)</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Service和Controller层</p>
<ul>
<li><p>Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function">City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">saveCity</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityServiceImpl</span> <span class="keyword">implements</span> <span class="title">CityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CityMapper cityMapper;</span><br><span class="line"></span><br><span class="line">    Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityServiceImpl</span><span class="params">(MeterRegistry meterRegistry)</span></span>&#123;</span><br><span class="line">        counter = meterRegistry.counter(<span class="string">&quot;cityService.saveCity.count&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cityMapper.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveCity</span><span class="params">(City city)</span> </span>&#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">        cityMapper.insert(city);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/city&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> City <span class="title">saveCity</span><span class="params">(City city)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cityService.saveCity(city);</span><br><span class="line">    <span class="keyword">return</span> city;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/city&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> City <span class="title">getCityById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cityService.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="混合版本"><a href="#混合版本" class="headerlink" title="混合版本"></a>混合版本</h4><ul>
<li>配置文件：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.admin.mapper.CityMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    public void insert(City city);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into  city(`name`,`state`,`country`) values(#&#123;name&#125;,#&#123;state&#125;,#&#123;country&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>mapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件中有方法了，因此不需要用注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(City city)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>简单DAO方法就写在注解上。复杂的就写在配置文件里。</p>
</li>
<li><p>使用<code>@MapperScan(&quot;com.lun.boot.mapper&quot;)</code> 简化，Mapper接口就可以不用标注<code>@Mapper</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.hpg.admin.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot05WebAdminApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Boot05WebAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="整合Mybatis-Plus"><a href="#整合Mybatis-Plus" class="headerlink" title="整合Mybatis-Plus"></a>整合Mybatis-Plus</h1><ul>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--会帮我们引入jdbc和mybatis的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引入了starter，按照惯例，接下来就是分析下到底配置了些什么内容：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;MybatisPlusProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisPlusLanguageDriverAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span></span><br></pre></td></tr></table></figure>

<p>经典的<code>@EnableConfigurationProperties(&#123;MybatisPlusProperties.class&#125;)</code>，由这个注解可以知道和哪个前缀进行绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;mybatis-plus&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusProperties</span></span></span><br></pre></td></tr></table></figure>

<p>答案是和<strong>mybatis-plus</strong>；这样子 以后写 mybatis-plus： xxx 就是对mybatis-plus的定制了</p>
<p>接着是<strong>SqlSessionFacoty</strong>，从类也可以看出来 是自动配置好的（代码是在太多了 就不全部截取）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MybatisSqlSessionFactoryBean factory = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">    <span class="comment">//这一步 就是进行了数据源的绑定</span></span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//后面的代码还进行了很多配置的绑定</span></span><br></pre></td></tr></table></figure>



<p>同时我们还注意到mybatisPlusProperties中有个属性：<code>mapperLocations</code> 翻译过来就是mapper的路径，它也是自动配置好的，有一个默认值：<code>classpath*:/mapper/**/*.xml</code>；</p>
<p>这表示：<strong>任意包</strong>的类路径下的<strong>所有mapper文件夹</strong>下任意路径下的<strong>所有xml</strong>都是<mark>sql映射文件</mark>（有点绕，但是如果理解了**表示什么应该还是很好理解）</p>
<p>再然后是<strong>sqlSessionTemplate</strong>，也自动配置好了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">return</span> executorType != <span class="keyword">null</span> ? <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后是注册类，表示着带<mark>@Mapper</mark>注解标注的接口会被自动扫描（当然建议使用@MaaperScan进行批量包扫描）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">        MybatisPlusAutoConfiguration.logger.debug(<span class="string">&quot;Searching for mappers annotated with @Mapper&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>MybatisPlus有一个很好的优点：Mapper接口只需要继承MybatisPlus的<strong>BaseMapper</strong>接口即可自动拥有<mark>CRUD</mark>的功能；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><ul>
<li>我们的bean类对应的是数据库哪张表呢？我们可以通过MyBatis给我们提供的@TableName注解去指定表；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user_tbl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Mapper层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service层：</p>
<ul>
<li><p>首先是接口 继承了MybatisPlus的IService接口，泛型是返回的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后是接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>,<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//不用写 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUserMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    log.info(<span class="string">&quot;用户信息：&#123;&#125;&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/21/SpringBoot/" data-id="ckppikuet0033p0wibhsyfy8d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SSM整合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" class="article-date">
  <time datetime="2021-03-18T14:26:02.754Z" itemprop="datePublished">2021-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>服务器开发分为三层：表现层 + 业务层 + 持久层</p>
</li>
<li><p>整合的桥梁或者说是方式，我们使用：XML（配置文件）+ 注解的方式</p>
</li>
</ul>
<p>整合的整体思路：</p>
<ol>
<li>搭建整合的环境（引入依赖，创建包，创建实体类）</li>
<li>先搭建好Spring</li>
<li>Spring整合SpringMVC</li>
<li>Spring整合MyBatis</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318205124357.png" alt="image-20210318205124357"></p>
<p>包结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318210741556.png" alt="image-20210318210741556"></p>
<h1 id="搭建整合环境"><a href="#搭建整合环境" class="headerlink" title="搭建整合环境"></a>搭建整合环境</h1><h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> ssm;</span><br><span class="line"><span class="keyword">use</span> ssm;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(Integer id, String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 帐户dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有账户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存帐户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Serivice层"><a href="#Serivice层" class="headerlink" title="Serivice层"></a>Serivice层</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318210831320.png" alt="image-20210318210831320"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有账户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存帐户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：查询所有账户...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：保存帐户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spring搭建"><a href="#Spring搭建" class="headerlink" title="Spring搭建"></a>Spring搭建</h1><ul>
<li>在Spring层，我们要进行<strong>业务</strong>的处理</li>
</ul>
<ol>
<li><p>创建好配置文件</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318211034573.png" alt="image-20210318211034573"></p>
</li>
<li><p>完成配置文件</p>
<ol>
<li><p>开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在Serivice层的类上加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对象</span></span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        as.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318222226498.png" alt="image-20210318222226498"></p>
<h1 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h1><h2 id="搭建测试SpringMVC的开发环境"><a href="#搭建测试SpringMVC的开发环境" class="headerlink" title="搭建测试SpringMVC的开发环境"></a>搭建测试SpringMVC的开发环境</h2><ol>
<li><p>web.xml中配置<code>DispatcherServlet</code>前端控制器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--加载springmvc.xml配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--启动服务器，创建该servlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置解决中文乱码的过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--解决中文乱码的过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建springmvc.xml </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318214209343.png" alt="image-20210318214209343"></p>
</li>
<li><p>添加约束</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解扫描，只扫描Controller注解 与Spring的注解反过来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置视图解析器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置的视图解析器对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤静态资源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--过滤静态资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启注解</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启SpringMVC注解的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>测试：</li>
</ul>
<ol>
<li><p>控制层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 帐户web</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>index.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;account/findAll&quot;&gt;测试查询&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>list.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;查询所有的帐户&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318215832607.png" alt="image-20210318215832607"></p>
</li>
</ol>
<h2 id="实现整合"><a href="#实现整合" class="headerlink" title="实现整合"></a>实现整合</h2><p>问题：</p>
<p>我们知道，SpringMVC现在的配置是只扫描Controller注解，而别的注解不扫，这就导致一个问题，我们的Spring的配置文件：<code>applicationContext.xml</code>是没有被加载的，因此里面的扫描也不会生效，那我们的service层就是个摆设，根本没有被加载到IOC容器中，就没办法注入了。</p>
<p>解决：</p>
<p>启动容器的时候就得把<strong>Spring</strong>的配置文件给加载了才行；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318221747580.png" alt="image-20210318221747580"></p>
<p>下面我们就要在web.xml中做以下两件事：</p>
<ol>
<li><p>配置Spring的监听器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置配置文件的路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>此时我们的Controller层就可以做到Service的注入了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        List&lt;Account&gt; list = accountService.findAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318222140952.png" alt="image-20210318222140952"></p>
<h1 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h1><h2 id="搭建测试MyBatis环境"><a href="#搭建测试MyBatis环境" class="headerlink" title="搭建测试MyBatis环境"></a>搭建测试MyBatis环境</h2><p>ps：配置文件找不到的处理方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>dao接口上加注解，进行映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 帐户dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有账户</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from account&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写sql配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.itcast.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建SqlSessionFactory对象</span></span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">    <span class="comment">// 创建SqlSession对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">// 获取到代理对象</span></span><br><span class="line">    AccountDao dao = session.getMapper(AccountDao.class);</span><br><span class="line">    <span class="comment">// 查询所有数据</span></span><br><span class="line">    List&lt;Account&gt; list = dao.findAll();</span><br><span class="line">    <span class="keyword">for</span>(Account account : list)&#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319202414601.png" alt="image-20210319202414601"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319202613009.png" alt="image-20210319202613009"></p>
<h2 id="Spring整合Mybatis实现"><a href="#Spring整合Mybatis实现" class="headerlink" title="Spring整合Mybatis实现"></a>Spring整合Mybatis实现</h2><ul>
<li>思路：通过让Spring框架接管Mybatis中的<strong>SqlSessionFactory工厂</strong>的创建，再通过读取<strong>mapper</strong>配置内容去创建<strong>dao的代理对象实现类</strong>，将它们（SqlSessionFactory工厂和代理对象）存入<mark>IOC容器</mark></li>
</ul>
<h3 id="Mybatis交由Spring托管"><a href="#Mybatis交由Spring托管" class="headerlink" title="Mybatis交由Spring托管"></a>Mybatis交由Spring托管</h3><p>分为三步：配置连接池、配置SqlSessionFactory工厂、配置接口所在的包</p>
<ol>
<li><p>配置连接池</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?userSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置SqlSessionFactory工厂</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置接口所在包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AccountDao接口所在包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上三步的作用：以后我们的SqlSessionFactory就将会由IOC容器帮助我们创建，接着就可以创建SqlSession，从而得到我们的mapper代理对象，并且这些对象全都在IOC容器中，意味着什么呢？就可以实现我们的<strong>依赖注入</strong>了</p>
<p>接下来就来测试一下：</p>
<ol>
<li><p>在AccountDao接口上添加<mark>@Repository</mark>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Serivice的实现类中，依赖注入我们的Dao类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：查询所有账户...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层：保存帐户...&quot;</span>);</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Controller层 增加一个视图封装数据部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表现层：查询所有账户...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用service的方法</span></span><br><span class="line">        List&lt;Account&gt; list = accountService.findAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;查询所有的帐户&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;list&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;account&quot;</span>&gt;</span><br><span class="line">        $&#123;account.name&#125;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试（这是我已经把sq配置文件删除后的，也就代表着mybatis的xml配置部分已经完全交由Spring托管了）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319205301055.png" alt="image-20210319205301055"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319205134009.png" alt="image-20210319205134009"></p>
</li>
</ol>
<h3 id="引入事务"><a href="#引入事务" class="headerlink" title="引入事务"></a>引入事务</h3><p>然而框架尚未完全整合完：我们的整合还差最后一步——那就是引入事务的控制</p>
<p>配置Spring框架声明式事务管理分为三步：配置事务管理器、配置事务通知、配置AOP增强</p>
<ol>
<li><p>配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置事务通知</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置AOP增强（切入点选择的是Service层）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* cn.itcast.service.impl.*ServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>测试一下：</p>
<ol>
<li><p>前端页面加入保存方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/findAll&quot;</span>&gt;</span>测试查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>测试包<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;account/save&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Controller层加入save方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    accountService.saveAccount(account);</span><br><span class="line">    response.sendRedirect(request.getContextPath()+<span class="string">&quot;/account/findAll&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：我们加入一个 姓名Test 金额100的用户</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319210932389.png" alt="image-20210319210932389"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319210941997.png" alt="image-20210319210941997"></p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210319210948522.png" alt="image-20210319210948522"></p>
<p>至此，我们成功整合了SSM框架啦！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/" data-id="ckppikudj000ap0wi1jechx4x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringMVC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/14/SpringMVC/" class="article-date">
  <time datetime="2021-03-14T09:46:13.464Z" itemprop="datePublished">2021-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/14/SpringMVC/">SpringMVC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h1><ul>
<li><p>MVC- Model - View - Controller的简写。是一种<strong>软件设计规范</strong></p>
</li>
<li><p>是将业务逻辑、数据、显示分离的方法来组织代码。</p>
</li>
<li><p>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</p>
</li>
<li><p>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</p>
</li>
</ul>
<p><strong>Model（模型）</strong>： 数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）</strong>：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）</strong>：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313170954275.png" alt="image-20210313170954275"></p>
<h2 id="Model1和Model2时代"><a href="#Model1和Model2时代" class="headerlink" title="Model1和Model2时代"></a>Model1和Model2时代</h2><h3 id="Model1"><a href="#Model1" class="headerlink" title="Model1"></a>Model1</h3><ul>
<li>在web早期的开发中，通常采用的都是Model1。</li>
<li>Model1中，主要分为两层，视图层和模型层。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719143141122.png" alt="在这里插入图片描述"></p>
<p>Model1优点：架构简单，比较适合小型项目开发；</p>
<p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p>
<h3 id="Model2时代"><a href="#Model2时代" class="headerlink" title="Model2时代"></a>Model2时代</h3><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型。</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719143141122.png" alt="在这里插入图片描述"></p>
<ol>
<li>用户发请求</li>
<li>Servlet接收请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到JSP，由JSP来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<ul>
<li><strong>职责分析：</strong></li>
</ul>
<p><strong>Controller：控制器</strong></p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<p><strong>Model：模型</strong></p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<p><strong>View：视图</strong></p>
<ol>
<li>显示页面</li>
</ol>
<p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。</p>
<p>Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p>
<h1 id="回顾Servlet"><a href="#回顾Servlet" class="headerlink" title="回顾Servlet"></a>回顾Servlet</h1><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写我们的hello.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;HPG&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Erii</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">3</span>/<span class="number">13</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">30</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;form action=<span class="string">&quot;/HelloServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;method&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>编写Servlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//取得参数</span></span><br><span class="line">        String method = req.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//业务逻辑</span></span><br><span class="line">        <span class="comment">//视图跳转</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/hello.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了在web.xml下注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.Servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--超时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--欢迎页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313175721621.png" alt="image-20210313175721621"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313175735643.png" alt="image-20210313175735643"></p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>SpringMVC的特点：</li>
</ul>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等…</p>
<h2 id="中央控制器"><a href="#中央控制器" class="headerlink" title="中央控制器"></a>中央控制器</h2><ul>
<li>Spring的web框架围绕<code>DispatcherServlet</code>设计。</li>
<li>DispatcherServlet的作用：是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</li>
<li><code>DispatcherServlet</code>的本质由下图我们也可以发现，其实就是个Servlet</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200719143231995.png" alt="在这里插入图片描述"></p>
<p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，<strong>DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)</strong>。</p>
<h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><p>相关blog：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hamawep789/p/10840774.html">https://www.cnblogs.com/hamawep789/p/10840774.html</a></p>
<h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1121080-20190509202147059-745656946.jpg" alt="img"></p>
<h3 id="springmvc工作流程"><a href="#springmvc工作流程" class="headerlink" title="springmvc工作流程"></a>springmvc工作流程</h3><p>1、 用户向服务端发送一次请求，这个请求会先到前端控制器<code>DispatcherServlet</code>(也叫中央控制器)。<br>2、<code>DispatcherServlet</code>接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、<code>DispatcherServlet</code>调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给<code>DispatcherServlet</code><br>5、<code>DispatcherServlet</code>将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、<code>DispatcherServlet</code>将模型数据填充到视图中<br>7、<code>DispatcherServlet</code>将结果响应给用户</p>
<h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ul>
<li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li>
<li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li>
<li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li>
<li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li>
<li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。</li>
</ul>
<h1 id="HelloSpringMVC"><a href="#HelloSpringMVC" class="headerlink" title="HelloSpringMVC"></a>HelloSpringMVC</h1><h2 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h2><p>下面试着来体验一下SpringMVC吧，首先来一个非注解版本的</p>
<p>目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313212544238.png" alt="image-20210313212544238"></p>
<ol>
<li><p>首先为该模块添加WEB支持 ofcourse</p>
</li>
<li><p>在pom.xml处配置好我们依赖（这一步一开始没弄，发现一直是404）</p>
</li>
<li><p>配置web.xml 进行我们的<code>DispatcherServlet</code>注册</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在上述配置文件中 我们有个<code>&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</code>，这个新的配置文件是我们所没有的，因此我们需要去配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册 <strong>处理映射器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理映射器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册 <strong>处理器适配器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--处理器适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册 <strong>视图解析器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Controller控制器，进行业务的控制。有两种实现方式：实现<code>Controller</code>接口，或是用注解去实现。我们这里选择前者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.erii.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装对象，放在ModelAndView中。Model</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMVC!&quot;</span>);</span><br><span class="line">        <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;hello&quot;</span>); <span class="comment">//: /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们需要将我们控制类交给SpringIOC容器，因此这一步就是注册bean了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.erii.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写需要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Erii</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">3</span>/<span class="number">13</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">49</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试环节</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313213204215.png" alt="image-20210313213204215"></p>
</li>
</ol>
<p>我们进行一个流程的分析吧：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210314173149351.png" alt="image-20210314173149351"></p>
<ol>
<li><p><strong><code>DispatcherServlet</code></strong>表示前端控制器，是整个SpringMVC的控制中心。用户发出请求，<strong><code>DispatcherServlet</code></strong>接收请求并拦截请求。</p>
<p>由于其本质就是个Servlet，我们就把他当做一个功能强化版本的Servlet即可；</p>
<ul>
<li>我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li>
<li><strong>如上url拆分成三部分：</strong></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a> ——&gt; <strong>服务器</strong>域名</li>
<li>SpringMVC ——&gt; 部署在服务器上的web<strong>站点</strong></li>
<li>hello ——&gt; 表示<strong>控制器Ccontroller</strong></li>
<li>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</li>
</ul>
</li>
<li><p><strong><code>HandlerMapping</code></strong> 为 处理器映射。<strong><code>DispatcherServlet</code></strong> 调用 <strong><code>HandlerMapping</code></strong>  ,根据请求url查找  <strong><code>Handler</code></strong>。</p>
</li>
<li><p><strong><code>HandlerExecution</code></strong>表示具体的<code>Handler</code>,其主要作用是根据<strong>url</strong>查找<strong>控制器</strong>，比如上述url被查找<strong>控制器</strong>为：<mark>hello</mark>。</p>
</li>
<li><p><strong><code>HandlerExecution</code></strong>将解析后的信息传递给<strong><code>DispatcherServlet</code></strong>,如解析控制器映射等。</p>
</li>
<li><p><strong><code>HandlerAdapter</code></strong>表示<strong>处理器适配器</strong>，其按照<mark>特定的规则去</mark>执行Handler。(特定的规则其实就是去找实现了Controller接口的控制器)</p>
</li>
<li><p><strong><code>Handler</code></strong>让具体的<strong>Controller</strong>执行。（上一步中，可能会适配到多个Contoller，在这步就会挑选具体的controller去执行请求）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.erii.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Controller</code></strong>将具体的执行信息返回给<strong><code>HandlerAdapter</code></strong>,如<strong><code>ModelAndView（模型和视图）</code></strong>。</p>
</li>
<li><p><strong><code>HandlerAdapter</code></strong>将视图逻辑名或模型传递给<strong><code>DispatcherServle</code>t</strong>。</p>
</li>
<li><p><strong><code>DispatcherServlet</code></strong>调用视图解析器<strong><code>(ViewResolver)</code></strong>来解析<strong><code>HandlerAdapter</code></strong>传递的逻辑视图名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>视图解析器将解析的逻辑视图名传给<strong><code>DispatcherServlet</code></strong>。</p>
</li>
<li><p><strong><code>DispatcherServlet</code></strong>根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>将数据渲染到视图上，将视图呈现给用户。</p>
</li>
</ol>
<h2 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h2><p>资源过滤问题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置springmvc文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/HelloController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实访问地址 : 项目名/HelloController/hello</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,SpringMVC&quot;</span>);</span><br><span class="line">        <span class="comment">//web-inf/jsp/hello.jsp 这里跳转的是jsp hello并不是个字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210314170733886.png" alt="image-20210314170733886"></p>
</li>
</ol>
<p>可以通俗的理解成两大步</p>
<ol>
<li>启动服务器，加载一些配置文件<ol>
<li><code>DispatcherServlet</code>对象创建</li>
<li><code>springmvc.xml</code>被加载</li>
<li><code>HelloController</code>创建成对象</li>
</ol>
</li>
<li>发送请求，后台处理请求，展示<ol>
<li>做了一定的选项操作</li>
<li>请求给到了<code>DispatcherServlet</code>(控制中心)</li>
<li>接着找到相应的@RequestMapping的方法，执行，包装模型，告诉<code>DispatcherServlet</code>下面转到哪个视图</li>
<li><code>DispatcherServlet</code>收到了响应，通知视图解析器，将视图解析；</li>
<li>视图解析器帮我我们进行跳转，页面显示，响应给<code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code>接收到页面，展示给用户</li>
</ol>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210314173500591.png" alt="image-20210314173500591"></p>
<h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h1><ul>
<li><p><strong>@RequestMapping</strong>作用：建立<code>请求URL</code>和<code>处理方法</code>之间的对应关系</p>
</li>
<li><p><strong>@RequestMapping</strong>的作用位置</p>
<ul>
<li><p>类上：表示第一级的访问目录（方便我们进行模块化的管理）</p>
</li>
<li><p>方法上：表示第二级的访问目录</p>
</li>
<li><p>路径可不写；</p>
</li>
<li><p>/表示应用的根目录开始</p>
</li>
<li><p>${pageContextt.request.contextPath}：这是JSP用于取得<strong>绝对路径</strong>的方法。</p>
<p>比如我的项目名称是demo1在浏览器中输入为：<code>http://localhost:8080/demo1/a.jsp</code>  </p>
<p>用<code>$&#123;pageContext.request.contextPath&#125;</code></p>
<p>或者<code>&lt;%=request.getContextPath()%&gt;</code></p>
<p>取出来的就是/demo1，而”/“代表的含义就是<code>http://localhost:8080</code></p>
<p>故有时候项目中这样写<strong>${pageContext.request.contextPath}/a.jsp</strong></p>
</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Controller(&quot;accountController&quot;)</span> </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span> <span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;查询了账户。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;查询了账户。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; 	</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>jsp：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line"> </span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;requestmapping 的使用&lt;/title&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 第一种访问方式 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">查询账户</span><br><span class="line"> </span><br><span class="line">&lt;/a&gt;</span><br><span class="line"> </span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;!-- 第二种访问方式 --&gt;</span><br><span class="line">&lt;a href=&quot;account/findAccount&quot;&gt;查询账户&lt;/a&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;!--注意:当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/，否则无法找到资源。--&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>@RequestMapping</strong>的属性</p>
<ul>
<li><p>path：指定请求路径</p>
</li>
<li><p>value：作用于path属性相同</p>
</li>
<li><p>method：制定该方法的请求方式</p>
</li>
<li><p>params：指定限制请求参数的条件，要求请求参数的 key 和 value 必须和 配置的一模一样。 </p>
<p>例如： params = {“accountName”}，表示请求参数必须有 accountName params = {“moeny!100”}，表示请求参数中 money 不能是 100。</p>
</li>
<li><p>headers：发送的请求中必须包含的请求头</p>
</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">控制器代码:</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存账户</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span> <span class="meta">@RequestMapping(value=&quot;/saveAccount&quot;,method=RequestMethod.POST)</span> <span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;保存了账户&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsp代码：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 请求方式的示例 --&gt;</span><br><span class="line">&lt;a href=&quot;account/saveAccount&quot;&gt;保存账户，get请求&lt;/a&gt; &lt;br/&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;account/saveAccount&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存账户，post请求&quot;</span>&gt; </span><br><span class="line">&lt;/form&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>使用<em>GET</em>请求，报错405，信息表示不支持<em>Get</em>方式请求</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315151022948.png" alt="image-20210315151022948"></p>
<h1 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>前端：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;param/testParam?username=hehe&amp;password=123&quot;&gt;请求参数绑定&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>控制器部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数绑定入门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+username);</span><br><span class="line">        System.out.println(<span class="string">&quot;密码：&quot;</span>+password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来到前端页面，点击请求参数绑定</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315152219548.png" alt="image-20210315152219548"></p>
<p>跳转，并且得到预先设置的数据</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315152228305.png" alt="image-20210315152228305"></p>
<p>打印数据：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315152243686.png" alt="image-20210315152243686"></p>
<h2 id="绑定的机制"><a href="#绑定的机制" class="headerlink" title="绑定的机制"></a>绑定的机制</h2><p>在上述的form表单中，请求参数是基于<code>key ： value</code>形式的，因此，<strong>SpringMVC</strong>绑定参数的实质就是：</p>
<p>通过把<mark>表单</mark>提交的<strong>请求参数</strong>，作为<mark>控制器</mark>中的<strong>方法参数</strong>进行绑定</p>
<p>如上述例子中的 username=hehe 以及 password = 123</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;param/testParam?username=hehe&amp;password=123&quot;&gt;请求参数绑定&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>作为了控制器的 username 和 password</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户名：&quot;</span>+username);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码：&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绑定支持的数据类型"><a href="#绑定支持的数据类型" class="headerlink" title="绑定支持的数据类型"></a>绑定支持的数据类型</h2><h2 id="请求参数绑定实体类型"><a href="#请求参数绑定实体类型" class="headerlink" title="请求参数绑定实体类型"></a>请求参数绑定实体类型</h2><ul>
<li><p>实体类</p>
<ul>
<li><p>Account类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&quot;, user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>User类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUname</span><span class="params">(String uname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uname=&#x27;&quot;</span> + uname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>前端页面：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--name 必须要和 实体类的属性名字是相同的--%&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;param/saveAccount&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;password&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        金额：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        用户姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user.uname&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        用户年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user.age&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Controller方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求参数绑定把数据封装到JavaBean的类中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/saveAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">(Account account)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(account);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315201412934.png" alt="image-20210315201412934"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315201425911.png" alt="image-20210315201425911"></p>
<h2 id="请求参数绑定集合类型"><a href="#请求参数绑定集合类型" class="headerlink" title="请求参数绑定集合类型"></a>请求参数绑定集合类型</h2><p>假如不绑定实体类，使用集合类型，又该怎么绑定呢？</p>
<p>Account类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;User&gt; list;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String,User&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;User&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, User&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, User&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.map = map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">            <span class="string">&quot;, list=&quot;</span> + list +</span><br><span class="line">            <span class="string">&quot;, map=&quot;</span> + map +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--把数据封装Account类中，类中存在list和map的集合--%&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;param/saveAccount&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;password&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        金额：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;%--<span class="keyword">private</span> List&lt;User&gt; list;--%&gt;</span><br><span class="line">        用户姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;list[0].uname&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        用户年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;list[0].age&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;%-- <span class="keyword">private</span> Map&lt;String,User&gt; map;--%&gt;</span><br><span class="line">        用户姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;map[&#x27;one&#x27;].uname&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        用户年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;map[&#x27;one&#x27;].age&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315203445912.png" alt></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315203455897.png" alt="image-20210315203455897"></p>
<h2 id="配置解决中文乱码问题"><a href="#配置解决中文乱码问题" class="headerlink" title="配置解决中文乱码问题"></a>配置解决中文乱码问题</h2><ul>
<li><p>其实解决中文乱码的过滤器，我们在javaweb部分也写过一个，有兴趣的朋友可以翻看Javaweb部分的笔记（在过滤器部分吧）</p>
<p>只不过就是springmvc帮助我们实现了这个Filter罢了，我们直接拿来用就好</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置解决中文乱码的过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>假设我们的User类中新增了日期属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315204856276.png" alt="image-20210315204856276"></p>
<p>我们用户生日写法为：years/month/day，那确实可以执行：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315205001320.png" alt="image-20210315205001320"></p>
<p>但如果改一下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315205018372.png" alt="image-20210315205018372"></p>
<p>就会报：错误的请求</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315205031012.png" alt="image-20210315205031012"></p>
<p>这就需要<strong>自定义类型转换器</strong>去解决这个问题</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>想要实现自定义转换器，我们就需要继承<code>Converter</code>这个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串 → 日期的转换器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把字符串转换日期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String source    传入进来字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span>(source == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请您传入数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把字符串转换日期</span></span><br><span class="line">            <span class="keyword">return</span> df.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据类型转换出现错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置自定义类型转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.utils.StringToDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启MVC注解支持同时增加类型转换的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时我们再测试一次：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315210010638.png" alt="image-20210315210010638"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315210035658.png" alt="image-20210315210035658"></p>
<h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><ul>
<li>作用：把<mark>请求</mark>中<strong>指定名称的参数</strong>给<mark>控制器</mark>中的形参赋值</li>
</ul>
<p>什么意思呢？假设有以下场景：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/testRequestParam?name=Test&quot;&gt;RequestParam&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前端中参数为<code>name</code>而控制器中的参数为<code>username</code> 此时我们能获取到数据吗？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315211437900.png" alt="image-20210315211437900"></p>
<p>此时，我们就需要使用<strong>@RequestParam</strong>这个注解咯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">defaultValue</span><span class="params">()</span> <span class="keyword">default</span> &quot;\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一些注意点</li>
</ul>
<p>需要注意 @RequestParam(name = “name”）</p>
<p>中第一个<code>name</code> 对应的是 RequestParam 类中的name，是不能写成别的username啊，name1之类的，只能写成name</p>
<p>第二个name呢，对应的是前端的<strong>name</strong>，假如前端写的是<strong>uname</strong>，那么这里也得写成<strong>uname</strong></p>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h2><ul>
<li>作用是获取<strong>请求体的内容</strong>；本质是获得key=value &amp;key =value结构的数据</li>
<li>在<code>Get</code>请求方式中是用不了的（因为在Get方式中是没有请求体的</li>
</ul>
<p>前端页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;anno/testRequestBody&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">    用户年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取到请求体的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315213053275.png" alt="image-20210315213053275"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315213103744.png" alt="image-20210315213103744"></p>
<p>指的说明的是，就算我<code>@RequestBody String body</code> 中的参数不写bdoy，写个与前端参数一样的username</p>
<p>我这里前面加了<strong>@RequestBody</strong>注解，他会优先判断成是获取请求体内容，而不是简简单单一个username；</p>
<h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h2><ul>
<li>作用：用于绑定url中的<strong>占位符</strong>；举个例子：请求url中的/xxxxx/{id}中的<mark>{id}</mark>就是一个url占位符</li>
</ul>
<p>想要去学习这个注解，首先我们需要去了解一个新概念：<strong>REST风格的URL</strong></p>
<h3 id="REST风格URL"><a href="#REST风格URL" class="headerlink" title="REST风格URL"></a>REST风格URL</h3><ul>
<li>其实就是让请求路径相同，但是请求方式不同，最后走的业务操作就不同的一种风格</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315214401444.png" alt="image-20210315214401444"></p>
<p>类似于java中重载的概念，假如我们的请求方式是相同的（类似于java中的方法名相同），但是传的参数不同（类比于java中的方法重载）。当有参数时，path中带有：{参数}，此时就出现了<strong>占位符</strong>，我们就可以用@PathVariable进行占位符的绑定啦</p>
<h3 id="注解演示"><a href="#注解演示" class="headerlink" title="注解演示"></a>注解演示</h3><p>前端：此时就不是写name=10这种，直接就是个/10</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/testPathVariable/10&quot;&gt;testPathVariable&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>控制层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PathVariable注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(name=&quot;sid&quot;)</span> String id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：路径中的&#123;&#125;数据，需要与注解中的值填写成一样的 ，与id无关，这就是个形参</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="meta">@PathVariable(name=&quot;sid&quot;)</span> String id</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315214934607.png" alt="image-20210315214934607"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315214940994.png" alt="image-20210315214940994"></p>
<h3 id="HiddentHttpMethodFilter"><a href="#HiddentHttpMethodFilter" class="headerlink" title="HiddentHttpMethodFilter"></a>HiddentHttpMethodFilter</h3><p>由于我们的浏览器<strong>form</strong>表单只支持<code>GET</code>和<code>POST</code> 请求，但我们的REST风格中可还有着<code>DELETE、PUT</code>等方法，那不就用不了了吗？</p>
<p>因此，我们可以依靠<code>HiddentHttpMethodFilter</code>这个过滤器，将浏览器的请求改为指定的请求方式</p>
<p>使用方法分三步：</p>
<ol>
<li><p>web.xml中配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HiddentHttpMethodFilter过滤器，修改浏览器请求为指定方式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>请求方式使用<code>POST</code></p>
</li>
<li><p>提供<code>_method</code>请求参数，这个参数的取值就是我们需要的请求方式啦</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 保存 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;springmvc/testRestPOST&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;!-- &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;_method&quot;</span> value=<span class="string">&quot;POST&quot;</span>&gt; --&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;!-- 更新 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;springmvc/testRestPUT/1&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;_method&quot;</span> value=<span class="string">&quot;PUT&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;更新&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;!-- 删除 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;springmvc/testRestDELETE/1&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;_method&quot;</span> value=<span class="string">&quot;DELETE&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;删除&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;!-- 查询一个 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;springmvc/testRestGET/1&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;_method&quot;</span> value=<span class="string">&quot;GET&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;查询&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt; </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>源码：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210315220048364.png" alt="image-20210315220048364"></p>
<h2 id="ReqeustHeader"><a href="#ReqeustHeader" class="headerlink" title="ReqeustHeader"></a>ReqeustHeader</h2><ul>
<li>作用：获取<strong>请求消息头</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/testRequestHeader&quot;&gt;RequestHeader&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求头的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> header</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRequestHeader&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestHeader</span><span class="params">(<span class="meta">@RequestHeader(value=&quot;Accept&quot;)</span> String header, HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(header);</span><br><span class="line">    <span class="comment">// return &quot;success&quot;;</span></span><br><span class="line">    <span class="comment">// response.sendRedirect(request.getContextPath()+&quot;/anno/testCookieValue&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/param.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316200712809.png" alt="image-20210316200712809"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316200722333.png" alt="image-20210316200722333"></p>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><ul>
<li>作用：用于获取指定<strong>cookie</strong>的值</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/testCookieValue&quot;&gt;CookieValue&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Cookie的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testCookieValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">(<span class="meta">@CookieValue(value=&quot;JSESSIONID&quot;)</span> String cookieValue)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了...&quot;</span>);</span><br><span class="line">    System.out.println(cookieValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316201057292.png" alt="image-20210316201057292"></p>
<h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h2><ul>
<li><p>该注解的作用根据 位置的不同也有不同</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;anno/testModelAttribute&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">    用户年龄：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span> /&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>出现在Controller上：会在每一个@RequestMapping标注的方法前执行，若有返回值，就将自动把返回值加入到<strong>ModelMap</strong>上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(value=&quot;/testModelAttribute&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testModelAttribute执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(String uname, Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showUser执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316202154305.png" alt="image-20210316202154305"></p>
</li>
<li><p>出现在方法参数上：会把客户端传过来的参数按照名称注入到指定对象中，并将该对象自动加入到<strong>ModelMap</strong>中</p>
<p>同时，还能应用在这个场景：当表单提交的数据并不是完整的朱提类数据时（比如我有三个数据，你就给我提交了两个）时，可以保证没有提交数据的字段使用数据库原来的数据</p>
<p>同时，@ModelAttribute注解的方法可以带或者不带返回值</p>
<ul>
<li><p>带返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ModelAttribute注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testModelAttribute&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(<span class="meta">@ModelAttribute(&quot;abc&quot;)</span> User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testModelAttribute执行了...&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">showUser</span><span class="params">(String uname)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showUser执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过用户查询数据库（模拟）</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUname(uname);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316203238836.png" alt="image-20210316203238836"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316203424889.png" alt="image-20210316203424889"></p>
</li>
<li><p>不带返回值</p>
<p>此时需要我们提供一个<strong>Map集合</strong>去帮助我们设立映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testModelAttribute&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(<span class="meta">@ModelAttribute(&quot;test&quot;)</span>User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testModelAttribute执行了...&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(String uname, Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;showUser执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过用户查询数据库（模拟）</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUname(uname);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">    map.put(<span class="string">&quot;test&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316203824309.png" alt="image-20210316203824309"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316203833524.png" alt="image-20210316203833524"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="SessionAttribute"></a>SessionAttribute</h2><ul>
<li>作用：用于多次执行控制器方法之间的<strong>参数共享</strong></li>
</ul>
<p>success.jsp：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;入门成功&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">$&#123; msg &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%--表达session域的集合--%&gt;</span><br><span class="line">$&#123;sessionScope&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存Session"><a href="#存Session" class="headerlink" title="存Session"></a>存Session</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/testSessionAttributes&quot;&gt;testSessionAttributes&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SessionAttributes的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testSessionAttributes&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSessionAttributes</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testSessionAttributes...&quot;</span>);</span><br><span class="line">    <span class="comment">// 底层会存储到request域对象中</span></span><br><span class="line">    <span class="comment">//model本质是一个map</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是我们将信息存储到了request域中，但仍然没有存到session里，想要实现就得使用@SessionAttribute注解，需要注意的是，要放在类上面不而不是方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value=&#123;&quot;msg&quot;&#125;)</span>   <span class="comment">// 把msg=Test存入到session域对中</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316210051415.png" alt="image-20210316210051415"></p>
<h3 id="取Session"><a href="#取Session" class="headerlink" title="取Session"></a>取Session</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/getSessionAttributes&quot;&gt;getSessionAttributes&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/getSessionAttributes&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSessionAttributes</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;getSessionAttributes...&quot;</span>);</span><br><span class="line">    String msg = (String) modelMap.get(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316210207694.png" alt="image-20210316210207694"></p>
<h3 id="删Session"><a href="#删Session" class="headerlink" title="删Session"></a>删Session</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;anno/delSessionAttributes&quot;&gt;delSessionAttributes&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/delSessionAttributes&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delSessionAttributes</span><span class="params">(SessionStatus status)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;getSessionAttributes...&quot;</span>);</span><br><span class="line">    status.setComplete();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316210227153.png" alt="image-20210316210227153"></p>
<p>此时再执行getSession方法的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316210315832.png" alt="image-20210316210315832"></p>
<h1 id="相应数据和结果视图"><a href="#相应数据和结果视图" class="headerlink" title="相应数据和结果视图"></a>相应数据和结果视图</h1><h2 id="多种不同返回值情况"><a href="#多种不同返回值情况" class="headerlink" title="多种不同返回值情况"></a>多种不同返回值情况</h2><h3 id="返回值为字符串"><a href="#返回值为字符串" class="headerlink" title="返回值为字符串"></a>返回值为字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;执行成功&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    $&#123;user.username&#125;</span><br><span class="line">    $&#123;user.password&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;user&#x2F;testString&quot; &gt;testString&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testString&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testString</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testString方法执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 模拟从数据库中查询出User对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// model对象</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316212234122.png" alt="image-20210316212234122"></p>
<h3 id="返回值为void"><a href="#返回值为void" class="headerlink" title="返回值为void"></a>返回值为void</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;user/testVoid&quot; &gt;testVoid&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是void</span></span><br><span class="line"><span class="comment"> * 请求转发一次请求，不用编写项目的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testVoid方法执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 编写请求转发的程序</span></span><br><span class="line">    <span class="comment">//自己手动转发的话，是不会经过视图解析器进行前后缀的拼接的，因此我们这里要写完整</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316214451608.png" alt="image-20210316214451608"></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是void</span></span><br><span class="line"><span class="comment"> * 请求转发一次请求，不用编写项目的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testVoid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVoid</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testVoid方法执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    <span class="comment">// 要注意 这里的index.jsp是直接在webapp包下的，要注意包的结构</span></span><br><span class="line">    <span class="comment">//如果是webapp包下的WEB-INF包下的就得写/WEB-INF/XXX.jsp 这样</span></span><br><span class="line">     response.sendRedirect(request.getContextPath()+<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316214643049.png" alt="image-20210316214643049"></p>
<p>注意看浏览器url路径区别</p>
<h4 id="直接用流输出"><a href="#直接用流输出" class="headerlink" title="直接用流输出"></a>直接用流输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;testVoid&quot;)</span><br><span class="line">public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;testVoid方法执行了...&quot;);</span><br><span class="line">    &#x2F;&#x2F; 直接会进行响应 输出流</span><br><span class="line">    response.getWriter().print(&quot;你好&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316214746157.png" alt="image-20210316214746157"></p>
<h3 id="返回值是ModelAndView对象"><a href="#返回值是ModelAndView对象" class="headerlink" title="返回值是ModelAndView对象"></a>返回值是ModelAndView对象</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;user/testModelAndView&quot; &gt;testModelAndView&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回ModelAndView</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 创建ModelAndView对象</span></span><br><span class="line">     ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">     System.out.println(<span class="string">&quot;testModelAndView方法执行了...&quot;</span>);</span><br><span class="line">     <span class="comment">// 模拟从数据库中查询出User对象</span></span><br><span class="line">     User user = <span class="keyword">new</span> User();</span><br><span class="line">     user.setUsername(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">     user.setPassword(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">     user.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 把user对象存储到mv对象中，也会把user对象存入到request对象</span></span><br><span class="line">     mv.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 跳转到哪个页面</span></span><br><span class="line">     mv.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> mv;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316215554193.png" alt="image-20210316215554193"></p>
<h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;user/testForwardOrRedirect&quot; &gt;testForwardOrRedirect&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul>
<li><p>需要注意（在上面也提过了）：如果用了forward，路径要写成实际视图url，而不能写成逻辑视图</p>
<p>也就是必须写完整，不能只写个<code>“success”</code>这种</p>
</li>
<li><p>其本质是相当于：<code>request.getRequestDispatcher(&quot;url&quot;).forward(request, respones)</code>;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForwardOrRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForwardOrRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testForwardOrRedirect方法执行了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求的转发</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316220642834.png" alt="image-20210316220642834"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316220625690.png" alt="image-20210316220625690"></p>
<h3 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li>需要注意，如果使用重定向到JSP页面的话，JSP页面上不能写在<code>WEB-INF</code>目录中的，不然不能找到</li>
<li>其本质相当于<code>response.senRedirect(url)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForwardOrRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForwardOrRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testForwardOrRedirect方法执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316220642834.png" alt="image-20210316220642834"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210316220726620.png" alt="image-20210316220726620"></p>
<h2 id="ResponseBody响应Json数据"><a href="#ResponseBody响应Json数据" class="headerlink" title="ResponseBody响应Json数据"></a>ResponseBody响应Json数据</h2><ul>
<li><p>使用场景：使用@ResponseBody将controller方法返回的对象转成<strong>json</strong>响应给客户端</p>
</li>
<li><p>相关jar包/依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>设置静态资源不拦截的方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--前端控制器，哪些静态资源不拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>User对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送Ajax请求,jsp代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 页面加载，绑定单击事件</span></span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(<span class="string">&quot;#btn&quot;</span>).click(function()&#123;</span><br><span class="line">            <span class="comment">// alert(&quot;hello btn&quot;);</span></span><br><span class="line">            <span class="comment">// 发送ajax请求</span></span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                <span class="comment">// 编写json格式，设置属性和值</span></span><br><span class="line">                <span class="comment">//表示发送请求的url字符串（路径） 也代表方法</span></span><br><span class="line">                url:<span class="string">&quot;user/testAjax&quot;</span>,</span><br><span class="line">                <span class="comment">//发送信息至服务器内容的编码类型 这里选json</span></span><br><span class="line">                contentType:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">                <span class="comment">//json的数据格式为&#123;xxx：xxx&#125;</span></span><br><span class="line">                data:<span class="string">&#x27;&#123;&quot;username&quot;:&quot;hehe&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:30&#125;&#x27;</span>,</span><br><span class="line">                <span class="comment">//数据类型</span></span><br><span class="line">                dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">                <span class="comment">//请求方式</span></span><br><span class="line">                type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">                <span class="comment">//成功后的回调函数 data表示数据</span></span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    <span class="comment">// data服务器端响应的json的数据，进行解析</span></span><br><span class="line">                    alert(data);</span><br><span class="line">                    alert(data.username);</span><br><span class="line">                    alert(data.password);</span><br><span class="line">                    alert(data.age);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟异步请求响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">testAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testAjax方法执行了...&quot;</span>);</span><br><span class="line">    <span class="comment">// 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">// 做响应，模拟查询数据库</span></span><br><span class="line">    user.setUsername(<span class="string">&quot;TestAjax&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">40</span>);</span><br><span class="line">    <span class="comment">// 做响应</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210317212938418.png" alt="image-20210317212938418"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210317212946752.png" alt="image-20210317212946752"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210317212952034.png" alt="image-20210317212952034"></p>
<p>根据结果我们发现：前端打印的username和age都是我们控制器中模拟修改后的，而我们没有修改的密码还是123；也就代表着，我们成功的把后端的数据包装成了user类，作为json数据传给了前端交由打印！</p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="传统文件上传"><a href="#传统文件上传" class="headerlink" title="传统文件上传"></a>传统文件上传</h2><ol>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>前端页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;文件上传&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;user/fileupload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">选择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传文件&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fileupload1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileuoload1</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fileupload组件完成文件上传</span></span><br><span class="line">    <span class="comment">// 上传的位置</span></span><br><span class="line">    String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断，该路径是否存在</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="comment">// 创建该文件夹</span></span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析request对象，获取上传文件项</span></span><br><span class="line">    <span class="comment">//DiskFileItemFactory：磁盘文件项工厂</span></span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">    ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">    <span class="comment">// 解析request</span></span><br><span class="line">    List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(FileItem item:items)&#123;</span><br><span class="line">        <span class="comment">// 进行判断，当前item对象是否是上传文件项</span></span><br><span class="line">        <span class="keyword">if</span>(item.isFormField())&#123;</span><br><span class="line">            <span class="comment">// 说明普通表单向</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 说明上传文件项</span></span><br><span class="line">            <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">            String filename = item.getName();</span><br><span class="line">            <span class="comment">// 把文件的名称设置唯一值，uuid</span></span><br><span class="line">            String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line">            <span class="comment">// 完成文件上传</span></span><br><span class="line">            item.write(<span class="keyword">new</span> File(path,filename));</span><br><span class="line">            <span class="comment">// 删除临时文件</span></span><br><span class="line">            item.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="SpringMVC传统方式文件上传"><a href="#SpringMVC传统方式文件上传" class="headerlink" title="SpringMVC传统方式文件上传"></a>SpringMVC传统方式文件上传</h2><ul>
<li>原理</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318152256193.png" alt="image-20210318152256193"></p>
<ul>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringMVC文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fileupload2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileuoload2</span><span class="params">(HttpServletRequest request, MultipartFile upload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;springmvc文件上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fileupload组件完成文件上传</span></span><br><span class="line">    <span class="comment">// 上传的位置</span></span><br><span class="line">    String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断，该路径是否存在</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="comment">// 创建该文件夹</span></span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们不再需要解析request对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明上传文件项</span></span><br><span class="line">    <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">    String filename = upload.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 把文件的名称设置唯一值，uuid</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line">    <span class="comment">// 完成文件上传</span></span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> File(path,filename));</span><br><span class="line">    <span class="comment">//不再需要删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置文件解析器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件解析器对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大文件大小（10*1024*1024）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="SpringMVC跨服务器方式文件上传"><a href="#SpringMVC跨服务器方式文件上传" class="headerlink" title="SpringMVC跨服务器方式文件上传"></a>SpringMVC跨服务器方式文件上传</h2><p>应用场景：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318153349281.png" alt="image-20210318153349281"></p>
<ul>
<li><p>首先创建两个服务器（主机号端口号区别）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318154455282.png" alt="image-20210318154455282"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318154512203.png" alt="image-20210318154512203"></p>
</li>
</ul>
<ul>
<li><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跨服务器文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fileupload3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileuoload3</span><span class="params">(MultipartFile upload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;跨服务器文件上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义上传文件服务器路径</span></span><br><span class="line">    String path = <span class="string">&quot;http://localhost:9090/uploads/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明上传文件项</span></span><br><span class="line">    <span class="comment">// 获取上传文件的名称</span></span><br><span class="line">    String filename = upload.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 把文件的名称设置唯一值，uuid</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端的对象</span></span><br><span class="line">    Client client = Client.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和图片服务器进行连接</span></span><br><span class="line">    WebResource webResource = client.resource(path + filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传文件</span></span><br><span class="line">    webResource.put(upload.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318162748477.png" alt="image-20210318162748477"></p>
<p>假如我们不去处理异常，那就会把异常信息直接打印在浏览器上，就不是很友好，因此我们需要去进行异常的处理</p>
<p>为了去进行异常处理，我们需要完成以下几步：</p>
<ol>
<li><p>编写<strong>自定义异常类</strong>（用于做信息的提示）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储提示信息的</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SysException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写<strong>异常处理器</strong>（进行异常的处理）</p>
<p>在这一步，我们需要去完成以下几件事</p>
<ul>
<li>定义异常信息/定义异常</li>
<li>判断传进来的异常类型<ul>
<li>如果是的自定义异常，就读取异常信息</li>
<li>其余情况就视情况而定</li>
</ul>
</li>
<li>创建ModelAndView对象，用于封装异常信息<ul>
<li>给异常信息赋值</li>
<li>给ModelAndView对象中的视图设置转发目的地</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到异常对象</span></span><br><span class="line">        SysException e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> SysException)&#123;</span><br><span class="line">            e = (SysException)ex;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            e = <span class="keyword">new</span> SysException(<span class="string">&quot;系统正在维护....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建ModelAndView对象</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;errorMsg&quot;</span>,e.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<strong>异常处理器</strong>（跳转到提示页面）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sysExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.exception.SysExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>测试一下：</p>
<p>发生异常时的前端页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    $&#123;errorMsg&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318164605255.png" alt="image-20210318164605255"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318164621203.png" alt="image-20210318164621203"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318164611047.png" alt="image-20210318164611047"></p>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><ul>
<li><p>SpringMVC中的处理器<strong>拦截器</strong>类似于<mark>Servlet</mark>开发中的<strong>过滤器Filter</strong></p>
</li>
<li><p>功能：对处理器进行<strong>预处理</strong>和<strong>后处理</strong></p>
</li>
<li><p>多个拦截器还能形成<strong>拦截器链</strong>：即将拦截器按照一定的顺序联结成一条链，在访问被拦截的<strong>方法</strong>或<strong>字段</strong>时，拦截器链中的拦截器能按照之前定义的顺序被调用</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318165857077.png" alt="image-20210318165857077"></p>
</li>
<li><p>拦截器与过滤器的区别：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318170025383.png" alt="image-20210318170025383"></p>
</li>
</ul>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>想要去自定义拦截器，主要分为两步</p>
<ol>
<li><p>编写一个类去实现<code>HandlerInterceptoe</code>接口</p>
<p>在这个类中我们有三个方法：</p>
<p><code>preHandle\postHandle\afterCompletion</code>分别代表：预处理 后处理 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理，controller方法执行前</span></span><br><span class="line"><span class="comment">     * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法</span></span><br><span class="line"><span class="comment">     * return false不放行 可以让跳转到错误页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1预处理执行&quot;</span>);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        <span class="comment">// request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后处理方法，controller方法执行后，success.jsp执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1后处理执行了&quot;</span>);</span><br><span class="line">        <span class="comment">// request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * success.jsp页面执行后，该方法会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1最后处理执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置拦截器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--要拦截的具体的方法--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果是/**就表示全部方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要拦截的方法</span></span><br><span class="line"><span class="comment">        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置第二个拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--要拦截的具体的方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要拦截的方法</span></span><br><span class="line"><span class="comment">        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.controller.cn.itcast.interceptor.MyInterceptor2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testInterceptor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testInterceptor执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>预处理</p>
<p>当设置为return false，但是不进行请求转发时：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172058438.png" alt="image-20210318172058438"></p>
<p>当设置为return false，且进行请求转发时：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172119009.png" alt="image-20210318172119009"></p>
<p>打印台：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172321718.png" alt="image-20210318172321718"></p>
<p>当设置为return true，且进行请求转发时：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172223216.png" alt="image-20210318172223216"></p>
<p>打印台：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172816802.png" alt="image-20210318172816802"></p>
</li>
<li><p>后处理</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172903058.png" alt="image-20210318172903058"></p>
<p>假如我们启用了请求转发，即：就算放行了，但依旧让转发到错误页面的话：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318172952445.png" alt="image-20210318172952445"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318173007076.png" alt="image-20210318173007076"></p>
</li>
<li><p>最后处理</p>
<p>通常是进行一些流的关闭</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210318173103024.png" alt="image-20210318173103024"></p>
</li>
</ol>
<ul>
<li><p>下面进行一下链的测试，我们编写第二个拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理，controller方法执行前</span></span><br><span class="line"><span class="comment">     * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法</span></span><br><span class="line"><span class="comment">     * return false不放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2执行了 预处理&quot;</span>);</span><br><span class="line">        <span class="comment">// request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后处理方法，controller方法执行后，success.jsp执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2执行了 后处理&quot;</span>);</span><br><span class="line">        <span class="comment">// request.getRequestDispatcher(&quot;/WEB-INF/pages/error.jsp&quot;).forward(request,response);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * success.jsp页面执行后，该方法会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor2执行了 最后处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后配置好，测试：</p>
<p><img src="/UesugiEr11.github.io/2021/03/14/SpringMVC/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210318173330115.png" alt="image-20210318173330115"></p>
</li>
</ul>
<p>从结果，我们可以看出来是个<strong>U型的打印顺序</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/14/SpringMVC/" data-id="ckppikue3000op0wihrglbr8r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MyBatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/07/MyBatis/" class="article-date">
  <time datetime="2021-03-07T13:47:55.930Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/07/MyBatis/">Mybatis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是  MyBatis？"></a>什么是  MyBatis？</h2><ul>
<li>MyBatis 是一款优秀的<strong><mark>持久层</mark>框架</strong> </li>
<li>它支持定制化  SQL、存储过程以及高级映射。 </li>
<li>MyBatis 避免了几乎所有的 <mark> JDBC 代码和手动设置参数以及获取结果集(ResultSet）</mark>。 </li>
<li>MyBatis 可以使用简单的  <strong>XML 或注解</strong>来配置和<strong>映射原生类型、接口</strong>和  Java 的  <strong>POJO（Plain Old Java Objects，普通老式  Java 对象</strong>）为数据库中 的记录。</li>
</ul>
<h2 id="如何获得MyBatis？"><a href="#如何获得MyBatis？" class="headerlink" title="如何获得MyBatis？"></a>如何获得MyBatis？</h2><ul>
<li>github 下载地址：<a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></li>
<li>中文文档：<a target="_blank" rel="noopener" href="https://github.com/tuguangquan/mybatis">https://github.com/tuguangquan/mybatis</a></li>
<li>Maven仓库：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!‐‐    https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis    ‐‐&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; </span><br><span class="line">&lt;version&gt;3.5.3&lt;&#x2F;version&gt; </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用3.5.3是因为用的人最多，目前最新3.5.6 --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul>
<li><p>数据持久化 </p>
<p>持久化就是将程序的数据在<strong>持久状态和瞬时状态</strong>转化的过程 </p>
</li>
<li><p>内存特性：断电即失<br>因此有了：数据库（JDBC）,io文件持久化 进行存储 </p>
</li>
<li><p>生活：冷藏、罐头。 </p>
</li>
<li><p>为什么需要持久化？ 因为有一些对象，不能让他丢掉。</p>
</li>
</ul>
<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><p>层次分为：Dao层、Service层、Controller层…..<br>因此 持久层 = 完成持久化工作的代码块 </p>
<h2 id="为什么需要Mybatis？"><a href="#为什么需要Mybatis？" class="headerlink" title="为什么需要Mybatis？"></a>为什么需要Mybatis？</h2><ol>
<li>帮助程序员将数据存入到数据库中。 方便 </li>
<li>传统的JDBC代码太复杂了。简化、框架、自动化。 </li>
<li>不用Mybatis也可以。更容易上手。但是是技术没有高低之分 </li>
<li>优点： <ol>
<li>简单易学 </li>
<li>灵活 </li>
<li>sql和代码的分离，提高了可维护性。 </li>
<li>提供映射标签，支持对象与数据库的<strong>orm字段关系映射</strong> </li>
<li>提供对象关系映射标签，支持对象关系组建维护 </li>
<li>提供xml标签，支持编写动态sql。 </li>
<li>最重要的一点：使用的人多！ </li>
<li>和Spring SpringMVC SpringBoot一起搭配使用</li>
</ol>
</li>
</ol>
<h1 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h1><p><strong>首先需要注意 ，如果用的是IDEA，把配置文件写在resource包下的话，需要引用以下代码到pom.xml以解决资源路径问题：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>思路：搭建环境‐‐&gt;导入Mybatis‐‐&gt;编写代码‐‐&gt;测试！</p>
<p>目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305220008983.png" alt="image-20210305220008983"></p>
<p>搭建数据库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_employee(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	last_name VARBINARY(<span class="number">255</span>),</span><br><span class="line">	GENDER <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	email <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>新建项目：</p>
<p>依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--mysql驱动--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--mybatis--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--junit--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>创建实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.mybatis.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写全局配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/hpg/mybatis/Mapper/EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写映射文件（Mapper文件）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hpg.mybatis.Mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace:名称空间;指定为接口的全类名</span></span><br><span class="line"><span class="comment">    id：唯一标识</span></span><br><span class="line"><span class="comment">    resultType：返回值类型</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;：从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.mybatis.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.mybatis.pojo.Employee;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mybatistest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据xml配置文件创建一个sqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取sqlSession实例，能直接执行已经映射的sql语句</span></span><br><span class="line">        <span class="comment">// sql的唯一标识：statement Unique identifier matching the statement to use.</span></span><br><span class="line">        <span class="comment">// 执行sql要用的参数：parameter A parameter object to pass to the statement.</span></span><br><span class="line">        String resource = <span class="string">&quot;com\\hpg\\mybatis\\Mapper\\mybatis-config.xml&quot;</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取sqlSession实例 能够执行已经映射的sql语句</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Employee employee = sqlSession.selectOne(<span class="string">&quot;com.hpg.mybatis.Mapper.EmployeeMapper.getEmpById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于selectOne函数：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305211236568.png" alt="image-20210305211236568"></p>
<p>第一个参数：sql唯一标识符；</p>
<p>第二个参数：执行sql要用的参数</p>
<p>打印结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305220024227.png" alt="image-20210305220024227"></p>
<p>总的来说可以分成这几步：</p>
<ol>
<li>根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息</li>
<li>sql映射文件；配置了每一个sql，以及sql的封装规则等。 </li>
<li>将sql映射文件注册在全局配置文件中</li>
<li>写代码<ol>
<li>根据全局配置文件得到SqlSessionFactory；</li>
<li>使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查，一个sqlSession就是代表和数据库的一次会话，用完关闭</li>
<li>使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。</li>
</ol>
</li>
</ol>
<h1 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h1><p>目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305222537083.png" alt="image-20210305222537083"></p>
<p>编写接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.mybatis.pojo.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将EmployeeMapper中的命名空间替换掉：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--原来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hpg.mybatis.Mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--现在--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hpg.mybatis.dao.EmployeeMapper&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hpg.mybatis.dao.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace:名称空间;指定为接口的全类名</span></span><br><span class="line"><span class="comment">    id：唯一标识</span></span><br><span class="line"><span class="comment">    resultType：返回值类型</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;：从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.mybatis.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        select id,last_name lastName,email,gender from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      String resource = <span class="string">&quot;com\\hpg\\mybatis\\Mapper\\mybatis-config.xml&quot;</span>;</span><br><span class="line">      InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InterfaceTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//获取sqlSessionFactory对象</span></span><br><span class="line">      SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">      <span class="comment">//获取sqlSession对象</span></span><br><span class="line">      SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取接口的实现类对象</span></span><br><span class="line">          EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">          Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">          System.out.println(employee);</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          sqlSession.close();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305222804382.png" alt="image-20210305222804382"></p>
<p>明明我们没写实现类，那究竟结果是怎么实现的呢？</p>
<p>是由Mybatis为接口自动创建的一个<strong>代理对象</strong>，<code>sqlSession.getMapper(xxxx.class)</code>由这个对象去实现CRUD的，当然了，使用之前需要将接口和xml进行<strong>绑定操作</strong></p>
<ul>
<li><p>接口式编程</p>
<ul>
<li>原生：Dao → DaoImpl、</li>
<li>Mybatis：Mapper → XXXMapper.xml</li>
</ul>
</li>
<li><p>SqlSession代表和数据库的一次会话，因此用完必须关闭</p>
</li>
<li><p>SqlSession和connection一样是<strong>非线程安全的</strong>，因此不能够设置private …每次使用的时候应该去主动获取</p>
</li>
<li><p>有两个重要的配置文件</p>
<ul>
<li>mybatis全局配置文件（可以不专门写一个出来，可以new出来）：包含了数据库连接池信息，事务管理器信息，系统运行环境信息等</li>
<li>sql映射文件：保存了每一个sql语句的映射信息；这个文件将sql抽取了出来</li>
</ul>
</li>
</ul>
<h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p>configuration下有以下几个标签：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306150224976.png" alt="image-20210306150224976"></p>
<h2 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306150215773.png" alt="image-20210306150215773"></p>
<ul>
<li><p>resource：resource属性是按照类路径的写法来写的,因此必须存在于类路径下</p>
</li>
<li><p>url：URL： Uniform Resource Locator 统一资源定位符</p>
<p>比如这个就是一个URL<br><a target="_blank" rel="noopener" href="http://localhost:8080/ABC/DEF">http://localhost:8080/ABC/DEF</a><br>其中<br>协议是:http 主机是:localhost 端口是8080<br>其他的都是 URI(在这里就是/ABC/DEF)</p>
</li>
</ul>
<p>编写一个配置文件 properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>修改一下全局配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;dbconfig.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;databaseIdProvider type=&quot;&quot;&gt;&lt;/databaseIdProvider&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/hpg/mybatis/Mapper/EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InterfaceTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sqlSession实例 能够执行已经映射的sql语句</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306154118099.png" alt="image-20210306154118099"></p>
<p>这一部分之后与Spring整合的时候会进一步优化，由Spring进行托管</p>
<h2 id="Settings标签"><a href="#Settings标签" class="headerlink" title="Settings标签"></a>Settings标签</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306154654358.png" alt="image-20210306154654358"></p>
<p>以最后一个为例：数据库一个属性叫A_xxx，但你sql语句写了一个select xxx，如果不设置驼峰参数的话，就读不了，设置了后就能自动进行映射，用于读取属性；</p>
<h2 id="TypeAliases标签"><a href="#TypeAliases标签" class="headerlink" title="TypeAliases标签"></a>TypeAliases标签</h2><ul>
<li>别名处理器，能为java类型起别名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1、typeAlias:为某个java类型起别名</span></span><br><span class="line"><span class="comment">			type:指定要起别名的类型全类名;默认别名：就是类名小写；employee</span></span><br><span class="line"><span class="comment">			alias:指定新的别名</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.mybatis.pojo.Employee&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;emp&quot;</span>/&gt;</span> </span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 2、package:为某个包下的所有类批量起别名 </span></span><br><span class="line"><span class="comment">			name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名：（类名小写），）</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.hpg.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 3、批量起别名的情况下，可能会造成类名重复从而重复，因此可以使用@Alias注解为某个类型指定新的别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但一般还是写全路径名，方便后期排查；0</p>
<h2 id="typeHandlers标签"><a href="#typeHandlers标签" class="headerlink" title="typeHandlers标签"></a>typeHandlers标签</h2><p>类型处理器：使java对象的属性映射成数据库对应的变量属性（比如：java String → 数据库 varchar）</p>
<p>自定义类型处理器：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306155957578.png" alt="image-20210306155957578"></p>
<h2 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306160103908.png" alt="image-20210306160103908"></p>
<p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li><strong>Executor</strong> (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)：执行器，作用是在sql执行增删改之前改变一些mybatis行为，达到自定义效果</li>
<li><strong>ParameterHandler</strong> (getParameterObject, setParameters)：参数处理器，预编译的时候设置以及获取参数</li>
<li><strong>ResultSetHandler</strong> (handleResultSets, handleOutputParameters)：结果集处理器，作用就是把得到的结果形成一个结果集并且封装成<mark>javabean对象</mark></li>
<li><strong>StatementHandler</strong> (prepare, parameterize, batch, update, query)：SQL语句处理器</li>
</ul>
<h2 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h2><p>一个environment标签内需要有 transactionManager 和 dataSource标签</p>
<p>环境标签的id：代表当前环境的唯一标识</p>
<p>比如一个环境用来测试，而另一个环境专门用来开发；</p>
<ul>
<li><p>事务管理器transactionManager</p>
<ul>
<li><p>type：表示事务管理器的事务类型（JDBC/MANAGE）</p>
<ul>
<li><pre><code class="java">JDBC(JdbcTransactionFactory)
&lt;!--code￼<span class="number">16</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>自定义事务管理器：实现TransactionFactory接口.type指定为全类名</p>
</li>
</ul>
</li>
<li><p>数据源dataSource</p>
<ul>
<li><p>type：数据源类型</p>
<ul>
<li><pre><code class="java">UNPOOLED(UnpooledDataSourceFactory)
&lt;!--code￼<span class="number">17</span>--&gt;</code></pre>
</li>
<li><pre><code class="java">JNDI(JndiDataSourceFactory)
&lt;!--code￼<span class="number">18</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<p>在全局配置文件中加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">value</span>= <span class="string">&quot;db2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>= <span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;PostgreSQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;postgresql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Derby&quot;</span> <span class="attr">value</span>= <span class="string">&quot;derby&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;H2&quot;</span> <span class="attr">value</span>= <span class="string">&quot;h2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;HSQL&quot;</span> <span class="attr">value</span>= <span class="string">&quot;hsqldb&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的sql标签中添加属性databaseId：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByMap&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        update sys_user</span><br><span class="line">        set</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;_parameter&quot;</span> <span class="attr">item</span>=<span class="string">&quot;val&quot;</span> <span class="attr">index</span>=<span class="string">&quot;key&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            $&#123;key&#125; =  #&#123;val&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以做到 从不同数据库中查了；</p>
<h2 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h2><p>每一个mappers标签的作用：将sql映射注册到了全局配置中</p>
<ul>
<li><p>resource：引用类路径下的sql映射文件</p>
</li>
<li><p>url：引用网络路径 或者 磁盘路径下的sql映射文件（file://xxxxx/xxx/xx.xml）</p>
</li>
<li><p>class：引用接口</p>
<p>如果要使用这个进行映射的话，要满足</p>
<ul>
<li><p>若有sql映射文件，则要和接口同名，且同一目录（包）下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306164452142.png" alt="image-20210306164452142"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper resource &#x3D; &quot;xxx&#x2F;xxx&#x2F;abc.xml&quot;&#x2F;&gt;</span><br><span class="line">&lt;mapper class &#x3D; &quot;xxx.xxx.abc&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>没有sql映射文件，根据注解进行配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.mybatis.pojo.Employee;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapperAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_employee where id =#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在全局配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.mybatis.dao.EmployeeMapperAnnotation&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AnnotationTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取sqlSession实例 能够执行已经映射的sql语句</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);</span><br><span class="line">        Employee empById = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(empById);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306164353447.png" alt="image-20210306164353447"></p>
</li>
</ul>
<h1 id="Mybatis映射文件"><a href="#Mybatis映射文件" class="headerlink" title="Mybatis映射文件"></a>Mybatis映射文件</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306164710236.png" alt="image-20210306164710236"></p>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>目录结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306173836777.png" alt="image-20210306173836777"></p>
<p>别忘了需要提交<code>openSession.commit()</code></p>
<p>当然了，如果设置了<code>sqlSessionFactory.openSession(true)</code>就可以进行自动提交啦</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    insert into tbl_employee(last_name,email,gender)</span><br><span class="line">    values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CRUD_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//获取sqlSession实例 能够执行已经映射的sql语句</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        mapper.addEmp(<span class="keyword">new</span> Employee(<span class="number">2</span>, <span class="string">&quot;jerry&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306173718756.png" alt></p>
<ul>
<li>获取自增主键的值：<br>mysql支持自增主键，自增主键值的获取，mybatis也是利用statement.getGenreatedKeys()；<br>useGeneratedKeys=”true”；使用自增主键获取主键值策略<br>keyProperty；指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">	insert into tbl_employee(last_name,email,gender) </span><br><span class="line">	values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>把一号员工也改成二号员工数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public void updateEmp(Employee employee);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span>&gt;</span></span><br><span class="line">    update tbl_employee</span><br><span class="line">    set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;</span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.updateEmp(<span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">&quot;jerry&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306174416906.png" alt="image-20210306174416906"></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>把二号员工删掉</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public void deleteEmpById(Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteEmpById&quot;</span>&gt;</span></span><br><span class="line">    delete from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.deleteEmpById(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306205210832.png" alt="image-20210306205210832"></p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307171355026.png" alt="image-20210307171355026"></p>
<h4 id="Select获取List"><a href="#Select获取List" class="headerlink" title="Select获取List"></a>Select获取List</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByLastNameLike(String lastName); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resultType：如果返回的是一个集合，要写集合中元素的类型  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByLastNameLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Select_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        List&lt;Employee&gt; list = mapper.getEmpsByLastNameLike(<span class="string">&quot;%e%&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Employee employee : list) &#123;</span><br><span class="line">            System.out.println(employee.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307171340880.png" alt="image-20210307171340880"></p>
<p>（为啥lastName是null呢？好像是因为Mybatis找不到的原因 这个问题可以在下一节解决）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307171230053.png" alt="image-20210307171230053"></p>
<h4 id="Select获取Map"><a href="#Select获取Map" class="headerlink" title="Select获取Map"></a>Select获取Map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//多条记录封装一个map：Map&lt;String,Employee&gt;:键是这条记录的主键，值是记录封装后的javaBean</span></span><br><span class="line">    <span class="comment">//@MapKey:告诉mybatis封装这个map的时候使用哪个属性作为map的key</span></span><br><span class="line"><span class="comment">//要注意Map的键值对类型，不要写错</span></span><br><span class="line">    <span class="meta">@MapKey(&quot;lastName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Employee&gt; <span class="title">getEmpByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByLastNameLikeReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Select_Map_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        Map&lt;String, Employee&gt; map = mapper.getEmpByLastNameLikeReturnMap(<span class="string">&quot;%e%&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307172722264.png" alt="image-20210307172722264"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307172729162.png" alt="image-20210307172729162"></p>
<h5 id="自定义resultMap（重点）"><a href="#自定义resultMap（重点）" class="headerlink" title="自定义resultMap（重点）"></a>自定义resultMap（重点）</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307185043006.png" alt="image-20210307185043006"></p>
<p>还记得不记得上面有个问题，取到的值为null吗？这个问题可以用<strong>ResultMap</strong>进行解决</p>
<ul>
<li>自定义某个javaBean的封装规则：</li>
</ul>
<ol>
<li>type：自定义规则的Java类型</li>
<li>id：取的名字，方便引用</li>
</ol>
<ul>
<li>指定主键类的封装规则</li>
</ul>
<ol>
<li>column：指定哪一列</li>
<li>property：指定对应的javaBean属性</li>
</ol>
<p>要使用的时候，只需要把原来的<code>resultType</code>替换成<code>resultMap</code>并且id填上我们自己取得ResultMap的id即可；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--自定义某个javaBean的封装规则</span></span><br><span class="line"><span class="comment">type：自定义规则的Java类型</span></span><br><span class="line"><span class="comment">id:唯一id方便引用</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MySimpleEmp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定主键列的封装规则:</span></span><br><span class="line"><span class="comment">        column：指定哪一列</span></span><br><span class="line"><span class="comment">        property：指定对应的javaBean属性--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- id定义主键会底层有优化（Mybatis就知道这是一个主键了）;result定义主键就不会有优化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- result列 定义普通列封装规则 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他不指定的列会自动封装;但我们只要写resultMap就把全部的映射规则都写上。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- resultMap:自定义结果集映射规则；  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- public Employee getEmpById(Integer id); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;MySimpleEmp&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OwnMapTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        Employee empID = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(empID);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307193615796.png" alt="image-20210307193615796"></p>
<h4 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h4><p>现在员工有一个属性叫部门Department，现在希望查询员工的时候把这个信息也显示出来</p>
<p>（其实就是结合Mysql的外键约束进行联表查询）</p>
<p>在Employee类中添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Department dept;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Department dept)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dept = dept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置一个Department类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDepartmentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartmentName</span><span class="params">(String departmentName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.departmentName = departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Department&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, departmentName=&#x27;&quot;</span> + departmentName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进行联合查询</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  联合查询：级联属性封装结果集</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.departmentName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--  public Employee getEmpAndDept(Integer id);--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDifEmp&quot;</span>&gt;</span></span><br><span class="line">      SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,e.email email,</span><br><span class="line">             d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d</span><br><span class="line">      WHERE e.d_id=d.id AND e.id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Join_Select_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        Employee emp = mapper.getEmpAndDept(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        System.out.println(emp.getDept().toString());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307201536083.png" alt="image-20210307201536083"></p>
<h5 id="association标签方法进行联合查询"><a href="#association标签方法进行联合查询" class="headerlink" title="association标签方法进行联合查询"></a>association标签方法进行联合查询</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--  public Employee getEmpAndDept(Integer id);--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDifEmp2&quot;</span>&gt;</span></span><br><span class="line">       SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,e.email email,</span><br><span class="line">              d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d</span><br><span class="line">       WHERE e.d_id=d.id AND e.id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   使用association定义关联的单个对象的封装规则；</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp2&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--  association可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">       property=&quot;dept&quot;：指定哪个属性是联合的对象 这个是原类中取得id</span></span><br><span class="line"><span class="comment">       javaType:指定这个属性对象的类型[不能省略]</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.hpg.pojo.Department&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--这里的property属性虽然也是id但是是Department中的id 不会与上面的冲突--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--然而这里的列名column就不能取id了 就会与上面Employee的列名id重复了--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是之前的测试代码，结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307203659476.png" alt="image-20210307203659476"></p>
<h5 id="association实现分步查询"><a href="#association实现分步查询" class="headerlink" title="association实现分步查询"></a>association实现分步查询</h5><ul>
<li>association定义关联对象的封装语法<ul>
<li>property：关联的对象，填入属性名（id）</li>
<li>select：表明使用哪个方法，填入对应的方法</li>
<li>column：指定将数据库中哪一列的值传入这个方法</li>
</ul>
</li>
</ul>
<p>运行的流程：使用<mark>select</mark>指定的方法 传入column指定的这列参数的值，查出来对象，并封装给property指定的属性</p>
<p>测试：</p>
<p>创建一个department接口 带有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.pojo.Department;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好Department的 mapper文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hpg.dao.DepartmentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--public Department getDeptById(Integer id);  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Department&quot;</span>&gt;</span></span><br><span class="line">        select id,dept_name departmentName from tbl_dept where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在EmployeeMapperPlus.xml中进行分步查询：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- 使用association进行分步查询：</span></span><br><span class="line"><span class="comment">   1、先按照员工id查询员工信息</span></span><br><span class="line"><span class="comment">   2、根据查询员工信息中的d_id值去部门表查出部门信息</span></span><br><span class="line"><span class="comment">   3、部门设置到员工中；</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--  id  last_name  email   gender    d_id   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyEmpByStep&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- association定义关联对象的封装规则</span></span><br><span class="line"><span class="comment">           select:表明当前属性是调用select指定的方法查出的结果</span></span><br><span class="line"><span class="comment">           column:指定将哪一列的值传给这个方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;com.hpg.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmpByStep&quot;</span>&gt;</span></span><br><span class="line">       select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Step_Association_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        Employee emp = mapper.getEmpByIdStep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        System.out.println(emp.getDept().toString());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210307213722020.png" alt="image-20210307213722020"></p>
<h5 id="懒加载-延迟查询"><a href="#懒加载-延迟查询" class="headerlink" title="懒加载/延迟查询"></a>懒加载/延迟查询</h5><p>懒加载针对级联使用的，懒加载的目的是减少内存的浪费和减轻系统负担。</p>
<p>懒加载是一种<strong>按需加载</strong>，也就是只用调用到关联的数据的时候，才会与数据库进行交互（执行相应sql）</p>
<p>以上述代码为例，我们知道Employee中有一个Department属性；</p>
<p>但我有时候不需要特定的部门的员工，只需要干净的员工信息即可，这就可以使用<strong>懒加载</strong>来只加载Employee表的信息，而不加载Department表的信息了</p>
<p>使用方法：</p>
<p>在全局配置文件中：</p>
<p>这是用于打印sql的设置，添加在全局配置中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--延迟加载/懒加载--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--显示的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LazyLoadTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">        SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">            Employee emp = mapper.getEmpByIdStep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(emp.getLastName());</span><br><span class="line"><span class="comment">//            System.out.println(emp.getDept().toString());</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            openSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在关闭配置的时候，我们只需要进行查询员工的lastName，但依旧执行了多余的sql：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308201325432.png" alt="image-20210308201325432"></p>
<p>开启之后：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308201338105.png" alt="image-20210308201338105"></p>
<hr>
<h5 id="collection标签实现关联集合查询"><a href="#collection标签实现关联集合查询" class="headerlink" title="collection标签实现关联集合查询"></a>collection标签实现关联集合查询</h5><p>首先需要明白collection和association标签区别：</p>
<p>他们都能进行多表的查询，但是association是【关联】，collection是【集合】</p>
<p>什么意思呢？</p>
<ul>
<li>association用于<mark>一对一</mark>和<mark>多对一</mark> 一个人对应一个部门，但部门可以有多人，希望查一个人顺带部门的时候，就用<strong>association</strong></li>
<li>collection是用于<mark>一对多</mark>，一个部门可容纳多人，希望查一个部门的时候，顺带把部门中的人查出来就用collection</li>
</ul>
<p>修改一下数据库：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308203757038.png" alt="image-20210308203757038"></p>
<p>DepartmentMapper接口中新增方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptByIdPlus</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    public class Department &#123;</span></span><br><span class="line"><span class="comment">            private Integer id;</span></span><br><span class="line"><span class="comment">            private String departmentName;</span></span><br><span class="line"><span class="comment">            private List&lt;Employee&gt; emps;</span></span><br><span class="line"><span class="comment">      did  dept_name  ||  eid  last_name  email   gender</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Department&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        collection:定义【关联集合类型】的属性的封装规则</span></span><br><span class="line"><span class="comment">        ofType:指定集合里面元素的类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义这个集合中元素的封装规则 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- public Department getDeptByIdPlus(Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByIdPlus&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">    SELECT d.id did,d.dept_name dept_name,</span><br><span class="line">           e.id eid,e.last_name last_name,e.email email,e.gender gender</span><br><span class="line">    FROM tbl_dept d</span><br><span class="line">             LEFT JOIN tbl_employee e</span><br><span class="line">                       ON d.id=e.d_id</span><br><span class="line">    WHERE d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collection_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DepartmentMapper mapper = openSession.getMapper(DepartmentMapper.class);</span><br><span class="line">        Department department = mapper.getDeptByIdPlus(<span class="number">1</span>);</span><br><span class="line">        System.out.println(department);</span><br><span class="line">        System.out.println(department.getEmps());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308203937320.png" alt="image-20210308203937320"></p>
<h5 id="collection实现分步查询"><a href="#collection实现分步查询" class="headerlink" title="collection实现分步查询"></a>collection实现分步查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptByIdStep</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdStep</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>EmployeeMapperPlus.xml</p>
<p>首先查询出来特定部门的员工数据</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByDeptId(Integer deptId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByDeptId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where d_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- collection：分段查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Department&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyDeptStep&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;departmentName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.hpg.dao.EmployeeMapperPlus.getEmpsByDeptId&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- public Department getDeptByIdStep(Integer id); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDeptStep&quot;</span>&gt;</span></span><br><span class="line">    select id,dept_name from tbl_dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collection_Step_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DepartmentMapper mapper = openSession.getMapper(DepartmentMapper.class);</span><br><span class="line">        Department dept = mapper.getDeptByIdStep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(dept);</span><br><span class="line">        System.out.println(dept.getEmps());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308205257235.png" alt="image-20210308205257235"></p>
<p>这里的Employee查询查询部分 没有配置resultMap 因此lastName是null；</p>
<h5 id="collection标签-extra"><a href="#collection标签-extra" class="headerlink" title="collection标签 extra"></a>collection标签 extra</h5><ul>
<li><p>多列的值传递过去：<br>将多列的值封装map传递；使用：column=”{key1=column1,key2=column2}”</p>
<p>比如在上一个例子中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;com.hpg.dao.EmployeeMapperPlus.getEmpsByDeptId&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>处的id也可以写成：<code>&#123;deptId = id&#125;</code>其中deptId的由来是EmployeeMaaperPlus中的sql语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByDeptId(Integer deptId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByDeptId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where d_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟加载</p>
<p>fetchType=”lazy”：表示使用延迟加载；</p>
<ul>
<li>lazy：延迟</li>
<li>er：立即</li>
</ul>
</li>
</ul>
<h3 id="discriminator鉴别器"><a href="#discriminator鉴别器" class="headerlink" title="discriminator鉴别器"></a>discriminator鉴别器</h3><p><strong>Mybatis</strong>可以使用<strong>discriminator</strong>判断某一列的值,然后根据某一列的值改变封装行为</p>
<p>现在模拟一个场景：</p>
<ul>
<li>如果查出的是女生：就把部门信息查询出来，否则不查询；</li>
<li>如果是男生，把last_name这一列的值赋值给email;</li>
</ul>
<p>修改数据库：gender 0代表女生， 1代表男生</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308212312476.png" alt="image-20210308212312476"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;&quot;</span> <span class="attr">column</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>javaType为鉴别的列值对应的属性 , column为列名，case代表不同的情况</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyEmpDis&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        column：指定判定的列名</span></span><br><span class="line"><span class="comment">        javaType：列值对应的java类型  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--女生  resultType:指定封装的结果类型；不能缺少。/resultMap--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">select</span>=<span class="string">&quot;com.hpg.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--男生 ;如果是男生，把last_name这一列的值赋值给email; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  public Employee getEmpByIdStep(Integer id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmpDis&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dis_Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        Employee emp = mapper.getEmpByIdStep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        System.out.println(emp.getDept());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>男生情况（gender=1）：email=lastName，且不显示部门信息</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308212556124.png" alt="image-20210308212556124"></p>
<p>女生情况（gender=0）：email不变，显示部门信息</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308212629729.png" alt="image-20210308212629729"></p>
<h2 id="Mybatis参数处理"><a href="#Mybatis参数处理" class="headerlink" title="Mybatis参数处理"></a>Mybatis参数处理</h2><ul>
<li>单个参数：mybatis不会做特殊处理，参数名可以随便写（当作占位符）<pre><code>#&#123;参数名/任意名&#125;：取出参数值。</code></pre></li>
<li>多个参数：mybatis会做特殊处理,多个参数会被封装成 一个<strong>map</strong><br>key：param1…paramN，或者参数的索引也可以<br>value：表示传入的参数值<br>#{}就是从map中获取指定的key的值；</li>
</ul>
<p>例子：</p>
<p>假如接口有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName</span><span class="params">(Integer id,String lastName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>并编写对应的sql映射：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  public Employee getEmpByIdAndLastName(Integer id,String lastName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdAndLastName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee emp = mapper.getEmpByIdAndLastName(<span class="number">1</span>, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">System.out.println(emp);</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">异常：   </span><br><span class="line">org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line">### Error querying database.  Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br><span class="line">### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br><span class="line">操作：</span><br><span class="line">	方法：<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName</span><span class="params">(Integer id,String lastName)</span></span>;</span><br><span class="line">	取值：#&#123;id&#125;,#&#123;lastName&#125;</span><br></pre></td></tr></table></figure>

<p>修改：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  public Employee getEmpByIdAndLastName(Integer id,String lastName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdAndLastName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;param1&#125; and last_name=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306211827961.png" alt="image-20210306211827961"></p>
<p>然而如果参数过多的话，占位符都写param1，param2会显得很臃肿，因此有了*<em>【命名参数】 *</em></p>
<ul>
<li><p>【命名参数】</p>
<p>形如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdAndLastName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span>Integer id,<span class="meta">@Param(&quot;lastName&quot;)</span>String lastName)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：明确指定封装参数时map的key；</p>
</li>
<li><p>形式：@Param(“id”)<br>多个参数会被封装成 一个map，<br>key：使用@Param注解指定的值<br>value：参数值<br>#{指定的key}取出对应的参数值</p>
<p>如果用这种形式的话，我们的xml文件就可以写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  public Employee getEmpByIdAndLastName(Integer id,String lastName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdAndLastName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>再测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306213238180.png" alt="image-20210306213238180"></p>
</li>
<li><p>POJO：<br>如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；</p>
<pre><code>#&#123;属性名&#125;：取出传入的pojo的属性值    </code></pre></li>
<li><p>Map：<br>如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map</p>
<pre><code>#&#123;key&#125;：取出map中对应的值</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public Employee getEmpByMap(Map&lt;String, Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">Employee emp = mapper.getEmpByMap(map);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">System.out.println(emp);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306214655409.png" alt="image-20210306214655409"></p>
</li>
</ul>
<h4 id="参数处理总结"><a href="#参数处理总结" class="headerlink" title="参数处理总结"></a>参数处理总结</h4><p><code>public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName);</code></p>
<ul>
<li><p>id → #{id/param1}  </p>
</li>
<li><p>lastName → #{param2}</p>
</li>
</ul>
<p><code>public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp);</code></p>
<ul>
<li><p>id → #{param1}    </p>
</li>
<li><p>lastName →  #{param2.lastName / e.lastName}</p>
<p>因为param2才代表employee</p>
</li>
</ul>
<p>##特别注意：</p>
<p>如果是Collection（List、Set）类型或者是数组，也会特殊处理，是把传入的list或者数组封装在map中。</p>
<ul>
<li>此时的key：<ul>
<li>Collection（collection）,</li>
<li>如果是List还key(list)</li>
<li>数组(array)</li>
<li>以<code>public Employee getEmpById(List&lt;Integer&gt; ids);</code>为例<br>现在取值：取出第一个id的值：   <strong>#{list[0]}</strong>，就不能用<strong>#{param[0]}</strong>或者是<strong>#{ids[0]}</strong></li>
</ul>
</li>
</ul>
<h4 id="参数传递源码分析"><a href="#参数传递源码分析" class="headerlink" title="参数传递源码分析"></a>参数传递源码分析</h4><p>我们知道mapper是以动态代理为原理执行sql的，下面看看整个运行流程</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">Employee employee = mapper.getEmpByIdAndLastName(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第三行处进行断点调试，先来到一个名字叫mapperProxy.class动态代理的InvocationHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看看这个类中的invoke方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//有一个判断,当前方法声明的类是在object里面声明的, 直接放行.</span></span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//否则,把method包装成一mapperMethod</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这里的<code>mapperMethod.execute(sqlSession, args);</code>方法中的参数传入的是1和Tom</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306221301585.png" alt="image-20210306221301585"></p>
<p>进入execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="comment">//执行之前,先判断是什么类型的,对应的走增删改查的方法</span></span><br><span class="line">  <span class="comment">//每次调用之前,resulte就是返回值,通过convertArgsToSqlCommandParam(args)会把你传过来的参数转化为sql能用的参数</span></span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">   Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;<span class="comment">//没有返回值</span></span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;<span class="comment">//多个</span></span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;<span class="comment">//map</span></span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;<span class="comment">//游标</span></span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);<span class="comment">//返回单个对象</span></span><br><span class="line">        <span class="comment">//底层调用的还是sqlSession</span></span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">        + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在convertArgsToSqlCommandParam(args)方法中 参数确实是传过来了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210306221955848.png" alt="image-20210306221955848"></p>
<p>在这个方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> paramNameResolver.getNamedParams(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用的又是 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paramNameResolver.getNamedParams(args);</span><br></pre></td></tr></table></figure>

<p>再step in 进入这个方法，下面这个方法将我们传入的参数封装成了param1,和param2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * A single non-special parameter is returned without a name.&lt;br /&gt;</span></span><br><span class="line"><span class="comment">   * Multiple parameters are named using the naming rule.&lt;br /&gt;</span></span><br><span class="line"><span class="comment">   * In addition to the default names, this method also adds the generic names (param1, param2,</span></span><br><span class="line"><span class="comment">   * ...).</span></span><br><span class="line"><span class="comment">   * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//上手先获取了一个names.size(),而这个names里面是有值的:&#123;0=id,1=lastName&#125;, key就是0,1 value就是id和lastName. 这里我们就能看出来是调用的哪个mapper接口, 见下图. 那name是如何确定的,我们见图下面的分析</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    ...........</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这行代码的第一段执行了一个<code>final int ParamCount = names.size();</code> 也就是先把参数的数量确认为了names的大小。</p>
<p>那么这个<strong>names</strong>又是什么呢？是<code>ParamNameResolver</code>类下的一个属性：<code>private final SortedMap&lt;Integer, String&gt; names;</code>也就是说，本质是一个map；</p>
<p><strong>names</strong>值的确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先拿到所有的参数</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">//以及参数的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// get names from @Param annotations  开始标注参数的索引</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// skip special parameters</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;<span class="comment">// 判断一下：如果当前参数的注解是param</span></span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;<span class="comment">//标记:拥有了注解值</span></span><br><span class="line">        name = ((Param) annotation).value();<span class="comment">//拿到param注解的value值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Param was not specified.</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);<span class="comment">//Jdk1.8</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());<span class="comment">//没标注解,name就是map的size</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(paramIndex, name);<span class="comment">//map每确定一个参数,就会增大一下</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//最终确定了names的值</span></span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说 names的确定流程：</p>
<ol>
<li>获取每个标注了@Param注解的参数的值，并且把这些值赋值给name（一个字符串）</li>
<li>接着每次解析一个参数，形成一个{key（参数索引），value（name的值}放到map中<ol>
<li>如果加了@Param注解，name的值就是注解值</li>
<li>没有标注@Param注解的话<ol>
<li>如果配置了  <code>useActualParamName（jdk1.8）</code> 那么 name=参数名</li>
<li>否则，name=map.size() 相当于元素索引</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>举个例子 来理解：对于<code>public Employee getEmpByIdAndLastName(@Param(&quot;id&quot;)Integer id, @Param(&quot;lastName&quot;)String lastName);</code>来说</p>
<p>由于id，lastName这两个属性前加了注解@Param，因此这俩的name值分别为：id和lastName，因此确定完names应该是：{0 : id, 1 : lastName}</p>
<p>假如再有另一个属性没加@Param注解，那最终的names应该是{0 : id, 1 : lastName, 2 : 2} （key=2,value=2)</p>
<hr>
<p>下面回到<code>getNamedParams</code>方法继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ParamCount = names.size();</span><br><span class="line"> <span class="comment">//如果参数为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || ParamCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//如果只有一个元素并且是没有@Param注解，就直接调用arg[0]，也就是单元素直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; ParamCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> args[names.firstkey()];</span><br><span class="line">  <span class="comment">//多个元素或者有@Param标注</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Map&lt;String, Object&gt; Param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//遍历names集合（该集合的确定在上文讲述过了）：names的values作为key；names集合的key作为取值的参考arg[0]:args[1,&quot;Tom&quot;]</span></span><br><span class="line">   <span class="comment">//比如：&#123;id=args[0]:1,lastName=args[1]:Tom&#125;</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">        Param.put(entry.getValue(), args[entry.getkey()]);</span><br><span class="line">  <span class="comment">//额外的将每一个参数也保存在map中，使用心得key：Param1...ParamN</span></span><br><span class="line">  <span class="comment">//因此，有Param注解也已使用#&#123;指定的key&#125;或者#&#123;Param1&#125;</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">          Param.put(genericParamName, args[entry.getkey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Param;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关于names集合遍历理解：</p>
<ul>
<li>首先我们有了一个names集合：{0:id, 1:lastName}和一个args（之前传入的参数列表）：【1，“Tom”】</li>
<li>接着新建了一个map我们称为Param，这个新map的key我们使用names集合中的value，而value我们得参数列表的值；举个例子就是，现在map应该为：{id:args[0] = 1, lastName : args[1] = “Tom”}、</li>
<li>同时啊，我们还贴心的将Param1，Param2….ParamN也做为了key与参数列表中的各个参数进行了映射封装进了map中，这样子以后不仅可以通过#{key}去获取值了，#{Param}也能取到值</li>
</ul>
<h2 id="参数值的获取（-与-）"><a href="#参数值的获取（-与-）" class="headerlink" title="参数值的获取（#{}与${}）"></a>参数值的获取（#{}与${}）</h2><p>主要探究<mark>#{}</mark>和<mark>${}</mark>的区别：</p>
<p>例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tbl_employee where id=$&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br></pre></td></tr></table></figure>

<p>控制台：Preparing: select * from tbl_employee where id=2 and last_name=?</p>
<p>我们发现使用了$的id能打印出来，而使用了#的属性就不能获取到；</p>
<ul>
<li><p>#{}:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入</p>
</li>
<li><p>${}:取出的值直接拼装在sql语句中；会有安全问题；</p>
<p>但我们仍有一些场景是能够去使用的：比如原生jdbc不支持占位符的地方我们就可以使用${}进行取值</p>
<p>按照年份分表拆分：select * from ${year}<br>排序：select * from tbl_employee order by ${f_name} ${order}</p>
</li>
</ul>
<h3 id="取参数的一些规则"><a href="#取参数的一些规则" class="headerlink" title="#{}取参数的一些规则"></a>#{}取参数的一些规则</h3><ul>
<li><p>参数位置支持的属性：</p>
<pre><code>javaType、 jdbcType、 mode（存储过程）、 numericScale、
resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；</code></pre></li>
<li><p>jdbcType通常需要在某种特定的条件下被设置：</p>
</li>
</ul>
<p>在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理，比如Oracle（报错）：<code>JdbcType OTHER：无效的类型；</code>因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;<br>由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；</p>
<p>两种办法进行解决：</p>
<ol>
<li>​    #{email,jdbcType=OTHER};</li>
<li>​    jdbcTypeForNull=NULL    <setting name="jdbcTypeForNull" value="NULL"></setting></li>
</ol>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//携带了哪个字段查询条件就带上这个字段的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByConditionIf</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">• if:判断</span></span><br><span class="line"><span class="comment">• choose (when, otherwise):分支选择；带了break的swtich-case</span></span><br><span class="line"><span class="comment">    如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个</span></span><br><span class="line"><span class="comment">• trim 字符串截取(where(封装查询条件), set(封装修改条件))</span></span><br><span class="line"><span class="comment">• foreach 遍历集合</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee</span><br><span class="line">        where</span><br><span class="line">            <span class="comment">&lt;!-- test：判断表达式（OGNL）</span></span><br><span class="line"><span class="comment">            OGNL参照PPT或者官方文档。</span></span><br><span class="line"><span class="comment">                   c:if  test</span></span><br><span class="line"><span class="comment">            从参数中取值进行判断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            遇见特殊符号应该去写转义字符：(转义字符可以在w3school中查询 html标签中）</span></span><br><span class="line"><span class="comment">            &amp;&amp;：&amp;amp;&amp;amp; 表示 and</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            /*<span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> = and*/</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==0 or gender==1&quot;</span>&gt;</span></span><br><span class="line">                and gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DynamciIFTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">        List&lt;Employee&gt; list = mapper.getEmpsByConditionIf(<span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">&quot;%e%&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308222402866.png" alt="image-20210308222402866"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210308222419630.png" alt="image-20210308222419630"></p>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>由于查询时候如果某些条件没带会出现<strong>SQL拼接问题</strong></p>
<p>因此有以下解决方案</p>
<ol>
<li><p>在where后添加<mark>1=1</mark>，以后的sql条件语句使用<strong>and xxx</strong></p>
</li>
<li><p>另一种方法是使用<strong>where标签</strong>去将所有的查询条件包括在内</p>
<p>也就是通过<mark>where标签</mark>与<mark>if标签</mark>配合使用来取代where条件</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">    <span class="comment">&lt;!-- where --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- test：判断表达式（OGNL）</span></span><br><span class="line"><span class="comment">        OGNL参照PPT或者官方文档。</span></span><br><span class="line"><span class="comment">               c:if  test</span></span><br><span class="line"><span class="comment">        从参数中取值进行判断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        遇见特殊符号应该去写转义字符：(转义字符可以在w3school中查询 html标签中）</span></span><br><span class="line"><span class="comment">        &amp;&amp;：&amp;amp;&amp;amp; 表示 and</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        /*<span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> = and*/</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">            and last_name like #&#123;lastName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">            and email=#&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==0 or gender==1&quot;</span>&gt;</span></span><br><span class="line">            and gender=#&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul>
<li><mark>trim标签</mark>是一个格式化的标签，可以完成set或者是where标记的功能</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309195726679.png" alt="image-20210309195726679"></p>
<p>trim标签的四个属性如上：</p>
<ol>
<li>prefix：前缀，该属性的值将会在拼接后的整个字符串作为前缀出现</li>
<li>prefixOverrides：前缀覆盖，会去掉字符串前面多余的字符</li>
<li>suffix：后缀，该属性的值将会在拼接后的整个字符串作为后缀出现</li>
<li>suffixOverrides：后缀覆盖，会去掉字符串后面多余的字符（可以用来去除多余的【逗号,】）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee</span><br><span class="line">        <span class="comment">&lt;!-- where --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            /*<span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> = and*/</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==0 or gender==1&quot;</span>&gt;</span></span><br><span class="line">                and gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--对比--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        --&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 自定义字符串的截取规则 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                last_name like #&#123;lastName&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null and email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- ognl会进行字符串与数字的转换判断  &quot;0&quot;==0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==0 or gender==1&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h2><p>类似于java中的 switch case进行分支选择</p>
<p>choose标签中 的case呢 则用了<strong>when标签</strong>，而default情况呢 则使用了<strong>otherwise标签</strong></p>
<p>下面模拟一个场景：</p>
<ul>
<li><p>假如我们想搜索的id不为空，那么执行的sql语句为：<code>select * from tbl_employee WHERE id=?</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309202705115.png" alt="image-20210309202705115"></p>
</li>
<li><p>假如我们想搜索的lastname不为空，执行<code>select * from tbl_employee WHERE last_name like ?</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309202637465.png" alt="image-20210309202637465"></p>
</li>
<li><p>假如我们想搜索的email不为空，则执行<code>select * from tbl_employee WHERE email = ?</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309202749417.png" alt="image-20210309202749417"></p>
</li>
<li><p>都为空，则执行<code>select * from tbl_employee WHERE gender = 0</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309202815040.png" alt="image-20210309202815040"></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- public List&lt;Employee&gt; getEmpsByConditionChoose(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null&quot;</span>&gt;</span></span><br><span class="line">                last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                gender = 0</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>关于set这个标签，我们是在更新状态中使用，也就是实现<strong>动态更新</strong>的效果（满足某种条件去对应更新）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--set 动态更新--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--public void updateEmp(Employee employee);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Set标签的使用 --&gt;</span></span><br><span class="line">    update tbl_employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null&quot;</span>&gt;</span></span><br><span class="line">            last_name=#&#123;lastName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">            email=#&#123;email&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender!=null&quot;</span>&gt;</span></span><br><span class="line">            gender=#&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Trim：更新拼串</span></span><br><span class="line"><span class="comment">            update tbl_employee</span></span><br><span class="line"><span class="comment">            &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;if test=&quot;lastName!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">                    last_name=#&#123;lastName&#125;,</span></span><br><span class="line"><span class="comment">                &lt;/if&gt;</span></span><br><span class="line"><span class="comment">                &lt;if test=&quot;email!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">                    email=#&#123;email&#125;,</span></span><br><span class="line"><span class="comment">                &lt;/if&gt;</span></span><br><span class="line"><span class="comment">                &lt;if test=&quot;gender!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">                    gender=#&#123;gender&#125;</span></span><br><span class="line"><span class="comment">                &lt;/if&gt;</span></span><br><span class="line"><span class="comment">            &lt;/trim&gt;</span></span><br><span class="line"><span class="comment">            where id=#&#123;id&#125;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collection</td>
<td>表示迭代集合的名称，可以使用@Param注解指定，如下图所示 该参数为必选<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309204419205.png" alt="image-20210309204419205"></td>
</tr>
<tr>
<td>item</td>
<td>表示本次迭代获取的元素，若collection为List、Set或者数组，则表示其中的元素；若collection为map，则代表key-value的value，该参数为必选</td>
</tr>
<tr>
<td>open</td>
<td>表示该语句以什么开始，最常用的是左括弧’(’，注意:mybatis会将该字符拼接到整体的sql语句之前，并且只拼接一次，该参数为可选项</td>
</tr>
<tr>
<td>close</td>
<td>表示该语句以什么结束，最常用的是右括弧’)’，注意:mybatis会将该字符拼接到整体的sql语句之后，该参数为可选项</td>
</tr>
<tr>
<td>separator</td>
<td>mybatis会在每次迭代后给sql语句append上separator属性指定的字符，该参数为可选项</td>
</tr>
<tr>
<td>index</td>
<td>在list、Set和数组中,index表示当前迭代的位置，在map中，index代指是元素的key，该参数是可选项。</td>
</tr>
</tbody></table>
<h3 id="foreach查询"><a href="#foreach查询" class="headerlink" title="foreach查询"></a>foreach查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询员工id&#x27;在给定集合中的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByConditionForeach</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span>List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids);  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionForeach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        collection：指定要遍历的集合：</span></span><br><span class="line"><span class="comment">            list类型的参数会特殊处理封装在map中，map的key就叫list</span></span><br><span class="line"><span class="comment">        item：将当前遍历出的元素赋值给指定的变量</span></span><br><span class="line"><span class="comment">        separator:每个元素之间的分隔符</span></span><br><span class="line"><span class="comment">        open：遍历出所有结果拼接一个开始的字符</span></span><br><span class="line"><span class="comment">        close:遍历出所有结果拼接一个结束的字符</span></span><br><span class="line"><span class="comment">        index:索引。遍历list的时候是index就是索引，item就是当前值</span></span><br><span class="line"><span class="comment">                      遍历map的时候index表示的就是map的key，item就是map的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #&#123;变量名&#125;就能取出变量的值也就是当前遍历出的元素</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item_id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">open</span>=<span class="string">&quot;where id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item_id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DynamicForEachTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        List&lt;Employee&gt; TestList = mapper.getEmpsByConditionForeach(list);</span><br><span class="line">        <span class="keyword">for</span>(Employee e : TestList) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库表中id：1 2 5,测试结果为2条数据 正确</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309205209258.png" alt="image-20210309205209258"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309205142077.png" alt="image-20210309205142077"></p>
<h3 id="foreach-批量保存"><a href="#foreach-批量保存" class="headerlink" title="foreach 批量保存"></a>foreach 批量保存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 批量保存 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--public void addEmps(@Param(&quot;emps&quot;)List&lt;Employee&gt; emps);  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line">      insert into tbl_employee(last_name, email, gender, d_id)</span><br><span class="line">      values</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">          (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMultiQueries=true；</span></span><br><span class="line"><span class="comment">	这种分号分隔多个sql可以用于其他的批量操作（删除，修改） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;insert id=&quot;addEmps&quot;&gt;</span></span><br><span class="line"><span class="comment">	&lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt;</span></span><br><span class="line"><span class="comment">		insert into tbl_employee(last_name,email,gender,d_id)</span></span><br><span class="line"><span class="comment">		values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span></span><br><span class="line"><span class="comment">	&lt;/foreach&gt;</span></span><br><span class="line"><span class="comment">&lt;/insert&gt; --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchSave</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">        List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        emps.add(<span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">&quot;smith0x1&quot;</span>, <span class="string">&quot;606@qq.com&quot;</span>, <span class="string">&quot;1&quot;</span>,<span class="keyword">new</span> Department(<span class="number">1</span>)));</span><br><span class="line">        emps.add(<span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">&quot;allen0x1&quot;</span>, <span class="string">&quot;111@qq.com&quot;</span>, <span class="string">&quot;0&quot;</span>,<span class="keyword">new</span> Department(<span class="number">1</span>)));</span><br><span class="line">        mapper.addEmps(emps);</span><br><span class="line">        openSession.commit();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309210642528.png" alt="image-20210309210642528"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309210651516.png" alt="image-20210309210651516"></p>
<h2 id="两个内置参数"><a href="#两个内置参数" class="headerlink" title="两个内置参数"></a>两个内置参数</h2><ul>
<li>_parameter：表示真个参数</li>
<li>_databaseId：表示当前数据库的别名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个内置参数：</span></span><br><span class="line"><span class="comment">   不只是方法传递过来的参数可以被用来判断，取值。。。</span></span><br><span class="line"><span class="comment">   mybatis默认还有两个内置参数：</span></span><br><span class="line"><span class="comment">   _parameter:代表整个参数</span></span><br><span class="line"><span class="comment">      单个参数：_parameter就是这个参数</span></span><br><span class="line"><span class="comment">      多个参数：参数会被封装为一个map；_parameter就是代表这个map</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   _databaseId:如果配置了databaseIdProvider标签。</span></span><br><span class="line"><span class="comment">      _databaseId就是代表当前数据库的别名oracle</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee);  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsTestInnerParameter&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line">         select * from tbl_employee</span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line">            where last_name == #&#123;lastName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">         select * from employees</span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line">            where last_name == #&#123;_parameter.lastName&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><ul>
<li>bind标签中，value对应传入实体类的某个字段，name属性既给对应字段取的变量名。在value属性中可以使用字符串拼接等特殊处理。</li>
</ul>
<p>以上述场景为例，如果要想使用like进行模糊查询：<code>where last_name lile &#39;%#&#123;lastNmae&#125;%&#39;</code> 这样写 是不可以的，需要将lastName绑定成一个变量传进去：<code>&lt;bind name=&quot;xxx&quot; value=&quot;&#39;%&#39;+ id + &#39;%&#39;&quot;/&gt;</code></p>
<p>其中，不仅仅可以写成 % +  id + % ，也可以写成_ + id + % ，看需求变化；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee);  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsTestInnerParameter&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hpg.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;_lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27;+lastName+&#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line">            select * from tbl_employee</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line">                where last_name like #&#123;_lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">            select * from employees</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter!=null&quot;</span>&gt;</span></span><br><span class="line">                where last_name like #&#123;_parameter.lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="sql标签-抽取-重用"><a href="#sql标签-抽取-重用" class="headerlink" title="sql标签 - 抽取/重用"></a>sql标签 - 抽取/重用</h2><p>抽取可重用的sql片段。方便后面引用 </p>
<ol>
<li>sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用</li>
<li>include来引用已经抽取的sql：</li>
<li>include还可以自定义一些property，sql标签内部就能使用自定义的属性<ol>
<li>nclude-property：取值的正确方式${prop},</li>
<li>#{不能使用这种方式}</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">  			employee_id,last_name,email</span><br><span class="line">  		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line">  			last_name,email,gender,d_id</span><br><span class="line">  		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line"> 	insert into tbl_employee(</span><br><span class="line"> 		<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"> 	) </span><br><span class="line">	values</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">		(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="缓存（重点）"><a href="#缓存（重点）" class="headerlink" title="缓存（重点）"></a>缓存（重点）</h1><ul>
<li>Mybatis包含了一个时分强大的查询缓存特性，可以非常方便的配置和定制；缓存的作用呢，是可以极大的<strong>提升查询效率</strong></li>
<li>Mybatis系统默认定义了<mark>两级缓存(一级缓存和二级缓存）</mark><ul>
<li>默认情况下，只有一级缓存（SqlSession级别的缓存，AKA本地缓存）开启</li>
<li>二级缓存需要手动的去开启和配置，是基于<strong>namespace</strong>级别的缓存</li>
<li>为了提高扩展石呢，MYbatis定义了<strong>缓存接口Cache</strong>，因此我们可以通过实现这个接口去自定义我们的二级缓存</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310210359313.png" alt="image-20210310210359313"></p>
<h2 id="两级缓存"><a href="#两级缓存" class="headerlink" title="两级缓存"></a>两级缓存</h2><p>缓存分为：一级缓存和二级缓存</p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><ul>
<li><strong>一级缓存（本地缓存）</strong>：与数据库同一次会话期间查询到的数据会放到<strong>本地缓存</strong>中，之后若需要获取相同数据，则可以直接从缓存去获取，没必要去查询数据库了</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1254583-20171026214546023-1354746770.png" alt="img"></p>
<p>下面进行一个测试去体会一下：</p>
<p>对于同一个请求，我们执行两次，却发现，只执行了第一次的sql；</p>
<p>第二次的数据是直接获取到的。是从哪里获取的呢？答案就是<strong>一级缓存</strong>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFirstLevelCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        Employee emp01 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp01);</span><br><span class="line"></span><br><span class="line">        Employee emp02 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp02);</span><br><span class="line">        </span><br><span class="line">        System.out.println(emp01==emp02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//openSession2.close();</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210309215628869.png" alt="image-20210309215628869"></p>
<ul>
<li>那么我们不由得就会产生一个疑问了，什么场景下我们的一级缓存不再适用了呢？</li>
</ul>
<ol>
<li><p>sqlSession不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSession openSession2 = sqlSessionFactory.openSession();</span><br><span class="line">EmployeeMapper mapper2 = openSession2.getMapper(EmployeeMapper.class);</span><br><span class="line">Employee empTest = mapper.getEmpById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用的sqlSession相同</p>
<ol>
<li><p>但查询条件不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee emp01 = mapper.getEmpById(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但两次查询之间执行了一次CRU（增删改）操作（因为有可能会导致数据受到影响）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.addEmp(<span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">&quot;testCache&quot;</span>, <span class="string">&quot;cache&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>但手动清除过了一级缓存（缓存清空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openSession.clearCache();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ul>
<li>一个一级缓存的<strong>生命周期</strong>有多长呢？<ul>
<li>MyBatis在开启一个数据库会话时，会 创建一个新的<mark>SqlSession</mark>对象，<mark>SqlSession</mark>对象中会有一个新的<mark>Executor</mark>对象。<mark>Executor</mark>对象中持有一个新的<mark>PerpetualCache</mark>对象；当会话结束时，<mark>SqlSession</mark>对象及其内部的<mark>Executor</mark>对象还有<mark>PerpetualCache</mark>对象也一并释放掉。</li>
<li>如果<mark>SqlSession</mark>调用了<mark>close()</mark>方法，会释放掉一级缓存<mark>PerpetualCache</mark>对象，一级缓存将不可用。</li>
<li>如果<mark>SqlSession</mark>调用了<mark>clearCache()</mark>，会清空<mark>PerpetualCache</mark>对象中的数据，但是该对象仍可使用。</li>
<li><mark>SqlSession</mark>中执行了任何一个<mark>update操作(update()、delete()、insert())</mark> ，都会清空<mark>PerpetualCache</mark>对象的数据，但是该对象可以继续使用</li>
</ul>
</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>为什么要有二级缓存呢？肯定是一级缓存有一定的不足，需要一个补丁或者是进化版缓存去弥补啦；</p>
<ul>
<li><p><strong>二级缓存（全局缓存）</strong>：基于namespace级别的缓存，即一个namespace对应一个二级缓存</p>
</li>
<li><p>工作机制</p>
<ul>
<li>一个会话，去查询一条数据，这个数据会被放在当前会话的<strong>一级缓存中</strong></li>
<li>会话关闭了，一级缓存的数据就会被保存到二级缓存中，这时候有一个新的会话去查询信息，就可以参照二级缓存去查了；</li>
<li>一个sqlSession去开启两个Mapper，两个Mapper又各自对应不同的对象，此时这两个对象是放在不同的二级缓存中的（因为一个namespace对应一个二级缓存）</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1254583-20171029185910164-1823278112.png" alt="img"></p>
<h4 id="二级缓存的使用"><a href="#二级缓存的使用" class="headerlink" title="二级缓存的使用"></a>二级缓存的使用</h4><ul>
<li><p>开启方式：在全局配置文件中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方式：哪个mapper文件要使用，就在哪个mapper文件中添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>cache</code>标签的几个属性</p>
<ul>
<li><p><strong>eviction</strong>：缓存的回收策略</p>
<ul>
<li><mark>LRU</mark> - 最近最少使用的:移除最长时间不被使用的对象。</li>
<li><mark>FIFO</mark> - 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li><mark>SOFT</mark> - 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li><mark>WEAK</mark> - 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
</li>
<li><p><strong>flushIntercal</strong>：缓存刷新间隔。可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</p>
</li>
<li><p><strong>readOnly</strong>：是否只读。属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</p>
<ul>
<li><p>true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。</p>
<p>mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快</p>
</li>
<li><p>false：非只读：mybatis觉得获取的数据可能会被修改。</p>
<p>mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢</p>
</li>
</ul>
</li>
<li><p><strong>size</strong>：引用数目，可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</p>
</li>
<li><p><strong>type</strong>：指定自定义的全类名，实现Cache接口即可；</p>
</li>
</ul>
</li>
<li><p>要想实现缓存，我们的POJO类（不是Mapeer类）就需要去实现<strong>序列化接口（Serializable）</strong></p>
<p>如果不实现的话：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310204032410.png" alt="image-20210310204032410"></p>
</li>
</ul>
<p>下面进行下测试：</p>
<p>当不开启缓存的时候：发送了两次sql</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310204214966.png" alt="image-20210310204214966"></p>
<p>当开启缓存的时候：只发送了一次sql 同时可以发现一句话：<code>Cache Hit Ratio</code> 也就是缓存命中了 后面的0.5是什么意思呢？<br>代表着第二次查缓存命中了，即 1/2 = 0.5 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310204140122.png" alt="image-20210310204140122"></p>
<p>ps：需要注意的是，查出来的数据都会被默认先放在一级缓存中，只有当会话提交或者关闭之后，一级缓存中的数据才会转移到二级缓存</p>
<p>也就是说，假如上述的例子。第一个sqlSession是在建立第二个sqlSession之后才关闭的，就算开启了二级缓存，那么照样会发送2条sql</p>
<h2 id="缓存相关设置"><a href="#缓存相关设置" class="headerlink" title="缓存相关设置"></a>缓存相关设置</h2><ul>
<li><p><mark>cacheEnabled=true：false</mark>：关闭缓存（<strong>二级</strong>缓存关闭）(一级缓存一直可用的)</p>
</li>
<li><p>在mapper配置中，每个<strong>select标签</strong>都有一个<code>useCache = &quot;true&quot;</code>.那么假如设置为false是设置一级缓存还是二级缓存为false呢？</p>
<p>答案是：一级缓存还能正常使用，二级缓存被禁止了</p>
</li>
<li><p>每个<strong>增删改</strong>标签中有 <code>flushCache=&quot;true&quot;</code> （刷新缓存）：表示每次增删改执行之后 就会清除缓存（一级二级缓存都会被清除）</p>
<p>每个<strong>查询</strong>标签中<code>flushCache=&quot;false&quot;</code>假如设置为true，则每次查询之前都会清除缓存</p>
</li>
<li><p><code>sqlSession.clearCache()</code>只清除当前session的一级缓存</p>
</li>
<li><p>localCacheScope：本地缓存作用域</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310205858366.png" alt="image-20210310205858366"></p>
<ul>
<li>一级缓存SESSION：当前会话的所有数据保存在会话缓存中；</li>
<li>STATEMENT：可以禁用一级缓存；       </li>
</ul>
</li>
</ul>
<h1 id="Mybatis与Spring进行整合"><a href="#Mybatis与Spring进行整合" class="headerlink" title="Mybatis与Spring进行整合"></a>Mybatis与Spring进行整合</h1><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 <strong>mapper</strong> 和 <strong><code>SqlSession</code></strong> 并注入到 <strong>bean</strong> 中，以及将 Mybatis 的异常转换为 Spring 的 <code>DataAccessException</code>。 最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p>
<p>（之后再补）</p>
<h1 id="Mybatis运行原理"><a href="#Mybatis运行原理" class="headerlink" title="Mybatis运行原理"></a>Mybatis运行原理</h1><ul>
<li>MyBatis层次图</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210310212828706.png" alt="image-20210310212828706"></p>
<p>首先我们回顾一下运用Mybatis来执行CRUD的几个步骤：</p>
<ol>
<li><p>获取SqlSessionFacroty对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取SqlSession对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession openSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取接口的实现对象（接口的代理对象MapperProxy）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行CRUD方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>下面就根据这4步，来仔细看看源码，探究下每一步都发生了什么事情</p>
<h2 id="SqlSessionFacroty初始化"><a href="#SqlSessionFacroty初始化" class="headerlink" title="SqlSessionFacroty初始化"></a>SqlSessionFacroty初始化</h2><p>首先把一个配置文件转成流的形式，把这个流作为参数传到下列方法即可获取到一个SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>那么其本质是怎么运作的呢？我们进入<code>biuld</code>方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现其实呢 他调用的是自己的<code>biuld</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来代码很多，但是真正执行的关键部分是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line"><span class="keyword">return</span> build(parser.parse());</span><br></pre></td></tr></table></figure>
<ol>
<li>通过调用 XMLConfigBuilder（对mybatsi的配置文件进行解析的类）的parse方法</li>
<li>将上一步获取到的元素作为参数传入biuld方法，返回值</li>
</ol>
<p>那么下面探究一下这个<strong>XMLConfigBuilder</strong>参数解析器类的<strong>parse()</strong>方法，我们step in：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//这里的/configuration 对应的是全局配置文件中的 /configuration标签</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的核心代码（如下）又做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//这里的/configuration 对应的是全局配置文件中的 /configuration标签</span></span><br><span class="line">parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中<code>parser.evalNode(&quot;/configuration&quot;)</code>是获取了一个根结点</p>
<p>我们进入这个<code>parseConfiguration</code> 类看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//issue #117 read properties first</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里发现了很多我们很眼熟的标签：properties，typeAliases，environments，mappers</p>
<p>这不由得让我们思考：这段代码与xml中的标签是否有关呢？答案是肯定的</p>
<ul>
<li>这段代码的作用是：解析每一个<strong>标签</strong>，把其中详细的信息保存在<strong>Configuration</strong>中</li>
</ul>
<p>那么又是怎么解析的呢？我们点进<code>mapperElement(root.evalNode(&quot;mappers&quot;));</code>看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">//如果使用package标签</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果不是的话（比如使用了mapper标签）</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">          <span class="comment">//以  &lt;mapper resource=&quot;com/hpg/mapper/EmployeeMapper.xml&quot;/&gt; 为例</span></span><br><span class="line">          <span class="comment">//我们就会进入这个方法</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">            <span class="comment">//得到一个流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">//用了一个XMLMApper的解析器 传进来</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            <span class="comment">//使用parse方法进行解析</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，上面我们说到了使用<code>mapperParser.parse();</code>方法进行解析，我们继续Step in 再看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的第一行：<code>configurationElement(parser.evalNode(&quot;/mapper&quot;));</code> 又是干嘛的呢？我们继续Step in’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取命名空间namespace</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//set方法注入</span></span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">      <span class="comment">//如果写了缓存 就把缓存set入节点</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是解析各种标签，我们以  <code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>为例，探究一下是如何解析增删改查标签的</p>
<p>我们首先看<code>context.evalNodes(&quot;select|insert|update|delete&quot;)</code>部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;XNode&gt; <span class="title">evalNodes</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> xpathParser.evalNodes(node, expression);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的返回值是一个List，也就是得到了一个增删改查所有标签的LIst</p>
<p>接着通过<code>buildStatementFromContext()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断全局配置中是否配置了DatabaseId</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//配置了 则把databaseid作为参数</span></span><br><span class="line">    buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//否则参数为null</span></span><br><span class="line">  buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管databaseId是否为空，我们都需要调用<code>buildStatementFromContext()</code>这个方法 我们Step in</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">    <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statementParser.parseStatementNode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">      configuration.addIncompleteStatement(statementParser);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先呢，创建了一个XMLStatementBuilder对象，这个对象的用途是将用户的<mark>CRUD</mark>配置解析成对应的<strong><code>MappedStatement</code>对象.</strong></p>
<p>关于<code>MappedStatement</code>对象：</p>
<p><img src="https://www.h5w3.com/wp-content/uploads/2020/05/17259403d2ef5002.png" alt="MappedStatement"></p>
<p>接着，通过这个对象调用<code>statementParser.parseStatementNode();</code>方法 </p>
<p>将mapper.xml中的每一个<strong>元素信息</strong>解析出来并且保存在<strong>configuration</strong>类（全局配置）中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....省略前面的代码。前面代码的作用就是将 XNode（结点）类型值 contex 的值取出来并且赋值给、</span></span><br><span class="line">    <span class="comment">//id,sqlSource...等等标签元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//再通过下列方法 传入参数去获取一个什么呢？我们进入方法看看</span></span><br><span class="line">  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">      resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入<code>builderAssistant.addMappedStatement</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    SqlSource sqlSource,</span></span></span><br><span class="line"><span class="function"><span class="params">    StatementType statementType,</span></span></span><br><span class="line"><span class="function"><span class="params">    SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer fetchSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    String parameterMap,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="function"><span class="params">    String resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="function"><span class="params">    KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">    String keyProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">    String keyColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">    String databaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">    LanguageDriver lang,</span></span></span><br><span class="line"><span class="function"><span class="params">    String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Cache-ref not yet resolved&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">  MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">      .resource(resource)</span><br><span class="line">      .fetchSize(fetchSize)</span><br><span class="line">      .timeout(timeout)</span><br><span class="line">      .statementType(statementType)</span><br><span class="line">      .keyGenerator(keyGenerator)</span><br><span class="line">      .keyProperty(keyProperty)</span><br><span class="line">      .keyColumn(keyColumn)</span><br><span class="line">      .databaseId(databaseId)</span><br><span class="line">      .lang(lang)</span><br><span class="line">      .resultOrdered(resultOrdered)</span><br><span class="line">      .resultSets(resultSets)</span><br><span class="line">      .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">      .resultSetType(resultSetType)</span><br><span class="line">      .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">      .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">      .cache(currentCache);</span><br><span class="line"></span><br><span class="line">  ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">  <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MappedStatement statement = statementBuilder.build();</span><br><span class="line">  configuration.addMappedStatement(statement);</span><br><span class="line">  <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入这个方法，看到前面的所有代码都是为了下面这三句代码服务的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MappedStatement statement = statementBuilder.build();</span><br><span class="line">configuration.addMappedStatement(statement);</span><br><span class="line"><span class="keyword">return</span> statement;</span><br></pre></td></tr></table></figure>

<p>我们首先看看第一句，鼠标放在satement对象上，看看里面都有哪些信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedStatement statement = statementBuilder.build();</span><br></pre></td></tr></table></figure>

<p>从下图，我们可以发现，一个MappedStatement保存了一个增删改查标签的详细信息</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311162130714.png" alt="image-20210311162130714"></p>
<p>第二句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.addMappedStatement(statement);</span><br></pre></td></tr></table></figure>

<p>将我们辛辛苦苦创建出来的statement对象，存到了configuration对象中；</p>
<p>还记得我们一开始从哪个方法进来的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>对的，这个代码又是在哪里被执行的呢？<code>parseConfiguration(parser.evalNode(&quot;/configuration&quot;));</code></p>
<p>mapper解析完了意味着这个方法也跑完了，最后我们就获取了一个configuration</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//这里的/configuration 对应的是全局配置文件中的 /configuration标签</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以来看看这个configuration到底保存了什么</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311163720603.png" alt="image-20210311163720603"></p>
<p>我们仅仅是拿了一个解析CRUD标签为例，但肯定是不止解析了CRUD标签的，由此我们可以推断：</p>
<ul>
<li>这个configuration类保存了<strong>所有配置文件的</strong>详细信息</li>
</ul>
<p>在这个类中有两个重要属性：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311164432459.png" alt="image-20210311164432459"></p>
<p>当然了，还没完，我们获取到了configuration后，按照流程走的话，调用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line"><span class="keyword">return</span> build(parser.parse());</span><br></pre></td></tr></table></figure>

<p>或者换句话说，其实调用的是<code>build(configuration);</code>  因为本质上传的参数就是我们的configuration嘛</p>
<p>其中这个biuld方法的返回值，是一个DefaultSqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个DefaultSqlSessionFactory也就是我们最后的返回值了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，大功告成，我们明白了，原来SqlSessionFactory初始化这一步的最终结果就是获取了一个DefaultSqlSessionFactory</p>
<ul>
<li>我们用一张图来总结一下流程</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311165446964.png" alt="image-20210311165446964"></p>
<h2 id="获取SqlSession对象"><a href="#获取SqlSession对象" class="headerlink" title="获取SqlSession对象"></a>获取SqlSession对象</h2><p>我们知道，获取SqlSession的方法是调用了SqlSession类中的openSession()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数的获取<code>configuration.getDefaultExecutorType()</code>  如下 默认是SIMPLE</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311170245338.png" alt="image-20210311170245338"></p>
<p>我们进入这个方法看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">//通过transactionFactory这个类我们也可以知道，【tx】这个类应该与事务有点关系</span></span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//接着通过newExecutor方法去获取一个Executor类对象</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step in <code>newExecutor(tx, execType);</code> 看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来啊，这个方法是通过Executor在全局配置中的类型，去创建以下三种类型的<strong>执行器Executor</strong></p>
<ol>
<li>BatchExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li>
<li>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li>
<li>SimpleExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li>
</ol>
<ul>
<li>这些执行器的特点，严格限制在SqlSession的生命周期范围内</li>
</ul>
<p>同时，根据有没有配置二级缓存，去决定是否包装成一个<strong>CachingExecutor</strong></p>
<p>接着执行很重要的一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<p>进入这个方法，我们发现其作用是使用每一个<strong>拦截器</strong>重新包装executor并且返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述全部执行完后，执行完</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br></pre></td></tr></table></figure>

<p>后，执行的就应该是下列代码，new了一个DefaultSqlSession （包含了configuration和execut）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br></pre></td></tr></table></figure>

<p>并且返回这个SqlSession，至此，我们成功获取到了SqlSession对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311171747802.png" alt="image-20210311171747802"></p>
<h2 id="接口的代理对象MapperProxy生成"><a href="#接口的代理对象MapperProxy生成" class="headerlink" title="接口的代理对象MapperProxy生成"></a>接口的代理对象MapperProxy生成</h2><p>我们知道，Mapper代理对象是由SqlSession生成，那么我们进入DefaultSqlSession查看其中的getMapper方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入<code>configuration.getMapper(type, this);</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是通过mapperRegistry（上文其实有提及过）的getMapper方法获取代理对象的，我们继续Step in</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过这第一行代码，通过传入type（接口类型）生成了一个代理对象的工厂</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//通过这个工程的newInstance方法,传入sqlSession，获得一个</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先生成一个代理对象的工厂对象</li>
<li>通过这个工厂的方法去进行下一步</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成了一个MapperProxy 这个代理实现了InvocationHandler的接口</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="comment">//接着又生成了什么呢？</span></span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们step in这重载的newInstance方法看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于，我们守得云开见月明，发现其本质就是调用了jdk中的newProxyInstance动态代理方法，为我们生成了一个<strong>MapperProxy</strong>的代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">                                ? <span class="keyword">null</span></span><br><span class="line">                                : Reflection.getCallerClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class and its constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，返回一个接口的代理对象，结束；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311194212629.png" alt="image-20210311194212629"></p>
<h2 id="CRUD的执行（以查询为例）"><a href="#CRUD的执行（以查询为例）" class="headerlink" title="CRUD的执行（以查询为例）"></a>CRUD的执行（以查询为例）</h2><p>以下列代码为例，我们继续Step in</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>首先，我们进入的是MapperProxy的invoke方法，其中将传入的方法包装成了一个MapperMthod，通过这个类的execute方法去执行我们调用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//method 是我们要走的方法getEmpById</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//在这里 把我们要走的method包装成了MapperMethod</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">//再调用包装后的MapperMethod的execute方法 此时会传入sqlSession</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们继续step in这个execute方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">    <span class="comment">//根据我们的标签的不同 我们进入不同的方法</span></span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">          <span class="comment">//在这里我们是选择 于是进入这个方法</span></span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//如果返回多个对象的话</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">          <span class="comment">//如果返回一个map的话</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">          <span class="comment">//如果返回一个cursor游标的话</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其余 我们这里返回一个对象 因此走这个方法</span></span><br><span class="line">          <span class="comment">//下列方法是不是很眼熟？没错 前面的参数解析部分我们也调用了这个方法</span></span><br><span class="line">          <span class="comment">//其本质就是将我们所传进来的参数，转换成sql中能用的参数</span></span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">          result = Optional.ofNullable(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">        + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先进行了方法的选择，之后将我们的参数解析包装成了sql中的参数，之后，调用sqlSession的selectOne方法（因为我们这里是查询单个嘛，如果是查询多个就是<code>executeForMany</code>了，视情况而定；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>

<p>我们step in这个<code>selectOne</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t首先通过：<code>List&lt;T&gt; list = this.selectList(statement, parameter);</code> 创建了一个list，然后根据list的大小进相应的操作；那这个selectList又进行了什么操作呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//通过全局配置中的getMappedStatement获得了 关于增删改查的全部详细信息</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">//调用执行器executor的 query方法</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过全局配置中的getMappedStatement获得了 关于增删改查的全部详细信息</p>
</li>
<li><p>接着调用执行器executor的方法，其中传入的参数 ms我们知道是一个MappedStatement对象，那后面的<code>wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER</code>又是什么呢？我们不妨看看</p>
<ol>
<li><pre><code class="java"><span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;
  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;
    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;&gt;();
    map.put(<span class="string">"collection"</span>, object);
    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;
      map.put(<span class="string">"list"</span>, object);
    &#125;
    <span class="keyword">return</span> map;
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;
    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;&gt;();
    map.put(<span class="string">"array"</span>, object);
    <span class="keyword">return</span> map;
  &#125;
  <span class="keyword">return</span> object;
&#125;
&lt;!--code￼<span class="number">154</span>--&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<p>首先通过mapperstatement获取了boundSql，这个类含有sql语句、参数映射等信息 总的来说 这是一个包含了sql详细信息的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sql语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">//参数映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311204437669.png" alt="image-20210311204437669"></p>
<p>接着第二步<code>CacheKey key = this.createCacheKey(ms, parameterObject, rowBounds, boundSql);</code> 得到了一个缓存</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311204742284.png" alt="image-20210311204742284"></p>
<p>获取完<strong>boundSql</strong>和<strong>CacheKey</strong>后，执行<code>query</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了<strong>Executor</strong>的<strong>query</strong>方法；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311205120391.png" alt="image-20210311205120391"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">      <span class="comment">//首先从本地缓存中通过key获取list</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//list不为空 即缓存中有存</span></span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        <span class="comment">//否则就调用真正的query方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先从本地缓存中通过key 拿到list；第一次调用的话，key应该是null，因此无法从缓存中获取</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311205400264.png" alt="image-20210311205400264"></p>
</li>
<li><p>若缓存中没有list，则调用真正的query方法： <code>list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中通过   <code>list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</code>创建list，且通过  <code>localCache.putObject(key, list);</code> 将list放入本地缓存中</p>
</li>
</ol>
<p>下面进入doQery方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//首先拿到一个全局配置</span></span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">//调用了newStatementHandler方法获得了Mybatsi的四大组件之一</span></span><br><span class="line">      <span class="comment">//这个组件负责操作Statement对象与数据库进行交流</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步：创建StatementHandler</p>
<p><code>StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//statementHandler在此处被创建出来</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先走第一步：<code>StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//根据mapperstatement中存储的statement的类型进行切换（type的设置在mapper文件中写sql语句可选择配）</span></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">          <span class="comment">//type = STATEMENT 非预编译形式</span></span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//type = PREPARED 预编译形式 这是默认的</span></span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//type = CALLABLE</span></span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>会走预编译形式 的执行器的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PreparedStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>然后走第二步：<code>statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</code></p>
<p>包装拦截器 之前也有讲过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：<code>stmt = prepareStatement(handler, ms.getStatementLog());</code> 通过这个方法，创建出了原生的<strong>Statement对象</strong>；继续step in：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">  Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">//通过handler进行参数预编译 设置到statemtnt对象中</span></span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">//调用ParameterHandler去设置参数</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>进入parameterize方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  private final StatementHandler delegate;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>本质上调用了<strong>StatementHandler</strong>的<strong>parameterize</strong>方法</p>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PreparedStatementHandler extends BaseStatementHandler</span></span><br><span class="line"><span class="comment">//BaseStatementHandler implements StatementHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//  protected final ParameterHandler parameterHandler; 调用的是ParameterHandler的方法</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有人会好奇，这个ParameterHandler是什么时候创建的呢？答案是在BaseStatementHandler被创建时就创建了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> .....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看这个ParameterHandler 他是一个接口，有着我们想要的setParameters 即 设置参数方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是由<code>public class DefaultParameterHandler implements ParameterHandler</code>类 去实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//获得类型处理器</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用类型处理器的setParameter方法 把预编译语句 下标 值 类型 传进去</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>第三步：<code>return handler.query(stmt, resultHandler);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//将语句转成预编译语句</span></span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">  ps.execute();</span><br><span class="line">    <span class="comment">//使用resultSetHandler去封装处理结果</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>execute()方法：（看不看得懂是一回事，先放上来…）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkClosed().getConnectionMutex()) &#123;</span><br><span class="line">      </span><br><span class="line">        MySQLConnection locallyScopedConn = <span class="keyword">this</span>.connection;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.doPingInstead &amp;&amp; !checkReadOnlySafeStatement()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;PreparedStatement.20&quot;</span>) + Messages.getString(<span class="string">&quot;PreparedStatement.21&quot;</span>),</span><br><span class="line">                    SQLError.SQL_STATE_ILLEGAL_ARGUMENT, getExceptionInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        ResultSetInternalMethods rs = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">this</span>.lastQueryIsOnDupKeyUpdate = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retrieveGeneratedKeys) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastQueryIsOnDupKeyUpdate = containsOnDuplicateKeyUpdateInSQL();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">this</span>.batchedGeneratedKeys = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">        resetCancelledState();</span><br><span class="line">      </span><br><span class="line">        implicitlyCloseAllOpenResults();</span><br><span class="line">      </span><br><span class="line">        clearWarnings();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.doPingInstead) &#123;</span><br><span class="line">            doPingInstead();</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        setupStreamingTimeout(locallyScopedConn);</span><br><span class="line">      </span><br><span class="line">        Buffer sendPacket = fillSendPacket();</span><br><span class="line">      </span><br><span class="line">        String oldCatalog = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (!locallyScopedConn.getCatalog().equals(<span class="keyword">this</span>.currentCatalog)) &#123;</span><br><span class="line">            oldCatalog = locallyScopedConn.getCatalog();</span><br><span class="line">            locallyScopedConn.setCatalog(<span class="keyword">this</span>.currentCatalog);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Check if we have cached metadata for this query...</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        CachedResultSetMetaData cachedMetadata = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (locallyScopedConn.getCacheResultSetMetadata()) &#123;</span><br><span class="line">            cachedMetadata = locallyScopedConn.getCachedMetaData(<span class="keyword">this</span>.originalSql);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        Field[] metadataFromCache = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (cachedMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            metadataFromCache = cachedMetadata.fields;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">boolean</span> oldInfoMsgState = <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retrieveGeneratedKeys) &#123;</span><br><span class="line">            oldInfoMsgState = locallyScopedConn.isReadInfoMsgEnabled();</span><br><span class="line">            locallyScopedConn.setReadInfoMsgEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Only apply max_rows to selects</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        locallyScopedConn.setSessionMaxRows(<span class="keyword">this</span>.firstCharOfStmt == <span class="string">&#x27;S&#x27;</span> ? <span class="keyword">this</span>.maxRows : -<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        rs = executeInternal(<span class="keyword">this</span>.maxRows, sendPacket, createStreamingResultSet(), (<span class="keyword">this</span>.firstCharOfStmt == <span class="string">&#x27;S&#x27;</span>), metadataFromCache, <span class="keyword">false</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (cachedMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            locallyScopedConn.initializeResultsMetadataFromCache(<span class="keyword">this</span>.originalSql, cachedMetadata, rs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.reallyResult() &amp;&amp; locallyScopedConn.getCacheResultSetMetadata()) &#123;</span><br><span class="line">                locallyScopedConn.initializeResultsMetadataFromCache(<span class="keyword">this</span>.originalSql, <span class="keyword">null</span> <span class="comment">/* will be created */</span>, rs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retrieveGeneratedKeys) &#123;</span><br><span class="line">            locallyScopedConn.setReadInfoMsgEnabled(oldInfoMsgState);</span><br><span class="line">            rs.setFirstCharOfQuery(<span class="keyword">this</span>.firstCharOfStmt);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (oldCatalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">            locallyScopedConn.setCatalog(oldCatalog);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lastInsertId = rs.getUpdateID();</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">this</span>.results = rs;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> ((rs != <span class="keyword">null</span>) &amp;&amp; rs.reallyResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resultSetHandler.handleResultSets(ps);</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">  ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">      </span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是查出数据，使用ResultSetHandler去处理结果；然后通过TypeHandler去获取结果值</p>
</li>
</ol>
</li>
</ol>
<p>总的来说：</p>
<ol>
<li>根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示</li>
<li>为当前的查询创建一个缓存Key</li>
<li>缓存中没有值，直接从数据库中读取数据</li>
<li>执行查询，返回List 结果，然后 将查询的结果放入缓存之中</li>
<li>根据既有的参数，创建StatementHandler对象来执行查询操作</li>
<li>将创建Statement传递给StatementHandler对象,调用parameterize()方法赋值</li>
<li>调用StatementHandler.query()方法，返回List结果集</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311220722327.png" alt="image-20210311220722327"></p>
<h3 id="查询流程总结"><a href="#查询流程总结" class="headerlink" title="查询流程总结"></a>查询流程总结</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210311220745262.png" alt="image-20210311220745262"></p>
<ul>
<li>查询流程</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210312202645885.png" alt="image-20210312202645885"></p>
<p>我们的对象调用过程：<strong>代理对象</strong>  → <strong>DefaultSqlSession</strong> → <strong>Executor</strong> → <strong>StatementHandler</strong></p>
<p>关于<code>StatementHandler</code>的类结构：（短暂过一下，不做细究）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1119937-20190830154347931-163652214.png" alt="img"></p>
<ul>
<li>RoutingStatementHandler：路由处理器，这个相当于一个静态代理，根据 MappedStatement.statementType 创建对应的对处理器；</li>
<li>SimpleStatementHandler：不需要预编译的简单处理器；</li>
<li>PreparedStatementHandler：预编译的 SQL 处理器；</li>
<li>CallableStatementHandler：主要用于存储过程的调度；</li>
</ul>
<p>以及<code>ResultSetHandler</code>的类继承结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1294391-20181206211711543-1870804152.png" alt="img"></p>
<p>在我们的查询流程中，我们主要使用的是<mark>PreparedStatementHandler</mark>和<mark>ResultSetHandler</mark></p>
<ol>
<li>通过前者进行设置参数预编译</li>
<li>后者进行结果集的一定处理</li>
</ol>
<p>这两个类在处理过程中，都使用了<code>typeHandler</code>类分别进行参数和结果集的处理：</p>
<ol>
<li><pre><code class="java">DefaultParameterHandler
 typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType)
&lt;!--code￼<span class="number">173</span>--&gt;
</code></pre>
</li>
</ol>
<p>因此，我们就知道了<mark>TypeHandler</mark>的作用了：进行<strong>数据库类型</strong>和<strong>javaBean类型</strong>的映射</p>
<p>当然了，所有的类的方法，追根溯源都依靠的是JDBC去执行，换句话说，都依靠的是<MARK>Statement和<mark>PreparedStatement</mark>去执行的；</MARK></p>
<h2 id="全局总结"><a href="#全局总结" class="headerlink" title="全局总结"></a>全局总结</h2><p>思维导图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210312210632202.png" alt="image-20210312210632202"></p>
<h1 id="Mybatis插件"><a href="#Mybatis插件" class="headerlink" title="Mybatis插件"></a>Mybatis插件</h1><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><p>要自己编写插件之前肯定得明白原理，即插件是什么，是怎么运作的，我们往下看；</p>
<p>首先，抛开插件，我们要明白，在<strong>四大对象（Executor、ParameterHandler、ResultSetHandler、StatementHandler）</strong>被创建的的时候，都调用了一个方法：<code>interceptorChain.pluginAll();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用，就是遍历/获取到所有的<strong>Interceptor（拦截器）</strong>，之后通过<code>interceptor.plugin(target)</code>返回target 包装后的对象</p>
<p>因此！到这里，我们可以思考一下，假如我们也能实现一个拦截器，那我们在创建四大对象的时候，相当于外面套了一层我们做的衣服/功能，这样的话，岂不是就可以让Mybatis做一些我们 想让他做的事情了吗？这就是插件的原理：利用动态代理去给目标对象创建一个代理对象，用以实现特殊功能；</p>
<h2 id="插件编写测试"><a href="#插件编写测试" class="headerlink" title="插件编写测试"></a>插件编写测试</h2><p>如我们上述所言，若我们能实现一个拦截器，就达到了插件的效果了，接下来就动手来做一做</p>
<p>首先，插件编写需要以下几步</p>
<ol>
<li>编写Interceptor的实现类</li>
<li>使用@Intercept注解去完成插件的签名</li>
<li>将写好的插件注册到全局配置文件中</li>
</ol>
<p>需要实现拦截器，就需要实现<code>Interceptor</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<ul>
<li>自定义插件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完成插件的签名: 告诉Mybatis当前使用的插件去拦截哪个对象的哪个方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">        &#123;</span></span><br><span class="line"><span class="meta">                @Signature(type= StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * intercept(拦截）: 拦截目标对象的目标方法的执行</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFirstPlugin 影响的方法&quot;</span> + invocation.getMethod());</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        <span class="comment">//return返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*plugin:包装, 本质就是为目标对象去创建一个代理对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//借助Plugin的wrap方法 去使用Interceptor去包装目标对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot;</span>+target);</span><br><span class="line">        <span class="comment">//这里对应的this 是  MyFirstPlugin</span></span><br><span class="line">        Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> wrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*   setProperties: 将插件注册时 的property属性设置进来</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插件配置的信息：&quot;</span>+properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意:插件的注册不能写在settings的前面--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--plugins：注册插件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.hpg.dao.MyFirstPlugin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.hpg.dao.MyFirstPlugin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210312221445363.png" alt="image-20210312221445363"></p>
<ul>
<li><p>关键信息</p>
<p>尽管我们的标签里面设置了只对<code>StatementHandler</code>对象进行包装，但是我们也会生成四个包装对象：</p>
<p>即分别对ParameterHandler、ResultSetHandler、StatementHandler、Executor进行了包装。这是我们需要注意的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.CachingExecutor@6973b51b</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.CachingExecutor@6973b51b</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.scripting.defaults.DefaultParameterHandler@399f45b1</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.scripting.defaults.DefaultParameterHandler@399f45b1</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.resultset.DefaultResultSetHandler@35cabb2a</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.resultset.DefaultResultSetHandler@35cabb2a</span><br><span class="line">  MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.statement.RoutingStatementHandler@7e07db1f</span><br><span class="line">MyFirstPlugin...plugin:mybatis将要包装的对象org.apache.ibatis.executor.statement.RoutingStatementHandler@7e07db1f</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>在执行完sql之后：<br>  我们的插件也对设置参数方法进行了影响/拦截，此时就只会对我们想要包装的对象的方法进行拦截了，就不会像上面生成代理对象这一步时一样，对四大对象都生成代理对象。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  MyFirstPlugin 影响的方法public abstract void org.apache.ibatis.executor.statement.StatementHandler.parameterize(java.sql.Statement) throws java.sql.SQLException</span><br><span class="line">MyFirstPlugin 影响的方法public abstract void org.apache.ibatis.executor.statement.StatementHandler.parameterize(java.sql.Statement) throws java.sql.SQLException</span><br></pre></td></tr></table></figure>



<h2 id="关于插件一些细节"><a href="#关于插件一些细节" class="headerlink" title="关于插件一些细节"></a>关于插件一些细节</h2><p>  假如我们在写一个插件，与第一个插件共同运作时，会怎么样呢？</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">      &#123;</span></span><br><span class="line"><span class="meta">         @Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">      &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecondPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;MySecondPlugin...intercept:&quot;</span>+invocation.getMethod());</span><br><span class="line">      <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot;MySecondPlugin...plugin:&quot;</span>+target);</span><br><span class="line">      <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313160743141.png" alt="image-20210313160743141"></p>
<p>我们发现 在产生代理对象时候是先进行first插件，再进行second插件</p>
<p>但是在拦截方法的时候，是先进行second插件，再进行first插件；</p>
<p>因此我们可以得出结论</p>
<ol>
<li><p>插件会产生目标对象的代理对象，多个插件就会产生多层代理对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313160901039.png" alt="image-20210313160901039"></p>
</li>
<li><p>创建动态代理的时候，是按照插件配置顺序层层去创建代理对象。然而执行目标方法时，是按照逆向顺序执行</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313160944715.png" alt="image-20210313160944715"></p>
</li>
</ol>
<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><p>有了上述例子，我们可以试着去推断开发插件的思路了：</p>
<p>从invocation参数中获取执行方法的对象/方法/方法参数 → 获取该对象的元数据 → 获取想要修改的参数 → 修改该参数</p>
<p>下面我们改造一下第一个插件的<code>intercept</code>方法 我们输入的员工id为1，我们修改成11</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   System.out.println(<span class="string">&quot;MyFirstPlugin...intercept:&quot;</span>+invocation.getMethod());</span><br><span class="line">   <span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询3号员工</span></span><br><span class="line">   Object target = invocation.getTarget();</span><br><span class="line">   System.out.println(<span class="string">&quot;当前拦截到的对象：&quot;</span>+target);</span><br><span class="line">   <span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line">   <span class="comment">//拿到target的元数据</span></span><br><span class="line">   MetaObject metaObject = SystemMetaObject.forObject(target);</span><br><span class="line">   Object value = metaObject.getValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;sql语句用的参数是：&quot;</span>+value);</span><br><span class="line">   <span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">   metaObject.setValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="number">11</span>);</span><br><span class="line">   <span class="comment">//执行目标方法</span></span><br><span class="line">   Object proceed = invocation.proceed();</span><br><span class="line">   <span class="comment">//返回执行后的返回值</span></span><br><span class="line">   <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313162533937.png" alt="image-20210313162533937"></p>
<h2 id="插件实战-PageHelper-分页插件"><a href="#插件实战-PageHelper-分页插件" class="headerlink" title="插件实战 - PageHelper 分页插件"></a>插件实战 - PageHelper 分页插件</h2><p>PageHelper失效问题在于版本没有对应：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_34104446/article/details/92679046">https://blog.csdn.net/sinat_34104446/article/details/92679046</a></p>
<p>解决方案：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- PageHelper4版本插件配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PageHelper4版本依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- PageHelper5版本配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PageHelper5版本依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>数据库信息：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313163849060.png" alt="image-20210313163849060"></p>
<p>外部依赖：</p>
<p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>全局配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- PageHelper4版本插件配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InterfaceTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、获取sqlSessionFactory对象</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">// 2、获取sqlSession对象</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; emps = mapper.getEmps();</span><br><span class="line">        <span class="comment">//传入要连续显示多少页 navigatePages 分页导航</span></span><br><span class="line">        PageInfo&lt;Employee&gt; info = <span class="keyword">new</span> PageInfo&lt;&gt;(emps, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : emps) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">/*System.out.println(&quot;当前页码：&quot;+page.getPageNum());</span></span><br><span class="line"><span class="comment">     System.out.println(&quot;总记录数：&quot;+page.getTotal());</span></span><br><span class="line"><span class="comment">     System.out.println(&quot;每页的记录数：&quot;+page.getPageSize());</span></span><br><span class="line"><span class="comment">     System.out.println(&quot;总页码：&quot;+page.getPages());*/</span></span><br><span class="line">        <span class="comment">///xxx</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码：&quot;</span>+info.getPageNum());</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数：&quot;</span>+info.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;每页的记录数：&quot;</span>+info.getPageSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;总页码：&quot;</span>+info.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+info.isIsFirstPage());</span><br><span class="line">        System.out.println(<span class="string">&quot;连续显示的页码：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = info.getNavigatepageNums();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210313165433423.png" alt="image-20210313165433423"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/07/MyBatis/" data-id="ckppikuf0003qp0wi6d2mf7wz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/03/03/Spring/" class="article-date">
  <time datetime="2021-03-03T12:10:38.305Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/03/03/Spring/">Spring</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring框架是由于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/软件开发/3448966">软件开发</a>的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/EJB/144195">EJB</a>完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p>
<ul>
<li><p>目的：解决企业应用开发的复杂性</p>
</li>
<li><p>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</p>
</li>
<li><p>范围：任何Java应用</p>
</li>
</ul>
<p>Spring是一个<strong>轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</strong></p>
<p>Spring理念：使现有技术更加实用 . 本身就是一个大杂烩 , <strong>整合现有的框架技术</strong></p>
<ul>
<li><p>框架文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html</a></p>
</li>
<li><p>官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p>
</li>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p>
</li>
<li><p>GitHub : <a target="_blank" rel="noopener" href="https://github.com/spring-projects">https://github.com/spring-projects</a></p>
</li>
<li><p>Maven地址：<a target="_blank" rel="noopener" href="https://mvnrepository.com/search?q=spring">https://mvnrepository.com/search?q=spring</a></p>
<p>ps：一般来说导webmvc和jdbc这俩：<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc">https://mvnrepository.com/artifact/org.springframework/spring-webmvc</a></p>
</li>
</ul>
<p>早些年使用框架SSH：Struct2 + Spring + Hibernate</p>
<p>现在SSM ： SpringMVC +Spring + Mybatis</p>
<p>maven配置的话：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>Spring是开源的免费的框架（容器）</p>
</li>
<li><p>是<mark>轻量级、非侵入式</mark>的框架（也就是不会破坏之前的架构，引入后反而会使得编程更简单了）</p>
</li>
<li><p>（核心）具有<mark>控制反转（IOC），面向切面编程（AOP）</mark>的特点（核心）</p>
</li>
<li><p>支持<strong>事务</strong>的处理（由于AOP）</p>
<p>ps：事务是对一系列数据库进行统一的提交和回滚</p>
</li>
</ul>
<p>总结：Spring 是一个轻量级的控制反转和面向切面编程的框架</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaobaizhiqian/p/7616453.html">https://www.cnblogs.com/xiaobaizhiqian/p/7616453.html</a></p>
<p>Spring分为七大组成模块</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210125160108693.png" alt="image-20210125160108693"></p>
<ul>
<li><strong>核心容器（Spring Core）</strong></li>
</ul>
<p>　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是<strong>工厂模式</strong>的实现。BeanFactory使用<strong>控制反转(IoC)模式</strong>将应用的配置和依赖性规范与实际的应用程序代码分开。</p>
<ul>
<li><strong>应用上下文（Spring Context）</strong></li>
</ul>
<p>　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
<ul>
<li><strong>Spring面向切面编程（Spring AOP）</strong></li>
</ul>
<p>　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
<ul>
<li><strong>JDBC和DAO模块（Spring DAO）</strong></li>
</ul>
<p>　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p>
<ul>
<li><strong>对象实体映射（Spring ORM）</strong></li>
</ul>
<p>　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</p>
<ul>
<li><strong>Web模块（Spring Web）</strong></li>
</ul>
<p>　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
<ul>
<li><strong>MVC模块（Spring Web MVC）</strong></li>
</ul>
<p>　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210125160937644.png" alt="image-20210125160937644"></p>
<p><strong>Spring Boot与Spring Cloud</strong></p>
<ul>
<li><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;</p>
<p>ps:需要记住<strong>约定大于配置</strong>;</p>
</li>
<li><p>Spring Cloud是基于Spring Boot实现的；</p>
</li>
<li><p>Spring Boot专注于快速、方便集成的单个<strong>微服务个体</strong>，Spring Cloud关注全局的服务治理框架；</p>
<p>什么是<strong>微服务</strong></p>
</li>
<li><p>Spring Boot使用了<strong>约束优于配置的理念</strong>，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是<strong>基于Spring Boot来实现</strong>，<strong>Spring Boot可以离开Spring Cloud独立使用开发项目</strong>，<strong>但是Spring Cloud离不开Spring Boot，属于依赖的关系</strong>。</p>
</li>
<li><p>SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。</p>
</li>
<li><p>Springboot是非常重要的，因为大多数公司都在用，然而学习Springboot就需要完全掌握好Spring和SpringMVC以做到承上启下</p>
</li>
</ul>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h2><ul>
<li>IOC理论背景：</li>
</ul>
<p>在之前所学的<strong>面向对象开发</strong>中，所有的组件都是对象，一般都是通过一个对象中new另一个对象，然后调用方法，对象合作然后去实现业务逻辑；</p>
<p>如下图：就像一组齿轮，一个转带动另一个转，然后再带动另一个转；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2011052709382686.jpg" alt="img"></p>
<p>然而这种开发的思想其实有点危险，就是对象与对象之间<strong>耦合度</strong>有点太高了。一个出问题，其他可能也会动不了了。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2011052709390013.jpg" alt="img"></p>
<p>因此我们开发终极目标：降低对象间耦合度（如果能完全解耦那再好不过了）</p>
<p>因此<strong>Michael Mattson</strong>提出<mark>IOC理论</mark></p>
<hr>
<ul>
<li>下面以一个开发实例进行理解：</li>
</ul>
<p>原先开发流程：</p>
<p>Dao接口 → DaoImpl → Service接口 → ServiceImpl</p>
<p>我们先用我们原来的方式写一段代码 .</p>
<p>1、先写一个UserDao接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再去写Dao的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;获取用户数据&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、然后去写UserService的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、最后写Service的实现类</p>
<p><strong><mark>注意看，我service实现类一般都会new一个对象，这就是导致耦合的原因</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试一下<code>(这里每次更换不同接口都需要在service层更改new的接口)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">   service.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p>
<p>把Userdao的实现类增加一个 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMySqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;MySql获取用户数据&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoMySqlImpl();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       userDao.getUser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再假设, 我们再增加一个Userdao的实现类 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Oracle获取用户数据&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . </p>
<p>假设我们的这种需求非常大 , 这种方式就根本不适用了,  , 每次变动 , 都需要修改大量代码 .</p>
<p> 这种设计的<strong>耦合性太高了,</strong> 牵一发而动全身 .</p>
<p><strong>那我们如何去解决呢 ?</strong></p>
<p>（有的人会说 <mark>工厂模式！策略模式</mark>，这当然也ok；）</p>
<p>在这里， <strong>我们不去new它出来</strong> , 而是留出一个<strong><mark>接口</mark></strong> , 利用set方法去实现我们的目的 </p>
<p>相当于解耦了，它上一层怎么样和我无关了，我写代码只需要focus在这一层即可了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="comment">//控制反转就是 </span></span><br><span class="line">    <span class="comment">//原来是把这里的 private UserDao userDao = new UserDaoImpl();（原来是写死了的）</span></span><br><span class="line">    <span class="comment">//然后需要用哪个接口 就把new后面的改了 </span></span><br><span class="line">    <span class="comment">//变更为以下:</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//利用set实现动态实现值的注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在去我们的测试类里 , 进行测试 ;<code>（有了set方法就可以在调用的时候由用户选择调用的接口）</code></p>
<p>把这里想象成用户的使用界面，用户点击不同按钮就相当于创建了不同的对象，去使用对应的方法</p>
<p>我们的底层代码根本没有进行修改，但是能够对相应选择做出相应的回应（结果）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        service.setUserDao( <span class="keyword">new</span> UserDaoMySqlImpl() );</span><br><span class="line">        service.getUser();</span><br><span class="line">        <span class="comment">//想使用Oracle当然也可以</span></span><br><span class="line">        service.setUserDao( <span class="keyword">new</span> UserDaoOracleImpl() );</span><br><span class="line">        service.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210125180219993.png" alt="image-20210125180219993"></p>
<p>由此我们发现区别：</p>
<ul>
<li>在之前，程序是占据主动的一方，也就是说，功能的应用、控制权在程序员手中，只有程序员能够对Service进行修改，然后才能调用相应的方法</li>
<li>而现在，用了set方法后，程序就写死了，不用修改，控制权在<strong>用户</strong>手中； </li>
</ul>
<p>这种思想从本质上解决了问题，我们程序员不用再去<strong>管理对象的创建问题</strong>了，这样系统的耦合性就降低了，我们开发就可以专注于业务实现，而不用老去进行修改没必要的接口代码了。</p>
<p>通俗来说就是，我们只用注重相应功能开发，至于用哪个接口，留给用户自己去选择了。</p>
<h2 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h2><ul>
<li><p>IOC原理解释：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m13666368773/article/details/7802126">https://blog.csdn.net/m13666368773/article/details/7802126</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/5597490.html">https://www.cnblogs.com/wang-meng/p/5597490.html</a></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210128152909864.png" alt="image-20210128152909864"></p>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。</p>
<p>没有IoC的程序中 , 我们使用<strong>面向对象编程</strong> , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制</p>
<p>然而，控制反转后将对象的创建转移给<strong>第三方</strong>，因此控制反转即：获得依赖对象的方式反转了。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/842724-20200217122147646-783512332.png" alt="img"></p>
<ul>
<li>那么 下面就详解一下<mark>控制反转IOC</mark></li>
</ul>
<p>控制反转/控制反向/控制倒置，IOC（<mark><strong>I</strong></mark>nversion <mark><strong>o</strong></mark>f <mark><strong>C</strong></mark>ontrol）</p>
<p>反转反转，我们到底反转了什么呢？答案是：反转了<strong>控制权</strong></p>
<p>简单来说，就是通过引入第三方，将复杂系统→可相互合作的对象，同时，这些对象的内部实现对外部是<strong>透明</strong>的</p>
<p>ps：什么叫透明的呢？意思是说，你不用管其中运行的原理，只用知道他能实现这个功能就行啦。</p>
<p>同时可以降低解决问题的复杂度（不用改之前的代码），我们写的组件就可以灵活的被<strong>重用</strong>以及<strong>扩展</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2011052709391014.jpg" alt="img"></p>
<p>IOC容器充当了第三方的角色，使得ABCD四个对象无耦合了，齿轮的转动依靠IOC容器，ABCD四个对象的<strong>控制权</strong>给了IOC容器</p>
<p>下面我们把容器去掉，发现ABCD四个对象达到了0耦合。</p>
<p>假设1 2 3 4号程序员分别去开发A B C D四个轮子，各程序员只需要focus开发自己的类，不用管别人，至于别人什么时候要用到自己这个轮子，根本就不是自己应该管的事情了。</p>
<p>举个例子，在没有引入这个思想之前，在我们上述ServiceImpl中去创建了UserDaoImpl对象去调用相应方法对吧</p>
<p>这样对象A与对象B就有了直接的联系。</p>
<p>然而，软件系统引入了IOC容器后，我们就不用这样了，在上述代码示例中，那个接口实际上就是一个IOC容器了</p>
<p>让对象之间没有了直接的联系，当我们对象A的代码跑着跑着发现，哦，我需要B对象了，这个时候接口（IOC容器）就会创建一个对象B注入到对象A需要的地方（由之前的主动创建，变成了被动的注入，控制权反转了），因此这思想/行为称为<strong>控制反转</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2011052709392670.jpg" alt="img"></p>
<h1 id="HelloSpring（第一个Spring程序）"><a href="#HelloSpring（第一个Spring程序）" class="headerlink" title="HelloSpring（第一个Spring程序）"></a>HelloSpring（第一个Spring程序）</h1><p>整体目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210128154915378.png" alt="image-20210128154915378"></p>
<p>首先需要导入jar包：</p>
<p>在maven中搜spring会出现很多个包含spring的包，这里我们使用了webmvc的；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>编写Hello实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">           <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写spring文件</p>
<p>可以这么理解：java中 创建对象方式为 类型 变量名 = new 类型();</p>
<ul>
<li>id → 变量名</li>
<li>class → 类型();</li>
<li>name → 类的属性</li>
<li>value → 属性的值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用Spring来创建对象，在Spring之中这些称为Bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类型 变量名 = new 类型();--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的id等价于变量名 class相当于全路径，相当于要new的对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这句话的意思是 Hello 这个类有个属性 叫 id，它的值是 HelloSpring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HelloSpring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，创建了一个Hello类的对象，取名为hello，将其属性【id】设置为了HelloSpring</p>
</li>
<li><p>通过Junit进行单元测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.pojo.Hello;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//configlocation:配置文件地址，可以传多个</span></span><br><span class="line">        <span class="comment">//获取Spring的上下文对象方法</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//在执行getBean的时候, Hello这个类已经创建好了 , 通过无参构造</span></span><br><span class="line">        <span class="comment">//这里的getBean参数与id相同</span></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//调用对象的方法 .</span></span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210128155536466.png" alt="image-20210128155536466"></p>
</li>
</ol>
<ul>
<li>Hello 对象是谁创建的 ? 由Spring创建</li>
<li>Hello 对象的属性是怎么设置的 ?由Spring容器设置</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p>依赖注入 : 就是利用set方法来进行注入的.</p>
<p>IOC是一种编程思想，由<strong>主动的创建变成被动的接收</strong></p>
<p>既然我们学习了Spring的初步入门了，下面把之前的第一个案例改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="comment">//控制反转就是</span></span><br><span class="line">    <span class="comment">//原来是把这里的 private UserDao userDao = new UserDaoImpl();（原来是写死了的）</span></span><br><span class="line">    <span class="comment">//然后需要用哪个接口 就把new后面的改了</span></span><br><span class="line">    <span class="comment">//变更为以下:</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//根据传入参数 动态改变</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原先利用set方法模拟了IOC，现在使用xml进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.dao.UserDaoMySqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;OracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.dao.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;OracleImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDaoMySqlImpl;</span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDaoOracleImpl;</span><br><span class="line"><span class="keyword">import</span> com.hpg.service.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ApplicationContext 拿到Spring的容器</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过容器去获取类（bean）</span></span><br><span class="line">        <span class="comment">//记住 这里getBean的参数填的是配置文件中的id，而不是类的名字哦</span></span><br><span class="line">        UserServiceImpl serviceImpl =(UserServiceImpl) context.getBean(<span class="string">&quot;ServiceImpl&quot;</span>);</span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        serviceImpl.getUser();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于我们ref处导向的是Oracle，因此这里的输出：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210128174939981.png" alt="image-20210128174939981"></p>
<p>假如修改了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.dao.UserDaoMySqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;OracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.dao.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;MysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导向Mysql，那么结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210128175037525.png" alt="image-20210128175037525"></p>
<p>我们根本就不需要去改动原来写的类，只需要在配置文件处修改一下ref导向就可以动态改变结果了。</p>
<h1 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h1><p>同时根据结果，我们发现整个程序没有出现<strong>new</strong>的字样，但是对象确实是实实在在的被创建了，那么究竟是怎么做到的？</p>
<p>而且还有另一个提示，我们所有的变更都是在配置文件中进行的；</p>
<p>学过JavaSE的朋友肯定知道，这种动态创建对象的方法 + 与配置文件进行配合 必定是用到了<strong>反射</strong>这个技术；</p>
<p>关于反射，我们之后再聊，我们首先需要知道IOC构建对象的方式</p>
<ol>
<li><p>是使用<strong>无参构造</strong>创建对象的，这个是默认的构造方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;user无参构造方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   配置文件：</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userwucan&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">   <span class="comment">//在执行getBean的时候, user已经创建好了 , 通过无参构造</span></span><br><span class="line">   User user = (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="comment">//调用对象的方法 .</span></span><br><span class="line">   user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   测试结果：</p>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228192702643.png" alt="image-20210228192702643"></p>
<ol start="2">
<li><p>那么要使用<strong>有参构造</strong>的话，可以使用如下几种方式：</p>
<p>首先需要在User.java中构造一个有参构造方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个有参构造方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>下标赋值</mark></p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黄&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131144831408.png" alt="image-20210131144831408"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131144836910.png" alt="image-20210131144836910"></p>
<ol>
<li><p><mark>参数名字设置（一般用这个）</mark></p>
<p>需要注意的是，创建对象与java遵循规则一样，不能取同名的，Spring并不会覆盖创建的对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131145545858.png" alt="image-20210131145545858"></p>
<p>参数匹配的方式代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 第二种根据参数名字设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黄2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对比一下一开始使用的--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hpg&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131145641385.png" alt="image-20210131145641385"></p>
</li>
<li><p><mark>根据类型匹配设置（不建议使用）</mark></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黄3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131145956312.png" alt="image-20210131145956312"></p>
</li>
</ol>
<p>同时，我们进行一个另外的测试：</p>
<p>我们再创建一个类UserTest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行UserTest无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个有参构造方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在beans中装载</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userTest&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.UserTest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210131151146247.png" alt="image-20210131151146247"></p>
<p>通过结果我们发现，我们并没有去使用这个UserTest类，但是却仍旧执行了UserTest的无参构造</p>
<p>也就是说，在<strong>配置文件加载的时候，Spring管理的对象就全部被初始化了</strong>，我们需要用的时候只需要从中取出来即可；</p>
<h1 id="Spring配置说明"><a href="#Spring配置说明" class="headerlink" title="Spring配置说明"></a>Spring配置说明</h1><h2 id="别名Alias"><a href="#别名Alias" class="headerlink" title="别名Alias"></a>别名Alias</h2><ul>
<li>意思就是给一个对象取一个别名，通过这个别名也可以取出对应的对象</li>
<li>id是bean的唯一标识符，而别名可以取很多个</li>
</ul>
<p>比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hpg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;uuuuuu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>进行测试：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210202154111750.png" alt="image-20210202154111750"></p>
<h2 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   id :bean的标识符,要唯一,相当于对象名</span></span><br><span class="line"><span class="comment">   class:bean对象对应的限定名—— 包名+类型</span></span><br><span class="line"><span class="comment">   name:相当于别名,而且可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">   如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">   如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userTest2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;u1,u2,u3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.UserTest&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HHHPPPGGG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li>用id执行：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210205164756955.png" alt="image-20210205164756955"></p>
<ul>
<li>用name执行:</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210205164716758.png" alt="image-20210205164716758"></p>
<p>结果是一样的，说明只不过参数是name别名和id唯一标识符的区别罢了；</p>
<h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><ul>
<li>团队开发使用，可以将多个配置文件，通过import导入合并成一个配置文件</li>
</ul>
<p>使用场景：项目多个人开发，每个人负责不同的实体类（bean）的开发，利用<strong>import</strong>将所有人的beans.xml合并成总的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210205173824383.png" alt="image-20210205173824383"></p>
<p>这样子 在</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml);</span><br><span class="line">//这个地方就只需要填入总的xml配置文件即可</span><br></pre></td></tr></table></figure>

<h1 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI - 依赖注入"></a>DI - 依赖注入</h1><ul>
<li>DI （Dependency Injection）依赖注入</li>
</ul>
<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><p>就是通过构造函数（参数的输入）进行依赖注入；</p>
<p>官方文档例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="comment">//这就是一个构造器注入方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于构造器注入方式，还有<strong>构造函数参数类型匹配，根据下标（索引）赋值，根据参数名称赋值等</strong>都在前文提及过了</p>
<h2 id="Setter方式注入"><a href="#Setter方式注入" class="headerlink" title="Setter方式注入"></a>Setter方式注入</h2><ul>
<li><p>依赖注入方式：使用了Set方法</p>
<ul>
<li><mark>依赖</mark>：代表着bean对象的创建是<strong>依赖</strong>于容器</li>
<li><mark>注入</mark>：bean对象的所有属性，通过容器进行<strong>注入</strong></li>
</ul>
</li>
<li><p>测试：</p>
<p>包结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228193323011.png" alt="image-20210228193323011"></p>
<ul>
<li><p>Address类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Student类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(String[] books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(Set&lt;String&gt; games)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Properties info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHobbys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getGames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address.toString() +</span><br><span class="line">                <span class="string">&quot;, books=&quot;</span> + Arrays.toString(books) +</span><br><span class="line">                <span class="string">&quot;, hobbys=&quot;</span> + hobbys +</span><br><span class="line">                <span class="string">&quot;, card=&quot;</span> + card +</span><br><span class="line">                <span class="string">&quot;, games=&quot;</span> + games +</span><br><span class="line">                <span class="string">&quot;, wife=&#x27;&quot;</span> + wife + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, info=&quot;</span> + info +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+ name</span><br><span class="line">                + <span class="string">&quot;,address=&quot;</span>+ address.getAddress()</span><br><span class="line">                + <span class="string">&quot;,books=&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String book:books)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&lt;&lt;&quot;</span>+book+<span class="string">&quot;&gt;&gt;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n爱好:&quot;</span>+hobbys);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;card:&quot;</span>+card);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;games:&quot;</span>+games);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;wife:&quot;</span>+wife);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;info:&quot;</span>+info);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--常量注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;s1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黄&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上下文对象先</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据上下文对象获取实例化的对象</span></span><br><span class="line">        Student student =(Student) context.getBean(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">        <span class="comment">//再根据这个实例化的对象获取属性</span></span><br><span class="line">        String name = student.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228193535103.png" alt="image-20210228193535103"></p>
</li>
</ul>
</li>
</ul>
<h3 id="注入实例"><a href="#注入实例" class="headerlink" title="注入实例"></a>注入实例</h3><p>首先实例化Address对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Address1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;深圳&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Address2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Address&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="普通值注入"><a href="#普通值注入" class="headerlink" title="普通值注入"></a>普通值注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;s1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.普通值注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小黄&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean注入"><a href="#Bean注入" class="headerlink" title="Bean注入"></a>Bean注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Bean注入,使用ref--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Address1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="List注入"><a href="#List注入" class="headerlink" title="List注入"></a>List注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>吃肉<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Map注入"><a href="#Map注入" class="headerlink" title="Map注入"></a>Map注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;中国邮政&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456456456465456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;建设&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1456682255511&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Set注入"><a href="#Set注入" class="headerlink" title="Set注入"></a>Set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>csgo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Dota2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="null注入"><a href="#null注入" class="headerlink" title="null注入"></a>null注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--null注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Properties注入"><a href="#Properties注入" class="headerlink" title="Properties注入"></a>Properties注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Properties注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小黄<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.MBeanAttributeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上下文对象先</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据上下文对象获取实例化的对象</span></span><br><span class="line">        Student student =(Student) context.getBean(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">        student.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228210140837.png" alt="image-20210228210140837"></p>
<h2 id="（拓展方式注入）p命名空间和c命名空间"><a href="#（拓展方式注入）p命名空间和c命名空间" class="headerlink" title="（拓展方式注入）p命名空间和c命名空间"></a>（拓展方式注入）p命名空间和c命名空间</h2><p>这两种方式不能直接使用，需要引用xml约束</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot; </span><br><span class="line"></span><br><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br></pre></td></tr></table></figure>

<p>User类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="P命名空间"><a href="#P命名空间" class="headerlink" title="P命名空间"></a>P命名空间</h3><ul>
<li>本质是setter注入 这里的<strong>p</strong>代表着properties </li>
<li>要注意的是，要使用p命名空间，就必须有无参构造！！不然会报错</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;小黄&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="C命名空间"><a href="#C命名空间" class="headerlink" title="C命名空间"></a>C命名空间</h3><ul>
<li>本质是构造器注入 这里的<strong>c</strong>代表着constructor</li>
<li>意味着这里的实体类必须要有<strong>带参构造</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;小小黄&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>假如没有带参构造，直接使用这种方式的话：</p>
<p>就会报错</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228213626464.png" alt="image-20210228213626464"></p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;userbeans.xml&quot;</span>);</span><br><span class="line">    User user1 = (User) context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    User user2 = (User) context.getBean(<span class="string">&quot;user2&quot;</span>);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210228214653421.png" alt="image-20210228214653421"></p>
<h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><p>分为六种（五种 有的人把后两种合并为一种了）：</p>
<ul>
<li><p><strong>singleton</strong>：<mark>单例模式</mark>，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例(Spring默认机制)</p>
</li>
<li><p><strong>prototype</strong>：<mark>原型模式</mark>，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</p>
</li>
<li><p><strong>request</strong>：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p><strong>session</strong>：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
<li><p><strong>globalsession</strong>：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210301204421750.png" alt="image-20210301204421750"></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li><p>当<strong>定义一个bean</strong>定义并且其作用域为单例时，Spring IoC容器将为该bean定义定义的对象<strong>创建一个实例</strong>（定义Bean的时候，IOC就会给这个对象创建一个实例了）。</p>
</li>
<li><p>该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210301205835365.png" alt="image-20210301205835365"></p>
<ul>
<li><p>单例模式中使用的是同一个对象</p>
</li>
<li><p>hashcode值相同</p>
</li>
</ul>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul>
<li><p>Bean部署的非单一原型范围会在每次请求该特定Bean时<strong>创建一个新的Bean实例</strong>。</p>
</li>
<li><p>也就是说，将Bean注入到另一个Bean中，或者您可以通过<code>getBean()</code>容器上的方法调用来请求它。通常，应将原型作用域用于所有有状态Bean，将单例作用域用于无状态Bean。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210301205850123.png" alt="image-20210301205850123"></p>
<p>原型模式使用的是拷贝的对象</p>
<p>hashcode值不同</p>
<h1 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h1><ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<h2 id="搭建环境测试"><a href="#搭建环境测试" class="headerlink" title="搭建环境测试"></a>搭建环境测试</h2><p>目录包结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210301201900920.png" alt="image-20210301201900920"></p>
<ul>
<li><p>Cat类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Dog类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>People类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.pojo.People;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        People people = (People) context.getBean(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        people.getCat().shout();</span><br><span class="line">        people.getDog().shout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="ByName自动装配"><a href="#ByName自动装配" class="headerlink" title="ByName自动装配"></a>ByName自动装配</h2><ul>
<li><p>假如使用ByName进行自动装配的话</p>
<p>要注意：bean的id填写是取决于 set方法后的字符小写</p>
<p>也就是说：假如在people类中，写的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog1</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么此时的bean的id应该填写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Dog&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，需要保证所有bean的id是唯一的，不能有重复；</p>
</li>
</ul>
<h2 id="ByType自动装配"><a href="#ByType自动装配" class="headerlink" title="ByType自动装配"></a>ByType自动装配</h2><ul>
<li><p>假如使用ByType进行自动装配的话，则需要保证bean的class是唯一的，并且这个bean要与自动注入的属性一致；</p>
<p>什么意思呢？就是假如在上述的bean中，再加入一个同类型的：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hpg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就不行，会报错，因为已经有一个Cat类了，就算取不同名也不行；</p>
<h2 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h2><p>这是原来的约束：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> 		            	   <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd 	    			http://www.springframework.org/schema/util 		 	 	 				         https://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要使用注解的话必须修改约束：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--别忘了这行代码 开启注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><mark>@Autowired</mark></strong></p>
<p>对于这个注解，放在属性上或者是set方法上即可，通常来说放在属性上；</p>
<p>默认通过BytType方式去查找bean，如果有多个类型相同的，再通过ByName；</p>
<p>假如还是有重复的，就需要配合@Qualifier使用</p>
<p><strong><mark>@Qualifier</mark></strong></p>
<p>用于指定一个bean；配合Autowired使用</p>
<p>Test：</p>
<p>Cat类和Dog类没有改变，改变了People类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beans.xml文件修改：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.pojo.People&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hpg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，我不用再去写autowire了；</p>
<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210301220908740.png" alt="image-20210301220908740"></p>
<h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><ul>
<li><p>注解@Component 相当于 <bean id="xxx" class="xxxxx">，把普通的pojo类实例化到了Spring容器中</bean></p>
<p>使用的时候放在实体类上</p>
</li>
<li><p>要注意，如果属性是私有的，则需要通过get方法去获取（意味着需要有set方法配合）；其实设置私有成员属性是通过反射访问的，关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Bean实现"><a href="#Bean实现" class="headerlink" title="Bean实现"></a>Bean实现</h2><p>要注意，如果@Component 后不加括号，即：@Component形式而非@Component(“xxx”)形式的话，默认的name是类名的小写，即如果类名是User111，那么getBean的时候name就得写user111</p>
<p>如果填入了id，name就得写那个id，且区分大小写；</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//@Component(&quot;user&quot;)等价于&lt;bean id=&quot;user&quot; class=&quot;com.hpg.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定要扫描的包，这个包下的注解会自动生成--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg.pojo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--别忘了这行代码 开启注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302171125811.png" alt="image-20210302171125811"></p>
<h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>现在假如我不写死属性的值，而是想随时变化</p>
<p>就需要使用<strong>@Value注解</strong></p>
<p>如果使用这个注解了：</p>
<ol>
<li><p>若提供<strong>Set方法</strong>，就在set方法上添加<strong>@Value(“xxx”)</strong>达到注入的效果</p>
<p>但我试了，就算提供set方法，在属性名上添加<strong>@Value(“xxx”)</strong>同样也行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//@Component(&quot;u&quot;)等价于&lt;bean id=&quot;u&quot; class=&quot;com.hpg.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Component(&quot;u&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="meta">@Value(&quot;xxx&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>假如没提供<strong>Set方法</strong>，就在属性名上添加<strong>@Value(“xxx”)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//@Component(&quot;u&quot;)等价于&lt;bean id=&quot;u&quot; class=&quot;com.hpg.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Component(&quot;u&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;xxx&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;u&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302172308644.png" alt="image-20210302172308644"></p>
<p>从结果可以看出，注解的优先级高于赋予的值；</p>
</li>
</ol>
<h2 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h2><p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li><strong>@Controller：web层</strong></li>
<li><strong>@Service：service层</strong></li>
<li><strong>@Repository：dao层</strong></li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<h2 id="注解与xml区别"><a href="#注解与xml区别" class="headerlink" title="注解与xml区别"></a>注解与xml区别</h2><p>注解：是一种分散式的元数据，与源代码紧绑定。</p>
<p>xml：是一种集中式的元数据，与源代码无绑定。</p>
<p>因此注解和XML的选择上可以从两个角度来看：分散还是集中，源代码绑定/无绑定。</p>
<p><strong>注解的缺点：</strong> </p>
<p>1、很多朋友比如在使用spring注解时，会发现注解分散到很多类中，不好管理和维护；这个其实要借助工具，我目前使用的是<strong>IDEA</strong>，它在这方面表现的非常好；当然现在还有<strong>Spring的STS</strong>，也是不错的； 所以借助工具，能解决这个问题；</p>
<p>2、注解的开启/关闭必须修改源代码，因为注解是源代码绑定的，如果要修改，需要改源码，这个有这个问题，所以如果是这种情况，还是使用XML配置方式；比如数据源；</p>
<p>3、注解还一个缺点就是灵活性，比如在之前翻译的Spring Framework 4.0 M1: WebSocket 支持；在实现复杂的逻辑上，没有XML来的更加强大；注解就是要么用，要么不用，比如之前的jpa bean validation，要么全，要么没；遇到这种情况很痛苦；</p>
<p>4、还一种就是约定大于配置，但是在处理一些复杂的情况下，注解还是需要的（如Spring的数据验证/数据绑定注解很强大）；</p>
<p>5、通用配置还是走XML吧，比如事务配置，比如数据库连接池等等，即通用的配置集中化，而不是分散化，如很多人使用@Transactional来配置事务，在很多情况下这是一种太分散化的配置；</p>
<p>6、XML方式比注解的可扩展性和复杂性维护上好的多，比如需要哪些组件，不需要哪些；在面对这种情况，注解扫描机制比较逊色，因为规则很难去写或根本不可能写出来；</p>
<p><strong>注解的好处： 数据绑定用注解，很少改变的用注解，类型安全，</strong></p>
<p>1、XML配置起来有时候冗长，此时注解可能是更好的选择，如jpa的实体映射；注解在处理一些不变的元数据时有时候比XML方便的多，比如springmvc的数据绑定，如果用xml写的代码会多的多；</p>
<p>2、注解最大的好处就是简化了XML配置；其实大部分注解一定确定后很少会改变，所以在一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；</p>
<p>3、注解相对于XML的另一个好处是类型安全的，XML只能在运行期才能发现问题。</p>
<p>注解也好，XML也好，我们还是需要一些开关/替换机制来控制特殊需求，以改变那种要么全部 要么没有的方案。。</p>
<p>还一种呼声就是约定大于配置，这种方案可能在某些场景下是最优的，但是遇到一些复杂的情况可能并不能解决问题，所以此时注解也是一个不错的方案。尤其在使用springmvc时，好处是能体会的出的。</p>
<p>不管使用注解还是XML，做的事情还是那些事情，但注解和XML都不是万能的，满足自己的需求且已一种更简单的方式解决掉问题即可。</p>
<p>就像探讨一下技术问题，很多人都带有很强的个人喜好来评判一个东西的好坏，这种探讨没有任何意义，我们最终的目的是解决方案，<strong>所以我们应该探讨的是能不能解决问题，能不能以更容易理解的方式解决问题，能不能更简单的解决问题。</strong></p>
<p><strong>不管是约定大于配置、注解还是XML配置也好，没有哪个是最优的，在合适的场景选择合适的解决方案这才是重要的。就像设计模式一样：是对特定环境中重复出现的特定问题的一个经过前人验证了的解决方案。</strong></p>
<h1 id="使用Java方式配置Spring"><a href="#使用Java方式配置Spring" class="headerlink" title="使用Java方式配置Spring"></a>使用Java方式配置Spring</h1><p>包结构:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302193809401.png" alt="image-20210302193809401"></p>
<p>配置文件类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//这个注解表示这个类是个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpgConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//这个注解 表示通过以下方法注册一个bean, 方法名为bean的id 在这里,bean的id = User</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>User类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//这里去掉这个注解也一样能跑的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;apple&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.config.HpgConfig;</span><br><span class="line"><span class="keyword">import</span> com.hpg.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在这里需要的就不熟之前的ClassPathXml..了 就得用注解的</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(HpgConfig.class);</span><br><span class="line">        <span class="comment">//这里填入的“User”对应的是Config类中的方法名 User</span></span><br><span class="line"><span class="comment">//        public User User() &#123;</span></span><br><span class="line"><span class="comment">//            return new User();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        User user = context.getBean(<span class="string">&quot;User&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302193921636.png" alt="image-20210302193921636"></p>
<p>整个过程，我们都没有去配置xml文件，而是用纯java实现的；</p>
<h2 id="Component和-Bean区别"><a href="#Component和-Bean区别" class="headerlink" title="@Component和@Bean区别"></a>@Component和@Bean区别</h2><p>看了上述例子有点奇怪，明明有@Component注解了 能够去注册一个bean了，还需要这个@Bean干嘛呢</p>
<p>(这个知识点还存疑，之后要着重复习下)</p>
<p>相关博客：<a target="_blank" rel="noopener" href="https://shanhy.blog.csdn.net/article/details/97533038">https://shanhy.blog.csdn.net/article/details/97533038</a></p>
<h3 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h3><ul>
<li>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</li>
<li>@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。</li>
</ul>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ul>
<li><p>相同点：两者的结果都是为spring容器注册Bean，也就是说将bean添加到了Spring的上下文中</p>
</li>
<li><p>不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。</p>
<p>@Bean 注解通常是我们在标有该<strong>注解的方法</strong>中定义产生这个bean的逻辑</p>
<p>@Bean注解比@Component注解的<strong>自定义性更强</strong>，而且很多地方只能通过@Bean注解来注册bean</p>
<p>比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过@Bean注解来实现。</p>
<p> 作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。</p>
<p>@Bean需要配合@Configuration注解一起用</p>
</li>
</ul>
<hr>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>这两个功能确实是一样，都是创建bean实例，并让spring容器管理其生命周期。</p>
<p>但是一般他们的使用情况不太一样。一般@Confiuration配合@Bean使用，写在配置文件中，返回的是某一个对象的实例；而@Component是对应某一个类，配合@ComponentScan使用，然后让spring ioc容器实例化。</p>
<p>而且使用@Confiugraion和@Bean， 会进行<strong>cglib动态代理</strong>增强，拿到的是一个代理对象；@Component拿到的是一个普通的java对象。</p>
<p>至于为什么？我并没有找到答案。不过两个进行对比以及我的猜测，是因为@Confiugraion和@Bean使用中返回的是一个已经定义的类的对象，可能后续要对它实例化的过程中添加一些逻辑，所以要用cglib进行动态代理；而@Component是由Spring容器进行实例化的。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>AOP 面向切面编程 利用这技术可以使得业务逻辑各部分耦合度降低，提高程序可重用性，提高开发效率</li>
<li>基本思想就是：在不通过修改源代码的方式去添加新的模块（功能）</li>
</ul>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>关于代理相关知识：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/teach/p/10763845.html">https://www.cnblogs.com/teach/p/10763845.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baizhanshi/p/6611164.html">https://www.cnblogs.com/baizhanshi/p/6611164.html</a></p>
<p>Spring使用的是<strong>动态代理</strong>去实现</p>
<ul>
<li><p>为什么不用静态代理呢？</p>
<p>静态代理的本质是在实现接口的基础上去实现额外功能，因此还是会有大量的代码重复</p>
<p>同时，静态代理只能对固定接口的实现类进行代理，不灵活；</p>
<p><strong>静态</strong>怎么理解呢？是指将代理类生成了源代码再进行编译，也就是程序跑之前这个代理类的.class文件就存在，而动态代理中的动态是利用了<strong>反射</strong>，代理类是在程序运行时用反射机制动态创建的</p>
</li>
</ul>
<p>动态代理分两种：JDK动态代理（有接口）和CGLIB动态代理（无接口）</p>
<ul>
<li><p>JDK动态代理：创建接口实现类的代理对象，然后通过该代理对象增强功能</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302211105958.png" alt="image-20210302211105958"></p>
</li>
<li><p>CGLIB动态代理：创建当前类的子类的代理对象，通过该代理对象去增强功能</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302211118766.png" alt="image-20210302211118766"></p>
</li>
</ul>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>使用的是Proxy类中的方法去创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br></pre></td></tr></table></figure>

<p>参数分析：</p>
<ul>
<li><p>第一个参数，类加载器</p>
</li>
<li><p>第二个参数，增强方法所在的类，这个类实现的接口，<em>支持多个接口</em></p>
</li>
<li><p>第三个参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
</li>
</ul>
<p>包结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302221808392.png" alt="image-20210302221808392"></p>
<p>UserDao接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UserDao实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行add方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行update方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.spring.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.hpg.spring.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="comment">//下面的方法是采取匿名内部类 比较冗杂</span></span><br><span class="line"><span class="comment">//        Proxy.newProxyInstance(MyTest.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;)</span></span><br><span class="line">        UserDaoImpl userdaoimpl = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao) Proxy.newProxyInstance(MyTest.class.getClassLoader(), interfaces, <span class="keyword">new</span> UserDaoProxy(userdaoimpl));</span><br><span class="line">        <span class="keyword">int</span> res = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res = &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个类是增强类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然是增强 就需要把原对象传过来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法之前进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行&quot;</span> + method.getName() + <span class="string">&quot;传递的参数&quot;</span> + Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行&quot;</span> + obj );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210302221945907.png" alt="image-20210302221945907"></p>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ul>
<li><p><mark>连接点</mark></p>
<p>类中哪些方法<strong>可以</strong>被增强，那么这些方法就叫做<strong>连接点</strong>（理论上可以被增强的方法，不一定真要去增强）</p>
</li>
<li><p><mark>切入点</mark></p>
<p><strong>实际</strong>被真正增强的方法，称为<strong>切入点</strong></p>
</li>
<li><p><mark>通知（增强）</mark></p>
<p>实际增强的<strong>逻辑部分</strong>称为<strong>通知（增强）</strong></p>
<ul>
<li><p>通知分为多种类型</p>
<ul>
<li><p>前置通知</p>
<p>在被增强的方法前执行</p>
</li>
<li><p>后置通知</p>
<p>在被增强的方法后执行</p>
</li>
<li><p>环绕通知</p>
<p>在被增强的方法前后都执行</p>
</li>
<li><p>异常通知</p>
<p>当被增强的方法发生了异常时执行</p>
</li>
<li><p>最终通知</p>
<p>类似java中try catch finally中的finally 被增强方法可能发生了异常，然后就不执行后置通知，但会执行最终通知；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><mark>切面</mark></p>
<p>这是一个动词，而非名词；</p>
<p>代表着把<mark>通知</mark>应用到了<mark>切入点</mark>这一过程</p>
</li>
</ul>
<h2 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Spring框架一般是基于<strong>AspectJ</strong>实现AOP操作</p>
<ul>
<li>什么是<strong>AspectJ</strong>呢？</li>
</ul>
<p>他不属于Spring的组成部分，是一个独立的AOP框架；通常将AspectJ与Spring一起使用，来完成AOP操作</p>
<ul>
<li>如何基于AspectJ实现AOP操作呢？</li>
</ul>
<ol>
<li>基于xml配置文件实现</li>
<li>基于注解方式实现</li>
</ol>
<ul>
<li>做项目工程中引入AOP相关依赖</li>
</ul>
<p>依赖（pom.xml中引入）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命名空间（beans.xml中引入）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>//这个为<span class="attr">aop</span>的</span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop			 //这个为aop的</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop/spring-aop.xsd	//这个为aop的</span></span></span><br><span class="line"><span class="tag"><span class="string">		&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><ul>
<li>作用：根据这个表达式，我们可以知道对哪个类里面的哪个方法进行增强</li>
<li>语法结构：<strong>execution( 权限修饰符 返回类型 包.类.方法名(参数列表) throws异常 )</strong></li>
</ul>
<p>括号中的内容其实就是声明一个方法。通常”修饰符“和”throw 异常“省略不写；</p>
<p><strong>返回值</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本类型，对象</span><br><span class="line">*<span class="comment">//（匹配任意返回值）</span></span><br></pre></td></tr></table></figure>

<p><strong>包</strong>：用限定名。可以使用通配符如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.abc.service<span class="comment">//表示固定包</span></span><br><span class="line">com.abc.crm.*.service<span class="comment">//表示crm包下任意子包的service包</span></span><br><span class="line">com.abc.crm..<span class="comment">//表示crm包下面的所有子包（包括自己）</span></span><br><span class="line">“..”可以表示自己本身和自己下面的多级包</span><br></pre></td></tr></table></figure>

<p><strong>类</strong>：可以使用固定名称，和统配符号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*Impl <span class="comment">//以Impl结尾</span></span><br><span class="line">User* <span class="comment">//以User开头的</span></span><br><span class="line">* <span class="comment">//任意</span></span><br></pre></td></tr></table></figure>

<p><strong>方法名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addUser<span class="comment">//固定方法</span></span><br><span class="line">add*<span class="comment">//以add开头</span></span><br><span class="line">*Do<span class="comment">//以Do结尾</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">()<span class="comment">//无参</span></span><br><span class="line">(<span class="keyword">int</span>)<span class="comment">//一个整型</span></span><br><span class="line">(<span class="keyword">int</span>,<span class="keyword">int</span>)<span class="comment">//两个</span></span><br><span class="line">(..)<span class="comment">//参数任意</span></span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execution(* *.someServiceImpl.*(..))</span><br><span class="line"><span class="comment">//所有的包下面（限定一级包）someServiceImpl类的所有任意参数的方法</span></span><br><span class="line">execution(* *..someServiceImpl.*(..))</span><br><span class="line"><span class="comment">//所有的包下面（可以是多级包）someServiceImpl类的所有任意参数的方法</span></span><br><span class="line">execution(* com.abc.crm.*.service..*.*(..))</span><br><span class="line"><span class="comment">//service下自己以及自己的子包的任意类的任意方法</span></span><br></pre></td></tr></table></figure>

<p>切入点表达式使用例子：</p>
<p>eg1：对com.hpg.dao.UserDao类中的add方法进行增强的写法：</p>
<ul>
<li><strong>execution(* com.hpg.dao.UserDao.add(..))</strong> <ul>
<li>第一个*表示所有的返回值类型</li>
<li>..表示所有参数</li>
</ul>
</li>
</ul>
<p>eg2：<strong>execution(* com.hpg.service.* . *(..))</strong></p>
<ul>
<li>第一个*表示所有返回值类型</li>
<li>第二个*表示所有的类</li>
<li>第三个*表示类所有的方法</li>
<li>..表示所有参数</li>
</ul>
<p>因此这行代码表示：</p>
<p>对com.hpg.service包下所有类和类中的所有方法进行增强</p>
<h3 id="AOP操作-AspectJ注解实现"><a href="#AOP操作-AspectJ注解实现" class="headerlink" title="AOP操作 - AspectJ注解实现"></a>AOP操作 - AspectJ注解实现</h3><ol>
<li><p>创建类，类中定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行add方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>创建增强类（编写增强逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>进行通知的配置</p>
<ol>
<li><p>配置好Spring中的命名空间相关信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解/组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg.spring.AopAnno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>使用注解创建User和UserProxy对象（@Component）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行add方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在增强类上面添加注解@Aspect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>在Spring配置文件中开启生成代理对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<ol start="4">
<li><p>配置不同类型的通知</p>
<p>在增强类的里面，在作为通知方法上面添加【通知类型注解】，使用切入点表达式配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知（返回通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕中的前置通知执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之中的后置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.spring.AopAnno.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210303213806207.png" alt="image-20210303213806207"></p>
<p>这是没有异常的情况，假如模拟一下异常，则打印结果是：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210303214042098.png" alt="image-20210303214042098"></p>
<p>可以发现环绕中的后置通知 和 后置（返回）通知 是不执行的</p>
</li>
<li><p>相同切入点抽取</p>
<p>我们发现，切入点大多数重复的，因此可以进行一个共性抽取 通过注解<em>@Pointcut</em>达到效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;GetPoint()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;前置通知执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个增强类对同个方法进行增强，设置增强类优先级</p>
<p>通过在增强类上添加注解<em>@Order(数字类型值)</em>，其中值越小优先级越高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopAnno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//后置通知（返回通知）</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.hpg.spring.AopAnno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;另一个前置通知执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给另一个增强类设为1，之前的增强类设置为2</p>
<p>打印结果是：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210303215857414.png" alt="image-20210303215857414"></p>
</li>
<li><p>完全使用注解开发，则需要创建配置类，不需要xml配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.hpg&quot;&#125;)</span> <span class="comment">//用于代替 开启注解扫描：    &lt;context:component-scan base-package=&quot;com.hpg.spring.AopAnno&quot;&gt;&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> <span class="comment">//用于代替 开启切面生成代理对象：    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigAop</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="AOP操作-AspectJ-XML实现"><a href="#AOP操作-AspectJ-XML实现" class="headerlink" title="AOP操作 - AspectJ XML实现"></a>AOP操作 - AspectJ XML实现</h3><ol>
<li><p>创建两个类 【增强类 + 被增强类】创建方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopXml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;buy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.spring.AopXml;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在Spring配置文件中创建两个类的对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建对象--&gt;</span><br><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.hpg.spring.AopXml.Book&quot;&gt;&lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">&lt;bean id=&quot;bookProxy&quot; class=&quot;com.hpg.spring.AopXml.BookProxy&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在Spring配置文件中配置切入点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.spring.AopXml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hpg.spring.AopXml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3、在 spring 配置文件中配置切入点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 aop 增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hpg.spring.AopXml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--增强作用在具体的方法上 method指向方法, pointcut-ref指向切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.spring.AopXml.Book;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopXmlTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans2.xml&quot;</span>);</span><br><span class="line">        Book book = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        book.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210303222535354.png" alt="image-20210303222535354"></p>
</li>
</ol>
<h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><ul>
<li>JdbcTemplate是什么？Spring框架对JDBC进行了封装，使用这个<strong>JdbcTemplate</strong>方便实现对数据库的操作</li>
</ul>
<p>下面进行一下测试：</p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>配置相关依赖（百度找的 不知道全不全）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在Spring配置文件中配置数据库连接池</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JdbcTemplate对象 注入DataSource</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JdbcTemplate对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库 创建表 创建对应实体类</p>
<p>创建Service类，创建Dao类，并且在Dao中注入JdbcTemplate对象</p>
<p>建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_book`</span> (</span><br><span class="line">  <span class="string">`book_id`</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`bookname`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_croatian_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`bookstatus`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_croatian_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`book_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_croatian_ci</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户ID</span></span><br><span class="line">    <span class="keyword">private</span> String BookID;</span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String BookName;</span><br><span class="line">    <span class="comment">//用户状态</span></span><br><span class="line">    <span class="keyword">private</span> String BookStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BookID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookID</span><span class="params">(String bookID)</span> </span>&#123;</span><br><span class="line">        BookID = bookID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        BookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BookStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookStatus</span><span class="params">(String bookStatus)</span> </span>&#123;</span><br><span class="line">        BookStatus = bookStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件扫描：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.Dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入Dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookdao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Dao：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入模板对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ol>
<li><p>编写Service和Dao</p>
<ol>
<li><p>在Dao类中进行数据库添加操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.Pojo.Book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Book book)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>在Dao实现类中调用JDBCTemplate对象里面的<strong>update方法</strong>去实现添加操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.Pojo.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入模板对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建sql语句</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line">        Object[] params = &#123;book.getBookID(), book.getBookName(), book.getBookStatus()&#125;;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, params);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304170002544.png" alt="image-20210304170002544"></p>
<ol>
<li>第一个参数：sql语句</li>
<li>第二个参数：可变参数，设置sql语句值</li>
</ol>
</li>
<li><p>在Service层的类中调用Dao类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.Dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> com.hpg.Pojo.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入Dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookdao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        bookdao.add(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.Pojo.Book;</span><br><span class="line"><span class="keyword">import</span> com.hpg.Service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        BookService bookService = context.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line"></span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setBookID(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        book.setBookName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        book.setBookStatus(<span class="string">&quot;free&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bookService.addBook(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304174445833.png" alt></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304174527504.png" alt="image-20210304174527504"></p>
</li>
</ol>
<p>ps：如果执行不成功，记得看数据库的用户名和密码输入有没有正确，还有注意url的填写问题以及数据库连接的版本一致性问题</p>
<h3 id="修改删除"><a href="#修改删除" class="headerlink" title="修改删除"></a>修改删除</h3><p>其实大体都一样，就只有sql语句是不同的：</p>
<ul>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;update t_book set bookname=?,bookstatus=? where book_id=?&quot;</span>;</span><br><span class="line"> Object[] args = &#123;book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line"> <span class="keyword">int</span> update = jdbcTemplate.update(sql, args);</span><br><span class="line"> System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;delete from t_book where book_id=?&quot;</span>;</span><br><span class="line"> <span class="keyword">int</span> update = jdbcTemplate.update(sql, id);</span><br><span class="line"> System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用JdbcTemplate 模板所实现的 “增删改” 都是调用了同一个 “update” 方法</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询分为：</p>
<ol>
<li><p>查询返回某个值</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304202952200.png" alt="image-20210304202952200"></p>
<ol>
<li>第一个参数：sql语句</li>
<li>第二个参数：返回类型Class</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line"><span class="comment">//queryForObject方法中：第一个参数代表--sql语句；第二个参数代表--返回类型class  </span></span><br><span class="line"> Integer count = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line"> <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">JdbcTemplate 操作数据库（</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>查询返回对象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304203359106.png" alt="image-20210304203359106"></p>
<ol>
<li><p>第一个参数：sql语句</p>
</li>
<li><p>第二个参数：RowMapper</p>
<p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304203923691.png" alt="image-20210304203923691"></p>
<p>这是一个接口，可以将数据中的每一行数据封装成用户定义的类</p>
<p>简单来说就是吧数据库中的列字段和java bean实体类的属性对应起来</p>
<p>作用形如：<code>bean.setName(rs.getString(&quot;name&quot;);</code> </p>
</li>
<li><p>第三个参数：sql语句中的参数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查询返回对象</span><br><span class="line">@Override</span><br><span class="line">public Book findBookInfo(String id) &#123;</span><br><span class="line"> String sql &#x3D; &quot;select * from t_book where user_id&#x3D;?&quot;;</span><br><span class="line"> &#x2F;&#x2F;调用方法</span><br><span class="line">&#x2F;*</span><br><span class="line">	queryForObject方法中：</span><br><span class="line">		第一个参数：sql语句</span><br><span class="line">		第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面 实现类 完成数据封装</span><br><span class="line">		第三个参数：sql 语句值</span><br><span class="line">*&#x2F;</span><br><span class="line"> Book book &#x3D; jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);</span><br><span class="line"> return book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>查询返回集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所用场景：查询图书列表分页、、</span></span><br><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line"> <span class="comment">//调用方法</span></span><br><span class="line"> List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class));</span><br><span class="line"> <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>顾名思义，就是操作表里面的多条记录</p>
<h4 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    BookService bookService = context.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量添加测试</span></span><br><span class="line">    List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">    Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">    Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    batchArgs.add(o1);</span><br><span class="line">    batchArgs.add(o2);</span><br><span class="line">    batchArgs.add(o3);</span><br><span class="line"></span><br><span class="line">    bookService.batchAdd(batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：[1，1，1] 代表着三组结果都成功了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304210854309.png" alt="image-20210304210854309"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304210944633.png" alt="image-20210304210944633"></p>
<h4 id="批量修改"><a href="#批量修改" class="headerlink" title="批量修改"></a>批量修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改(同批量添加一样，调用同一个方法)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line"> String sql = <span class="string">&quot;update t_book set bookname=?,bookstatus=? where book_id=?&quot;</span>;</span><br><span class="line"> <span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line"> System.out.println(Arrays.toString(ints));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li><p>事务是数据库操作的最基本单元，逻辑上来说：一组操作要么都成功，若有一个失败则所有操作都失败,</p>
<p>其本质就是一个具有一定特性的<strong>工作单元</strong>，为什么服务呢？为了访问或者更新数据库中各数据项。</p>
</li>
<li><p>事务的四个特性（ACID）</p>
<ul>
<li><p><strong>原子性</strong></p>
<p>一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性</p>
</li>
<li><p><strong>一致性</strong></p>
<p>事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</p>
<p>如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态</p>
</li>
<li><p><strong>隔离性</strong></p>
<p>事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。</p>
</li>
<li><p><strong>持久性</strong></p>
<p>一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。–即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态</p>
</li>
</ul>
</li>
</ul>
<h2 id="转账-模拟事务"><a href="#转账-模拟事务" class="headerlink" title="转账 - 模拟事务"></a>转账 - 模拟事务</h2><p>Dao层：创建 多钱 少钱 2个方法</p>
<p>Service层：创建转账的方法 —— 分别调用Dao层2个方法 实现转账</p>
<h3 id="搭建环境并测试"><a href="#搭建环境并测试" class="headerlink" title="搭建环境并测试"></a>搭建环境并测试</h3><ul>
<li>创建表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_account`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_croatian_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_croatian_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`money`</span> <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_croatian_ci</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>加入两条数据：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304213014230.png" alt="image-20210304213014230"></p>
<ul>
<li><p>完成配置文件处理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JdbcTemplate对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建Service，Dao 完成对象创建和注入关系</p>
<ul>
<li>service注入Dao，Dao中又注入JdbcTemplate，JdbcTempate中注入DataSource</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入Dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减少钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceMoney</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="comment">//lucy 转账 100 给 mary</span></span><br><span class="line">    <span class="comment">//少钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//转账的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lucy 少 100</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        <span class="comment">//mary 多 100</span></span><br><span class="line">        userDao.addMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hpg.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AccountTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">        userService.accountMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果（没有发生异常的）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304215213380.png" alt="image-20210304215213380"></p>
</li>
</ul>
<h3 id="引入异常"><a href="#引入异常" class="headerlink" title="引入异常"></a>引入异常</h3><p>假如现在有一个异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里执行后将会产生错误（异常）：lucy明明少了钱，但是mary却并没有多钱</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//转账方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.reduceMoney();<span class="comment">//lucy 少 100</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        userDao.addMoney(); <span class="comment">//mary 多 100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java的方法来说，使用try catch 抓异常 —— 编程式的事务管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//第一步 开启事务</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//第二步 进行业务操作</span></span><br><span class="line">         <span class="comment">//lucy少100</span></span><br><span class="line">         userDao.reduceMoney();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//模拟异常</span></span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//mary多100</span></span><br><span class="line">         userDao.addMoney();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//第三步 没有发生异常，提交事务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         <span class="comment">//第四步 出现异常，事务回滚</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring事务操作"><a href="#Spring事务操作" class="headerlink" title="Spring事务操作"></a>Spring事务操作</h2><ul>
<li><p>事务添加到JavaEE三层架构中的<strong>Service层</strong></p>
</li>
<li><p>在Spring中进行事务管理操作主要有2种方式：编程式事务管理 &amp; 声明式事务管理</p>
<ul>
<li>编程式事务管理<ul>
<li>在实际应用中很少使用</li>
<li>通过<code>TransactionTemplate</code>手动管理事务</li>
</ul>
</li>
<li>声明式事务管理<ul>
<li>代码侵入性小，推荐使用</li>
<li>Spring中声明事务通过<strong>AOP实现</strong></li>
<li>基于注解/xml配置文件方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring事务API"><a href="#Spring事务API" class="headerlink" title="Spring事务API"></a>Spring事务API</h3><p>提供了一个接口，代表着事务管理器，这个接口针对不<strong>同的框架提供不同的实现类</strong> </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210304221853695.png" alt="image-20210304221853695"></p>
<h3 id="注解-声明式事务管理"><a href="#注解-声明式事务管理" class="headerlink" title="注解 声明式事务管理"></a>注解 声明式事务管理</h3><ol>
<li><p>在Spring配置文件中配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;TransactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在Spring配置文件中开启事务注解</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string"></span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;TransactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305165809201.png" alt="image-20210305165809201"></p>
<p>看到这个绿了 才代表事务注解开启</p>
</li>
<li><p>在Service类上面（或者Service类的具体方法上面）添加<strong>事务注解@Transactional</strong></p>
<ol>
<li>如果把这个注解添加到类上，代表类所有方法都添加<strong>事务</strong></li>
<li>如果添加到方法上，只为这个方法添加事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//转账的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lucy 少 100</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        <span class="comment">//模拟异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//mary 多 100</span></span><br><span class="line">        userDao.addMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305165244504.png" alt="image-20210305165244504"></p>
<p>数据库之前设置回了两个1000，现在的结果仍然不变，证明事务回滚了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305165311118.png" alt="image-20210305165311118"></p>
</li>
</ol>
<h4 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h4><p>在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<ul>
<li>Transactional注解的参数如下：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305170329832.png" alt="image-20210305170329832"></p>
<h5 id="propagation：事务传播行为"><a href="#propagation：事务传播行为" class="headerlink" title="propagation：事务传播行为"></a>propagation：事务传播行为</h5><p>多<mark>事务方法</mark>直接进行调用，表示这个过程中事务是如何进行管理的</p>
<p>事务方法：指对数据表数据进行变化的操作 ，事务方法≠事务</p>
<p>事务传播行为解释如下图：</p>
<p>在一个事务中调用另一个事务，称为<strong>事务传播行为</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305171415695.png" alt="image-20210305171415695"></p>
<p>事务传播行为：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305171607613.png" alt="image-20210305171607613"></p>
<ul>
<li><p><strong>REQUIRED</strong>：以上述图为例：如果add方法本身有事务，调用update方法后，update使用当前add方法里面的事务；（这也是默认的propagation参数）</p>
<p> 如果add方法本身没有事务，调用update方法后，创建新的事务</p>
</li>
<li><p><strong>REQUIRED_NEW</strong>：同样，以上述图为例：使用add调用update方法，不论add方法是否有事务，都会创建新的事务</p>
</li>
</ul>
<h5 id="solation：事务隔离级别"><a href="#solation：事务隔离级别" class="headerlink" title="solation：事务隔离级别"></a>solation：事务隔离级别</h5><p>事务具有一个特性，我们称为：隔离性 —— 多事务操作之间不会产生影响</p>
<p>假如我们不考虑隔离性，就会有很多问题，包括：<strong>脏读、不可重复读、幻读</strong></p>
<ol>
<li><p><strong>脏读：</strong> 一个<strong>未提交事务</strong>读取到<strong>另一个未提交事务</strong>的数据</p>
<p>以下图为例：A B都想对同一个数据的值进行修改，A首先进行了修改，B这时读到了修改后的数据，但A发生了事务回滚，数据回到了一开始未修改的状态，但是A仍然读到的是修改后的数据，这就是<strong>脏读</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305173122516.png" alt="image-20210305173122516"></p>
</li>
<li><p><strong>不可重复读：</strong> 一个<strong>未提交事务</strong>读取到<strong>另一提交事务中修改</strong>的数据</p>
<p>以下图为例：A B对同一个数据值进行查询。A首先看到数据为5000，B将数据修改成了900，并进行了提交。虽然A并未提交数据，但是此时再查看数据的时候发现数据改变了，这就叫<strong>不可重复读</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305185250438.png" alt="image-20210305185250438"></p>
</li>
<li><p><strong>幻读：</strong> 一个<strong>未提交事务</strong>读取到<strong>另一提交事务中添加</strong>的数据</p>
<p>幻读和不可重复读的区别在于，后者是<strong>修改</strong>，而前者是<strong>添加</strong>；</p>
<p>A B对一个表单进行查询数据，假设一开始只有一条数据。A此时查表，发现只有一条数据，而后B添加了一条数据，A再查数据发现多了一条，这与之前的查询结果不一样，这就叫<strong>幻读</strong></p>
</li>
</ol>
<p>既然有上述问题出现，那么如何解决呢？就通过<mark>设置事务隔离性</mark>去解决读的问题</p>
<p>其中假如我们不设置隔离级别，Mysql默认设置的是：REAPETABLE READ 即 可重复读</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305190003173.png" alt="image-20210305190003173"></p>
<h5 id="timeout：超时时间"><a href="#timeout：超时时间" class="headerlink" title="timeout：超时时间"></a>timeout：超时时间</h5><p>首先需要明白的是：事务需要在一定的时间内进行提交，如果不提交则需要进行<strong>回滚（rollback）</strong></p>
<p>如果不设置超时时间，则默认的超时时间是 -1，设置时间以秒为单位进行计算</p>
<h5 id="readOnly：是否只读"><a href="#readOnly：是否只读" class="headerlink" title="readOnly：是否只读"></a>readOnly：是否只读</h5><ul>
<li><p><strong>读</strong>：指的是查询操作</p>
</li>
<li><p><strong>写</strong>：指的是增添 删除 和修改操作</p>
</li>
<li><p>默认值 ：false，代表着可以进行查询、添加、修改和删除操作</p>
</li>
<li><p>设置成true后：只能进行查询，而不能进行增添、修改和删除操作</p>
</li>
</ul>
<h5 id="rollbackFor：回滚"><a href="#rollbackFor：回滚" class="headerlink" title="rollbackFor：回滚"></a>rollbackFor：回滚</h5><p> 表示：出现了哪些异常进行<strong>事务回滚</strong></p>
<h5 id="noRollbackFor：不回滚"><a href="#noRollbackFor：不回滚" class="headerlink" title="noRollbackFor：不回滚"></a>noRollbackFor：不回滚</h5><p>表示：出现了哪些异常不进行<strong>事务回滚</strong></p>
<h5 id="noRollbackForClassName：不回滚-参数String-类型，默认为空数组。"><a href="#noRollbackForClassName：不回滚-参数String-类型，默认为空数组。" class="headerlink" title="noRollbackForClassName：不回滚 参数String[]类型，默认为空数组。"></a>noRollbackForClassName：不回滚 参数String[]类型，默认为空数组。</h5><h3 id="配置文件-声明式事务管理"><a href="#配置文件-声明式事务管理" class="headerlink" title="配置文件 声明式事务管理"></a>配置文件 声明式事务管理</h3><ol>
<li><p>在spring配置文件中进行配置</p>
<ol>
<li><p>配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>配置通知</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--2.配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;tx:method name=&quot;account*&quot;/&gt; &amp;lt;!&amp;ndash;表示所有以account开头的方法&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>配置切入点和切面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.配置切入点和切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hpg.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这行代码的意思是：把txadvice设置的通知 配置到了PT对应的方法上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.hpg&quot;)</span> <span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">getDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 JdbcTemplate 对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;<span class="comment">//从IOC容器中拿到配置注入的数据源</span></span><br><span class="line">        <span class="comment">//到 ioc 容器中根据类型找到 dataSource</span></span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        <span class="comment">//注入 dataSource</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager</span><br><span class="line">    getDataSourceTransactionManager(DataSource dataSource) &#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，Service类也要开启注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hpg.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//转账的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//lucy 少 100</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        <span class="comment">//模拟异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//mary 多 100</span></span><br><span class="line">        userDao.addMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AccountTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TxConfig.class);</span><br><span class="line"></span><br><span class="line">    UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.accountMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 模拟异常：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305202923965.png" alt="image-20210305202923965"></p>
<p>数据库没有发生变化：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210305202935032.png" alt="image-20210305202935032"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/03/03/Spring/" data-id="ckppikuet0032p0wid4iw8xcq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2021-01-06T14:02:59.477Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h3><ul>
<li>计算机网络：是一个<strong>分散的</strong>、<strong>并具有独立功能</strong>的 <strong>计算机系统</strong>，通过<strong>通信设备</strong>（路由器、交换机、无线网卡…）与<strong>线路</strong>（端系统与通信设备连接的介质）连接起来，由功能完善的<br>软件<strong>实现</strong>资源共享<strong>和</strong>信息传递<strong>的</strong>系统</li>
<li>一句话来说，计算机网络是互连的、自治的计算机集合。<ul>
<li>互连：互联互通，通过通信链路（卫星，电波…)</li>
<li>自治：相互独立,端系统之间可以通信，但不能控制对方，没主从关系</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012200821531.png" alt="image-20201012200821531"></p>
<h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><ul>
<li><strong>数据通信</strong>：文档传输   </li>
<li><strong>资源共享</strong> ：凡是入网用户均能享受网络中各个计算机系统的全部或部分软件、硬件和数据资源，为最本质的功能。</li>
<li><strong>分布式处理</strong>：通过算法将大型的综合性问题交给不同的计算机同时进行处理。用户可以根据需要合理选择网络资源，就近快速地进行处理。</li>
<li><strong>提高可靠性</strong>：一旦某台计算机出现故障，它的任务就可由其他的计算机代为完成，这样可以避免在单机情况下，一台计算机发生故障引起整个系统瘫痪的现象，从而提高系统的可靠性</li>
<li><strong>负载均衡</strong>：而当网络中的某台计算机负担过重时，网络又可以将新的任务交给较空闲的计算机完成，均衡负载，从而提高了每台计算机的可用性</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203319972.png" alt="image-20201012203319972"></p>
<h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203839874.png" alt="image-20201012203839874"></p>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>工作方式<ul>
<li>边缘部分：用户直接使用</li>
<li>核心部分：为边缘部分服务</li>
</ul>
</li>
<li>核心部分为边缘部分服务，支撑边缘部分实现各种功能</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012203947005.png" alt="image-20201012203947005"></p>
<h4 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h4><ul>
<li><p>主要功能分 <strong>数据通信</strong> 和 <strong>资源共享</strong></p>
<ul>
<li>通信子网：实现数据通信</li>
<li>资源子网：实现数据处理/资源共享</li>
</ul>
</li>
<li><p>通信子网:包含网络层，数据链路层，物理层</p>
</li>
<li><p>资源子网:包含应用层，表示层，会话层</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012204615021.png" alt="image-20201012204615021"></p>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012205917270.png" alt="image-20201012205917270"></p>
<ul>
<li>按分布范围分：广域网 城域网 局域网 个人区域网</li>
<li>按使用者分：公用网 专用网</li>
<li>按交换技术分：电路交换 报文交换 分组交换</li>
<li>按拓扑结构分：线型 星型 环形 网状型 混合型</li>
<li>按传输技术分：广播式网络 点对点网络</li>
</ul>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><ul>
<li>速率：<strong>数据率</strong> or <strong>数据传输率</strong> or <strong>比特率</strong></li>
<li>表示连接在计算机网络上的<strong>主机</strong> 在 <strong>数字信道上</strong>传送<strong>数据位数的速率</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012211716629.png" alt="image-20201012211716629"></p>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><ul>
<li>带宽是用于表示网络的通信线路栓送数据的能力，是指<strong>单位时间</strong>内能<strong>向链路发送</strong>多少<strong>数据</strong>，而<strong>不是</strong>单位时间内能<strong>实际传输多少数据</strong>，因为能传输多少数据有很多其他因素限制，<strong>带宽是理想条件下的最高速率</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012213423873.png" alt="image-20201012213423873"></li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><ul>
<li><p>吞吐量：表示单位时间内通过某个网络（或信道，接口）的数据量，是实际速率，其单位是b/s，kb/s，Mb/s</p>
</li>
<li><p>受网络带宽或网络的额定速率的限制。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012214948913.png" alt="image-20201012214948913"></p>
</li>
</ul>
<h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><ul>
<li><strong>时延</strong>：指数据从网络的<strong>一端传送导另一端</strong>所需要的<strong>时间</strong>，也叫<strong>延迟或迟延</strong>，单位是<strong>s</strong>。</li>
<li>时延包括：<strong>发送时延，传播时延，排队时延，处理时延</strong><ul>
<li><strong>发送时延</strong><ul>
<li>是主机或路由器发送数据帧所需要的时间</li>
<li>也是指从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间</li>
<li>发送时延（传输时延）发生在机器的内部的发送器中</li>
<li>等于数据长度/信道带宽</li>
</ul>
</li>
<li><strong>传播时延</strong>:<ul>
<li>取决于电磁波传播速度和链路长度</li>
<li>传播时延则发生在机器外部的传输信道媒体上</li>
<li>等于信道长度/电磁波在信道上的传播速率（这个速率主要由介质影响）</li>
</ul>
</li>
<li><strong>排队时延</strong>:<ul>
<li>是路由器或者交换机处理数据包排队所消耗的时间</li>
<li>一个特定分组的排队时延取决于先期到达的、正在排队等待向链路传输分组的数量</li>
</ul>
</li>
<li><strong>处理时延</strong>:<ul>
<li>主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错或查找适当的路由等等</li>
</ul>
</li>
</ul>
</li>
<li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li>
<li>《计算机网络》一书中将<strong>传输时延</strong>与<strong>传播时延</strong>的关系类比成车队经由收费站的例子；十分生动形象</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017221745259.png" alt="image-20201017221745259"></p>
<h5 id="时延宽带积"><a href="#时延宽带积" class="headerlink" title="时延宽带积"></a>时延宽带积</h5><ul>
<li><p>时延带宽积 = 传播时延 × 带宽</p>
<p>bit                      s                b/s</p>
</li>
<li><p>如何生动形象的描述时延带宽积呢？</p>
<p>我们把链路的<strong>长</strong>定义为<strong>传播时延</strong>;把横截面的<strong>宽</strong>定义为<strong>带宽</strong></p>
<p>一个<strong>比</strong>特经过一个<strong>传播时延</strong>正好通过一个<strong>链路</strong></p>
<p>当第一个比特在左侧出现 然后 碰到右侧时停止，此时链路中的比特数量就是时延带宽积了</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022170410645.png" alt="image-20201022170410645"></p>
<h5 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h5><ul>
<li>从<strong>发送方</strong>发送数据完开始，到<strong>发送方</strong>收到<strong>接收方</strong>的确认，总共经历的时延</li>
<li>RTT越<strong>大</strong>，在收到确认之前，可以发送的<strong>数据越多</strong></li>
<li>RTT包括<ul>
<li><strong>往返传播时延</strong> = <strong>传播时延 × 2</strong></li>
<li>末端处理时间（指的是接收方对数据进行处理所花费的时间）</li>
</ul>
</li>
<li>RTT不包括传输时延，大部分只由<strong>传播时延</strong>决定</li>
</ul>
<h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><ul>
<li><p>利用率</p>
<ul>
<li>信道利用率：有数据通过时间/（有+无）数据通过时间</li>
<li>网络利用率：信道利用率的加权平均值</li>
</ul>
</li>
<li><p>利用率并不是越高越好的，当利用率升高的时候，时延也会急剧增大</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022190039038.png" alt="image-20201022190039038"></p>
</li>
</ul>
<h2 id="计算机体系结构与参考模型"><a href="#计算机体系结构与参考模型" class="headerlink" title="计算机体系结构与参考模型"></a>计算机体系结构与参考模型</h2><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022192251153.png" alt="image-20201022192251153"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022200844795.png" alt="image-20201022200844795"></p>
<ul>
<li>首先我们考虑一下为什么要分层？</li>
</ul>
<p>我们知道，一端要发送文件到另一端前要完成的工作有：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong></li>
<li>告知网络如何识别目的主机</li>
<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常</li>
<li>发起通信的计算机要弄清楚，对方计算机中<strong>文件管理程序</strong>是否已经做好了准备工作</li>
<li>确保差错和意外可以解决</li>
<li>……….等等等等</li>
</ol>
<p>我们这些问题都需要解决，显然不可能在一层就解决，那对于我们程序员来说，最喜欢的事情就是分层处理（大问题→小问题）</p>
<h4 id="分层基本原则"><a href="#分层基本原则" class="headerlink" title="分层基本原则"></a>分层基本原则</h4><ol>
<li>各层之间相互独立，每层 只实现<strong>一种相对独立</strong>的功能</li>
<li>各层之间界面<strong>自然清晰，易于理解</strong>，相互交流尽可能<strong>少</strong></li>
<li>结构上可分隔开，每层都采用<strong>最合适的技术</strong>来实现</li>
<li>保持<strong>下层</strong>对<strong>上层</strong>的独立性，上层单向使用<strong>下层提供的服务</strong></li>
<li>整个分层结构应该能促进<strong>标准化工作</strong></li>
</ol>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022194736600.png" alt="image-20201022194736600"></p>
<ul>
<li>在分层网络结构中，在传输系统的每一层都将建立<strong>协议数据单元（PDU）</strong></li>
<li>PDU由两部分组成：<strong>SDU服务数据单元 + PCI协议控制信息</strong></li>
<li>PDU协议数据单元：对等层次之间传送的数据单位<ul>
<li>SDU服务数据单元：为完成用户所要求的功能而应传送的数据</li>
<li>PCI协议控制信息：控制协议操作的信息</li>
</ul>
</li>
</ul>
<h3 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h3><ul>
<li><strong>实体</strong><ul>
<li>在第n层的活动元素称为n层实体，同一层实体叫做<strong>对等实体</strong>；</li>
<li>当研究开放系统中的信息交换时，往往使用<strong>实体(entity)</strong>这一较为抽象的名词。</li>
</ul>
</li>
<li>协议<ul>
<li>协议为进行网络中的<strong>对等实体</strong>数据交换而建立的规则、标准或约定称为网络协议；</li>
<li>协议的语法方面规则定义了所交换的信息的格式。</li>
<li>协议是<strong>水平</strong>的，即协议是控制<strong>对等实体</strong>之间通信的规则。</li>
<li>协议的语义方面<strong>规则定义</strong>了<strong>发送者</strong>或<strong>接收者</strong>所要<strong>完成的操作</strong>，例如，在何种条件下数据必须重传或丢弃。</li>
<li>在协议的控制下，两个<strong>对等实体间</strong>的通信使得本层能够<strong>向上一层提供服务</strong>。要<strong>实现本层协议</strong>，还<strong>需要使用下面一层所提供的服务。</strong></li>
<li>协议的实现保证了能够<strong>向上一层提供服务</strong>。使用<strong>本层服务的实体</strong>只能<strong>看见服务</strong>而<strong>无法看见下面的协议</strong>。<strong>下面的协议对上面的实体是透明的。</strong></li>
<li>协议由三部分组成：<ul>
<li>语法：规定传输数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：执行各种操作的条件、时序关系等等</li>
</ul>
</li>
</ul>
</li>
<li><strong>接口</strong><ul>
<li>在同一系统中相邻两层的实体进行交互(即交换信息)的地方，通常称为<strong>服务访问点SAP(Service Access Point)</strong>。</li>
<li>服务访问点SAP是一个抽象的概念，它<strong>实际上</strong>就是一个<strong>逻辑接口</strong>，有点像邮政信箱(可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口(并行的或串行的)并不一样。</li>
<li>OSI把层与层之间交换的数据的单位称为<strong>服务数据单元SDU(Service Data Unit)</strong>，它可以与PDU不一样，例如，可以是多个SDU合成为一个PDU，也可以是一个SDU划分为几个PDU。</li>
</ul>
</li>
<li><strong>服务</strong><ul>
<li><strong>服务是垂直的，即服务是由下层向上层通过层间接口提供的。</strong></li>
<li>并非在一个层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</li>
<li>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为<strong>服务原语</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022195305866.png" alt="image-20201022195305866"></p>
<h3 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h3><table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>功能</th>
<th>对应的网络协议</th>
<th>TCP/IP四层概念模型</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>文件传输，文件管理，电子邮件的信息处理——apdu</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td>确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，最小单位——ppdu</td>
<td>Telnet, Rlogin, SNMP, Gopher，JPEG,ASCII</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
<td>负责在网络中的两节点建立，维持和终止通信，在一层协议中，可以解决节点连接的协调和管理问题。包括通信连接的建立，保持会话过程通信连接的畅通，两节点之间的对话，决定通信是否被终端一斤通信终端是决定从何处重新发送，最小单位——spdu</td>
<td>SMTP, DNS，ADSP,ASP</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>定义一些传输数据的协议和端口。传输协议同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题——tpdu</td>
<td>TCP, UDP</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>控制子网的运行，如逻辑编址，分组传输，路由选择最小单位——分组（包）报文</td>
<td>IP, IPX，ICMP,IGMP, ARP, RARP, AKP, UUCP,OSPF</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装，也可以简单的理解为物理寻址。交换机就处在这一层，最小的传输单位——帧</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
<td>数据链路层</td>
</tr>
<tr>
<td>物理层</td>
<td>定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准，传输比特流，因此最小的传输单位——位（比特流）</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td>
<td>数据链路层</td>
</tr>
</tbody></table>
<h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/750327-20160822164857776-669486844.gif" alt="img"></p>
<ul>
<li>为解决计算机网络复杂大问题 → 分层结构</li>
<li>不同的公司使用不同的网络体系结构，因此异构网络是很难通信的</li>
<li>为了解决这个问题，<strong>国际标准化组织ISO</strong>在1984提出开放系统互连（<strong>OSI</strong>）参考模型</li>
<li>虽然它被TCP/IP模型打败了，但是仍具有很高学习价值，下面就来学习下什么是OSI参考模型</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022204144457.png" alt="image-20201022204144457"></p>
<h5 id="ISO-OSI参考模型通信过程"><a href="#ISO-OSI参考模型通信过程" class="headerlink" title="ISO/OSI参考模型通信过程"></a>ISO/OSI参考模型通信过程</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205418866.png" alt="image-20201022205418866"></p>
<ul>
<li>我们不难发现，上面四层：应用层 表示层 会话层 传输层是中间系统没有进行处理的，那么我们可将这部分视作是<strong>端到端</strong>的</li>
<li>而下面三层只知道应该去往下一个节点，因此是<strong>点到点的</strong></li>
</ul>
<p>那么每一层每一层之间其实又进行了什么处理呢?其实就是添加各种<strong>PCI</strong>，而只有每一层对等的知道怎么解那个协议；像是礼物的包装和拆包一样。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205604505.png" alt="image-20201022205604505"></p>
<h5 id="每层的功能"><a href="#每层的功能" class="headerlink" title="每层的功能"></a>每层的功能</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022205841421.png" alt="image-20201022205841421"></p>
<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022210842056.png" alt="image-20201022210842056"></p>
<ul>
<li>应用层是<strong>用户与网络的界面</strong>；</li>
<li>应用层定义的是应用程序用于请求网络服务的<strong>接口</strong>，而不是指应用程序本身。</li>
<li>应用层主要定义了应用程序能够从网络上请求使用哪种类型的服务，并且规定了在从应用程序接收消息或向应用程序发送消息时，数据所必须采用的<strong>格式</strong>。</li>
<li>典型的应用层服务以及对应的协议<ul>
<li><strong>文件传输 - FTP</strong></li>
<li><strong>电子邮件 - SMTP</strong></li>
<li><strong>万维网 - HTTP</strong></li>
</ul>
</li>
</ul>
<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022210853321.png" alt="image-20201022210853321"></p>
<ul>
<li>用于处理在两个通信系统中交换信息的表示方式（语法和语义)</li>
<li><strong>功能</strong><ul>
<li><strong>数据格式变换</strong></li>
<li><strong>数据加密解密</strong></li>
<li><strong>数据压缩和恢复</strong></li>
</ul>
</li>
</ul>
<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024164651127.png" alt="image-20201024164651127"></p>
<ul>
<li><p>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序的传输数据</strong>，这是会话，也是<strong>建立同步（SYN)</strong></p>
<p>会话之间彼此独立，不会互相影响</p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li>建立、管理、终止会话</li>
<li>使用校验点可以使会话在通信失效的时候从校验点/同步点继续恢复通信，实现数据同步</li>
</ul>
</li>
</ul>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024165727974.png" alt></p>
<ul>
<li><p>负责主机中两个进程的通信，即<strong>端到端</strong>的通信，传输内容是报文段或是用户数据报；</p>
</li>
<li><p>我们这里提到 <strong>端到端</strong> 什么是<strong>端到端</strong>呢？</p>
<p>OSI七层模型中，上面四层是<strong>端到端通信</strong>，下面三层是<strong>点到点通信</strong></p>
<p><strong>端到端通信</strong>，是一个网络连接，网络通信需要建立连接，只需要实现应用程序之间通信，而不需要知道底层是如何传输的</p>
<p> A → B → C → D → E</p>
<p><strong>点到点通信</strong>，是发送端把传给他直接相连的设备，这台设备在合适的时候把数据传给与之相连的下一台设备，通过一台一台直接相连的设备，把数据传到接收端。</p>
<p>A → B 、B → C、 C → D 、D → E</p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><p><strong>可靠传输、不可靠传输</strong></p>
<ul>
<li>可靠传输：传输层使用TCP来提供通信数据的可靠传输。（确认机制）</li>
<li>不可靠传输：传输层中不可靠的传输方式使用的是UDP协议（不管确不确认，直接发）</li>
</ul>
</li>
<li><p><strong>差错控制</strong>：报文段数据丢失，需要进行纠正</p>
</li>
<li><p><strong>流量控制</strong>：控制发送方的速度，不能一次传太多</p>
</li>
<li><p><strong>复用分用</strong></p>
<ul>
<li><p><strong>复用</strong>：多个应用层进程可同时使用下面运输层的服务</p>
</li>
<li><p><strong>分用</strong>：运输层把收到的信息分别交付给上面应用层中相应的进程</p>
<p>比如说一台手机上两个进程（应用）QQ和微信，QQ端口号是1 微信端口号是2；</p>
<p>这两个进程同时使用传输层传输数据 —— <strong>复用</strong></p>
<p>另一台手机接收了QQ和微信信息，并且根据其中端口号不同的不同用不同的应用程序接受信息 —— <strong>分用</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024172551239.png" alt="image-20201024172551239"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024172806918.png" alt="image-20201024172806918"></p>
<ul>
<li><p>主要任务是把<strong>分组</strong>（很小的无需分片的ip数据包就是分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务；</p>
<p>网络层传输单位是<strong>数据报</strong></p>
</li>
<li><p><strong>功能</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024174151515.png" alt="image-20201024174151515"></p>
<ul>
<li><strong>路由控制</strong>：左边的主机想和右边的主机通话，那么这个数据包一定会经过网络。中间灰色的圆圈是路由器，他们组成了一个网络，数据链路层只是把这个信息传递了“一跳”，也就是从介质的一端传递到另一端，在图里面比如说从路由器1传递到2.但是网络层做的事情是，规划好所有跳的路线，比如说数据包要依次经过1,2,3,6才能从左边主机到达右边主机，这就是网络层一个非常重要的作用，也就是提供“路由routing”。</li>
<li><strong>流量控制</strong>：控制发送方发送数据的速度（与传输层功能好像有点重读？</li>
<li><strong>差错控制</strong>：通信的节点之间约定一些规则，接收方根据规则校验分组有没有错，然后纠错，纠不了错就丢弃分组；保证传输层的数据是正确的</li>
<li><strong>拥塞控制</strong>：就像城市里面哪里堵车了，其他人就知道不要再去了，网络层也一样。比如上图中2，3路由器出现了严重的拥塞，那么左边主机往右边发送包就会从1236变成1456。拥塞控制对于网络的效率以及降低丢包率有着无可替代的作用。</li>
</ul>
</li>
</ul>
<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024175136346.png" alt="image-20201024175136346"></p>
<ul>
<li><p>主要任务是把网络层传下来的<strong>数据报</strong>组装成<strong>帧</strong></p>
<p>数据链路层/链路层的<strong>传输单位</strong>是<strong>帧</strong></p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><strong>成帧（定义帧的开始和结束）</strong>：</li>
<li><strong>差错控制/错误检测</strong>：这里的错误包括 <strong>帧错+位错</strong>，可以通过一些协议去纠错</li>
<li><strong>流量控制</strong>：同样，也是控制发送方数据的发送速度，确保数据通信的有序进行，还可避免通信过程中不会出现因为接收方来不及接收而造成的数据丢失。</li>
<li><strong>访问（接入）控制/链路控制</strong>：控制对信道的访问，当网络中两个节点要进行通信的时候，数据的发送方必须确知接收方是否已经处在准备接收的状态。为此通信双方必须先交换一些必要信息，以建立一条基本的数据链路。在传输数据时要维持数据链路，而在通信完毕的时候释放数据链路</li>
</ul>
</li>
</ul>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024180209001.png" alt="image-20201024180209001"></p>
<ul>
<li><p>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>（指不管所传数据是什么样的比特组合，都应当能够在链路上进行传输）</p>
<p>物理层传输单位是<strong>比特</strong></p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li><p><strong>定义接口特性</strong></p>
<ul>
<li><p><strong>机械特性</strong>:说明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p>
</li>
<li><p><strong>电气特性</strong>:指明在接口电缆的各条线上出现的电压的范围。</p>
</li>
<li><p><strong>功能特性</strong>:指明某条线上出现的某一电平的电压表示何意。</p>
</li>
<li><p><strong>规程特性</strong>:说明对于不同功能的各种可能事件的出现顺序。</p>
</li>
</ul>
</li>
<li><p>定义传输模式：</p>
<ul>
<li>单工：只能一个发一个收</li>
<li>半双工：两者都可以当发的，可以同时发</li>
<li>双工：两者都可以当发的，但同一时间只能一个人发</li>
</ul>
</li>
<li><p>定义传输速率：十兆、百兆 这些传输速率由物理层进行定义</p>
</li>
<li><p>比特同步：发送方发一个 1 ，接收方接收一个 1</p>
</li>
<li><p>比特编码：什么电压0 ，什么电压表示1</p>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027190911334.png" alt></p>
<p>既然OSI七层协议体系结构概念清楚，理论也完整，那我们为什么不用他呢？因为它太复杂且不适用，而TCP/IP体系结构不然，TCP/IP其实是一个<strong>四层体系结构</strong>，它包含：应用层、传输层、网际层和网络接口层</p>
<p>从实质来说，TCP/IP只包含上面三层，下面的网络接口层没什么协议啊之类的，没什么内容。因此我们往往结合两种模型优点，形成了一种五层协议的体系结构。</p>
<p>在网上看到一段话 用于解释TCP/IP模型，我觉得说的非常好：</p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/90fa75863fce">https://www.jianshu.com/p/90fa75863fce</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">要理解TCP/IP，我们依旧要先搞清楚它想干嘛？</span><br><span class="line"></span><br><span class="line">一句话概括，就是用最少的资源，准确快速的把信息传送到对端去。</span><br><span class="line"></span><br><span class="line">那么这里面就有很多问题要解决了：怎样充分利用资源？用资源怎么发信息？怎样找到对端？怎样做到准确？怎样快速？怎样保证对端完整收到信息？………</span><br><span class="line"></span><br><span class="line">对于学计算机的我们，这个时候应该就能想到，这么多问题，不可能一次性解决，需要分解，分模块来解决，TCP/IP分层模型也是这么想的。</span><br><span class="line"></span><br><span class="line">首先是怎样充分利用资源，用什么物质传又省钱又好用？这就是物理层要解决的问题了，这里展开来就是无线铜线光纤损耗等等的问题。很好理解。</span><br><span class="line"></span><br><span class="line">然后知道介质了，怎样把信息传给设备？这就是数据链路层要解决的问题了。这里需要解决信息的封装问题，信息传送机制问题。所以这一层的所有协议设计都是围绕着怎么传信息展开。</span><br><span class="line"></span><br><span class="line">理论上到这里就结束了，但随着入网设备越来越多，就需要被管理了，所以网络层就来解决网络管理的问题。IP层是整个网络分层里承上启下的核心，他主要解决两个问题，一个是编号，一个是找人。网络太大，人太多，认识不过来，所以要用ip地址给人编号。编完号找人，几十亿人一个个问也不可行，也是要讲方法的，所以这里就有了路由技术。网络层的关键是路由技术，路由技术解决怎样快速准确找到对端的问题。</span><br><span class="line"></span><br><span class="line">找到对端后，怎样保证对端完整收到信息？这就是传输层要解决的问题了，这里就有传送速度的调节，传送信息的验证，传完信息的确认等等问题，对应的TCP和UDP也是两种不同的实现思路。</span><br><span class="line"></span><br><span class="line">来到这里，关于网络的问题基本上就结束了，因为终端已经拿到了别人发过来的信息了，至于怎么处理信息，就是会话层，表示层，应用层的问题了。不同的应用程序有着不同的通信协议（Email——SMTP，Web——Http，文件传输——Ftp等），这些通信协议都工作在应用层。</span><br><span class="line"></span><br><span class="line">可见，分层之间相互独立，却又是紧密合作，他们的出现不是无中生有，而是在问题的解决中，不断成熟并定形的。</span><br></pre></td></tr></table></figure>



<h5 id="面向连接、无连接"><a href="#面向连接、无连接" class="headerlink" title="面向连接、无连接"></a>面向连接、无连接</h5><p>下面我们介绍两种连接方式：<mark>面向连接</mark> 和 <mark>无连接</mark></p>
<ol>
<li><strong>面向连接</strong>分为三个阶段<ol>
<li>建立连接，在此阶段，发出一个建立连接的请求</li>
<li>只有建立成功之后，才能开始数据传输</li>
<li>当数据传输完毕之后，释放连接</li>
</ol>
</li>
<li><strong>无连接</strong>：没有上述阶段，直接进行数据传输</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027193631754.png" alt="image-20201027193631754"></p>
<h5 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h5><h6 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h6><ul>
<li>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</li>
</ul>
<h6 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h6><ul>
<li>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
</ul>
<p>运输层主要使用一下两种协议</p>
<ol>
<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<table>
<thead>
<tr>
<th>UDP</th>
<th>TCP</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p>运行在<code>TCP协议</code>上的协议：</p>
<ul>
<li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议）</code>，主要用于普通浏览。</li>
<li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,<code>HTTP</code>协议的安全版本。</li>
<li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li>
<li><code>POP3（Post Office Protocol, version 3，邮局协议）</code>，收邮件用。</li>
<li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li>
<li><code>TELNET（Teletype over the Network，网络电传）</code>，通过一个<code>终端（terminal）</code>登陆到网络。</li>
<li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li>
</ul>
<p>运行在<code>UDP协议</code>上的协议：</p>
<ul>
<li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li>
<li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li>
<li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li>
</ul>
<p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p>
<ul>
<li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li>
</ul>
<h6 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h6><ul>
<li>网络层(network layer)负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</li>
</ul>
<h6 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h6><ul>
<li>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</li>
</ul>
<h6 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h6><ul>
<li>在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</li>
</ul>
<h1 id="物理层-2"><a href="#物理层-2" class="headerlink" title="物理层"></a>物理层</h1><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112220734703.png" alt="image-20201112220734703"></p>
<h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><ul>
<li>物理层主要关注的点是在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的<strong>传输媒体</strong></li>
<li>物理层的主要任务：确定与传输媒体接口有关的一些特性 也就是 ==定义标准==</li>
</ul>
<ol>
<li><p><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格，接口形状，引线数目，引脚数量和排列情况</p>
</li>
<li><p><strong>电气特性</strong>：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等</p>
</li>
<li><p><strong>功能特性</strong>：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</p>
<p>==电平==：是指两功率或电压之bai比的对数，du有时也可用来表示zhi两电流之比的对数。</p>
</li>
<li><p><strong>规程特性/过程特性</strong>：定义各条物理线路的工作规程和时序关系</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030212511637.png" alt="image-20201030212511637"></p>
<h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="典型数据通信模型"><a href="#典型数据通信模型" class="headerlink" title="典型数据通信模型"></a>典型数据通信模型</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030213350863.png" alt></p>
<p>如上图所示，我们的 电脑称为信源，用于信号转换的”猫”（路由猫）称为调职解调器，信号传入的公用电话网称为广域网；</p>
<p>其中 <strong>信源 + 发送器</strong> 称为 ==源系统==；中间<strong>传输系统</strong>依旧是==传输系统==；<strong>接收器 + 信宿</strong> 称为==目的系统==</p>
<h3 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h3><p>我们知道，数据的目的是为了传送消息，那么为了传送消息 需要什么呢？</p>
<ul>
<li><p>数据：传送信息的实体，通常是有意义的符号序列（汉字 转成的计算机可以理解的语言 010101….）</p>
</li>
<li><p>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式；</p>
<ul>
<li><p>数字信号：代表消息的参数取值是离散的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030215723704.png" alt="image-20201030215723704"></p>
</li>
<li><p>模拟信号：代表消息的参数取值的连续的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030215731831.png" alt="image-20201030215731831"></p>
</li>
</ul>
</li>
<li><p>信源：产生和发送数据的==源头==</p>
</li>
<li><p>信宿：接收数据的==终点==</p>
</li>
<li><p>信道：<strong>信号的传输媒介</strong>，一般用来表示向某个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道</p>
<ul>
<li>按照传输信号来分<ul>
<li>模拟信道：传送模拟信号</li>
<li>数字信道：传送数字信号</li>
</ul>
</li>
<li>按照传输介质来分<ul>
<li>无线信道：不需要介质，通过无线电波等</li>
<li>有线信道：需要介质，通过同轴电缆等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><p>从通信双方信息的交互方式来看，有三种基本方式：</p>
<ol>
<li>==单工通信==：只有<strong>一个方向的通信</strong>而<strong>没有反方向</strong>的交互，仅需要<strong>一条信道</strong></li>
<li>==半双工通信==：通信的双方都可以发送或接收信息，但任何一方都<strong>不能同时</strong>发送和接收，需要<strong>两条信道</strong></li>
<li>==全双工通信==：通信双方<strong>可以同时</strong>发送和接收信息，需要<strong>两条信道</strong></li>
</ol>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><p>如果说通信方式是决定谁来做发送方，谁来做接收方的话，那么数据传输方式就是研究数据在信道上的传输方式</p>
<p>传输方式主要分两种：串行传输 和 并行传输</p>
<ul>
<li><p>串行传输：使用bai一条数据线，将du数据一位一位地依次传输，每zhi一位数据占据一个固定的时间长度dao。只需要少数几条线就可以在系统间交换信息；</p>
<p>特点：速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远距离</strong>传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030221935943.png" alt="image-20201030221935943"></p>
</li>
<li><p>并行传输：并行传输指的是数据以成组的方式，在多条并行信道上同时进行传输，是在传输中有多个数据位同时在设备之间进行的传输。</p>
<p>特点：速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近距离</strong>传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030222150405.png" alt="image-20201030222150405"></p>
</li>
</ul>
<h2 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><ul>
<li>码元：是指用一个<strong>固定时长</strong>的<strong>信号波形（数字脉冲)</strong>，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个<strong>时长</strong>内的信号称为<strong>k进制码元</strong>，而该<strong>时长</strong>称为<strong>码元宽度</strong>。码元的<strong>离散状态（就是可以有几种形态)</strong>有M个的时候，此时码元就成为<strong>M进制码元</strong></li>
<li>一个码元可以<strong>携带多个比特的信息量</strong>。譬如在<strong>二进制</strong>编码中，只有2种不同码元，0状态和1状态</li>
</ul>
<p>是不是感觉很抽象，我们结合图示来理解</p>
<p>下面是一个4进制码元，代表着有四种离散状态，以为着有四种高低不同的波形</p>
<p>四种高低不同波形可以用比特组合：00，01，10，11 来表示</p>
<p>下图中，一个波形 代表着的是1个码元，携带着2个比特的信息量</p>
<p>要注意：四进制码元 代表着 可以由0、1组成4种组合，每个组合是由01组成的；</p>
<p><strong>因此 n进制码元 携带着log2n个比特的信息量</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103202344690.png" alt="image-20201103202344690"></p>
<h3 id="速率-1"><a href="#速率-1" class="headerlink" title="速率"></a>速率</h3><ul>
<li><p>速率，也称为<strong>数据率</strong>，代表着数据的<strong>传输速率</strong>（不是传播速率，不是一个概念），代表着单位时间内传输的数据量。</p>
<p>可以用==码元传输速率==和==信息传输速率==来表示</p>
<ul>
<li><p>==码元传输速率==：别名<strong>码元速率、波形速率、调制速率、符号速率等</strong></p>
<ul>
<li><p>表示单位时间内数字通信系统所传输的码元个数（也可以称为是<strong>脉冲个数或信号变化的次数</strong>）</p>
</li>
<li><p>单位是<strong>波特</strong>（Baud）</p>
</li>
<li><p>1波特表示数字通信系统每秒传输一个码元；此处的码元可以是多进制的；</p>
</li>
<li><p>码元速率与进制数<strong>无关</strong></p>
</li>
<li><p>==言简意赅：1s传输了多少个码元==</p>
<p>下图的码元传输速率就是5波特，表示1秒传送了5个码元</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103205304365.png" alt="image-20201103205304365"></p>
</li>
</ul>
</li>
<li><p>==信息传输速率==：别名<strong>信息速率、比特率</strong></p>
<ul>
<li>表示单位时间内数字通信系统传输的二进制码元个数（即比特数）</li>
<li>单位是比特/秒（b/s）</li>
<li>==言简意赅：1s传输了多少个比特==</li>
</ul>
</li>
<li><p>若一个码元携带<strong>n比特</strong>的信息量，则<strong>M 波特</strong>的码元传输速率所对应的<strong>信息传输速率</strong>为==*<em>M×n *</em>bit/s==</p>
</li>
</ul>
</li>
</ul>
<h3 id="带宽-1"><a href="#带宽-1" class="headerlink" title="带宽"></a>带宽</h3><ul>
<li>表示在单位时间内从网络的某一点到另一点所能通过的<strong>最高数据率</strong>，常用来表示网络的通信线路能传输数据的能力；</li>
<li>单位是 b/s</li>
</ul>
<h2 id="编码＆调制"><a href="#编码＆调制" class="headerlink" title="编码＆调制"></a>编码＆调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><ul>
<li>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质；因此一条通信线路往往包含一条<strong>发送信道</strong>和一条<strong>接受信道</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103212329122.png" alt="image-20201103212329122"></p>
<p>而信道上传送的信号肯定也有不同，分为：<strong>基带信号</strong>和<strong>宽带信号</strong></p>
<ul>
<li><p>基带信号：将数字信号1、0直接用不同的电压表示，再送到数字信道上传输（==基带传输==）；</p>
<p>最大的特点就是：基带信号是<strong>来自信源的信号</strong></p>
<p><strong>基带信号</strong>就是发出了<strong>直接表达了的要传输的信息的信号（无须二次加工）</strong></p>
</li>
<li><p>宽带信号：将基带信号进行调制后行程的频分复用<strong>模拟信号</strong>，再传送到<strong>模拟信道</strong>上去传输（==宽带传输==）；</p>
<p><strong>基带信号</strong>经过载波调制后，把信号的频率范围搬移到较高的频段上以便在信道种传输（二次加工)</p>
</li>
<li><p>传输距离近 → 基带传输</p>
</li>
<li><p>传输距离远 → 宽带传输</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103213741148.png" alt="image-20201103213741148"></p>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103215604932.png" alt="image-20201103215604932"></p>
<h4 id="先置概念"><a href="#先置概念" class="headerlink" title="先置概念"></a>先置概念</h4><ul>
<li><p>数据：即要传送的信息。分 数字数据（离散的）和模拟数据（连续的）两种。</p>
</li>
<li><p>信号：数据的电气或电磁表现。亦分 数字信号（离散的）和模拟信号（连续的）两种。</p>
</li>
</ul>
<p>我们要传输数据，但数据是不能直接传输的，必须转换成信号，即我们用信号来表示数据。<br>而当我们要使用数据，是不能直接使用信号的，需把信号转换成数据。</p>
<p>因此，我们有了<code>数据</code>和<code>信号</code>互相转换的需求。</p>
<p>数据有两种，信号有两种，自然就有四种转换</p>
<h4 id="模拟信号和数字信号"><a href="#模拟信号和数字信号" class="headerlink" title="模拟信号和数字信号"></a>模拟信号和数字信号</h4><p><img src="https://img-blog.csdnimg.cn/20190226235309127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>模拟信号：简单来说就是，用电信号去模拟其他信号。电话、传真、电视信号都是模拟信号。如上图第一行。</p>
<p>模拟信号具有连续的特点，可以表达丰富的数值信息，但在传播的过程中容易受到干扰，出现失真的情况。</p>
<p>而数字信号是离散的。因为数字信号只用两种物理状态来表示0和1的（如上图的第二行），故其抗干扰能力比模拟信号强很多。</p>
<p><img src="https://img-blog.csdnimg.cn/20190227000451909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>当传输距离较远时，波形失真度一般较大，这时候我们可以通过中继器（即休息站）来保持波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20190227000715561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">在现代技术的信号处理中，数字信号发挥的作用越来越大，几乎复杂的信号处理都离不开数字信号；或者说，只要能把解决问题的方法用数学公式表示，就能用计算机来处理代表物理量的数字信号。</p>
<h4 id="模拟数据-→-数字信号"><a href="#模拟数据-→-数字信号" class="headerlink" title="模拟数据 → 数字信号"></a>模拟数据 → 数字信号</h4><p><img src="https://img-blog.csdnimg.cn/20190227000850472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>由于计算机内部处理的是二进制数据，处理的都是数字音频，因此需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）</p>
<p>模拟信号的数字化一般需要三个步骤：<strong>抽样、量化和编码</strong>。</p>
<ul>
<li><p>==抽样==：对模拟信号周期性的扫描，把时间上连续的信号变成时间上离散的信号。</p>
<p>如上图，每 1s 进行一次采样（采样的频率被称为采样率）。</p>
<p>当然 采样也不是随便采的，需要遵循采样定理进行采样<code>f采样频率 ≥ 2f信号最高频率</code></p>
</li>
<li><p>==量化==：因为模拟信号本质上是一连串连续的值，我们可以对这些值进行等级划分（量化的等级），这样步骤一的采集到的样品就可以被划分到不同的等级。</p>
<p>具体方法：把抽样取得的<strong>电平幅值</strong>按照一定的分级标度转换为对应的数字值，并取整数，这就把连续的<strong>电平幅值</strong>转换为离散的<strong>数字量</strong></p>
</li>
<li><p>==编码==：步骤二中的不同等级可以表示不同的编码。则连续的模拟信号最终可以转化 0101 的数字信号。也就是把量化的结果转换为与之对应的二进制编码</p>
</li>
</ul>
<p>综上，不难得出，随着采样率和量化等级的增加，转换后的数字信号的曲线也就越能贴近模拟信号的曲线（对比上图的原曲线和黄色曲线）。</p>
<h4 id="数字数据-→-数字信号"><a href="#数字数据-→-数字信号" class="headerlink" title="数字数据 → 数字信号"></a>数字数据 → 数字信号</h4><p>比如我们在键盘上输入<code>A</code>，实际上就是把<code>A</code>对应的 ASCII 二进制编码<code>0100 0001</code>转换成了对应的脉冲信号（脉冲信号是数字信号的一种，即离散的），传给了电脑的 CPU。</p>
<ul>
<li><p>常见的脉冲信号：</p>
<p><img src="https://img-blog.csdnimg.cn/20190804204605803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>比如我们可以用正脉冲表示<code>1</code>，负脉冲表示<code>0</code>。此即编码。</p>
</li>
<li><p>常见的编码方式：</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190804210807302.png" alt="img"></p>
<ul>
<li><p>==非归零编码【NRZ】(高1低0)==：编码容易实现，但是没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步，比如说发了一长串的1，接收方读不出来到底有几个1，需要发送方告知；</p>
</li>
<li><p>==归零编码【RZ】==：信号电平在一个码元之内都要恢复到0这种编码成编码方式</p>
</li>
<li><p>==反向不归零编码【NRZI】==信号电平翻转表示0，信号电平不变表示1 （下图例子为 1 0 0 1 1 0 1 0）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103222516296.png" alt="image-20201103222516296"></p>
</li>
<li><p>==曼彻斯特编码==：将一个码元分成两个相等的间隔：【前一个间隔为低电平+后一个间隔为高电平 = 码元1】【前一个间隔为高电平 + 后一个间隔为低电平 = 码元0】当然也可以采取相反的规定了。</p>
<p>该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步），又可以作数据信号，但他的频带宽度是原始的基带宽度的两倍</p>
<p>由于每一个码元都被调成了2个电平，因此<strong>栓据传输速率只有调制速率的1/2</strong></p>
</li>
<li><p>==差分曼彻斯特编码==: 如果<strong>前半个码元电平</strong>与<strong>上一个码元</strong>的<strong>后半个码元</strong>电平相同，则为1；反之则为0；</p>
<p>编码的特点是：在每个码元的中间，都有一次电平跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码</p>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108222609379.png" alt="image-20201108222609379"></p>
</li>
<li><p>==4B/5B编码==：比特流插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B；编码效率为80%；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109204002802.png" alt="image-20201109204002802"></p>
<p>我们知道 2^4^ = 16,2^5^ = 32；因此这种编码只会采用16种去对应16种不同的<strong>四位码</strong>，而另外的16位作为<strong>控制码（帧的开始和结束，线路的状态信息等）或保留</strong></p>
</li>
</ul>
<p>我们刚才说到，敲击键盘后，键盘会向 CPU 发出一串脉冲信号。</p>
<p>事实上，我们把这种，在数字信号频谱中，把直流（零频）开始到能量集中的一段频率范围称为基本频带，简称为基带。因此，数字信号被称为<code>数字基带信号</code>，在信道中直接传输这种基带信号就称为<code>基带传输</code>。</p>
<p>这种传输方式的缺点是，在基带传输中，整个信道只传输一种信号，通信信道利用率低。</p>
<p>由于在近距离范围内，基带信号的功率衰减不大，从而信道容量不会发生变化，因此，在局域网中通常使用基带传输技术。</p>
<h4 id="数字数据-→-模拟信号"><a href="#数字数据-→-模拟信号" class="headerlink" title="数字数据 → 模拟信号"></a>数字数据 → 模拟信号</h4><p>如果要将数据进行远距离传输，只能将数字信号转换为模拟信号，再进行传输。</p>
<p>为什么呢？因为上面有提到数字信号，又叫数字基带信号。频率低，在传输的过程中容易失真。因此需要<code>调制</code>为高频信号（频带信号）。</p>
<p>将<strong>基带信号（数字信号）</strong>转换为<strong>模拟信号</strong>的过程，称为<code>调制</code>。对应的转换器称为==调制器==。</p>
<p>反过来将<strong>模拟信号</strong>转换为<strong>数据（数字信号）</strong>的转换器称为==解调器==。</p>
<p><strong>模拟信号</strong>只在<strong>模拟信道</strong>上传输。如绞线、光纤，模拟信号以无线电波的形式在上面传递。这种传输叫<code>频带传输</code>。</p>
<p>4种数字调制形式：<strong>ASK,PSK,FSK,QAM</strong></p>
<ul>
<li><strong>ASK（调幅）</strong>:按波的幅度受到数字数据的调制而取不同的值，如对应二进制0 → 振幅位0，二进制1 → 振幅为1</li>
<li><strong>FSK（调频）</strong>:即按数字数据的值（0或1）调制载<strong>波的频率</strong>。例如对应二进制0的载波频率为F1，而对应二进制1的载波频率为F2。</li>
<li><strong>PSK（调相）</strong>：即按数字数据的值调制载波<strong>相位</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109210050702.png" alt="image-20201109210050702"></p>
<p>思考一下 某通信链路的波特率是1200Baud，采用了4个相位，每个相位有四种振幅的QAM（调幅+调相）技术，则该链路的信息传输速率是多少？</p>
<p>分析：我们需要算 信息传输速率 需要知道 波特率（码元传输速率）以及一个码元携带了多少个比特</p>
<p>我们现在知道其中一个条件了，则需要知道另一个条件即可求解</p>
<p>4个相位，每个相位有4种振幅，那么就有16种不同波形的码元 → 16进制的码元；</p>
<p>而16进制码元可以由 log2 16求解=4，也就是一个码元携带4个比特</p>
<p>那么信息传输速率 = 1200 × 4 = 4800(b/s)</p>
<h4 id="模拟数据-→-模拟信号"><a href="#模拟数据-→-模拟信号" class="headerlink" title="模拟数据 → 模拟信号"></a>模拟数据 → 模拟信号</h4><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用<strong>频分复用技术</strong>，充分利用贷款资源；</p>
<p>在电话机和本地交换机所传输的信号是采用<strong>模拟信号传模拟数据的方式</strong></p>
<p>比如下图:</p>
<p>有一个广播电台发射塔，然后我对着麦克风说话，我对着话筒说话，传出来声波，但这个声波是频率很低的，在信道上会衰减，导致传不出去；因此，需要把这个声波调制成高频的信号。通过解调器再把信号转成声波，通过收音机播放。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109213521662.png" alt="image-20201109213521662"></p>
<h2 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109214402508.png" alt="image-20201109214402508"></p>
<ul>
<li>影响失真程度的因素<ul>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ul>
</li>
</ul>
<h3 id="失真现象-码间串扰"><a href="#失真现象-码间串扰" class="headerlink" title="失真现象-码间串扰"></a>失真现象-码间串扰</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109214959124.png" alt="image-20201109214959124"></p>
<p>如果信道带宽太小，不能通过信道，我们这很好理解；</p>
<p>那为什么信道带宽高了也不能通过呢？这就是因为<strong>码间串扰</strong></p>
<ul>
<li><p>码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<p>为什么会有码间串扰呢？是由于信道带宽远大于脉冲带宽时，脉冲的拓展很小，当信道带宽接近于信号的带宽的时候，拓展会超过一个码元周期，造成信号脉冲的重叠，这就形成<strong>码间串扰</strong>了</p>
<p>其实简单来说就是频率过快了，分辨不出来码元了</p>
</li>
</ul>
<h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>奈氏准则是为了解决<strong>码间串扰</strong>这一问题的</p>
<ul>
<li><p>==<strong>奈氏准则</strong>==：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2 W Baud，w是信道带宽，单位是hz</p>
<p>只有在奈氏准则，香农定理中带宽单位采用hz，其他时候都是bit/s</p>
</li>
</ul>
<p>同时，我们也得到了以下几点结论：</p>
<ol>
<li><p>任何信道中，码元传输速率有上限，超过上限，就产生码间干扰。</p>
</li>
<li><p>信道的频带越宽，即通过的信号高频分量越多，可以用更高的速率就行码元的有效传输</p>
</li>
<li><p><strong>奈氏准则</strong>只是限制码元传输速率，<strong>香农定理</strong>才真的限制信息传输速率</p>
</li>
<li><p>由于码元的传输速率受奈氏准则制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多的信息量，这就需要采用<strong>多元制</strong>的调制方法。</p>
</li>
<li><p>理想低通信道下的极限数据传输率=<strong>2Wlog2V</strong> （b/s） <strong>w</strong>是带宽，<strong>v</strong>是几种码元，即码元的离散电平数目、</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111102027489.png" alt="image-20201111102027489"></p>
</li>
</ol>
<h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>奈氏准则只规定了极限码元传输速率，但没有规定极限比特传输速率是多少</p>
<p>而我们的<strong>香农定理</strong>就是来解决这个问题的，同时它还考虑了<strong>噪声</strong>的干扰</p>
<p>噪声是随机产生的，他的瞬时值很大，影响接收端的判决</p>
<p>但噪声的影响是相对的，若信号较强，那么噪声影响相对较小，因此，信噪比就很重要。</p>
<p><strong>信噪比=信号的平均功率/噪声的平均功率，常记作S/N，并用分贝(db)作为度量单位</strong></p>
<p><strong>即：信噪比（db）= 10log10（S/N）数值等价</strong></p>
<ul>
<li><p><strong>==香农定理==</strong>：在带宽受限且有噪声的情况下，为了不产生误差，信息的数据传输速率有上限值</p>
</li>
<li><p>信道的极限数据传输速率=Wlog2（1+S/N） b/s</p>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201111102152770.png" alt="image-20201111102152770"></p>
</li>
</ul>
<p>同样，我们可以得出以下结论：</p>
<ol>
<li>带宽或者信噪比越大，信息的传输速率就越高</li>
<li>对一定的chuanshu带宽和一定信噪比，信息传输速率的上限就确定了</li>
<li>只要信息的传输速率低于信息的极限传输速率，就一定有方法来实现无差错传输</li>
<li>香农定理得到的为极限信息传输速率，实际信道能达到的传输速率比他低不少</li>
<li>若信道带宽W或者信噪比S/N没上限，那信道的极限信息传输速率也没有上限</li>
</ol>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111103347887.png" alt="image-20201111103347887"></p>
<h2 id="传输介质及分类"><a href="#传输介质及分类" class="headerlink" title="传输介质及分类"></a>传输介质及分类</h2><p>传输介质也称传输媒体/传输媒介，是数据传输系统中，在发送设备和接收设备之间的物理通路</p>
<p>传输媒体≠物理层，传输媒体在物理层下面，因为物理层是体系结构第一层，因此有时候称传输媒体为第0层。</p>
<p>在传输媒体中传输的是<strong>信号</strong>，传输媒体并不能解析这个信号</p>
<p>而物理层规定<strong>电气特性</strong>，因此可以识别传送的比特流</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111104318427.png" alt="image-20201111104318427"></p>
<h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><h4 id="导向性传输介质-1-双绞线"><a href="#导向性传输介质-1-双绞线" class="headerlink" title="导向性传输介质 - 1.双绞线"></a>导向性传输介质 - 1.双绞线</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111104958448.png" alt="image-20201111104958448"></p>
<h4 id="导向性传输介质-2-同轴电缆"><a href="#导向性传输介质-2-同轴电缆" class="headerlink" title="导向性传输介质 - 2.同轴电缆"></a>导向性传输介质 - 2.同轴电缆</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111105542264.png" alt="image-20201111105542264"></p>
<h4 id="导向性传输介质-3-光纤"><a href="#导向性传输介质-3-光纤" class="headerlink" title="导向性传输介质 - 3.光纤"></a>导向性传输介质 - 3.光纤</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111110145645.png" alt="image-20201111110145645"></p>
<ul>
<li>光纤特点<ul>
<li>传输损耗小、中继距离长，对远距离传输经济</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无传音干扰，保密性好，不容易被窃听或截取数据</li>
<li>体积小，重量轻</li>
</ul>
</li>
</ul>
<h5 id="单模光纤、多模光纤"><a href="#单模光纤、多模光纤" class="headerlink" title="单模光纤、多模光纤"></a>单模光纤、多模光纤</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111110741251.png" alt="image-20201111110741251"></p>
<h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111111321549.png" alt="image-20201111111321549"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112212848540.png" alt="image-20201112212848540"></p>
<ul>
<li><p>==诞生原因==：由于信号传输存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定的程度就会造成信号的失真，因此会导致接受错误</p>
</li>
<li><p>==中继器的功能==：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度</p>
</li>
<li><p>==中继器的两端==：两端的的网络部分是<strong>网段</strong>，而不是<strong>子网</strong>，适用于完全相同的两类网络的互连，且两个网段速率要相同</p>
<p>中继器只负责发送电缆端的数据，但读不懂里面的数据，因此里面就算有错误数据也照样会被传输</p>
<p>中继器两端可以连相同媒体也可以连不同媒体</p>
<p>中继器两端的网段必须要是同一个协议</p>
</li>
<li><p>==5-4-3规则==：网络标准中对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会造成网络的故障</p>
<p>所谓“5-4-3规则”，是指在10M<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/以太网">以太网</a>中，网络总长度不得超过<strong>5个区段</strong>，<strong>4台网络延长设备</strong>，且<strong>5个区段中只有3个区段可接<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/网络设备">网络设备</a>。</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112213440447.png" alt="image-20201112213440447"></p>
</li>
</ul>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><ul>
<li>集线器功能：对信号进行再生放大转发，对衰减的信号进行放大， 接着转发到其他所有处于工作状态的端口上，以增加<strong>信号传输的距离</strong>，延长网络的长度。</li>
<li>集线器不具备信号的定向传送能力，是一个共享式设备</li>
<li>集线器工作过程：节点发送信号到信道，集线器接收该信号，该信号在电缆传输中有衰减，集线器接收信号后将衰减的信号<strong>整形放大</strong>，最后集线器把放大的信号广播转发给其他所有<strong>端口</strong></li>
<li>由于集线器不能够分割<strong>冲突域</strong>，因此连在<strong>集线器上的工作主机</strong>需要平分带宽</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112215953832.png" alt="image-20201112215953832"></p>
<h1 id="数据链路层-2"><a href="#数据链路层-2" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><ul>
<li><p><strong>结点：</strong>主机、路由器</p>
</li>
<li><p><strong>链路（物理链路）：</strong>网络中两个结点之间的物理线路（有线或者无线），中间没有任其他的交换节点，链路的传输介质主要有双绞线、光纤和微波；进行数据通信的时候，两台计算机之间的通信路径往往要经过许多段这样的链路。链路只是一条路径的组成部分</p>
</li>
<li><p><strong>数据链路（逻辑链路）：</strong>数据链路≠链路，在一条线路上传送数据的时候，除了需要一条物理线路（链路），还需要一些必要的通信协议去控制数据的传输。把实现这些协议的<strong>硬件和软件</strong>加到链路上，就构成 <mark>数据链路</mark></p>
<p>现在常用<strong>网络适配器</strong>去实现这些协议；</p>
</li>
<li><p><strong>帧：</strong>点对点信道的数据链路层的协议数据单元</p>
</li>
</ul>
<p>数据链路层负责通过一条链路从<strong>一个结点</strong>向另一个物理链路直接相连的<strong>相邻结点</strong>传送数据报（数据报是网络层协议数据单元，又称为IP数据报，分组或是包）</p>
<p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>，其最基本的服务是将源自<strong>网络层</strong>的数据可靠的传输到相邻节点的<strong>目标机网络层</strong>，其主要作用是加强物理层传输原始比特流的功能：什么意思呢？原本不是说 物理层不管数据是否正确都会传输吗？那么数据链路层就会把物理层中可能出错的物理连接改成<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路了。</p>
<ul>
<li><mark><strong>数据链路层功能</strong></mark>：<ul>
<li><strong>为网络层提供服务</strong>：无确认无连接服务、有确认无连接服务、有确认面向连接服务<ul>
<li><mark><em>无确认无连接服务</em></mark>：发送数据的时候不需要建立连接，收到数据也不需要返回确认。通常用于实时通信、码率比较低的信道；</li>
<li><mark><em>有确认无连接服务</em></mark>：发送数据事先不需要建立连接，但目的主机收到数据需要返回确认。通常用于码率比较高的通信，比如无线通信</li>
<li><mark><em>有确认面向连接服务</em></mark>：最安全最可靠的服务，事先需要建立连接，收到数据也需要返回确认。通常用于通信质量差的无线传输链路</li>
</ul>
</li>
<li><strong>链路管理</strong>：即连接的建立、维持和释放</li>
<li><strong>组帧</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>差错控制（帧错/位错）</strong></li>
</ul>
</li>
</ul>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>首先我们需要明白一个概念：所有在互联网上传送的数据都是以分组（IP数据报）为传送单位</p>
<p>因此对于这分组进行<strong>加工处理</strong>就非常有必要了</p>
<p>如下图所示，<mark>IP数据报</mark>传送到数据链路层就成为了帧的<strong>数据部分</strong></p>
<ul>
<li><h4 id="组装成帧"><a href="#组装成帧" class="headerlink" title="组装成帧"></a>组装成帧</h4><p>就是在帧的数据部分前后部分分别添加上<strong>首部和尾部</strong>，构成一个完整的帧。这样的帧 → 数据链路层的<strong>数据传送单元</strong></p>
<p>接收端在收到物理层上交的比特流后，根据首部和尾部表寄，从收到的比特流中识别帧的开始和结束——这就是<strong>帧定界</strong></p>
<p>此外，首部尾部还包含许多控制信息。</p>
<p>一个帧的帧长 = 帧的数据部分长度 + 帧首部长度 + 帧尾部长度 </p>
<p>为了提高帧的传输效率，应尽可能使<strong>帧的数据部分长度</strong>尽可能大于首部和尾部长度，但不能无限大：每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限——最大传送单元MTU</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218213138634.png" alt="image-20201218213138634"></p>
<p>组帧的四种方式：字符计数法、字符填充法、零比特填充法、违规编码法</p>
<h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117220136249.png" alt="image-20201117220136249"></p>
<p>这种方法就是用每一个帧的<strong>第一个计数字段</strong>表命该帧包含了几个字符数</p>
<p>但是这种方法风险也很大，一旦某一帧开始出错了，后面的基本都会出错</p>
<h4 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117222624482.png" alt="image-20201117222624482"></p>
<h4 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h4><p>这个方法确定了发送端与接收端都是包含了6个1，这样的话我们只要保证数据部分不存在连续六个1即可</p>
<p>那么<strong>零比特填充法</strong>就是扫描信息字段，只要出现连续5个1，就填充个0来保证不出现连续的六个1</p>
<p>而接受的时候也非常方便，只需要扫描，发现连续5个1就删除掉后面的0，就可以保证数据的正确性啦</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117223137910.png" alt="image-20201117223137910"></p>
<h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>曼彻斯特编码中，不存在连续的高或者连续的低；</p>
<p>因此用连续高或者连续低表示首尾标志，这就是违规编码的思想</p>
<p>主要应用在物理层进行编码，只适用于采用冗余编码的特殊编码环境</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201118215607086.png" alt="image-20201118215607086"></p>
<p>由于字节计数法count字段脆弱性（如果一个错了后面跟着全错）</p>
<p>字符填充实现上的复杂和不兼容性</p>
<p>一般来说采用<strong>比特填充和违规编码法</strong></p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul>
<li>在数据链路层透明传送数据：表示无论什么样的比特组合的数据都能按照原样无差错的通过数据链路层，因此链路层是看不到有什么妨碍数据传输的东西，换句话说就是，数据链路层对这些数据来说是<strong>透明的</strong></li>
<li>如下图所示：数据的某个二进制代码正好与EOT的控制字符相同，那接收端误以为是传输结束的控制符，其后面的数据因为找不到SOH就被接收端当作<strong>无效帧</strong>丢弃了。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113214934518.png" alt="image-20201113214934518"></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125203545446.png" alt="image-20201125203545446"></p>
<p>要进行控制，首先要明白差错是从何而来。</p>
<p>通常来说，传输中的差错都是由于噪声所引起的</p>
<p>噪声分两种：<strong>全局性噪声和局部性噪声</strong></p>
<ul>
<li>全局性：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125193958284.png" alt="image-20201125193958284"></li>
<li>局部性:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125193958284.png" alt></li>
</ul>
<p>差错也分为两种：<strong>位错和帧错</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194102872.png" alt="image-20201125194102872"></p>
<p>链路层为网络层提供服务：</p>
<ul>
<li>无确认无连接服务（通信质量好，通常用于有线传输链路）</li>
<li>有确认无连接服务（通信质量差的无线传输链路）</li>
<li>有确认面向连接服务（通信质量差的无线传输链路）</li>
</ul>
<h4 id="检错编码与纠错编码"><a href="#检错编码与纠错编码" class="headerlink" title="检错编码与纠错编码"></a>检错编码与纠错编码</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194435401.png" alt="image-20201125194435401"></p>
<h5 id="检错编码-奇偶校验码"><a href="#检错编码-奇偶校验码" class="headerlink" title="检错编码 - 奇偶校验码"></a>检错编码 - 奇偶校验码</h5><p>奇偶校验码 就是用 <strong>n - 1位信息元表示信息，1位校验元用于校验的校验方式</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125194620006.png" alt="image-20201125194620006"></p>
<p>注意 这里的奇偶校验码指的是 加上了校验元后 1的个数是奇数还是偶数 而不是加之前</p>
<ul>
<li><p>奇偶校验码特点:</p>
<p>只能检查出奇数个比特错误，检错能力为50%：什么意思呢？假如有一串编码为111001的编码采用奇校验 → 111001<mark>1</mark></p>
<p>此时传过来的假如是111001<mark>0</mark> 那我可以发现是错的，但假如传过来是1110110 还是奇数个1，虽然是错误的，但我无法检验出来</p>
</li>
</ul>
<h5 id="检错编码-CRC循环冗余码"><a href="#检错编码-CRC循环冗余码" class="headerlink" title="检错编码 - CRC循环冗余码"></a>检错编码 - CRC循环冗余码</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125195452859.png" alt="image-20201125195452859"></p>
<p>发送端 把要传的数据 %（取余） 生成的多项式  所得到的结果是 <mark>FCS帧检验序列/冗余码</mark></p>
<ul>
<li><p>冗余码的计算方式：</p>
<p>题目给定生成多项式，求它的阶（最高次）r，在所传的数据后 + r个0</p>
<p>然后用这个新数据去 % 生成的多样式 所得到的余数就是FCS（冗余码）</p>
</li>
</ul>
<p>得到了冗余码之后，把该冗余码 添加在索要发送的数据后 这就是我们最重要发送的数据了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200200951.png" alt="image-20201125200200951"></p>
<p>而接收端把传过来的数据 % 所生成的多项式 </p>
<p>若没有余数，代表该帧在传输过程中无差错，否则认为出了差错。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200507201.png" alt="image-20201125200507201"></p>
<h5 id="纠错编码-海明码"><a href="#纠错编码-海明码" class="headerlink" title="纠错编码 - 海明码"></a>纠错编码 - 海明码</h5><p>海明码：发现双比特错，纠正单比特错</p>
<p>基本工作原理:<mark>动一发而牵全身</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125200945084.png" alt="image-20201125200945084"></p>
<ul>
<li><p>确定校验码位数r</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125201218149.png" alt="image-20201125201218149"></p>
</li>
<li><p>确认校验码和数据的位置</p>
<p>将校验码放在2的几次方的位置 （2的几次方从0开始 ） 之后按照顺序把数据填下来，并写出实际值</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125201328620.png" alt="image-20201125201328620"></p>
</li>
<li><p>求出校验码的值</p>
<p> 这一步应该是最难懂的了：其求值方法是<strong>令所有要检验的位异或=0</strong>（异或，2个值相同为0，不相同为1）</p>
<p>什么意思呢？以P1为例子：</p>
<p>它的数据位是1，二进制表示成0001（因为有4位校验码 所以说是xxxx）</p>
<p>它的1在第一位，因此要找还有哪个代码的1在第四位：有D1,D2,D4,D5</p>
<p>那么就令P1⊕D1⊕D2⊕D4⊕D5 = 0</p>
<p>其中D1 D2 D4 D5的取值是用下面的实际值来代表</p>
<p>P1⊕1⊕0⊕1⊕0=P1⊕(1⊕0)⊕(1⊕0) = P1⊕（1⊕1）=P1⊕0=0</p>
<p>则P1 = 0 同理可求得 其他得校验码P2,P3,P4</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125202212275.png" alt="image-20201125202212275"></p>
</li>
<li><p>检错并纠错</p>
<p>纠错的方法与上面其实很相似。</p>
<p>首先用四个校验码分别异或运算 得出新的P1,P2,P3,P4实际值</p>
<p>然后反着从P4写到P1 形成新的二进制数，这个二进制数所表示的十进制数 就是出错的位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125203314628.png" alt="image-20201125203314628"></p>
</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125204100218.png" alt="image-20201125204100218"></p>
<p>为什么要有流量控制呢？因为<strong>高发送速度</strong>和<strong>低接受能力</strong>不匹配会造成传输出错</p>
<p>数据链路层与传输层都有流量控制 其区别在于：</p>
<ul>
<li>数据链路层的流量控制是<strong>点 → 点</strong>的，其流量控制手段是：接收方收不下就不回复确认</li>
<li>传输层的流量控制是<strong>端 → 端</strong>的，其流量控制手段是：接收端给发送端一个窗口公式（一个回复？）</li>
</ul>
<h4 id="流量控制方法"><a href="#流量控制方法" class="headerlink" title="流量控制方法"></a>流量控制方法</h4><p>控制方法有两种协议：<mark>停止 - 等待协议</mark> 和 <mark>滑动窗口协议（包括后退N帧协议<strong>GBN</strong>，选择重传协议<strong>SR</strong>）</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125204841578.png" alt="image-20201125204841578"></p>
<ul>
<li>停止-等待协议就是 发送完一个帧就等待一下确认，收到确认后再发下一个帧</li>
<li>滑动窗口协议就是 发送端和接收端各有一个窗口，发送端一股脑将窗口里的所有帧全部发送出去，当接收端收到帧后 接收窗口往后移一个单位，并返回确认，发送端接收到了接收端的确认后，发送窗口也往后移一个单位。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125205820355.png" alt="image-20201125205820355"></p>
<h5 id="可靠传输，滑动窗口，流量控制"><a href="#可靠传输，滑动窗口，流量控制" class="headerlink" title="可靠传输，滑动窗口，流量控制"></a>可靠传输，滑动窗口，流量控制</h5><ul>
<li>可靠传输：发送端发的数据，接收端都能接受</li>
<li>流量控制：控制发送速率，让接收端有<strong>足够的缓冲空间</strong>来接受每一个帧</li>
<li>解决方案:滑动窗口（包含了可靠传输和流量控制两个特性）<ul>
<li>可靠传输：依靠发送端的自动重传机制</li>
<li>流量控制：依靠接收端的如果收不下就不给确认，导致发送端想发送帧也发不了</li>
</ul>
</li>
</ul>
<h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止 - 等待协议"></a>停止 - 等待协议</h4><ol>
<li><p>为什么要有<strong>停止 - 等待协议？</strong></p>
<ol>
<li><p>因为除了比特出差错意外，底层的信道也会出现<strong>丢包</strong>的问题。</p>
<p>（丢包 是指物理线路故障、设备故障、病毒攻击、路由信息错误等原因，导致数据包的丢失</p>
</li>
<li><p>为了实现流量控制</p>
</li>
</ol>
</li>
<li><p>研究停止等待协议的前提？</p>
<p>虽然现在经常使用全双工通信方式，但为了讨论问题的方便，仅仅考虑一方发送数据（发送方），一方接受数据（接收方）</p>
<p>停止 - 等待协议就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下个分组。</p>
</li>
<li><p>停止- 等待协议有几种应用情况？</p>
<p>主要有两种：有差错情况 和 无差错</p>
</li>
</ol>
<h5 id="停-等协议-之-无差错情况"><a href="#停-等协议-之-无差错情况" class="headerlink" title="停 - 等协议 之 无差错情况"></a>停 - 等协议 之 无差错情况</h5><p>其实就是发送方发一个帧，接收方对于发送的帧进行确认 （通过返回ACK 0 / 1)</p>
<p>指的注意的是 第一次发送的0帧与第二次发送的0帧并不是一回事，这只是一个编号而已</p>
<p>如果可以的话 其实可以理解成发送A 确认A，发送B 确认B….发送N 确认N</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210203114341.png" alt="image-20201210203114341"></p>
<h5 id="停-等协议-有差错情况"><a href="#停-等协议-有差错情况" class="headerlink" title="停 - 等协议 有差错情况"></a>停 - 等协议 有差错情况</h5><ol>
<li><p><strong>当发现数据帧丢失或检测到帧出错</strong></p>
<ol>
<li>类似于OS中进程饥饿现象，假如接收端迟迟收不到发送端发来的数据帧，就会导致无法发送确认帧，下一个帧就无法发送过去，形成了<mark>饥饿</mark>现象；为了解决这个问题，引入了<strong>超时重传方法</strong></li>
<li><strong>超时计时器</strong> —— 每次发送一个帧就启动一个计时器 ；</li>
<li>回忆一下什么是<mark>RTT</mark>:数据从网络一端传送到另一端所需时间（包的往返时间，也就是单纯发出去还不够，还得包含回来的时间）</li>
<li><mark>超时重传时间（RTO）</mark>：计时器记录的时间超过RTO就重新传输数据，RTO的设置应该是比RTT值略大一点点</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210205156432.png" alt="image-20201210205156432"></p>
</li>
<li><p><strong>ACK丢失</strong></p>
<p>由于确认帧（ACK）的丢失，发送方会误认为没发过去数据，于是又发一次帧；</p>
<p>但这个帧是重复的，我们怎么办呢？</p>
<p>对于这种情况，确认方会丢弃重复的发送过来的帧，并进行重传确认；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210210003641.png" alt="image-20201210210003641"></p>
</li>
<li><p><strong>ACK迟到</strong></p>
<p>ACK的发送有可能会有延迟，此时发送方会把一开始来晚的确认帧收下并且丢弃掉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210210554755.png" alt="image-20201210210554755"></p>
</li>
</ol>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>这个方法虽然简单，但是信道的利用率非常低</p>
<p>什么是信道利用率呢？</p>
<p>是发送方在<strong>一个发送周期内</strong>,有效地发送数据所需要的的时间占<strong>整个发送周期的比率</strong></p>
<p>有效发送数据时间：发送时延 因为在这个时间段内有在一直发送数据</p>
<p>整个发送周期：<strong>发送时延 + RTT + 接受时延</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201210212405281.png" alt="image-20201210212405281"></p>
<h4 id="GBN-与-SR"><a href="#GBN-与-SR" class="headerlink" title="GBN 与 SR"></a>GBN 与 SR</h4><p>GBN(后退重传协议) SR（选择重传协议）</p>
<p>有新协议肯定是为了解决之前协议所带来的不足问题的，回想一下之前的 停止-等待协议：</p>
<p>它每次只发一个帧，需要等到收到确认了才发下一个，这种方式信道利用率太低了。</p>
<p>有人说 可以在发送的时候不单单发一个帧，而是发很多个帧，这种方式叫<strong>流水线技术</strong></p>
<p>而这种技术需要：</p>
<ol>
<li>增加序号的范围</li>
<li>发送方需要缓存多个分组</li>
</ol>
<p>针对这两种解决方案 我们有两种协议：<strong>后退N帧协议 和 选择重传协议</strong></p>
<h4 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211180209766.png" alt="image-20201211180209766"></p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ul>
<li><p><mark>发送窗口</mark>：发送方维持一组<strong>连续</strong>的允许发送的<strong>帧</strong>的<strong>序号</strong></p>
<p>意思是格子中的数字并不代表数据，而是序号（1号帧，2号帧这样）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172238290.png" alt="image-20201211172238290"></p>
</li>
<li><p><mark>接收窗口</mark>：接收方维持一组连续的允许接收的<strong>帧</strong>的<strong>序号</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172238290.png" alt="image-20201211172244046"></p>
</li>
<li><p><strong>停止 - 等待协议</strong>其实可以理解成 <strong>接收窗口 和 发送窗口 都是1</strong>的后退N帧协议</p>
</li>
</ul>
<p>发送过程：</p>
<p>发送窗口一般可分为<strong>四</strong>部分:</p>
<ol>
<li>发完被确认的</li>
<li>已经发送但等待接收端确认的</li>
<li>在窗口内 还能继续发送的</li>
<li>不在窗口内 暂时不能发的</li>
</ol>
<p>ps:橙色部分是 发送端发送的帧的拷贝副本（保证帧不丢失嘛）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211172542168.png" alt="image-20201211172542168"></p>
<h5 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h5><p>这三件事分别为：</p>
<ol>
<li><p><strong>上层的调用</strong></p>
<ol>
<li>上层要发送数据的时候，发送方要先检查发送窗口是否已满，如果<strong>未满</strong>，就产生一个帧并且将其发送；</li>
<li>如果窗口<strong>已满</strong>，发送方就只需要将数据返回给上层，按时上层窗口已满，等一会再发</li>
<li>对于2这种情况，发送方可以缓存这些数据，等到窗口不满的时候再发帧</li>
</ol>
</li>
<li><p><strong>收到了一个ACK</strong></p>
<p>GBN协议中，对n号帧的确认采用了<mark>累计确认</mark>的方式，标明接收方已经收到n号帧以及它之前的全部帧</p>
</li>
<li><p><strong>超时事件</strong></p>
<p>协议的名字叫后退N帧，来源于出现<strong>丢失</strong>和<strong>时延</strong>过长帧时发送方的<strong>行为</strong>。类似于停-等协议，定时器将再次用于<strong>恢复数据帧或确认帧的丢失</strong>。如果出现超时，发送方将会重传<mark>所有已发送但没有被确认的帧</mark></p>
</li>
</ol>
<h5 id="GBN接收方需要做的事"><a href="#GBN接收方需要做的事" class="headerlink" title="GBN接收方需要做的事"></a>GBN接收方需要做的事</h5><p>可以简单记忆为：接受正确帧回复ACK、其余情况都丢弃帧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211174152514.png" alt="image-20201211174152514"></p>
<h5 id="运行中的GBN"><a href="#运行中的GBN" class="headerlink" title="运行中的GBN"></a>运行中的GBN</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211174602686.png" alt="image-20201211174602686"></p>
<h5 id="滑动窗口的长度"><a href="#滑动窗口的长度" class="headerlink" title="滑动窗口的长度"></a>滑动窗口的长度</h5><p>如果是采用n个比特对帧的编号,那么发送窗口的尺寸W应该满足：</p>
<p><code>1 &lt;= W &lt; 2^n - 1</code></p>
<p>因为如果发送窗口太小，那就没什么意义，而如果过大，会导致接收方无法区别<strong>新帧和旧帧</strong></p>
<p>比如发送方为:12341234,窗口尺寸为4；然后我发第一个1丢失了，过了一会发送方又会发一次1234，那么究竟是前半段的还是后半段的呢？</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211175602540.png" alt="image-20201211175602540"></p>
<h5 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h5><ul>
<li><strong>优点</strong>：因为连续发送数据帧而提高了信道利用率</li>
<li><strong>缺点</strong>：在重传的时候必须把原来已经正确传送的数据帧给重传了，使得传送效率降低了</li>
</ul>
<h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203522001.png" alt="image-20201211203522001"></p>
<ul>
<li>选择重传协议（Selective Repeat）</li>
</ul>
<p>上一节我们学习了GBN，虽然方便，但有一个问题，它会批量重传，那么有没有一个办法可以只重传出错的帧呢？</p>
<p>有一个解决办法：设置单个确认，同时加大接受窗口，设置接受缓存，缓存乱序到达的帧</p>
<h5 id="SR中的滑动窗口"><a href="#SR中的滑动窗口" class="headerlink" title="SR中的滑动窗口"></a>SR中的滑动窗口</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211181238830.png" alt="image-20201211181238830"></p>
<h5 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h5><ol>
<li><p><strong>上层的调用</strong></p>
<ol>
<li>上层要发送数据的时候，发送方要先检查下一个<strong>可用于该帧的序号</strong>；</li>
<li>如果序号在发送窗口内，就发送数据帧</li>
<li>如果不在，就要么先将数据缓存没要么返回给上层之后在传输</li>
</ol>
</li>
<li><p><strong>收到了一个ACK</strong></p>
<p>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为<strong>已接收</strong>；</p>
<p>如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处</p>
<p>如果窗口移动了，并且有<strong>序号在窗口</strong>内的<strong>未发送帧</strong>，就发送这些帧</p>
</li>
<li><p><strong>超时事件</strong></p>
<p>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧</p>
</li>
</ol>
<h5 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218213350924.png" alt="image-20201218213350924"></p>
<h5 id="运行中的SR"><a href="#运行中的SR" class="headerlink" title="运行中的SR"></a>运行中的SR</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211201830691.png" alt="image-20201211201830691"></p>
<h5 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203045763.png" alt="image-20201211203045763"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201211203156437.png" alt=" "></p>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><h4 id="数据传输使用的两种链路"><a href="#数据传输使用的两种链路" class="headerlink" title="数据传输使用的两种链路"></a>数据传输使用的两种链路</h4><ul>
<li>点对点链路<ul>
<li>两个相邻的节点通过一个链路进行连接，其间没有第三者</li>
<li>应用：PPP协议，常应用于<mark>广域网</mark></li>
</ul>
</li>
<li>广播式链路<ul>
<li>所有的主机共享通信介质</li>
<li>应用：早期的总线以太网、无线局域网，常应用于<mark>局域网</mark></li>
<li>典型拓扑结构：总线型、星型（逻辑总线型）</li>
</ul>
</li>
</ul>
<h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><p>介质访问控制的内容就是采取一定的措施，使得两对节点之间的通信不会发生相互干扰的情况</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105161938675.png" alt="image-20210105161938675"></p>
<h5 id="信道划分介质访问控制-1"><a href="#信道划分介质访问控制-1" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h5><ul>
<li>这种控制方式的本质：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把<strong>时域</strong>和<strong>频域资源</strong>合理地分配给网络上的设备,是基于多路复用技术去划分资源的</li>
<li>网络负载重的时候：共享信道效率高（处于忙碌状态的主机很多，都在工作中），公平（分配资源平均分配的）</li>
<li>网络负载轻的时候：共享信道效率低（处于忙碌状态的主机很少）</li>
</ul>
<p>假设现在有三组主机间需要进行信号传输：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212175524387.png" alt="image-20201212175524387"></p>
<p>明明三组主机都需要经过同一个信道，那么有没有一种办法能只用一条信道去传输信息呢？</p>
<p>答案是：<mark>多路复用技术</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212175828985.png" alt="image-20201212175828985"></p>
<h6 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212180421784.png" alt="image-20201212180421784"></p>
<h6 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h6><p> 这里引入了一个概念:<strong>时隙</strong></p>
<p>时隙可以理解成一个<mark>时间片</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212180715242.png" alt="image-20201212180715242"></p>
<h6 id="改进的时分复用-统计时分复用STDM"><a href="#改进的时分复用-统计时分复用STDM" class="headerlink" title="改进的时分复用 - 统计时分复用STDM"></a>改进的时分复用 - 统计时分复用STDM</h6><p>上面的这种方式，有一个问题，假如我只有D用户需要发数据，但由于我排在了ABC后面，我得等他们的时隙转完了，才能轮到我</p>
<p>因此就有了改进措施了：用一个集中器，把所有要发的数据收集起来，只要收到的数据达到了一定帧长，就发送；</p>
<p>这样就不用管我排在第几位了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212181620617.png" alt="image-20201212181620617"></p>
<h6 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212201805495.png" alt="image-20201212201805495"></p>
<h6 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h6><p>分享两个解释码分多路复用的博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianlongtc/article/details/80152442">https://blog.csdn.net/tianlongtc/article/details/80152442</a></p>
<p><a target="_blank" rel="noopener" href="https://bingw.blog.csdn.net/article/details/52705205">https://bingw.blog.csdn.net/article/details/52705205</a></p>
<p>网上的博客喜欢把CDM与坐标系联系在一起，就是给定一个向量空间内的向量，然后就能解出各轴上的向量表达式；</p>
<p>（学过线代的同学应该对这个非常熟悉了）</p>
<p>码分多址（CDMA）是码分复用的一种方式：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201212205538902.png" alt="image-20201212205538902"></p>
<p>其实可以理解成 把多个坐标轴上的数据统一了规格，然后用一个信道去传送符合某种算法的数据，接收方只需要根据算法反向破译，就能够得到原来不同坐标轴上的数据；</p>
<p>因此，我们只需要考虑三个问题：</p>
<ul>
<li><p>如何做到各坐标轴独立，数据能不弄混</p>
<ul>
<li><p>CDMA规定了，多个站点同时发送数据的时候，各站点芯片(码片)序列是<strong>相互正交的</strong></p>
<p>什么意思呢？正交：向量S和T<strong>规格化内积</strong>是0</p>
<p>即：两个向量相乘的点积再除以向量分量的个数 = 0（向量能点积就意味着向量长度相同）。</p>
</li>
</ul>
</li>
<li><p>如何做到合并，把各坐标轴上的数据放到一个信道上进行传输</p>
<ul>
<li>让各路数据在信道中被线性的相加（各比特对应的序列线性相加）</li>
</ul>
</li>
<li><p>如何分离，知道哪些数据是A站点发的，哪些是B站点发的</p>
<ul>
<li>使用第二步中合并的数据，与源站<strong>规格化内积</strong>（点乘再除以位数）就可以解出来是0还是1…（用-1表示0比特）</li>
</ul>
</li>
</ul>
<h5 id="随机访问介质控制"><a href="#随机访问介质控制" class="headerlink" title="随机访问介质控制"></a>随机访问介质控制</h5><p>这种控制方式特点是：所有用户都可以<strong>随机</strong>发送信息，发送信息的时候是可以占<strong>全部带宽的</strong></p>
<p>但这种情况就一定会产生用户冲突，于是就有了一系列规定或者说协议，去调和这个矛盾</p>
<ul>
<li>网络负载重的时候：产生冲突开销（产生冲突，发送的数据就会失效，因此产生开销）</li>
<li>网络负载轻的时候：共享信道效率高，单个结点就可以利用信道全部带宽</li>
</ul>
<h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><p>ALOHA协议分为两种：纯ALOHA协议和时隙ALOHA协议</p>
<ul>
<li><strong>纯ALOHA</strong><ul>
<li><strong>协议思想</strong>：不监听信道，不按时间槽发送，随机重发，想发就发；</li>
<li><strong>冲突检测方法</strong>：如果发生了冲突，接收方能够检测出差错，并且不予以确认，发送方在一定时间内收不到（确认帧）就判断出发生了冲突</li>
<li><strong>冲突解决办法</strong>：超时后，等待一个<strong>随机时间</strong>再重传</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213160036860.png" alt="image-20201213160036860"></p>
<ul>
<li><p><strong>时隙ALOHA</strong></p>
<ul>
<li><p><strong>协议思想：</strong>把时间分成了<strong>若干个相同的时间片</strong>，所有用户在时间片<strong>开始时刻</strong>同步接入网络信道，如果发生了冲突（发生冲突，就是一个完整的时间片内并不是只有我一个用户在发数据）</p>
<p>就必须等下一个时间片开始的时候再发送 —— 控制了ALOHA协议想发就发的<mark>随意性</mark></p>
</li>
<li><p><strong>冲突检测方法</strong>：只能在<mark>整时整分</mark>的时候发送数据，如果有两个用户同时发送了，接收方就会检测到出错，也就无法返回确认帧；</p>
</li>
<li><p><strong>冲突解决办法</strong>：发送方超时没接收到确认帧就等到下一个<mark>整时整分</mark>的时候重发</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213160941790.png" alt="image-20201213160941790"></p>
<ul>
<li>细枝末节<ul>
<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>
<li>纯ALOHA协议是想发就发的，而时隙ALOHA协议只有在时间片段开始的时候才能发</li>
</ul>
</li>
</ul>
<h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6><p>载波监听多路访问协议CSMA（carrier sense multiple access）</p>
<ul>
<li><strong>CS:载波监听</strong>，每个站发送数据之前检测一下总线上是否有其他的计算机在发送数据</li>
<li><strong>MA:多点接入</strong>，表示有许多计算机以多点接入的方式连接在<strong>一根总线</strong>上</li>
</ul>
<p>协议的核心思想是：发送帧<strong>之前</strong>，监听信道</p>
<p>根据信道空闲与否，选择发送完整帧还是推迟发送</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161550163.png" alt="image-20201213161550163"></p>
<ul>
<li><h4 id="1-坚持CSMA"><a href="#1-坚持CSMA" class="headerlink" title="1-坚持CSMA"></a><mark>1-坚持CSMA</mark></h4></li>
</ul>
<p>这里的<strong>坚持</strong>指的是对于监听到了信道<mark>忙</mark>后的坚持 （也就是发现忙了还继续听，直到空闲就抓住机会立刻传输）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213162607336.png" alt="image-20201213162607336"></p>
<hr>
<ul>
<li><h4 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a><mark>非坚持CSMA</mark></h4></li>
</ul>
<p><strong>非坚持</strong>指的是对于监听信道<mark>忙</mark>后就<strong>不继续监听了</strong>，也就是<strong>不坚持了</strong>（也就是发现忙了后，等一个随机时间后再监听，不会傻傻继续等）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213162858548.png" alt="image-20201213162858548"></p>
<hr>
<ul>
<li><h4 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p - 坚持CSMA"></a><mark>p - 坚持CSMA</mark></h4></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213163127853.png" alt="image-20201213163127853"></p>
<ul>
<li><h4 id="三种CSMA对比总结"><a href="#三种CSMA对比总结" class="headerlink" title="三种CSMA对比总结"></a><mark>三种CSMA对比总结</mark></h4></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213163300015.png" alt="image-20201213163300015"></p>
<hr>
<ul>
<li><h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA-CD协议"></a><mark>CSMA-CD协议</mark></h4></li>
</ul>
<p>学习该协议，需要明白 <strong>CS MA CD</strong>三个分别代表着什么</p>
<ul>
<li><p><mark>CS</mark>：<strong>载波监听</strong>，指的是每个<strong>站</strong>在<mark>发送数据之前</mark>以及<mark>发送数据的时候</mark>，都需要检测一下<strong>总线</strong>上是否有其他计算机在发送数据</p>
</li>
<li><p><mark>MA</mark>：<strong>多点接入</strong>，表示许多计算机以多点接入的方式连接在一根总线上</p>
<p>说明CSMA/CD协议用于<strong>总线型网络</strong></p>
</li>
<li><p><mark>CD</mark>：<strong>碰撞检测（冲突检测）</strong>，<strong>边发送边监听</strong>，适配器<strong>边发送数据边检测信道上信号电压变化情况</strong>，以便判断自己在发送数据的时候，别的站是不是也在发送数据</p>
<p>侧面说明了CSMA/CD协议应用于<strong>半双工网络</strong>（不允许双方同时发送信息的网络）</p>
</li>
<li><h5 id="传播时延对于载波监听影响"><a href="#传播时延对于载波监听影响" class="headerlink" title="传播时延对于载波监听影响"></a>传播时延对于载波监听影响</h5></li>
</ul>
<p>想一想，既然是监听后确定信道没人了再发送数据，那么为什么还会有<strong>冲突</strong>呢？是因为有着<strong>传播时延</strong>，也就是信号的传输是需要时间的，你正在征用信道的时候，你这个信号没传过去，别人还就误以为现在信道是空的了，也就是所谓的<strong>监听失误</strong></p>
<p>但我们需要明白，对于链路层这里来说，我发生了碰撞并不会影响发送数据，而是在发送到对方那端的时候进行差错检测，才能发现，哦原来发生了碰撞，这时候才能停发。</p>
<p>设总线上单程<strong>端到端</strong>的<strong>传播时延</strong>为τ（tao）</p>
<p>那么A发送数据后，最迟需要经过多久才能知道自己发送的数据与其他站发送的数据有么有发送碰撞？</p>
<p>答案是：2τ，也就是两倍的总线端到端的传播时延/总线的端到端往返传播时延</p>
<p>也就是说只要经过2τ的时间还没有检测到碰撞，那么就肯定这次发送不会发送碰撞</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105165259377.png" alt="image-20210105165259377"></p>
<ul>
<li>如何确定碰撞后的重传时机</li>
</ul>
<p>采用<strong>截断二进制指数规避算法</strong></p>
<p>主要分成以下几步：</p>
<ol>
<li>首先确定<strong>基本推迟的时间</strong>为2τ</li>
<li>第二步，定义<strong>参数k （重传次数）</strong>，k = min{重传次数，10}</li>
<li>第三步，在离散的整数集合[0,1,…..,2^k - 1]中选一个数作为<strong>r</strong>，此时重传的所需要推迟的时间就是<strong>r倍的基本退避时间</strong></li>
<li>第四步，判断重传次数，假如为16次，就说明网络太拥挤了，判断这个帧是永远无法正确发出去的，就抛弃掉，并向上层报告出错</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105171008058.png" alt="image-20210105171008058"></p>
<ul>
<li>最小帧长问题</li>
</ul>
<p>考虑下，假如一个帧，非常小，我发送方发出去了，在途中发生碰撞，由于有碰撞，接收方理所应当的会丢弃掉这个帧对吧？但我发送方以及发送完了，并不知道出了错啊，因此并不会再发一次，这个帧就白白丢失掉了。因此为了避免这种情况，以太网规定了<mark>最小帧长</mark></p>
<p>以太网规定了最小帧长为64字节 = 512bit，如果发送数据很小，没达到这个最小长度，就假如一些填充字节</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105172018775.png" alt="image-20210105172018775"></p>
<hr>
<ul>
<li><h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA-CA协议"></a><mark>CSMA-CA协议</mark></h4></li>
</ul>
<p>载波监听多点接入/碰撞<strong>避免</strong> CSMA/CA (carrier sense multiple access with collision avoidance)</p>
<p>为什么要有CSMA-CA协议呢？是因为 之前的CSMA -CD (冲突检测) 这种方式在无线局域网中有两个问题：</p>
<ol>
<li>无法做到360°全面检测冲突</li>
<li>当A和C都检测不到信号，认为信道是空闲的时候，就会向终端B发送数据帧，导致了冲突</li>
</ol>
<p><strong>工作原理：</strong></p>
<p>RTS/CTS机制的工作原理是，发送站点在向接收站点发送数据包之前，即在DIFS之后不是立即发送数据，而是代之以发送一个请求发送<mark>RTS（Ready To Send）帧</mark>，以申请对介质的占用</p>
<p>当接收站点收到<strong>RTS信号</strong>后，立即在一个<strong>短帧隙SIFS</strong>之后回应一个<mark>准许发 CTS（Clear To send）帧</mark>，告知对方已准备好接收数据。</p>
<p>双方在成功交换RTS/CTS信号对（即完成握手）后才开始真正的数据传递，保证了多个互不可见的发送站点同时向同一接收站点发送信号时，实际只能是收到接收站点回应CTS帧的那个站点能够进行发送，避免了冲突发生。</p>
<p>即使有冲突发生，也只是在发送RTS帧时，这种情况下，由于收不到接收站点的CTS消息，大家再回头用DCF提供的竞争机制，分配一个随机退守定时值，等待下一次介质空闲DIFS后竞争发送RTS帧，直到成功为止。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218002216775.png" alt="image-20201218002216775"></p>
<ul>
<li><h4 id="CSMA-CA-与-CSMA-CD"><a href="#CSMA-CA-与-CSMA-CD" class="headerlink" title="CSMA/CA 与 CSMA/CD"></a>CSMA/CA 与 CSMA/CD</h4><ul>
<li><p>相同点：这两种机制都属于CSMA的思路 —— <mark>先听再说</mark>（也就是这两种方式在接入信道之前都需要“敲敲门”，进行监听，发现了信道是空闲的，才能进行接入）</p>
</li>
<li><p>不同点：</p>
<ul>
<li><p>传输介质不同：CA方式用于<strong>无线局域网（无线）</strong>，CD方式用于<strong>总线式以太网（有线）</strong></p>
</li>
<li><p>载波检测方式不同：由于传输介质的不同，这两种方式的载波检测方式也是不同的</p>
<p>CD通过电缆中电压变化进行检测，数据发生碰撞的时候，电缆中电压会随之而变化；</p>
<p><strong>CA采用能量检测（ED）</strong>，<strong>载波检测（CS）</strong>和<strong>能量载波检测混合检测</strong>三种检测信道空闲的方式</p>
</li>
<li><p>CSMA/CD 是 <strong>检测冲突</strong>，CSMA/CA 是 <strong>避免冲突</strong>，两者发生冲突后都会进行<mark>有上限的重传</mark></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="轮询访问介质控制"><a href="#轮询访问介质控制" class="headerlink" title="轮询访问介质控制"></a>轮询访问介质控制</h5><p>结合了信道划分介质访问控制和随机访问介质控制的两个优点，做到：</p>
<p>既不产生冲突，又可以发送的时候占全部带宽</p>
<p>主要包括：轮询协议和令牌传递协议</p>
<h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><mark>轮询协议</mark></h6><p>核心思想：主节点轮流询问/邀请从属结点发送数据<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213165808469.png" alt="image-20201213165808469"></p>
<h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><mark>令牌传递协议</mark></h6><p>首先要明白什么是令牌：</p>
<p>“令牌”是一个特殊格式的MAC控制帧，不含任何信息。它是用于控制信道的使用，确保了<strong>同一时刻</strong>只有<strong>一个结点独占信道</strong></p>
<p>虽然说它不含任何信息，但不代表不能携带信息，假如一个主机想要用令牌传递数据，会修改令牌上的标记位，并说明要发给哪个主机</p>
<p>然后传递令牌，接受主机发现令牌上有自己的数据，就接受，最后令牌回到发送的主机上，清空标记位，进行令牌下一轮传递。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213170539234.png" alt="image-20201213170539234"></p>
<h2 id="局域网基本概念-amp-体系结构"><a href="#局域网基本概念-amp-体系结构" class="headerlink" title="局域网基本概念 &amp; 体系结构"></a>局域网基本概念 &amp; 体系结构</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul>
<li><p>局域网(Local Area Network, LAN)是指在一个较小的地理范围(如一所学校) 内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络</p>
<p>也就是 <strong>某一区域内</strong>由多台计算机互联组成的<strong>计算机组</strong>，使用的是<mark>广播信道</mark>（与点对点传输相对）</p>
</li>
<li><p>特点2中提到的是有线介质，其实局域网中包含无线局域网，就不用有线介质了；</p>
</li>
<li><p>决定局域网的因素为：<strong>网络拓扑</strong>、<strong>传输介质</strong>和<strong>介质访问控制办法</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218004411562.png" alt="image-20201218004411562"></p>
<h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><p>主要有四种拓扑结构：</p>
<ol>
<li><p><strong>星型拓扑</strong></p>
<p>定义：网络中各节点都连接到一个中心设备上，由该中心节点向目标节点传送信息。<br>优点：网络的维护和调试方便。</p>
</li>
<li><p><strong>总线型拓扑</strong></p>
<p>各个节点都连接到单一连续的物理线路上<br>常见的总线结构局域网<br>Ethernet 、ARCnet 、Token Bus 。<br>特征：信息广播式传播<br>特点：价格低廉，用户接入灵活，是一种小型、成熟、经济的解决方案。</p>
</li>
<li><p><strong>环形拓扑</strong></p>
<p>定义：连续网络中各节点的电缆构成一个封闭的环。<br>信息传递方式：沿节点单向传输。<br>应用范围：<br>一是工厂环境中，环网抗干扰能力强；<br>二是有许多大型机场合。</p>
</li>
<li><p><strong>树形拓扑</strong></p>
<p>易于拓展和隔离故障，但容易有<strong>单点故障</strong></p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218004811356.png" alt="image-20201218004811356"></p>
<h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><p>局域网细分为<strong>有线局域网和无线局域网</strong></p>
<ul>
<li>有线局域网：常用介质为 —— 双绞线、同轴电缆、光纤</li>
<li>无线局域网：常用介质为 —— 电磁波</li>
</ul>
<h4 id="介质访问控制办法"><a href="#介质访问控制办法" class="headerlink" title="介质访问控制办法"></a>介质访问控制办法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218005153816.png" alt="image-20201218005153816"></p>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><p>主要分为五种：</p>
<ol>
<li><p><strong>以太网</strong>：这个是目前应用最广泛的的<strong>局域网</strong>，包括了<mark><strong>标准以太网</strong>、<strong>快速以太网</strong>、<strong>千兆以太网</strong>和<strong>10G以太网</strong></mark>，他们都是符合<strong>IEE802.3系列标准规范</strong>。</p>
<p>采用的逻辑拓扑结构是：逻辑总线型</p>
<p>物理拓扑结构是：星型 or 拓展星型。</p>
<p>介质访问控制办法采用：<mark>CSMA/CD</mark></p>
</li>
<li><p><strong>令牌环网</strong>（有点被淘汰了已经）</p>
<p>逻辑拓扑结构：<strong>环形拓扑结构</strong></p>
<p>物理拓扑结构：<strong>星型拓扑结构</strong></p>
</li>
<li><p><strong>FDDI网</strong>（Fiber Distributed Data Interface）</p>
<p>逻辑拓扑结构：环形拓扑结构</p>
<p>物理拓扑结构：双环拓扑结构</p>
</li>
<li><p><strong>ATM网</strong>（Asynchronous Transfer Mode）：这是较为新型的单元交换技术，采用了53字节<strong>固定</strong>长度的单元进行交换</p>
<p>（为什么要强调是 固定的呢？因为1 - 3局域网等的数据交换单元是可变的，非固定的）</p>
</li>
<li><p><strong>无线局域网</strong>（Wireless  Local Area NetWord；也就是我们常常说的 <mark>WLAN</mark>)：采用的是IEEE 802.11标准;</p>
<p>不要把这个和WiFi搞混了，无线局域网覆盖的范围要比WiFi广很多</p>
</li>
</ol>
<h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><ul>
<li>IEEE 802标准描述的局域网参考模型仅仅只对应<strong>OSI参考模型中的</strong><mark>数据链路层和物理层</mark></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218170355928.png" alt="image-20201218170355928"></p>
<p>设立了很多的标准，这里只截取一小部分了：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218170435716.png" alt="image-20201218170435716"></p>
<h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><ul>
<li>上面说到IEEE 802标准只对应OSI参考模型中的数据链路层以及物理层，而他将<strong>数据链路层</strong>划分为了：<ul>
<li><mark>逻辑链路层LLC子层</mark></li>
<li><mark>介质访问控制MAC子层</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218184905744.png" alt="image-20201218184905744"></p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网概述"><a href="#以太网概述" class="headerlink" title="以太网概述"></a>以太网概述</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218191032708.png" alt="image-20201218191032708"></p>
<h3 id="以太网-1"><a href="#以太网-1" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>以太网提供的是<mark>无连接且不可靠</mark>的服务</li>
</ul>
<ol>
<li><strong>无连接</strong>:指的是发送方和接受方之间是没有<strong>握手过程的</strong></li>
<li><strong>不可靠</strong>:指的是 不对发送方的<strong>数据帧</strong>进行编号，接收方也不向发送方进行<mark>确认</mark>，差错的帧就会直接丢弃掉，差错的纠正由高层负责</li>
</ol>
<p>总的来说，就是以太网只负责<strong>无差错的接受</strong>，而不去实现<strong>可靠传输</strong></p>
<h3 id="以太传输介质与拓扑结构发展"><a href="#以太传输介质与拓扑结构发展" class="headerlink" title="以太传输介质与拓扑结构发展"></a>以太传输介质与拓扑结构发展</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218193653567.png" alt="image-20201218193653567"></p>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE - T以太网"></a>10BASE - T以太网</h3><p>如何理解这个以太网呢？我们拆开来看：</p>
<ul>
<li>10 ：指的是传输速率是10Mb/s</li>
<li>BASE : 指的是传送<strong>基带信号</strong></li>
<li>T ：指的是采用<strong>双绞线</strong>(如今采用的是无屏蔽双绞线UTP)</li>
</ul>
<p>which means：10BASE - T以太网是 <mark>传送基带信号的双绞线以太网</mark></p>
<p>物理上采取：星型拓扑</p>
<p>逻辑上采取：总线型拓扑</p>
<p>每段双绞线的最长为100m，采用<strong>曼彻斯特编码</strong>，采用CSMA/CD 介质访问控制</p>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h3><p>计算机 与 外界局域网是怎么连接的呢？是通过<strong>通信适配器</strong></p>
<p>这个名字我们也许并不是那么熟悉，他还有另外的名字叫：<strong>网络接口板 or 网络接口卡 （AKA 网卡</strong></p>
<p>它上面装有处理器和存储器</p>
<p>而存储器上就有着一个非常重要的东西：<mark>计算机硬件地址MAC地址</mark></p>
<p>硬件地址又称为物理地址/MAC地址 —— 相当于身份证？标识符的作用吧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218194922159.png" alt="image-20201218194922159"></p>
<h4 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h4><p>从图中我们可以发现：以太网MAC帧由这么几部分组成</p>
<ul>
<li><p>目的地址：标记<mark>接收方</mark>的地址，地址有三种情况：</p>
<ul>
<li>单播地址：专有的MAC地址</li>
<li>广播地址：全1或者是全F，发送给全部主机</li>
<li>多播地址</li>
</ul>
</li>
<li><p>源地址：标记<mark>发送方</mark>的地址</p>
</li>
<li><p>类型：用于标记上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。</p>
<p>理解起来很抽象的话举个例子：如果值是<strong>0x0800</strong> 代表上一层用的是<strong>IP数据报</strong></p>
<p>如果值是<strong>0x8137</strong>，表示帧是由<strong>NovellIPX</strong>发过来的</p>
</li>
<li><p>数据（IP数据报）：长度在<strong>46到1500</strong>字节之间</p>
<p>为什么是46呢？46是这么来的：最小长度64减去了（目的地址 + 源地址 + 类型 + FCS = 18) = 46</p>
</li>
<li><p>FCS（帧检验序列FCS）：使用前面所学习的CRC冗余码进行校验</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201218200623396.png" alt="image-20201218200623396"></p>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><ul>
<li>速率 &gt;= 100Mb/s的以太网称之为<strong>高速以太网</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219011857324.png" alt="image-20201219011857324"></p>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219012505859.png" alt="image-20201219012505859"></p>
<h3 id="802-11-的-MAC帧头格式"><a href="#802-11-的-MAC帧头格式" class="headerlink" title="802.11 的 MAC帧头格式"></a>802.11 的 MAC帧头格式</h3><p>首先先看看MAC帧头格式的样子：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219190647470.png" alt="image-20201219190647470"></p>
<ul>
<li><p><mark>帧控制（2bytes大小）</mark>：用于指示数据帧的类型，是否分片等等信息，也就是记录了MAC 802.11的属性</p>
<ul>
<li><strong><em>Protocol version</em></strong>：表明版本类型，现在所有帧里面这个字段都是0x00</li>
<li><strong><em>Type</em></strong>：指明数据帧类型，是管理帧，数据帧还是控制帧</li>
<li><strong><em>Subtype</em></strong>：指明数据帧的子类型，因为就算是控制帧，控制帧还分RTS帧，CTS帧，ACK帧等等，通过这个域判断出该数据帧的具体类型</li>
<li><strong><em>To DS/From DS</em></strong>：这两个数据帧表明数据包的发送方向，分四种可能情况讨论</li>
<li><strong><em>若数据包To DS为0</em></strong>，From DS为0，表明该数据包在网络主机间传输**</li>
<li><strong><em>若数据包To DS为0</em></strong>，From DS为1，表明该数据帧来自AP</li>
<li><strong><em>若数据包To DS为1</em></strong>，From DS为0，表明该数据帧发送往AP</li>
<li><strong><em>若数据包To DS为1</em></strong>，From DS为1，表明该数据帧是从AP发送自AP的，也就是说这个是个WDS(Wireless Distribution System)数据帧，</li>
<li><strong>*Moreflag</strong>：分片标志，若数据帧被分片了，那么这个标志为1，否则为0*</li>
<li><strong><em>Retry</em></strong>：表明是否是重发的帧，若是为1，不是为0</li>
<li><strong>*PowerManage</strong>：当网络主机处于省电模式时，该标志为1，否则为0.*</li>
<li><strong><em>Moredata</em></strong>：当AP缓存了处于省电模式下的网络主机的数据包时，AP给该省电模式下的网络主机的数据帧中该位为1，否则为0</li>
<li><strong>*Wep</strong>：<a target="_blank" rel="noopener" href="http://www.2cto.com/Article/jiami/">加密</a>标志，若为1表示数据内容加密，否则为0*</li>
<li><strong><em>Order</em></strong> 这个表示用于PCF模式下，这里不予讨论</li>
</ul>
</li>
<li><p><mark>生存周期/Associate ID (2 bytes)</mark>:</p>
<p>Duration/ID 在frame control 后面，占2byte</p>
<ul>
<li>当设置为NAV 网络分配矢量情况 （network allowcation Vector ）<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="NAV"><br>第15bit 设置为0，0~14 用来设置NAV，单位微秒</li>
<li>免竞争期间（CFP contention free period）传送的帧<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="CFP frames"><br>第14bit 设置0 和15bit设置1 其他bit为0 所以duration/ID 为32768 设置为NAV，告诉收到beacon帧的sta，免竞争期间，所以其他sta 会更新NAV值，不干扰竞争传输</li>
<li>PS-Poll帧（省电模式-轮询）的 duration/ID的用法<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20191018211443707.png" alt="PS-Poll"><br>处于省电模式的sta 会定期醒来，送出一个PS-Poll帧，从基站取出暂存的帧，会在Duration/ID中设置连接识别码AID（association ID），显示加入的BSS，1-2007范围</li>
</ul>
</li>
<li><p><mark>序列控制(2 bytes：4 bits/12 bits)</mark>：这个域分2部分，一个是分片序列号和标识帧列号。分片序列号就是记录分片序号的。比如一个帧A被分片成a1，a2，a3，那么a1，a2，a3这三个分片帧的分片序列分别是0,1,2。这个和IP分段原理一样的，该域占4个比特位。剩下的12个比特位就用于标识帧的序号，这个跟IP头里面的序列号一样。</p>
</li>
<li><p><mark>MAC地址 1-4</mark></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219185912839.png" alt="image-20201219185912839"></p>
<h4 id="RA-TA-BSSID-DA-SA"><a href="#RA-TA-BSSID-DA-SA" class="headerlink" title="RA TA BSSID DA SA"></a>RA TA BSSID DA SA</h4><ul>
<li><strong>BSSID(Basic Service Set ID)</strong>：在infrastructure BBS中，BSSID就是AP的mac地址。但是在IBBS中，它是一个随机即生成的46位二进制序列，还有最高两位分别是Universal/Local标志位和Individual/Group标志位。IBBS的BSSID中，Universal/Local标志位为1，表示本地MAC，Individual/Group标志位为0，表示是个人MAC。也就是说在IBBS中，BSSID地址应该类如 10xxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx（x表示随机数要么0要么1, 2进制表示）</li>
<li><strong>DA(destine address)</strong>：该帧的<code>目的mac地址</code></li>
<li><strong>SA(source address</strong>)：该帧的<code>源mac地址</code></li>
<li><strong>RA(receiver address)</strong>：无线网络中，该数据帧的<code>接收者</code></li>
<li><strong>TA(transmitter address)</strong>：无线网络中，该数据帧的<code>发送者</code></li>
</ul>
<p>注意 这上面两个定义中说的是无线网络 而不是 网络</p>
<p>有的人会觉得奇怪 有什么区别吗？</p>
<p>意思是说 RA TA 仅仅只在<strong>相应的无线网络</strong>中有作用</p>
<p>假如我现在有一台主机 需要向目的主机发送数据，而目的主机并不在我的无线网络中，我就没法发了。</p>
<p>在这种情况中此时，<strong>RA</strong>作为的是一个<mark>中转站</mark>的身份，并不能一次性的完成数据传输的作用。</p>
<p>最典型的一个例子就是在WDS模式下，数据帧会有4个地址，RA，TA表示接收端和发送端，这两个地址用于无线传输的时候。还有2个地址是DA和SA，分别跟以太网中一样表示源地址和目的地址。WDS帧的格式如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20120213105413973.jpg" alt="."><br>打个比方说，AP1有主机A，AP2有主机B。如果A要和B同学，那么A会首先发送数据帧给AP1，然后AP1发送帧给AP2 。这个时候帧里面会有4个地址，分别是RA=mac(AP2)，TA=mac(AP1)，DA=mac(B)，SA=mac(A)。</p>
<h3 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h3><p>主要分成两类：</p>
<ol>
<li>有固定基础设施无线局域网</li>
<li>无固定基础设施无线局域网的<strong>自组织网络</strong></li>
</ol>
<h4 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219193756031.png" alt="image-20201219193756031"></p>
<p>一个<mark>基本服务集 BSS </mark>包括一个<strong>基站</strong>和<strong>若干个移动站</strong>，</p>
<p>所有的站在<strong>本 BSS 以内</strong>都可以直接通信，</p>
<p>但在和<strong>本 BSS 以外</strong>的站通信时都要通过本 BSS 的<strong>基站</strong>。</p>
<p>基本服务集中的基站叫做接入点 AP (Access Point),其作用和网桥相似。</p>
<p>一个基本服务集可以是孤立的，也可通过接入点 AP连接到一个主干分配系统 DS (Distribution System)，然后再接入到另一个基本服务集，构成扩展的服务集ESS (Extended Service Set)。</p>
<p>ESS 还可通过叫做门桥(portal)为无线用户提供到非 802.11 无线局域网（例如，到有线连接的因特网）的接入。门桥的作用就相当于一个网桥。</p>
<p>移动站 A 从某一个基本服务集漫游到另一个基本服务集，而仍然可保持与另一个移动站 B 进行通信。</p>
<h4 id="无固定基础设施无线局域网的自组织网络"><a href="#无固定基础设施无线局域网的自组织网络" class="headerlink" title="无固定基础设施无线局域网的自组织网络"></a>无固定基础设施无线局域网的自组织网络</h4><p>在这个网络之中的各节点地位平等，每个主机既可以充当主机也可以当路由器的作用</p>
<p>也就是既可以发送数据，也可以接收数据</p>
<p>把主机都安排在一个网段就可以形成自组织网络</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219194044200.png" alt="image-20201219194044200"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>局域网只覆盖物理层和数据链路层，而广域网不仅仅如此，还覆盖了网络层；</p>
<p>广域网中强调的是：<mark>资源共享</mark> while 局域网强调<mark>数据传输</mark> </p>
<p>广域网中的通信子网采用：<strong>分组交换技术</strong>（在网络层会细讲）；</p>
<p>广域网能够将<strong>局域网或计算机系统</strong>连接起来，达到了<mark>资源共享</mark>的目的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219195652107.png" alt="image-20201219195652107"></p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ul>
<li>点对点协议PPP（<mark>P</mark>oint-to-<mark>P</mark>oint <mark>P</mark>rotocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网的时候一般使用该协议</li>
<li>只支持<strong>全双工链路</strong></li>
</ul>
<h4 id="PPP协议需要满足的要求"><a href="#PPP协议需要满足的要求" class="headerlink" title="PPP协议需要满足的要求"></a>PPP协议需要满足的要求</h4><ul>
<li><p><mark>简单</mark>：由于最复杂的部分在TCP协议中，而网络协议IP相对来说比较简单，它提供的是不可靠的数据报服务；</p>
<p>在这种情况下，数据链路层没必要提供比IP协议还多的功能；</p>
<p>因此对数据链路层的帧，不需要进行：<strong>纠错、序号、流量控制</strong></p>
<p>总的来说，这种数据链路层的协议（PPP协议）非常简单：接收方每收到了一个帧，进行<strong>CRC检验</strong></p>
<p>如果正确，就收下；反之则丢弃；</p>
</li>
<li><p><mark>封装成帧</mark>：PPP协议必须规定<mark>特殊的字符</mark>作为<strong>帧定界符</strong>（标志一个帧的开始和结束的字符）以便：</p>
<p>接收端从收到的的比特流中能准确的找出<strong>帧的开始和结束的位置</strong></p>
</li>
<li><p><mark>透明性</mark>：PPP协议必须保证数据传输的<strong>透明性</strong>，什么叫透明性呢？</p>
<p>意思是，如果数据中碰巧出现了和<strong>帧定界符</strong>一样的<strong>比特组合</strong>的时候，就必须要采取<mark>有效的措施</mark>去解决这个问题</p>
</li>
<li><p><mark>多种网络层协议</mark>：PPP协议必须能够在<strong>同一条物理链路上同时支持<mark>多种网络层协议</mark></strong>（IP、IPX）的运行</p>
<p>要注意：当<strong>点对点链路</strong>连接的是<strong>局域网or路由器</strong>的时候，PPP协议必须同时支持在链路所连接的<strong>局域网or路由器</strong>上所运行的各种<mark>网络层协议</mark></p>
</li>
<li><p><mark>多种类型链路</mark>：除了要支持多种<strong>网络层的协议</strong>以外，PPP还必须能够在多种类型的链路上运行；</p>
<p>比如：串行（一次只发一个比特）、并行（一次并行地发送多个比特）；</p>
<p>同步、异步；低速、高速；电的、光的；交换的、非交换的；</p>
</li>
<li><p><mark>差错检测</mark>：PPP协议必须能够对接收端收到的帧进行<strong>检测</strong>，并且对<strong>有差错的帧</strong>立即丢弃；</p>
<p>如果在数据链路层不进行差错检测，那么出现差错的<strong>无用帧</strong>就会在网络中继续向前转发，浪费很多网络资源</p>
</li>
<li><p><mark>检测连接状态</mark>：PPP协议必须具有一种<strong>机制</strong>能够及时自动检测出来链路有没有在正常工作；</p>
</li>
<li><p><mark>最大传送单元</mark>：PPP协议必须对每一种类型的点对点链路设置<strong>MTU（最大传送单元）</strong>的标准默认值；</p>
<p>这样做的目的是什么呢？是为了促进各种实现的<strong>互操作性</strong>；</p>
<p>如果高层协议发送的分组过长，超过了MTU数值，PPP就需要丢弃，并且返回差错；</p>
<p>ps：MTU是数据链路层的帧可以载荷的<strong>数据部分的最大长度</strong>，而不是<strong>帧的总长度</strong></p>
</li>
<li><p><mark>网络层地址协商</mark>：PPP协议必须提供一种<strong>机制</strong>，去让通信的两个<strong>网络层</strong>的实体能够通过协商去 →</p>
<p>知道或者说是能够配置彼此的网络层地址；</p>
<p>对于<strong>拨号连接</strong>的链路十分重要，若是只在链路层建立了连接 但不知道对方的网络层地址，就不能够保证网络层可以传送<mark>分组</mark></p>
</li>
<li><p><mark>数据压缩协商</mark>：PPP协议需要提供一种方法去协商使用<strong>数据压缩算法</strong>；但PPP协议并不要求将这个算法进行标准化；</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220161411120.png" alt="image-20201220161411120"></p>
<h4 id="PPP协议三个组成部分"><a href="#PPP协议三个组成部分" class="headerlink" title="PPP协议三个组成部分"></a>PPP协议三个组成部分</h4><ul>
<li>将IP数据报封装到串行链路的<strong>方法</strong></li>
<li>用来建立、配置和册数数据链路连接的<mark>链路控制协议LCP</mark></li>
<li>一套<mark>网络控制协议NCP</mark></li>
</ul>
<p><img src="/UesugiEr11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201220164741323.png" alt="image-20201220164741323"></p>
<h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p>可以这么理解：</p>
<p>用户拨号接入了ISP(互联网服务提供商)，等于建立了一条<strong>用户个人电脑到ISP</strong>的物理连接</p>
<p>用户个人电脑向ISP发送一系列的<mark>链路控制协议LCP小组</mark>（封装成多个PPP帧），以便建立LCP连接；</p>
<p>接着NCP介入了，给新接入的用户个人电脑分配一个临时的IP地址；</p>
<p>结果就是：用户个人电脑成为互联网上一个有<strong>IP地址的主机</strong>了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220165159747.png" alt></p>
<h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201223222125357.png" alt="image-20201223222125357"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><ul>
<li>HDLC协议 - 高级数据链路控制，是一种在同步网上<strong>传输数据、面向比特</strong>的数据链路层协议</li>
</ul>
<p>这种协议的特点是：</p>
<ol>
<li>数据报文 可以透明传输，用于实现透明传输的<mark>0比特插入法</mark>易于硬件实现</li>
<li>采用全双工通信</li>
<li>所用的帧都采用<mark>CRC检验</mark>，对信息帧进行编号，可以防止<strong>漏收或重份</strong>，传输可靠性高</li>
</ol>
<h4 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h4><p>HDLC的站主要有三个：<strong>主站、从站、复合站</strong></p>
<p>其中：</p>
<ol>
<li>主站<ol>
<li>发送命令（包括数据信息）帧</li>
<li>接受响应帧</li>
<li>负责对整个链路的控制系统的初启</li>
<li>负责流程的控制</li>
<li>负责差错检测或恢复</li>
</ol>
</li>
<li>从站<ol>
<li>接受由主站发来的命令帧</li>
<li>向主站发送响应帧</li>
<li>配合主站参与差错恢复等链路控制</li>
</ol>
</li>
<li>复合站<ol>
<li>既能发送、又能接受命令帧和响应帧</li>
<li>负责整个链路的控制</li>
</ol>
</li>
</ol>
<p>下面提及三种数据的操作方式：</p>
<ul>
<li>正常响应方式</li>
<li>异步平衡方式</li>
<li>异步响应方式</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201223223014398.png" alt="image-20201223223014398"></p>
<h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><p>主要由这几部分组成：</p>
<p>标志F(首尾各一个) 地址A 控制C 信息Info 帧检验序列FCS </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224201319176.png" alt="image-20201224201319176"></p>
<h3 id="HDLC与PPP"><a href="#HDLC与PPP" class="headerlink" title="HDLC与PPP"></a>HDLC与PPP</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224201526269.png" alt="image-20201224201526269"></p>
<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h3><p>由于在物理层中，主机与集线器之间距离不能太远，不然会失真，信号怎么恢复都恢复不成原来的了；</p>
<p>而为了使远距离主机之间进行通信，就需要<strong>扩展</strong></p>
<ul>
<li>方法1：使用光线解调器</li>
</ul>
<p>主机到光线调制器：电信号 → 光信号</p>
<p>光线解调器到集线器：光信号 → 集线器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202049007.png" alt="image-20201224202049007"></p>
<ul>
<li>方法2：集线器连接集线器</li>
</ul>
<p>首先普及一个概念：<mark>冲突域</mark></p>
<p>如果一个集线器附近如果有多台主机同时发送消息，就会发生碰撞/冲突，构成的区域就叫<strong>冲突域</strong></p>
<p>没用集线器连接起来前：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202624221.png" alt="image-20201224202624221"></p>
<p>添加了主干集线器后：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224202645059.png" alt="image-20201224202645059"></p>
<h3 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h3><p>由于上面的方法有个缺点：</p>
<p>冲突域增大了，发生冲突的概率会更高，那么除了物理层去扩展以太网以外，有没有办法从链路层去扩展呢？</p>
<p>主要是通过<mark>网桥和交换机</mark>去实现，顺便引入一个<mark>网段</mark>的概念</p>
<ul>
<li><p>网桥：是根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发和过滤</strong>，也就是说：</p>
<p>当网桥收到了一个<strong>帧</strong>之后，并不向所有接口转发这个帧，而是先去检查这个<strong>帧</strong>的<strong>目的MAC地址</strong>，然后再确定该<strong>帧</strong>转发到哪个接口</p>
<p>或是把它丢弃掉(过滤掉)</p>
</li>
<li><p>网段：一般是指一个计算机网络中使用同一 物理层设备（传输介质、中继器、集线器等）能够直接通讯的那一部分</p>
</li>
</ul>
<p>通过这个<mark>网桥</mark>就能将冲突域之间联系起来，进行数据传输</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224204821160.png" alt="image-20201224204821160"></p>
<h4 id="网桥分类"><a href="#网桥分类" class="headerlink" title="网桥分类"></a>网桥分类</h4><h5 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h5><ul>
<li>透明网桥指的是以太网上的站点是并不知道所发送的帧会经过哪几个网桥，是一种<strong>即插即用的设备——自学习</strong></li>
</ul>
<p>什么叫自学习？就是在传输过程中逐渐完善<strong>转发表（包含了地址和接口等信息）</strong>，这样子在下一次发送帧的时候，如果转发表中有对应的目的地址的信息，网桥就不用再转发帧了，就可以直接丢弃这个帧了。</p>
<h5 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h5><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224210745626.png" alt="image-20201224210745626"></p>
<h5 id="多接口网桥"><a href="#多接口网桥" class="headerlink" title="多接口网桥"></a>多接口网桥</h5><p>多接口网桥 又名 以太网交换机（我觉得这个更广为人知一点）</p>
<p>这种方式的好处就是 连接了以太网交换机的<strong>设备</strong>可以做到<mark>独占传输媒体带宽</mark> </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224212235252.png" alt="image-20201224212235252"></p>
<h6 id="以太网交换机的两种交换方式"><a href="#以太网交换机的两种交换方式" class="headerlink" title="以太网交换机的两种交换方式"></a>以太网交换机的两种交换方式</h6><ul>
<li><p>直通式交换机：查完目的地址就立刻转发，延迟小，可靠性低</p>
<p>无法支持具有不同速率的端口的交换</p>
</li>
<li><p>存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃；</p>
<p>延迟大，可靠性高，可以支持具有不同速率的端口的交换</p>
</li>
</ul>
<h5 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a>冲突域与广播域</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201224212734539.png" alt="image-20201224212734539"></p>
<h1 id="网络层-2"><a href="#网络层-2" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li><p>网络层的主要任务是把<mark>分组</mark>从<strong>源端</strong>传到<strong>目的端</strong>，为<mark>分组交换网</mark>上的不同主机提供通信服务；</p>
</li>
<li><p>网络层传输单位是<mark>数据报</mark></p>
</li>
</ul>
<h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><ul>
<li><p>路由选择与分组转发</p>
</li>
<li><p>异构网络互联</p>
</li>
<li><p>拥塞控制</p>
<p>什么叫拥塞呢？假如所有结点来不及接受<mark>分组</mark>，而要丢弃大量的<mark>分组</mark>的话呢，网络就会处于<strong>拥塞</strong>的状态；</p>
<p>因此，需要采取一些措施去缓解这种<strong>拥塞</strong></p>
</li>
</ul>
<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><p> 思考一下，我们知道数据想要从一个源主机传送到一个目的主机，需要经由<strong>路由器</strong>进行转发</p>
<p>那么究竟是如何进行的呢？就是通过<strong>数据交换</strong>这个技术了；</p>
<p> 下图有三种数据传输方式，P1没有引入交换设备，那么N个设备就需要CN2条链路</p>
<p>P2引入了一个交换设备，那么N设备各自只需要连接一条链路到交换设备即可，需要N条链路</p>
<p>P3将多个交换设备连接在一起，形成了一个交换网络，这样解决了远距离传输；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102145831047.png" alt="image-20210102145831047"></p>
<p>那么数据交换方式主要有三种：</p>
<ol>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换<ol>
<li>数据报方式</li>
<li>虚电路方式</li>
</ol>
</li>
</ol>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102151441549.png" alt="image-20210102151441549"></p>
<p>电话网络就是一种电路交换方式，这种方式的特点是：<mark>独占资源</mark></p>
<p>电路交换的阶段分为三步：</p>
<ol>
<li>建立连接（呼叫/电路建立）</li>
<li>通信</li>
<li>释放连接（拆除电路）</li>
</ol>
<p>这种方式的优点为:</p>
<ol>
<li>通信时延小（这是一种数据直达的过程，建立连接后，有数据就能通过交换设备发出去）</li>
<li>有序传输（发送数据按照顺序发送，按照顺序接受）</li>
<li>没有冲突（因为是独占资源的）</li>
<li>实时性强（建立连接后，随时可以进行通信）</li>
</ol>
<p>缺点为：</p>
<ol>
<li>建立连接时间长（需要建立连接，比如拨号）</li>
<li>线路独占，使用效率低（假如AB建立连接，但不传输数据，就白白浪费了了一个信道嘛）</li>
<li>灵活性差（假如其间一个交换设备宕机了，那么AB之间就完全无法进行通信了）</li>
<li>没有差错控制的能力（只转发，不检错）</li>
</ol>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102152148259.png" alt="image-20210102152148259"></p>
<p>首先需要明白什么是报文</p>
<ul>
<li>报文：是源应用发送的信息整体</li>
</ul>
<p>这种方式的优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态的分配线路（存储转发就是，不同于电路交换，拿到数据就转发，而是先存储，伺机转发，这样就可以做到动态的分配线路）</li>
<li>线路可靠性比较高（不用担心其间一个设备宕机了，就不能进行信息传输了，而是条条大路通罗马）</li>
<li>线路利用率比较高（在通信过程中，一段一段占用通信线路，而非占用一整条通信线路）</li>
<li>多目标服务（一个报文可以同时发往多个目的地址）</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储转发时延（因为需要存储嘛，肯定需要花额外一点时间的）</li>
<li>报文大小不定，需要网络节点有较大缓存空间</li>
</ol>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>思想上与报文交换差不多，都是使用<strong>存储转发</strong>，而分组转发就是将转发的数据块切分为了小的数据块——<strong>分组</strong></p>
<p>在分组交换中，只有最后一组（分组）的数据到达目的主机才算接受成功</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102153101471.png" alt="image-20210102153101471"></p>
<p>优点：</p>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态分配线路（类比于报文交换，其实就是把转发的单位变了下，主要原理差不多）</li>
<li>线路可靠性比较高（分组短，出错几率小）</li>
<li>线路利用率较高（不同时间，只占用一段段路径）</li>
<li>相对于报文交换来说，存储管理更容易（对于缓存的要求没那么高了，因为不需要够大的缓存空间容纳大报文，而是可容纳小分组即可）</li>
</ol>
<p>缺点：</p>
<ol>
<li>有存储转发时延</li>
<li>需要传输额外的信息量（因为报文进行分片后，需要给各报文添加额外信息：源地址、目的地址、编号等）</li>
<li>乱序到目的主机的时候，需要对分组排序重组</li>
</ol>
<h4 id="数据报方式-amp-虚电报方式"><a href="#数据报方式-amp-虚电报方式" class="headerlink" title="数据报方式&amp;虚电报方式"></a>数据报方式&amp;虚电报方式</h4><p>分组交换方式分为两种：<strong>数据报方式&amp;虚电报方式</strong></p>
<p>其中，</p>
<p><mark>数据报方式</mark>为网络层提供<strong>无连接服务</strong></p>
<ul>
<li>无连接服务：不会事先为分组的传输确定传输路径，每个分组独立确定传输路径，因此不同分组的传输路径是可能不同的</li>
</ul>
<p><mark>虚电路方式</mark>为网络层提供<strong>连接服务</strong></p>
<ul>
<li>连接服务：首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输<mark>系列分组</mark>，<mark>系列分组</mark>传输路径相同，传输结束后拆除连接</li>
</ul>
<h5 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h5><p>主要特点是：</p>
<p>每个分组携带源地址和目的地址</p>
<p>路由器根据分组的目的地址转发分组：</p>
<p>基于<strong>路由协议/算法</strong>去构建<mark>转发表</mark></p>
<p>而后检索<mark>转发表</mark>，每个分组独立选路</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102162414098.png" alt="image-20210102162414098"></p>
<h5 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h5><p>虚电路方式结合了<strong>数据报方式</strong>和<strong>电路交换方式</strong></p>
<p>虚电路：一条<strong>源主机</strong>到<strong>目的主机</strong>；类似于电路的路径，路径上所有的结点维持这条虚电路的建立，维持一张<mark>虚电路表</mark></p>
<p>这张表的每一项记录了一个<strong>打开的虚电路</strong>的信息</p>
<p>因此，属于同一条虚电路（路径）的分组会按照同一路由转发</p>
<p>你看 这样就有有问题了，假如一个虚电路上有一个结点出问题了，那么经由该结点的虚电路就都不能工作了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102163256159.png" alt="image-20210102163256159"></p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102163506772.png" alt="image-20210102163506772"></p>
<h4 id="传输单元名词辨析"><a href="#传输单元名词辨析" class="headerlink" title="传输单元名词辨析"></a>传输单元名词辨析</h4><p>分组、包，packet，信息在互联网当中传输的单元，网络层实现分组交付。用抓包工具抓到的一条条记录就是包。<br>帧，frame，数据链路层的协议数据单元。我们将链路层分组称为帧。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102161842138.png" alt="image-20210102161842138"></p>
<p>应用层——消息（报文）</p>
<p>传输层——数据段(segment)，报文段</p>
<p>网络层——分组、数据包（packet），IP数据报</p>
<p>链路层——帧（frame）</p>
<p>物理层——P-PDU（bit），比特流</p>
<p><mark>数据报，Datagram</mark>，通过网络传输的数据的基本单元，包含一个报头（header）和数据本身，其中报头描述了数据的目的地以及和其它数据之间的关系。可以理解为传输数据的分组。我们将通过网络传输的数据的基本单元称为数据报。</p>
<p><mark>报文段，segment</mark>，组成报文的每个分组。我们将运输层分组称为报文段。</p>
<p><mark>报文，message</mark>，一般指完整的信息，传输层实现报文交付。我们将位于应用层的信息分组称为报文。</p>
<p>由此可见，抓包抓到的是传输层的包，所以packet，frame，Datagram，segment是存在于同条记录中的，而frame，Datagram，segment是基于所在协议层不同而取了不同的名字。</p>
<p><strong>1.报文(message)</strong><br>报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</p>
<p><strong>2.分组(packet)</strong><br>分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。</p>
<p><strong>3.数据包(data packet)</strong><br>数据包是TCP/IP协议通信传输中的数据单元，也称为“包”。是指自包含的，带有足够寻址信息，可独立地从源主机传输到目的主机，而不需要依赖早期的源主机和目的主机之间交换信息以及传输网络的数据包。</p>
<p><strong>4.数据报(datagram)</strong><br>面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。</p>
<p><strong>5.帧(frame)</strong><br>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。</p>
<h3 id="报文交换-amp-分组交换对比"><a href="#报文交换-amp-分组交换对比" class="headerlink" title="报文交换 &amp; 分组交换对比"></a>报文交换 &amp; 分组交换对比</h3><p>对于下面这道题来说，将<code>10000bit</code>的报文分成了<code>1000组</code>每个大小为<code>10bit</code>的分组</p>
<p>其实可以这么想区别：类似于火车进隧道吧。报文交换需要将整个 </p>
<ul>
<li><p>对于报文交换来说：需要考虑将整个报文传到第二个设备所需要的的时间，也就是用报文长度/链路传输速率，再考虑传了几次</p>
</li>
<li><p>对于分组交换来说：先考虑单个分组的发送时延，也就是单个比特大小/传输速率；</p>
<p>而分组交换的总时延由2部分组成，一个是第一个分组开始发送直至最后一个分组发送到链路上所需要时间</p>
<p>另一个是由交换设备到交换设备，以及交换设备到目的主机的时间</p>
<p>（由于分组交换各个交换设备之间传输数据是重叠的，因此省时间）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102154646133.png" alt="image-20210102154646133"></p>
<h3 id="三种数据交换方式比较"><a href="#三种数据交换方式比较" class="headerlink" title="三种数据交换方式比较"></a>三种数据交换方式比较</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102160612397.png" alt="image-20210102160612397"></p>
<h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>首先需要有知识总览，要了解TCP/IP协议栈的构造</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102171803060.png" alt="image-20210102171803060"></p>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p>IP数据报粗糙来说有2部分组成：首部 + 数据部分</p>
<p>其中首部包含了固定部分和可变部分</p>
<p>数据部分包含了TCP段 和 UDP段</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>注释</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>版本 Version</td>
<td>ipv4或者ipv6</td>
<td>4位</td>
</tr>
<tr>
<td>首部长度 IHL</td>
<td>此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101</td>
<td>4位</td>
</tr>
<tr>
<td>区分服务 DSCP + ECN</td>
<td>希望获得哪种服务，用的比较少</td>
<td>8位</td>
</tr>
<tr>
<td>总长度 Total Length</td>
<td>首部+数据的长度，最大为2^16-1=65535</td>
<td>16位</td>
</tr>
<tr>
<td>标识 Identification</td>
<td>用来表示是哪一个数据报的分片，不同的分片标识各不相同</td>
<td>8位</td>
</tr>
<tr>
<td>标志 Flags</td>
<td>用来表示是否分片和分片是否结束</td>
<td>3位，但实际有用的只有后两位</td>
</tr>
<tr>
<td>片偏移 Fragment Offset</td>
<td>用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位</td>
<td>13位</td>
</tr>
<tr>
<td>生存时间 Time To Live</td>
<td>即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同</td>
<td>8位</td>
</tr>
<tr>
<td>协议 Protocol</td>
<td>用来标记协议名的字段值，如TCP,UDP,ICMP等等</td>
<td>8位</td>
</tr>
<tr>
<td>首部检验和 Header Checksum</td>
<td>检验首部的字段是否出错，出错就丢弃此数据报</td>
<td></td>
</tr>
<tr>
<td>源地址 Source IP Address</td>
<td>发送方ip地址</td>
<td>32位</td>
</tr>
<tr>
<td>目的地址 Destination IP Address</td>
<td>接收方ip地址</td>
<td>32位</td>
</tr>
<tr>
<td>可选字段 Options</td>
<td>用来排错等安全检测</td>
<td>未知，可在0-40位之间</td>
</tr>
<tr>
<td>填充</td>
<td>将数据报对齐成4字节的整数倍，数值全部为0</td>
<td>未知，根据可选字段来定</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102173951640.png" alt="image-20210102173951640"></p>
<p>标识、标志、片偏移留在下面IP数据报分片来讲</p>
<h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h3><p>首先需要了解为什么要分片</p>
<p>我们知道最大链路层中有一个概念叫<strong>最大传送单元MTU</strong></p>
<p>代表着数据链路层数据帧可以封装数据的上限，以太网的MTU是1500字节</p>
<p>那么，如果所传送的数据报长度超过了某个链路的MTU值，那么应该怎么办呢？<mark>分片</mark></p>
<p>首先把上面没讲完的 <strong>标识、标志、片偏移</strong>的概念理一下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102175308496.png" alt="image-20210102175308496"> </p>
<ul>
<li>例题</li>
</ul>
<p>要根据题目的所给的MTU将数据部分分片</p>
<p>其中片偏移 = 各分片在原来数据部分的位置 / 8b</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102200854563.png" alt="image-20210102200854563"></p>
<p>要注意的是：</p>
<p>总长度的单位是<strong>1B</strong></p>
<p>片偏移的单位是<strong>8B</strong></p>
<p>首部长度的单位是<strong>4B</strong></p>
<h3 id="IP数据报的传输方式"><a href="#IP数据报的传输方式" class="headerlink" title="IP数据报的传输方式"></a>IP数据报的传输方式</h3><p>参考博客1：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/CNHK1949/p/10680651.html">https://www.cnblogs.com/CNHK1949/p/10680651.html</a></p>
<p>参考博客2：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45755666/article/details/109552216">https://blog.csdn.net/weixin_45755666/article/details/109552216</a></p>
<p>有三种：<strong>单播、广播、组播</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104153654513.png" alt="image-20210104153654513"></p>
<h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>网络节点之间的通信就好像是人们之间的对话一样。如果一个人对另外一个人说话，那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行；用于发送数据包到单个目的地，且每发送一份单播报文都使用一个<strong>单播IP地址</strong>作为目的地址。</p>
<ul>
<li>是一种点对点传输方式。</li>
</ul>
<p>在发送者和每一接收者之间需要<strong>单独的数据信道</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104154754052.png" alt="image-20210104154754052"></p>
<p>单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用。</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播”可以理解为一个人通过广播喇叭对在场的全体说话，这样做的好处是通话效率高，信息一下子就可以传递到全体。</p>
<p>是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式</p>
<ul>
<li>是一种<mark>点对多点</mark>传输方式。</li>
<li>目的IP地址全1，目的MAC地址全F</li>
</ul>
<p>“广播”在网络中的应用较多，如客户机通过DHCP自动获得IP地址的过程就是通过广播来实现的。但是同单播和多播相比，广播几乎占用了子网内网络的所有带宽。拿开会打一个比方吧，在会场上只能有一个人发言，想象一下如果所有的人同时都用麦克风发言，那会场上就会乱成一锅粥。</p>
<p>在网络中不能长时间出现大量的广播包，否则就会出现所谓的“广播风暴”。广播风暴就是网络长时间被大量的广播数据包所占用，正常的点对点通信无法正常进行，外在表现为网络速度奇慢无比。出现广播风暴的原因有很多，一块有故障的网卡，就可能长时间向网络上发送广播包而导致广播风暴。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104155429364.png" alt="image-20210104155429364"></p>
<p>集线器由于其工作原理决定了不可能过滤广播风暴，一般的交换机也没有这一功能，不过现在有的网络交换机（如全向的QS系列交换机）也有过滤广播风暴功能了，路由器本身就有隔离广播风暴的作用。</p>
<p>广播风暴不能完全杜绝，但是只能在同一子网内传播，就好像喇叭的声音只能在同一会场内传播一样，因此在由几百台甚至上千台电脑构成的大中型局域网中，一般进行子网划分，就像将一个大厅用墙壁隔离成许多小厅一样，以达到隔离广播风暴的目的。</p>
<p>在IP网络中，广播地址用IP地址“255.255.255.255”来表示，这个IP地址代表同一子网内所有的IP地址。</p>
<h4 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h4><p>“多播”可以理解为一个人向多个人（但不是在场的所有人）说话，这样能够提高通话的效率。</p>
<p>如果你要通知特定的某些人同一件事情，但是又不想让其他人知道，使用电话一个一个地通知就非常麻烦，而使用日常生活的大喇叭进行广播通知，就达不到只通知个别人的目的了，此时使用“多播”来实现就会非常方便快捷，但是现实生活中多播设备非常少。</p>
<p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立<strong>组播分发树</strong>，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发。</p>
<ul>
<li>是一种<mark>点对多点</mark>传输方式。</li>
</ul>
<p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络（如果有组播路由器的支持）</p>
<p><strong>组播路由器</strong>：运行组播协议的路由器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104155349590.png" alt="image-20210104155349590"></p>
<p>“多播”也可以称为“组播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。</p>
<p>因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；</p>
<p>如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。</p>
<p>采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。</p>
<p>IP网络的多播一般通过多播IP地址来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。Windows 2000中的DHCP管理器支持多播IP地址的自动分配。</p>
<h5 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h5><p>我们知道，IP地址是用于接收别人传送信息的，那么对于组播来说，如果还是以原来的IP地址作为接受信息的目的IP，那岂不是达不到组播的效果了？因此必须要有一个<strong>IP组播地址</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104160611338.png" alt="image-20210104160611338"></p>
<h5 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h5><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。</p>
<p>组播MAC地址以十六进制值 <strong>01-00-5E</strong> 打头，余下的6个十六进制位是根据IP组播组地址的最后 <strong>23</strong> 位转换得到的。</p>
<ul>
<li>TCP/IP协议使用的以太网多播MAC地址的范围：<br>01-00-5E-00-00-00 ~ 01-00-5E-7F-FF-FF。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104162812431.png" alt="image-20210104162812431"></p>
<p> 有可能不使用的5位不一样，但后23位一样，导致两个组播组的接收端成为了一个组播组：</p>
<p>收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>
<h5 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h5><h6 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h6><ul>
<li>IGMP协议，网际组管理协议</li>
<li>作用：让路由器知道<strong>本局域网</strong>上是否有主机（的进程）参加或者退出了某个<strong>组播组</strong></li>
</ul>
<p>如下图所示，四个主机参加了同一个组播组，每个路由器根据<strong>IGMP协议</strong>就可以判断，每接受一个组播组，要不要给局域网中的主机们呢？下图中，发送数据报的话就只会给R1 R2 R3而不会给R4，这就是根据IGMP协议来的</p>
<p>但这个IGMP协议也有不完备性，只能让路由器知道进程参加或者退出了这个组播组，而不能知道参加了组播组的成员在什么网络上</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104165551913.png" alt="image-20210104165551913"></p>
<p>在协议中的位置：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104165620489.png" alt="image-20210104165620489"></p>
<ul>
<li>工作的两个阶段</li>
</ul>
<ol>
<li><p>阶段1：某主机要加入组播组时，该主机向组播维的组播地址发送一个IGMP报文，声明自己要称为该组的成员。</p>
<p>本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
</li>
<li><p>阶段2：本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p>
<p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；</p>
<p>如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
</li>
</ol>
<p><strong>成员关系</strong>：组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>
<h6 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h6><p>一个组播组中的成员是可以动态变化的。</p>
<p>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</p>
<p>构造树可以避免在路由器之间兜圈子。</p>
<p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104170226000.png" alt="image-20210104170226000"></p>
<p>组播路由选择协议常使用的三种算法</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播（稀疏/密集）</li>
</ul>
<h2 id="路由算法-amp-路由协议"><a href="#路由算法-amp-路由协议" class="headerlink" title="路由算法 &amp; 路由协议"></a>路由算法 &amp; 路由协议</h2><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>路由器中有两个表：路由表/转发表</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102164632550.png" alt="image-20210102164632550"></p>
<p>路由算法的意义就在于：每次选择转发的路由都选择最佳的路由</p>
<p>ps：最佳路由中的<strong>最佳</strong>是相对于某一种特定要求下得出的较为合理地选择</p>
<p>路由算法有两种：</p>
<ol>
<li>静态路由算法（非自适应路由算法）</li>
<li>动态路由算法（自适应路由算法） </li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102165131431.png" alt="image-20210102165131431"></p>
<hr>
<p>关于动态路由算法，有两个性质：<strong>全局性</strong>和<strong>分散性</strong></p>
<ul>
<li><p>全局性：体现出全局性的算法叫<strong>链路状态路由算法 OSPF</strong></p>
<p>所有路由器掌握完整的网络拓扑和链路费用信息</p>
</li>
<li><p>分散性：体现出分散性的算法叫<strong>距离向量路由算法 RIP</strong></p>
<p>路由器只掌握物理相连的邻居及链路费用</p>
</li>
</ul>
<h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>为什么要分层次呢？</p>
<p>因为因特网的规模很大，而且单位不想让外界知道自己的路由选择协议，但仍想要连入因特网</p>
<p>因此就衍生了<mark>自制系统AS</mark>的概念：</p>
<p>在单一技术管理下的<strong>一组路由器</strong>，而这些路由器使用<strong>一种AS内部的路由选择协议</strong>和<strong>共同的度量</strong>以确定分组在该AS内的<strong>路由</strong></p>
<p>同时使用一种AS之间的额路由协议以确定在AS之间的路由属于一个行政单位进行管辖，一个自治系统的所有路由器在本自治系统内都必须要联通</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102170941984.png" alt="image-20210102170941984"></p>
<p>路由选择协议因此也分为两种：</p>
<ol>
<li>内部网关协议IGP：一个AS内使用的（<strong>RIP OSPF</strong>）</li>
<li>外部网关协议EGP：AS之间使用的（<strong>BGP</strong>）</li>
</ol>
<h3 id="RIP协议和距离向量算法"><a href="#RIP协议和距离向量算法" class="headerlink" title="RIP协议和距离向量算法"></a>RIP协议和距离向量算法</h3><h4 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h4><ul>
<li><p>这是一种分布式的基于<strong>距离向量</strong>的<mark>路由选择协议</mark></p>
</li>
<li><p>他要求网络中<strong>每个路由器</strong>都维护<em>从它自己到其他每一个目的网络的唯一最佳距离记录</em>（一组距离）</p>
</li>
<li><p><strong>距离</strong>：通常表示为<mark>跳数</mark>，即从<strong>源端口</strong>到<strong>目的端口</strong>所经过的路由器个数。经过一个路由器，跳数就+1</p>
<p>取值为1 ~ 15,16表示无穷大</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103204255367.png" alt="image-20210103204255367"></p>
<p> 那么RIP协议是交换什么信息，和谁交换呢？</p>
<ol>
<li>与<strong>相邻的路由器</strong>交换信息</li>
<li>所交换的信息是<strong>自己的路由表</strong></li>
<li><strong>每30秒</strong>交换一次路由信息，而后路由表根据新信息来更新自己的路由表，若180s没接收到邻居路由器的通告，就认定邻居路由器消失</li>
</ol>
<p>一开始路由器只知道数目有限的相邻路由器信息，后来更新次数多了，所有路由器最终都会知道到达<strong>AS</strong>任何一个网络的最短距离和下一跳路由器的地址，就<mark>收敛</mark>了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103205551346.png" alt="image-20210103205551346"></p>
<h4 id="RIP协议的报文格式"><a href="#RIP协议的报文格式" class="headerlink" title="RIP协议的报文格式"></a>RIP协议的报文格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103214456225.png" alt="image-20210103214456225"></p>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>如果有学过数据结构的图的内容的话，其实对于这个距离向量算法还是比较熟悉的</p>
<p>主要分为三步：</p>
<ol>
<li>初始化表项，修改相邻路由器发来的RIP报文中的所有表项</li>
<li>对于1中修改后的RIP报文中的每个项目，进行判断并做相应操作</li>
<li>如果180s未收到相邻路由器X的更新路由表，将X标记成不可达的路由器（距离=16）</li>
<li>返回 循环</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103211349636.png" alt="image-20210103211349636"></p>
<p>ps：</p>
<ul>
<li><strong>为什么改地址</strong>？因为图中是从x得到的信息</li>
<li><strong>为什么距离固定+1</strong>？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1</li>
<li><strong>为什么下一跳是x就要替换</strong>？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的</li>
<li><strong>为什么下一跳不是x时有更新和不处理两种手段</strong>？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解</li>
</ul>
<p>例题1分析：</p>
<p>首先把R4发来的路由信息（左下），进行更新，把距离+1，然后更改下一跳路由器为R4</p>
<p>第二步，根据发来的路由信息修改R6的路由表</p>
<p>发现：R6的路由表中没Net1的目标网络，因此填进去</p>
<p>对于目的网络Net2，R6表中有，且下一跳的路由器相同，因此进行替换</p>
<p>对于目的网络Net3，R6表中有，且下一跳的路由器不同，因此选择距离短的那个</p>
<p>（这里选择R4的那个是因为，新的含义为：如果我下一跳走R4，那么到达Net3只需要2跳）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103212724472.png" alt="image-20210103212724472"></p>
<p>例题2分析：</p>
<p>来自B的向量为（5,0,8,12,6,2）是什么意思呢？意思是B到达A、B、C、D、E、F的距离为这几个数字</p>
<p>后面几个向量同理</p>
<p>现在给定了C到B、D、E的延迟了，只需要把这几个延迟分别加到原来的向量里</p>
<p>然后在这几个新的向量组里，每一步选择距离最短的，最后即可得到C到达所有结点的最短路径了。</p>
<p>ps：0的意思是到自己的距离</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103213941432.png" alt="image-20210103213941432"></p>
<h4 id="RIP协议特点"><a href="#RIP协议特点" class="headerlink" title="RIP协议特点"></a>RIP协议特点</h4><p>  来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111526974.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111637786.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111700886.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200629111718198.png" alt="在这里插入图片描述"></p>
<h3 id="OSPF协议与链路状态算法"><a href="#OSPF协议与链路状态算法" class="headerlink" title="OSPF协议与链路状态算法"></a>OSPF协议与链路状态算法</h3><p>参考博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8ace17859bd1">https://www.jianshu.com/p/8ace17859bd1</a></p>
<h4 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h4><ul>
<li>Open Shortest Path First, 开放最短路径优先协议，是一种开源的使用最短路径优先（SPF）算法的内部网关协议（IGP）。</li>
<li>常用于路由器的动态选路。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103215911003.png" alt="image-20210103215911003"></p>
<h4 id="OSPF常见的几个概念"><a href="#OSPF常见的几个概念" class="headerlink" title="OSPF常见的几个概念"></a>OSPF常见的几个概念</h4><ul>
<li><p><mark>邻居（Neighbor）</mark>：宣告OSPF的路由器（也可能是通过quagga软件配置的普通服务器）从所有启动OSPF协议的接口上发出Hello数据包。</p>
<p>如果两台路由器位于同一条数据链路上，并且它们根据互相的hello消息中指定的某些信息（比如id等）协商成功，那么它们就成为了邻居（Neighbor）。</p>
</li>
<li><p><mark>邻接关系（Adjacency）</mark>：两台邻居路由器之间构成的一条点到点的虚链路，邻接关系的建立是由交换hello信息的路由器类型和网络类型决定的。</p>
</li>
<li><p><mark>链路状态通告（Link State Advertisement，LSA）</mark>：每一台路由器都会在所有形成邻接关系的邻居之间发送链路状态通告LSA。</p>
<p>LSA描述了路由器所有的链路、接口、邻居等信息。ospf定义了许多不同的LSA类型。</p>
</li>
<li><p><mark>链路状态数据库（LSDB）</mark>：每一台收到来自邻居路由器发出的LSA的路由器都会把这些LSA信息记录在它的LSDB中，并且发送一份LSA的拷贝给该路由器的其他所有邻居。</p>
<p>这样当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB。</p>
</li>
</ul>
<h4 id="OSPF的基本原理"><a href="#OSPF的基本原理" class="headerlink" title="OSPF的基本原理"></a>OSPF的基本原理</h4><p>OSPF算法是让每个路由器中的数据库储存整个网络的拓扑图，即每个路由器掌握了全局的信息，此时这个网络趋于稳定，便可以使用单源最短路径（Dijkstra）来选择路由。</p>
<p>每个路由器与其邻居的通信行为有以下几种：<br> 1.<strong>保持联系</strong><br> 整个自治系统中，每个路由器都有唯一标识RouterID(32-bit). 与其每个邻居间隔30s，发送一次Hello 报文，意思就是你还活着吗？<br> 二者相互通信发送Hello，并收到对方回应Hello。双方会周期性将自己的路由数据摘要发送给对方，一般30min，平时，<br> 双方只是联系感情，直到对方没有挂。<br> 2.<strong>告知现今情况</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/16845916-40717fbbfc3b07a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp" alt="img"></p>
<p>如图，R1会周期性地将自己的路由摘要发送给所有邻居。比如对R6路由器，R1会发送称为DD报文的包，里面会说自己认识R6,R2,R4,R5,R6对比自己的信息库发现 除了自己R1的朋友它一个都不认识，于是就发送请求报文，请求告知这些不认识的路由详情。</p>
<p>这个请求报文称为LSR(链路状态请求报文)报文。<br>R1收到之后，直到R6还不认识自己另外三个朋友，于是发送LSU报文（链路状态更新）告知R6详情</p>
<p>R6收到之后，给R1个确认-LSAck报文。两个人现在认识的路由器一样多了，此时两个人是好基友了-全毗邻关系。</p>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p>其实就是<strong>Dijkstra算法</strong>的实例运用吧 我感觉</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104001203805.png" alt="image-20210104001203805"></p>
<h4 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h4><p>关于区域：<a target="_blank" rel="noopener" href="https://blog.51cto.com/14157628/2392133">https://blog.51cto.com/14157628/2392133</a></p>
<p><strong>为什么要分区域呢？</strong></p>
<p>在大型网络中，使用OSPF路由协议经常遇到以下问题：<br>1.在大型网络中，网络结构的变化是时常发生的，因此OSPF路由器就会经常运行SPF算法来重新计算路由信息，大量消耗路由器的CPU和内存资源；<br>2.在OSPF网络中，随着多条路径的增加，路由表会变得越来越庞大，每一次路径的改变都使路由器不得不花大量的时间和资源去重新计算路由表，路由器会变得越来越低效；<br>3.包含完整网络结构信息的链路状态数据库也会变得越来越大，这将有可能使路由器的CPU和内存资源彻底耗尽，从而导致路由器的崩溃。</p>
<p>为了解决这个问题，OSPF允许把大型区域划分成多个小区域，这些小区域可以交换路由汇总信息，而不是每个路由器的详细信息；也更容易管理；OSPF的工作也会更加流畅。</p>
<p><strong>生成OSPF多区域的原因</strong><br>改善网络的可扩展性；<br>快速收敛。<br>想要达到上面两个要求的关键就是把网络分成更小的区域。比如<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104005113687.png" alt="image-20210104005113687"><br>划分区域之后，每个OSPF区域中支持的最多路由器的个数30——200。</p>
<p>但是一个区域中实际加入的路由器的数量要小于单个区域所能容纳路由器的最大数量。因为有很多原因影响，比如：一个区域内链路的数量、网络拓补稳定性、路由器的内存和CPU等等。</p>
<p>对于和区域相关的通信量定义了三种类型，如：</p>
<ol>
<li>域内通信量：指由单个区域内的路由器之间交换的数据包构成的通信量；</li>
<li>域间通信量：指由不同区域的路由器之间交换的数据包构成的通信量；</li>
<li>外部通信量：指由OSPF区域内的路由器与OSPF区域外或两一个AS（自治系统）内的路由器之间交换的数据包构成的通信量。</li>
</ol>
<p>OSPF被分为多区域的能力是依照分层路由实现的。当划分成小区域以后，像重新计算拓补数据库这样的操作就被限定在该小区域内，区域间则只需通告一些汇总信息。<br>分层路由的优势：</p>
<ol>
<li>降低了SPF运算的频率；</li>
<li>减小了路由表；</li>
<li>减小了链路状态更新报文（LSU）的流量。</li>
</ol>
<p><strong>什么是区域呢？</strong></p>
<ul>
<li>为了使OSFP能够用于大规模的网络，OSPF将一个自治系统再划分成了<strong>若干个更小的范围：<mark>区域</mark></strong></li>
</ul>
<p>在区域内有着不同种类的路由器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104005642122.png" alt="image-20210104005642122"></p>
<p><strong>内部路由器</strong>：指所有接口都属于同一个区域的路由器；<br><strong>区域边界路由器（ABR）</strong>：指连接一个或多个区域到骨干区域的路由器并且这些路由器会作为域间通信量的网关。物理上至少连接两个区域。<br><strong>自治系统边界路由器（ASBR）</strong>：ASBR路由器是用来把其他路由选择协议学习到的路由通过路由选择重分配的方式注入OSPF域的路由器。至少配置两种路由协议。</p>
<p>OSPF根据能够学习到的路由种类将区域分为不同的类型，包括<strong>骨干区域、标准区域、末梢区域、完全末梢区域、非纯末梢区域</strong>等。<br>运行OSPF的整个区域属于一个AS，AS范围外的路由都属于外部路由。</p>
<p>骨干区域用于连接其他区域，骨干区域中的路由器大都是ABR。</p>
<p><strong>骨干区域Area 0</strong>该区域的ID一定是0，它是连接所有其他区域的核心，在不同的区域间传递路由信息，其他区域必须跟骨干区域直连。<br><strong>标准区域</strong>能够学习到其他区域的路由；也能学习到外部路由就称为标准区域。<br>每个路由器都创建了由每个接口、对应的相邻节点和接口速度组成的数据库，称为<mark>链路状态数据库</mark>。<br>链路状态数据库中每个条目称为<strong>LSA（链路状态通告）</strong>，常见的有六种LSA类型;</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104004124140.png" alt="image-20210104004124140"></p>
<h4 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104010148222.png" alt="image-20210104010148222"></p>
<h4 id="OSPF特点"><a href="#OSPF特点" class="headerlink" title="OSPF特点"></a>OSPF特点</h4><ol>
<li>每隔三十分钟，要刷新一次数据库中的链路状态</li>
<li>由于一个路由器的<strong>链路状态</strong>只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系；因此当<strong>互联网规模很大</strong>的时候，OSPF协议要比<strong>距离向量协议RIP</strong>好很多</li>
<li>OSPF不存在坏消息传的慢的问题，<strong>收敛速度很快</strong></li>
</ol>
<h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><ul>
<li>BGP协议是外部网关协议</li>
</ul>
<p>关于BGP协议：</p>
<ul>
<li>和谁交换信息？与其他的AS的临站BGP发言人交换信息</li>
<li>交换内容是什么？交换的是<strong>网络可达性的信息</strong>，即：要到达某个网络所要经过的一系列AS，也就是一个<strong>完整的路径</strong></li>
<li>多久交换一次呢？不同于RIP协议，30s更新一次，发生变化时就更新有变化的部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104144938982.png" alt="image-20210104144938982"></p>
<h4 id="BGP协议交换信息的过程"><a href="#BGP协议交换信息的过程" class="headerlink" title="BGP协议交换信息的过程"></a>BGP协议交换信息的过程</h4><p>上面我们提到过：BGP协议交换的网络可达性的信息就是<mark>要到达某个网络所要经过的一系列AS</mark>。当<strong>发言人</strong>互相交换了<strong>网络可达性</strong>的信息之后，各<strong>BGP发言人</strong>根据所采用的策略，从收到的<strong>路由信息</strong>中找到到达各AS的<strong>较好路由</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150436525.png" alt="image-20210104150436525"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150457601.png" alt="image-20210104150457601"></p>
<h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104150644601.png" alt="image-20210104150644601"></p>
<h4 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h4><ul>
<li><p>BGP协议支持<strong>CIDR</strong>，which meas，BGP的路由表也就应当包括：<strong>目的网络前缀、下一跳路由器、以及到达目的网络索要经过的各个自治系统序列</strong></p>
</li>
<li><p>在BGP刚运行的时候，BGP的邻站是交换整个的<strong>BGP路由表</strong>。但在之后只需要<mark>发生变化的时候，更新有变化的部分</mark></p>
<p>这样做的好处：对节省网络带宽和减少路由器的处理开销都有好处</p>
</li>
</ul>
<h4 id="BGP-4-的四种报文"><a href="#BGP-4-的四种报文" class="headerlink" title="BGP-4 的四种报文"></a>BGP-4 的四种报文</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104151523075.png" alt="image-20210104151523075"></p>
<h3 id="三种报文的比较"><a href="#三种报文的比较" class="headerlink" title="三种报文的比较"></a>三种报文的比较</h3><ol>
<li><mark>RIP</mark>是一种<strong>分布式</strong>的<strong>基于距离向量</strong>的<strong>内部网关路由选择协议</strong>，通过广播<mark>UDP</mark>报文来交换路由信息</li>
<li><mark>OSPF</mark>是一个<strong>内部网关协议</strong>，要交换的信息量比较大，应该使得交换的报文尽可能的短，所以不使用<strong>传输层协议</strong>（比如UDP/TCP），而是直接采取<mark>IP</mark></li>
<li><MARK>IP是一种<strong>外部网关协议</strong>，在不同的自治系统AS之间交换路由信息，由于网络的环境很复杂，需要保证<strong>可靠传输</strong>，所以采用<mark>TCP</mark></MARK></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104152605563.png" alt="image-20210104152605563"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p>首先明白什么是IP地址</p>
<p> 其实就是给网络中的主机或是主机的接口、路由器的接口赋予标识符，能够做到全球唯一化，方便互联网中寻址通信</p>
<p>由两部分组成：网络号 + 主机号</p>
<p>顾名思义，网络号呢 就是用于确认在哪个区域网络，主机号用于确定该区域内哪个主机</p>
<p>通常采用<strong>点分十进制</strong></p>
<p>ip地址的四段数字分别代表了：网络类型、网络范围、网络位和主机位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102203123904.png" alt="image-20210102203123904"></p>
<p>在下图中，我们不难发现，红色区域和绿色区域内的网络位相同，总共有6个实际上的网络，只是绿色部分不是由主机，是由线路形成的</p>
<p>也不难发现，一个路由器，它的主机位是一样的，但是可以连接多个网络位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102212812420.png" alt="image-20210102212812420"></p>
<h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>A类中为什么是2^7 - 2呢？因为第一位固定0，因此可用的是7位，而减2是刨除了全0以及网络号为127这种情况</p>
<p>主机数为什么也要减2呢，一个是主机号为全0情况，一个是主机号为全1情况</p>
<p>同理也可以推出下面-1，-2的意思</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102215104191.png" alt="image-20210102215104191"></p>
<h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><p>特殊主要是体现在，网络号和主机号上，如果其全为0或是全为1，那么代表着什么呢？</p>
<p>（前三位是网络号，第四位是主机号）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102214017320.png" alt="image-20210102214017320"></p>
<h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>前面我们学习了IP地址分类，有A、B、C…类等等</p>
<p>根据类别不同就有了私有IP地址了，因为根据地址的类别，可以划分地址范围因而可以设定网段的个数</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102214458357.png" alt="image-20210102214458357"></p>
<p>为什么A类最大是126.xxx.xxx.xxx？<br>因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉<br>为什么B类最大是191.255.xxx.xxx？<br>因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址<br>为什么C类最大是223.255.xxx.xxx？<br>因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip</p>
<h4 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h4><p>网络层的分组为<strong>数据报</strong>，数据报为<strong>首部和数据</strong>两部分组成，如下图所示。</p>
<p><img src="https://images2015.cnblogs.com/blog/833392/201604/833392-20160404203420640-797750729.png" alt="img"></p>
<p>首部的长度是以<strong>4个字节</strong>为单位，长度可以是<strong>20-60</strong>字节，这跟首部的HLEN字段有关。</p>
<p><img src="https://images2015.cnblogs.com/blog/833392/201604/833392-20160404201653937-531539500.png" alt="img"></p>
<p><strong>版本：</strong></p>
<p>这个4位字段定义了IP协议的版本，目前主流的版本是4。</p>
<p><strong>首部长度：</strong></p>
<p>这个4位字段定义了数据报首部的长度，以<strong>4字节</strong>的字为<strong>单位</strong>。</p>
<p>当首部<strong>没有选项</strong>时，首部长度位<strong>20字节</strong>；当这个字段值位最大值F时，首部长度<strong>最大为60字节</strong>。</p>
<p><strong>服务类型：</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106140012964.png" alt="image-20210106140012964"></p>
<p><strong>总长度：</strong></p>
<p>这个16位字段定义了数据报总长度，其<strong>以字节为单位</strong>。故IPv4数据报总长度上限值位<strong>65536字节</strong>。</p>
<p>注：为什么需要这个字段？在许多情况下，我们确实不需要这个字段值。但是有些情况下，封装在一个帧里的并不仅仅是数据报，还可能附加了一些<strong>填充</strong>。比如，以太网协议对帧的数据有最大值（1500字节）和最小值（46字节）的限制，当数据小于46字节时，数据将含有填充数据。</p>
<p><strong>标识（identification）：</strong></p>
<p>这个16位字段标志了从源主机发出的一个数据报，这样就确定了<strong>数据报的唯一性</strong>。这样使得数据报被分片后，在到达终点时终点能根据标识号将同一个数据报的分片重新组装成一个数据报。</p>
<p><strong>标志（flag）：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>D</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第一位保留（未用），第二位为“不分片（do not fragment）”，第三位位“还有分片（more fragment）”。</p>
<p>D为1时，不能对数据进行分片；为0可以进行分片。</p>
<p>M为1时，标识还有分片；为0表示最后一个分片。</p>
<p><strong>片偏移：</strong></p>
<p>这个13位字段表示的是分片在整个数据报中的相对位置。这是<strong>数据</strong>在原始数据报中的<strong>偏移量</strong>，以<strong>8字节位单位</strong>。</p>
<p>注：分片本身还可能进行分片，这种情况下，分片偏移值永远是相对于原始数据报的。</p>
<p><strong>生存时间：</strong></p>
<p>这个8位字段用来控制数据报所经过的最大跳数（路由器），每经过一个路由器，这个字段数值都减1，减1后变位0时，路由器就丢弃这个数据报。</p>
<p><strong>协议：</strong></p>
<p>这个8位字段定义了使用IPv4服务的高层协议，如TCP，UDP，ICMP，IGMP，OSPF等的数据都将被封装到IP数据报中。这个字段指明数据报必须交付给哪个最终目的协议。</p>
<p>注：1表示ICMP，2表示IGMP，6表示TCP，17表示UDP，89表示OSPF</p>
<p><strong>检验和：</strong></p>
<p>检验IP数据报首部。</p>
<p><strong>源地址：</strong></p>
<p>定义了源点的IP地址，这个字段始终保持不变。</p>
<p><strong>目的地址：</strong></p>
<p>定义了终点的IP地址，这个字段始终保持不变。</p>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>网络地址转换NAT有什么用呢？之前我们学习到私有IP地址这个概念</p>
<p>我们知道：路由器对于目的地址是私有IP地址的数据报一律不进行转发，那假如我处于私有IP地址，我怎么与外界进行通信呢？</p>
<p>就要通过<mark>网络地址转换NAT</mark>这个技术了</p>
<p>在NAT技术中，通过NAT转换表，把<strong>源IP地址</strong>转换成<strong>NAT路由器的IP地址</strong>，<strong>原来的端口号</strong>替换成<strong>NAT路由器的端口号</strong>，就能够在因特网中进行转发了</p>
<p>而外部因特网想与专用网通信也是同样道理，数据报填上：源IP地址，目的地址（这个时候目的地址就得填NAT路由器的IP地址了），端口号；</p>
<p>经由NAT路由器查找对应的WAN端找到LAN端的端口号，进而找到对应主机</p>
<p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210102221152359.png" alt="image-20210102221152359"></p>
<h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p>为什么要有子网划分呢？肯定是因为之前的<strong>分类的IP地址</strong>不够好</p>
<p>主要有以下两点缺点：</p>
<ol>
<li>IP地址空间的利用率有时候会很低</li>
<li>两级IP地址不够灵活(网络号+主机号)</li>
</ol>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>子网划分主要就是把：主机号中<strong>高位数</strong>换成了<strong>子网号</strong>，剩下依旧表示主机号</p>
<p>子网划分的意义是什么呢？是为了增加子网的数量，而子网之间数据传输又需要经由路由器，因此最终目的是减少了<strong>广播域</strong>的大小</p>
<p>同时，划分子网由于子网号占用主机号位，因此会减少主机的数量；</p>
<p>划分子网仅仅只提高了IP地址的利用率，并不会增加网络的数量</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103150436799.png" alt="image-20210103150436799"></p>
<p>下面是一个子网划分的例子：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt="image-20210103151451563"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码有什么用呢？是用于和IP地址一起计算<strong>子网的地址</strong>的</p>
<p>方法：子网掩码由1组成，与原来的ip地址进行<strong>与运算</strong>，即可得到<strong>子网的IP地址</strong></p>
<p>我感觉子网掩码部分需要记住的知识点就是十进制转二进制，然后找一下对应的属于哪一类网，然后看看对应网有什么性质，做题这样。</p>
<p>然后根据子网掩码和ip地址算子网地址，一个是通过与运算算出来子网地址之后，又要求广播地址</p>
<p>那么这个时候广播地址是基于子网地址的嘛，就在子网地址的基础上，分清楚主机号网络号，把主机号置为1就是广播地址</p>
<p>主机地址范围就是在子网地址的基础上：</p>
<p>最小值是主机号全为0 的二进制数+1，最大值是主机号全为1的二进制数 - 1</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt="image-20210103151948576"></p>
<p>用IP的术语来说，互联这三个主机接口与一个路由器接口的网络形成一个<strong>子网</strong>。</p>
<p>（在因特网文献中，子网也称为IP网络或直接成为网络）Ip编址为这个子网分配一个地址：233.1.1.0/24，其中的/24记法，有时称为<strong>子网掩码</strong>（networkmask）,指示了32比特中的最左侧24比特定义了子网地址。</p>
<p>通俗来讲，子网掩码用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别<strong>网络标识</strong>和<strong>主机标识</strong>，并说明该IP地址是在局域网上，还是在远程网上。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt></p>
<p>子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。</p>
<ul>
<li>对于<strong>A</strong>类地址来说，默认的子网掩码是<strong>255.0.0.0</strong>；</li>
<li>对于<strong>B</strong>类地址来说默认的子网掩码是<strong>255.255.0.0</strong>；</li>
<li>对于<strong>C</strong>类地址来说默认的子网掩码是<strong>255.255.255.0</strong>；</li>
</ul>
<p>那么通过子网掩码我们可以知道什么信息呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过子网掩码，就可以判断两个IP在不在一个局域网内部。</span><br><span class="line">子网掩码可以看出有多少位是网络号，有多少位是主机号</span><br></pre></td></tr></table></figure>

<h5 id="子网掩码习题"><a href="#子网掩码习题" class="headerlink" title="子网掩码习题"></a>子网掩码习题</h5><p>通过用IP地址 与 子网掩码进行与运算（相同为1，不同为0）得到网络地址</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2020062821061359.png" alt></p>
<p>对于此类题，首先要判断出网络号有多少位：255.255.252.0 有 8 + 8 + 6 = 22位的网络号 则后面的 32 - 22 = 10位是主机号</p>
<p>180.80.77.55 解析 —— 可以知道在77部分某部分开始会用来表示主机号位</p>
<p>子网掩码前面是255.255 则180.80能保留下来 也就是占有8 + 8 = 16位，我们已知有22位的网络号，则留给IP地址180.80.77.55第三位<strong>77</strong>来构成网络号的就有6位，77二进制：010011 01，则前6位是归于网络号，后面01开始为主机号</p>
<p>则用于表示子网ip地址的就是<strong>180.80.76(<mark>010011 00</mark>).xxx</strong> </p>
<p>本体要求是发布广播地址 —— 主机号全为1</p>
<p>则目的地址应该是<strong>180.80.79（<mark>010011 11</mark>）.255(11111111）</strong> 选D</p>
<h4 id="使用子网的时候分组的转发"><a href="#使用子网的时候分组的转发" class="headerlink" title="使用子网的时候分组的转发"></a>使用子网的时候分组的转发</h4><p>当使用子网的时候分组转发分以下几步：</p>
<ol>
<li><p>从收到的分组首部提取<mark>目的IP地址D</mark></p>
</li>
<li><p>首先用各相邻网络的<mark>子网掩码和<strong>目的IP地址D</strong></mark>逐位相与，看是否和相应的网络地址匹配。</p>
<p>如果匹配了，就把分组直接交付了。否则进行<strong>间接交付，</strong>也就是执行3</p>
</li>
<li><p>若路由表中有目的地址为D的<mark>特定主机路由</mark>，就把分组传送给指明的下一跳路由器；</p>
<p>如果没有，则执行4</p>
</li>
<li><p>在这一步，对<strong>路由表</strong>中的每一行，将<mark>子网掩码</mark>和D逐位相与。</p>
<p>如果结果和该行的目的地址匹配，就把分组传送给该行指明的<strong>下一跳路由器</strong></p>
<p>否则，执行5</p>
</li>
<li><p>如果路由表中有一个<mark>默认路由</mark>。就把分组传送给路由表中指明的默认路由器</p>
<p>否则，执行6</p>
</li>
<li><p>报告转发分组出错</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201220164741323.png" alt></p>
<h3 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h3><p>有个博客讲的真的不错：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dan15188387481/article/details/49873923">https://blog.csdn.net/dan15188387481/article/details/49873923</a></p>
<hr>
<ul>
<li><p>CIDR中文全称是无分类域间路由选择，英文全称是Classless Inter-Domain Routing</p>
</li>
<li><p>CIDR这种方法比较灵活，消除了传统A B C类以及划分子网的概念</p>
</li>
</ul>
<p>使用下面的IP地址表示法：</p>
<p><code>IP地址 ::= &#123;&lt;网络前缀&gt;， &lt;主机号&gt;&#125; / 网络前缀所占位数</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103161001783.png" alt="image-20210103161001783"></p>
<ul>
<li>融合了子网地址和子网掩码，方便子网划分</li>
</ul>
<p>CIDR表示法给出任何一个IP地址，就相当于给出了一个CIDR地址块，这是由连续的IP地址组成的，所以CIDR表示法构成了超网，实现了路由聚合，即从一个IP地址就可以得知一个CIDR地址块。</p>
<p>例如：已知一个IP地址是：128.14.35.7/20，那么这个已知条件告诉大家的并不仅仅是一个IP地址这么简单，我们来分析一下。</p>
<p>  <code>128.14.35.7/20 = 10000000  00001110  00100011  00000111</code></p>
<p>  即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即</p>
<p>  最小地址是：128.14.32.0    = <strong>10000000  00001110  0010</strong>0000  00000000 </p>
<p>  最大地址是：128.14.47.255  = <strong>10000000  00001110  0010</strong>1111 11111111   </p>
<p>  子网掩码是：255.255.240.0  = <strong>11111111  11111111  1111</strong>0000  00000000 </p>
<p>  因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103161649928.png" alt="image-20210103161649928"></p>
<h4 id="构成超网-路由聚合"><a href="#构成超网-路由聚合" class="headerlink" title="构成超网/路由聚合"></a>构成超网/路由聚合</h4><ul>
<li>基本概念：将多个子网聚合成一个较大的子网，就叫做<strong>构成超网</strong>或是<strong>路由聚合</strong> </li>
</ul>
<p>如下图中网络1和网络2的前16位都是一样的，因此可以聚合成一个网络</p>
<p>方法就是：<strong>网络前缀缩短</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103162648219.png" alt="image-20210103162648219"></p>
<h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p>使用缩短前缀这种方法，转发表会有多个匹配结果，因此使用<strong>最长前缀匹配</strong></p>
<p>前缀越长，地址块越小，那么所留下的范围就很小，路由就非常具体了</p>
<p>取/n的意思：就是目的网络中n位表示网络号，被截取的那部分剩下用0补充的意思</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103163727792.png" alt="image-20210103163727792"></p>
<p>例题：</p>
<p>这道题可以理解成前24为为一个网络号，后面8为取出一部分作为子网号，其他作为主机号</p>
<p>那么就看子网掩码号的<strong>248</strong>,二进制是11111 000，则前5位可作为子网号，后3位作为主机号；</p>
<p>那么最大子网个数就是前五位都充分利用起来：2^5 = 32</p>
<p>而每个子网内最大可分配地址个数就是根据主机号来的：2^3 - 2 = 6</p>
<p>为什么要减去2呢，因为不能用全0全1两种情况</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103165228306.png" alt="image-20210103165228306"></p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h4 id="发送数据的过程"><a href="#发送数据的过程" class="headerlink" title="发送数据的过程"></a>发送数据的过程</h4><p>应用层传一个文件 → 传输层拆分成报文段（传输单元）→ 网络层将传输层的报文段加源主机和目的主机IP地址还有一些其他信息  → 数据链路层封装 加上MAC地址（源和目的MAC地址）→ 物理层</p>
<p>在上述过程中有个问题，我怎么知道目的MAC地址呢？就是根据ARP高速缓冲得到的，它其中有IP地址与MAC地址的映射</p>
<p>下图中 1 → 3主机 （在一个网段内的请求）</p>
<p>假如没有映射呢 那就得根据<mark>ARP协议</mark>：首先广播一个<strong>ARP请求分组</strong>（包含源和目的IP地址以及源MAC地址以及全1的目的MAC地址 来达到广播的作用）</p>
<p>而后目标主机收到了请求，回应一个<strong>单播ARP响应分组</strong>（包括目的主机的IP地址和MAC地址）给源主机，这样数据链路层就有了目的主机的MAC地址了；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103182614267.png" alt="image-20210103182614267"></p>
<p>假设 1 → 5 （不在一个网段内请求）</p>
<p>此时大体流程相似，但是广播ARP请求分组要的是IP6，也就是默认网关IP6的MAC地址</p>
<p>后续的路由器也是这样操作，源MAC和目的MAC地址一直在变换，直到要到了5号主机的MAC地址为止</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103183649947.png" alt="image-20210103183649947"></p>
<h4 id="ARP协议-1"><a href="#ARP协议-1" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul>
<li><p>ARP协议：完成了<strong>主机或路由器IP地址</strong>到<strong>MAC地址</strong>的映射 </p>
<p>解决了<mark>下一跳走哪</mark>的问题</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103184556700.png" alt="image-20210103184556700"></p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><ul>
<li>主机是如何获取IP地址的呢？</li>
</ul>
<p>通常有两种方式：静态配置 和 动态配置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103185646353.png" alt="image-20210103185646353"></p>
<p>而动态配置中就需要用到 <strong><mark>动态主机配置协议DHCP</mark></strong></p>
<p>这是一种<mark>应用层</mark>协议，使用<mark>客户/服务器</mark>方式，客户端和服务端通过<mark>广播</mark>方式进行交互，是基于<mark>UDP</mark>的</p>
<p> 它提供了一种<strong>即插即用</strong>联网的机制，主机可以从服务器动态获取<mark>IP地址、子网掩码、默认网关、DNS服务器名称以及IP地址</mark>，</p>
<ul>
<li>它允许<strong>地址重用</strong>（什么意思呢？DHCP服务器有一个IP地址池，有很多IP地址，主机进来后，HDCP分配一个地址给它用，主机走后就回收，达到一个地址重用的效果）</li>
<li>支持<strong>移动用户加入网络</strong></li>
<li>支持<strong>在用地址续租</strong>（有时间性的分配一个地址，这段时间内叫租用期，时间过了后也可以续租继续用IP地址）</li>
</ul>
<p>工作流程：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103191040319.png" alt></p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP与IGMP是IP层协议 位于网络层与传输层之间，起桥梁作用，能够有效转发IP数据报和提高交互成功机会</p>
<ul>
<li>ICMP（Internet Control Message Protocol）Internet控制报文协议</li>
</ul>
<p>主要分为两种：ICMP差错报文和ICMP询问报文</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192150807.png" alt="image-20210103192150807"></p>
<h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h4><h5 id="ICMP差错报告报文数据字段"><a href="#ICMP差错报告报文数据字段" class="headerlink" title="ICMP差错报告报文数据字段"></a>ICMP差错报告报文数据字段</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192653668.png" alt="image-20210103192653668"></p>
<h5 id="5种ICMP差错报告报文"><a href="#5种ICMP差错报告报文" class="headerlink" title="5种ICMP差错报告报文"></a>5种ICMP差错报告报文</h5><p>主要分成五种：</p>
<ol>
<li><strong>终点不可达</strong></li>
<li><strong>源点抑制（已经废除了）</strong></li>
<li><strong>时间超过</strong></li>
<li><strong>参数问题</strong></li>
<li><strong>改变路由（重定向）</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103192627572.png" alt="image-20210103192627572"></p>
<h5 id="不应该发送ICMP差错报文情况"><a href="#不应该发送ICMP差错报文情况" class="headerlink" title="不应该发送ICMP差错报文情况"></a>不应该发送ICMP差错报文情况</h5><ol>
<li>对<strong>ICMP差错报告报文</strong>不再发送ICMP差错报告报文</li>
<li>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送IMCP差错报告报文</li>
<li>对具有<strong>组播地址</strong>的数据报都不发送ICMP差错报告报文</li>
<li>对具有<strong>特殊地址（比如127.0.0.0 or 0.0.0.0）</strong>的数据报不发送ICMP差错报告报文</li>
</ol>
<h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h4><h5 id="4种ICMP询问报文"><a href="#4种ICMP询问报文" class="headerlink" title="4种ICMP询问报文"></a>4种ICMP询问报文</h5><p>主要分为：</p>
<ol>
<li>回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文（已废除）</li>
<li>路由器询问和通告报文（已废除）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103194019766.png" alt="image-20210103194019766"></p>
<h3 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210103194445898.png" alt="image-20210103194445898"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为什么要有IPv6呢？因为我们的IPv4快用完了，虽然说有CIDR和NAT两门技术延缓了地址资源的不足，但是是治标不治本的，因此有了IPv6</p>
<p>同时还能趁机改进首部格式，让路由器能够快速处理/转发数据报</p>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul>
<li><strong>版本</strong>：指明了版本协议，总是为6</li>
<li><strong>优先级</strong>：区分数据报的类别的优先级</li>
<li><strong>流标签</strong>：有点类似与IPv4中的标识位的意思。首先需要明白<strong>流</strong>是什么，流是互联网络上从<strong>特定源点</strong>到<strong>特定终点</strong>的一一系列<strong>数据报</strong>。所有属于<strong>同一个流</strong>的数据报都具有相同的<strong>流标签</strong></li>
<li><strong>有效载荷长度</strong>：有效载荷长度的大小，也就是扩展首部+数据的大小</li>
<li><strong>下一个首部</strong>：标识下一个扩展首部或是上层协议首部</li>
<li><strong>跳数限制</strong>：IPv4的TTL，也就是生存时间，到0就会被丢弃</li>
<li><strong>源地址</strong>：不同于IPv4的源地址（32位），这里足足有128位，表示发送端的 IP 地址。</li>
<li><strong>目的地址</strong>：不同于IPv4的目的地址（32位），这里有128位，表示接收端 IP 地址。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104201536495.png" alt="image-20210104201536495"></p>
<p>可以看到，相较于 IPv4 ，IPv6 取消了下面几个字段</p>
<ul>
<li><strong>标识符、标志和比特偏移</strong>：IPv6 不允许在中间路由器上进行分片和重新组装。这种操作只能在端系统上进行，IPv6 将这个功能放在端系统中，加快了网络中的转发速度。</li>
<li><strong>首部校验和</strong>：因为在运输层和数据链路执行了报文段完整性校验工作，IP 设计者大概觉得在网络层中有首部校验和比较多余，所以去掉了。<strong>IP 更多专注的是快速处理分组数据</strong>。</li>
<li><strong>选项字段</strong>：选项字段不再是标准 IP 首部的一部分了，但是它并没有消失，而是可能出现在 IPv6 的扩展首部，也就是下一个首部中。</li>
</ul>
<h4 id="IPv6与IPv4"><a href="#IPv6与IPv4" class="headerlink" title="IPv6与IPv4"></a>IPv6与IPv4</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104201921303.png" alt="image-20210104201921303"></p>
<h4 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h4><p> 一般使用<mark>冒泡十六进制记法</mark>：4个为一组，一共有8组，每组之间用冒号隔开</p>
<p>还能用压缩形式，将0000的压缩成0，00xx压缩成xx，000x压缩成x</p>
<p>还有零压缩形式：将一连串连续的0用一堆冒号取代</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104202519386.png" alt="image-20210104202519386"></p>
<h4 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>单播</td>
<td>一对一通信</td>
<td>可做源地址，目的地址</td>
</tr>
<tr>
<td>多播</td>
<td>一对多通信，以前的广播地址当做覆盖所有主机的多播</td>
<td>可做目的地址</td>
</tr>
<tr>
<td>任播</td>
<td>一对多当中的一个通信，看似一对多，实则一对一</td>
<td>可做目的地址</td>
</tr>
</tbody></table>
<h4 id="IPv6向IPv4过渡的策略"><a href="#IPv6向IPv4过渡的策略" class="headerlink" title="IPv6向IPv4过渡的策略"></a>IPv6向IPv4过渡的策略</h4><p>现在大部分还在使用IPv4，但我一个应用IPv6的协议的数据报怎么向只采取了IPv4协议的设备交流呢？</p>
<p>使用：<strong>双栈协议、隧道技术</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104203621228.png" alt="image-20210104203621228"></p>
<h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>现在已经在实践中使用的从 IPv4 迁移到 IPv6 的方法是 <code>隧道技术(tunneling)</code>。</p>
<blockquote>
<p>什么是隧道技术呢？</p>
</blockquote>
<p>隧道技术是一种使用互联网络的基础设施在网络之间的传输数据的方式，使用隧道传递的数据可以是不同协议的数据帧或包。使用隧道技术所遵从的协议叫做<code>隧道协议(tunneling protocol)</code>。隧道协议会将这些协议的数据帧或包封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络进行传递。</p>
<p>使用隧道技术一般都会建一个<code>隧道</code>，建隧道的依据如下：</p>
<p>比如两个 IPv6 节点(下方 B、E)要使用 IPv6 数据报进行交互，但是它们是经由两个 IPv4 的路由器进行互联的。那么我们就需要将 IPv6 节点和 IPv4 路由器组成一个隧道，如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTPDUWdATSUHbTwDfcxTqJWibibib4U1rWHyAubCs7QGVxU5UWSweACBE3sftNtTLicwicGH2NWLmBfFYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>借助于隧道，在隧道发送端的 IPv6 节点可将整个 IPv6 数据报放到一个 IPv4 数据报的<code>数据(有效载荷)</code> 字段中，于是，IPv4 数据报的地址被设置为指向隧道接收端的 IPv6 的节点，比如上面的 E 节点。然后再发送给隧道中的第一个节点 C，如下所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTPDUWdATSUHbTwDfcxTqJWbY3ziaFnz7e9gE0j9MNUsBRCjQLadlz5KUr1lu4BKLoZeLXFaKmgqrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>隧道中间的 IPv4 提供路由，路由器不知道这个 IPv4 内部包含一个指向 IPv6 的地址。隧道接收端的 IPv6 节点收到 IPv4 数据报，会确定这个 IPv4 数据报含有一个 IPv6 数据报，通过观察数据报长度和数据得知。然后取出 IPv6 数据报，再为 IPv6 提供路由，就好像两个节点直接相连传输数据报一样。</p>
<h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul>
<li><p>移动IP技术是<strong>移动结点</strong>（计算机\服务器等）以<mark>固定的网络IP地址</mark>，实现跨越不同网段的<strong>漫游</strong>功能，并保证了基于<strong>网络IP</strong>的网络权限在漫游过程中<strong>不发生任何改变</strong></p>
<p>which means：当你的手机在漫游时，虽然人在B地，IP却是A地购买手机卡的运营商提供的IP。于是当你在B地手机（用蜂窝网）、电脑同时登陆QQ时经常会提示异地登陆</p>
</li>
<li><p><strong>移动结点</strong>：具有永久IP地址的移动设备</p>
</li>
<li><p><strong>归属代理（本地代理）</strong>：一个<strong>移动结点</strong>拥有的<mark>就居所</mark>称为<strong>归属网络</strong>，在归属网络中代表移动节点执行移动管理功能的实体叫做<strong>g归属代理</strong></p>
</li>
<li><p><strong>外部代理（外地代理）</strong>：在<strong>外部网络</strong>中帮助移动节点完成移动管理功能的实体称为<strong>外部代理</strong></p>
</li>
<li><p><strong>永久地址（归属地址/主地址）</strong>：移动结点在归属网络中的<strong>原始地址</strong></p>
</li>
<li><p><strong>转交地址（辅地址）</strong>：移动结点在外部网络使用的<strong>临时地址</strong></p>
</li>
</ul>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>相关博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gzxultra/article/details/45649083">https://blog.csdn.net/gzxultra/article/details/45649083</a></p>
<p>其实可以理解成A有事出去了，但碰巧B找A，这个时候由于本地代理知道A在哪，就能把消息转交给他</p>
<p>过程：</p>
<ol>
<li><p>移动节点在本地时，按传统的TCP/IP方式进行通信（在本地网固有地址）</p>
</li>
<li><p><strong>移动节点</strong>漫游到一个<strong>外地网络</strong>时，仍然使用固定的IP地址进行通信。为了能收到通信对端发给他的IP分组，<strong>移动节点</strong>需要向<strong>本地代理</strong>注册当前的位置地址，这个未知地址就是<strong>转交地址</strong>（它可以是外部代理地址或动态分配的地址）</p>
<p><mark>ps：可以理解成儿子要出远门了，告诉妈妈，有人找我就联系xxx这个地方就好，至于到底xxx是什么，我到了那个地方再告诉你。</mark></p>
</li>
<li><p><strong>本地代理</strong>接收到来自<strong>转交地址</strong>的注册后，会构建一条通往<strong>转交地址</strong>的<strong>隧道</strong>，将截获的发给<strong>移动节点</strong>的IP分组送到<strong>转交地址</strong>处。</p>
</li>
<li><p>在<strong>转交地址</strong>处解除隧道封装，恢复原始的IP分组，最后送到<strong>移动节点</strong>处，这样<strong>移动节点</strong>在外网就能收到这些发送给他的IP分组了。</p>
</li>
<li><p><strong>移动节点</strong>在外网通过外网的路由器或者外代理向本地发送IP数据包。</p>
</li>
<li><p>当<strong>移动节点</strong>来自一个外网时，只需要向<strong>本地代理</strong>更新注册的<strong>转交地址</strong>，就可以继续通信。</p>
<p><mark>这里就是第二步的，告知妈妈：哦，我这边的地址是xxx</mark></p>
</li>
<li><p>当<strong>移动节点</strong>回到本地网络，移动节点向<strong>本地代理</strong>注销<strong>转交地址</strong>，这时<strong>移动节点</strong>又将使用传统的TCP/IP方式进行通信</p>
</li>
</ol>
<p>为什么漫游收费贵呢？因为移动IP需要给你的设备分配两个IP地址（主地址和辅地址（转交地址）），并且需要完成这个转交工作。而各地区的运营商是独立运营的。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104193725381.png" alt="image-20210104193725381"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104195038315.png" alt="image-20210104195038315"></p>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>技术参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HpxpLgpltOzNrtnFBaP8SA">https://mp.weixin.qq.com/s/HpxpLgpltOzNrtnFBaP8SA</a></p>
<ul>
<li>路由器是一种具有<strong>多个输入端口</strong>和<strong>多个输出端口</strong>的<strong>专用计算机</strong>，任务是：<mark>转发分组</mark></li>
<li>每个路由器维护一个<mark>路由表</mark>,来决定分组的转发，为了提高路由表的查询效率并且减少路由表维护的内容，路由表只保留<strong>到达目的地址的下一个路由器的IP地址，而不保留整个传输路径的信息</strong></li>
<li>转发与路由选择的区别<ul>
<li>转发是在路由器内部，把一个<strong>分组</strong>由一个<strong>输入端口</strong>转发到另一个<strong>输出端口</strong></li>
<li>路由选择是比较宏观的了，是在路由器组之间，选择一个合适的路径，把一个信息从源主机发送到目的主机</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104204552835.png" alt="image-20210104204552835"></p>
<ul>
<li>输入端口：<code>输入端口(input port)</code>有很多功能。<code>线路终端功能</code>和<code>数据链路处理</code>功能，这两个功能实现了路由器的单个输入链路相关联的物理层和数据链路层。<code>输入端口查找/转发功能</code>对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是查询转发表来确定的。</li>
<li>交换结构：<code>交换结构(Switching fabric)</code>就是将路由器的输入端口连接到它的输出端口。这种交换结构相当于是路由器内部的网络。</li>
<li>输出端口：<code>输出端口(Output ports)</code> 通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。</li>
<li>路由选择处理器：<code>路由选择处理器(Routing processor)</code> 在路由器内执行路由协议，维护路由表并执行网络管理功能。</li>
</ul>
<p>上面只是这几个组件的简单介绍，其实这几个组件</p>
<h4 id="输入端口对线路上收到的分组的处理"><a href="#输入端口对线路上收到的分组的处理" class="headerlink" title="输入端口对线路上收到的分组的处理"></a>输入端口对线路上收到的分组的处理</h4><p>从线路那接收到了<strong>分组</strong>，分别交由<strong>物理层、数据链路层和网络层</strong>进行处理</p>
<p>其中网络层这块进行分组排队，并进行<mark>查表和转发</mark>，最后发送至交换结构</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104205946118.png" alt="image-20210104205946118"></p>
<p>每个输入端口中都有一个路由处理器维护的<strong>路由表的副本</strong>，根据路由处理器进行更新。这个路由表的副本能 够使每个输入端口进行切换，而无需经过路由处理器统一处理。这是一种<code>分散式</code>的切换，这种方式避免了路 由选择器统一处理造成转发瓶颈。</p>
<p>在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据 路由表查找并将数据包转发到相应的输出端口。</p>
<h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p>交换结构是路由器的核心功能，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，主要分为 <strong>通过内存交换、通过总线交换、通过互联网络进行交换</strong>，下面我们分开来探讨一下。</p>
<ul>
<li>经过内存交换：最开始的传统计算机就是使用<code>内存交换</code>的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以<code>中断</code> 的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后，路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。</li>
</ul>
<blockquote>
<p>这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<ul>
<li>经过总线交换：在这种处理方式中，总线经由输入端口直接将分组传送到输出端口，中间不需要路由选择器的干预。总线的工作流程如下：输入端口给分组分配一个<code>标签</code>，然后分组经由总线发送给所有的输出端口，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有 <code>多个</code> 分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<ul>
<li>经过互联网络交换：克服单一、共享式总线带宽限制的一种方法是使用一个更复杂的互联网络。如下图所示</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/640" alt="图片"></p>
<p>每条垂直的的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启和闭合。当分组到达输入端口 A 时，如果需要转发到端口 X，交换机控制器会闭合 A 到 X 交叉部分的交叉点，然后端口 A 在总线上进行分组转发。这种网络互联式的交换结构是 <code>非阻塞的(non-blocking)</code>的，也就是说 A -&gt; X 的交叉点闭合不会影响 B -&gt; Y 的链路。如果来自两个不同输入端口的两个分组其目的地为相同的输出端口的话，这种情况下只能有一个分组被交换，另外一个分组必须进行等待。</p>
<h4 id="输出端口将交换结构传送来的分组发送到线路"><a href="#输出端口将交换结构传送来的分组发送到线路" class="headerlink" title="输出端口将交换结构传送来的分组发送到线路"></a>输出端口将交换结构传送来的分组发送到线路</h4><p>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。</p>
<p>缓存管理其实就是维护一个<strong>队列</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104210940469.png" alt="image-20210104210940469"></p>
<p>在输入端口中有等待进入交换的排队队列，而在输出端口中有等待转发的排队队列，排队的位置和程度取决于<strong>流量负载、交换结构</strong>的相对频率和线路速率。</p>
<p>随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现<code>丢包(packet loss)</code>，这就是我们说的在网络中丢包或者被路由器丢弃。</p>
<h4 id="路由表和路由转发"><a href="#路由表和路由转发" class="headerlink" title="路由表和路由转发"></a>路由表和路由转发</h4><p><strong>路由表</strong>是根据<strong>路由选择算法</strong>得出的，主要用途是<strong>路由选择</strong>，总用软件进行实现</p>
<ul>
<li><strong>路由表</strong>总会和<strong>转发表</strong>弄混</li>
</ul>
<p><mark>转发表</mark>是由<mark>路由表</mark>得来的，可用软件实现，也可以用特殊的硬件来实现。<strong>转发表</strong>必须包含<mark>完成转发功能所必须的信息</mark>，在<strong>转发表</strong>的每一行都必须包含：<mark>从要到达的目的网络到输出端口和某些MAC地址信息的映射</mark></p>
<p>路由表主要是选择我<strong>下一跳</strong>要走哪个路由器，或是下一个IP地址应该走什么</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104212236599.png" alt="image-20210104212236599"></p>
<h3 id="路由器-网桥-集线器"><a href="#路由器-网桥-集线器" class="headerlink" title="路由器 网桥 集线器"></a>路由器 网桥 集线器</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210104211228632.png" alt></p>
<h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p>网络层是把数据从<strong>一个主机</strong>传送到<strong>另一个主机</strong>，但是并没有与<mark>进程</mark>建立联系</p>
<p>而传输层就是将<strong>进程</strong>与所收到的<strong>数据</strong>联系到一起，让数据能够用到应用上</p>
<ul>
<li><p>因此说 网络层提供：主机之间的逻辑通信，while 传输层提供：进程和进程之间的逻辑通信</p>
</li>
<li><p>传输层还能够进行：<strong>复用和分用</strong></p>
<ul>
<li><p><mark>复用</mark>：<strong>应用层</strong>所有的的应用进程都可以通过<strong>传输层</strong>再传输到<strong>网络层</strong></p>
<p>就是把多个进程的数据使用同一个传输层协议进行传输</p>
</li>
<li><p><mark>分用</mark>：<strong>传输层</strong>从<strong>网络层</strong>收到数据后交付给指明的<strong>应用进程</strong></p>
<p>就是把接收过来的报文传送给对应的进程</p>
</li>
</ul>
</li>
<li><p>传输层对收到的报文进行<strong>差错检测</strong></p>
</li>
<li><p>传输层还有两种重要的协议：<strong>TCP &amp; UDP</strong></p>
</li>
</ul>
<h3 id="寻址与端口"><a href="#寻址与端口" class="headerlink" title="寻址与端口"></a>寻址与端口</h3><p>之前说到了复用分用，那么这两个与进程是有着一定关系的，说到进程，就要想到主机中应用进程肯定有标识符</p>
<p>这就是<strong>端口</strong>，用于标识主机中的应用进程</p>
<p>端口号按照范围分有两种：一种是<mark>服务端</mark>使用的端口号，另一种是<mark>客户端</mark>使用的端口号</p>
<ul>
<li>服务端使用的端口号<ul>
<li>熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户都知道（0~1023）</li>
<li>登记端口号：为没有熟知端口号的应用程序使用（1024~49151）</li>
</ul>
</li>
</ul>
<p>一些重要的熟知端口号：</p>
<table>
<thead>
<tr>
<th>应用进程</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
</tr>
</tbody></table>
<ul>
<li>客户端使用的端口号：仅仅在客户进程运行才动态选择的端口号，客户进程结束后就收回（49152~65535）</li>
</ul>
<p>同时我们还需要知道：在网络中采用<strong>发送方</strong>和<strong>接收方</strong>的<mark>套接字组合</mark>来识别端点，<strong>套接字</strong><mark>唯一标识了</mark>网络中一个主机和它上面的一个进程</p>
<p><code>套接字Socket = (主机IP地址, 端口号)</code></p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105173004219.png" alt="image-20210105173004219"></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>用户数据报协议UDP：<strong>不可靠，无连接，时延小，适用于小文件</strong></li>
</ul>
<h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>UDP只在IP数据报服务上增加了很少的功能：<strong>复用、分用、差错检测</strong></p>
<p>UDP的特点是：</p>
<ol>
<li><p><strong>UDP是无连接的</strong></p>
</li>
<li><p>UDP使用<strong>尽最大努力交付</strong>，就是<mark>不保证可靠交付</mark>，因此主机是不需要维持复杂的连接状态表的</p>
</li>
<li><p><strong>UDP是面向报文的</strong>，什么意思呢？</p>
<ol>
<li><p><strong>发送方</strong>UDP对于应用程序发下来的<strong>报文</strong>，仅添加<strong>首部</strong>后就向下交付给了<strong>IP层</strong></p>
</li>
<li><p>UDP对于应用层交下来的报文，既<strong>不合并，也不拆分</strong>，而是保留这些<strong>报文</strong>的<mark>边界</mark></p>
<p>which means，应用层交给UDP多长报文，UDP就照样发送，也就是一次发一个完整报文</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105175958381.png" alt="image-20210105175958381"></p>
<p>因此，应用程序必须选择合适的报文：如果太长了，UDP发送给IP层后，IP层还得进行分片，影响效率；如果太短了，UDP发送给IP层后，IP数据报的<strong>首部</strong>相对长度也会太长，也降低了IP层效率</p>
</li>
<li><p><strong>UDP没有拥塞控制</strong>，网络出现的拥塞并不会使得<strong>源主机</strong>的发送速率降低（适用于实时应用：视频会议、IP电话）</p>
</li>
<li><p>UDP支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信</p>
</li>
<li><p><strong>UDP的首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要<strong>短</strong></p>
</li>
</ol>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><p>用户UDP有2个字段：<strong>数据字段和首部字段</strong></p>
<p>首部字段由8个字节，4个字段组成（每个字段长度为2字节）</p>
<ul>
<li><strong>源端口</strong>：源端口号，在需要对方回信的时候选用，不需要的时候可设置成全0</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时使用</li>
<li><strong>长度</strong>：UDP用户数据报的长度，最小值为8</li>
<li><strong>检验和</strong>：检验UDP和用户数据报在传输的时候是否有错，有错就丢弃</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105180902193.png" alt="image-20210105180902193"></p>
<p>运输层从IP层收到UDP数据报，根据<strong>首部</strong>中目的端口，把UDP数据报通过相应端口，上交到最后终点：应用进程</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105181614867.png" alt="image-20210105181614867"></p>
<p>如果接收方UDP发现收到的报文中的<strong>目的端口号</strong>错的（没有这个端口号对应着的应用程序），就丢弃，并有ICMP发送<mark>端口不可达</mark>差错报文给发送方</p>
<p>ps：UDP通信为无连接通信，不需要使用套接字（while TCP通信就必须在两个套接字间建立连接）</p>
<h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><p>UDP校验需要用到<mark>伪首部</mark></p>
<p>叫做伪首部，就证明并不是UDP用户数据报的真正首部了，伪首部既不向下传送也不向上递交，仅仅为了计算<strong>检验和</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105182636041.png" alt="image-20210105182636041"></p>
<p>计算方法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105182927004.png" alt="image-20210105182927004"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>传输通知协议TCP：可靠，面向连接，时延大，适用于大文件</li>
</ul>
<h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><ol>
<li><p>TCP是<strong>面向连接</strong>的传输层协议：应用程序在使用TCP协议前，必须先建立TCP连接；传送数据完毕后，必须释放已经建立的TCP连接</p>
<p>像是在打电话：通话前拨号建立连接，通话结束后挂机释放连接</p>
</li>
<li><p>每一条TCP连接只能有<strong>两个端点</strong>：每一条TCP连接只能是<strong>点对点的</strong></p>
</li>
<li><p>TCP提供<strong>可靠交付</strong>的服务：通过TCP连接传送的数据 —— 无差错，不丢失，不重复且按序到达</p>
</li>
<li><p>TCP提供<strong>全双工通信：</strong>TCP允许通信双方的应用程序在任何时候都能发送数据，因此TCP连接的两端设立了<mark>发送缓存</mark>和<mark>接受缓存</mark>。</p>
<ol>
<li>发送缓存：存储准备发送的数据和已经发送但尚未收到确认的数据</li>
<li>接收缓存：存储按序到达但尚未被接受应用程序读取的数据和不按序到达的数据</li>
</ol>
</li>
<li><p>TCP面向<strong>字节流：</strong>首先要明白<mark>流</mark>是什么：是指流入到进程或从进程流出的<strong>字节序列</strong>。面向字节流的意思是：TCP把应用程序交下来的数据仅看成是<strong>一连串的无结构的字节流</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105194822707.png" alt="image-20210105194822707"></p>
</li>
</ol>
<h4 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h4><p>技术参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32998153/article/details/79680704">https://blog.csdn.net/qq_32998153/article/details/79680704</a></p>
<ul>
<li>TCP报文段分别两部分：首部 + 数据</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105200622983.png" alt="image-20210105200622983"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105201245781.png" alt="image-20210105201245781"></p>
<p><strong><em>\</em>首部固定部分各字段意义如下：**</strong></p>
<p>1） <strong><em>\</em><mark>源端口和目的端口</mark>**</strong>    各占2个字节，分别写入源端口和目的端口。</p>
<p>2） <strong><em>\</em><mark>序号seq</mark>**</strong>   占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。 序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。</p>
<p>例如，一报文段的<strong>序号是301</strong>，而接待的数据共有<strong>100字节</strong>。这就表明：本报文段的数据的<strong>第一个字节的序号是301</strong>，<strong>最后一个字节</strong>的序号是<strong>400</strong>。显然，<strong>下一个报文段</strong>（如果还有的话）的<strong>数据序号应当从401</strong>开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。</p>
<p>3） <strong><em>\</em><mark>确认号</mark>**</strong>   占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。</p>
<p>​    总之：<strong><em>\</em>若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到**</strong>。</p>
<p>4） <strong><em>\</em><mark>数据偏移</mark>**</strong>     占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。</p>
<p>5） <strong><em>\</em><mark>保留</mark>**</strong>     占6位，保留为今后使用，但目前应置为0 。</p>
<ul>
<li><h3 id="下面有6个控制位，用来说明本报文段的性质。"><a href="#下面有6个控制位，用来说明本报文段的性质。" class="headerlink" title="下面有6个控制位，用来说明本报文段的性质。"></a><strong>下面有6个控制位，用来说明本报文段的性质。</strong></h3></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105201846182.png" alt="image-20210105201846182"></p>
<p>6） <strong><em>\</em><mark>紧急URG</mark>**</strong>（URGent）    当<strong>URG=1</strong>时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于<strong>高优先级</strong>的数据），<strong>而不要按原来的排队顺序来传送</strong>（就可以<mark>插队</mark>了）。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</p>
<p>​    当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p>
<p>7） <strong><em>\</em><mark>确认值ACK</mark>**</strong>（ACKnowledgment）   仅当<strong>ACK = 1时确认号字段</strong>才<strong>有效</strong>，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
<p>ps：<strong>大写ACK是确认值</strong>，确认位的意思；<strong>小写ack是确认编号</strong>，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。</p>
<p>8） <strong><em>\</em><mark>推送 PSH</mark>**</strong>（PuSH）  当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到<strong>PSH=1</strong>的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p>
<p>9） <strong><em>\</em><mark>复位RST</mark>**</strong>（ReSeT）    当<strong>RST=1</strong>时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
<p>10） <strong><em>\</em><mark>同步SYN</mark>**</strong>（SYNchronization）    在连接建立时用来同步序号。当<strong>SYN=1而ACK=0</strong>时，表明这是一个<strong>连接请求报文段</strong>。对方若<strong>同意建立连接</strong>，则应在响应的报文段中使<strong>SYN=1和ACK=1</strong>，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
<p>11） <strong><em>\</em><mark>终止FIN</mark>**</strong>（FINis，意思是“完”“终”）     用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105202241456.png" alt="image-20210105202241456"></p>
<p>12） <strong><em>\</em><mark>窗口</mark>**</strong>       占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>   例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。”</p>
<p>   总之：<strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化</strong>。</p>
<p>13） <strong><em>\</em><mark>检验和</mark>**</strong>    占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<p>14） <strong><em>\</em><mark>紧急指针</mark>**</strong>      占2字节。<strong>紧急指针仅在URG=1</strong>时才有意义，它指出本报文段中的<strong>紧急数据的字节数</strong>（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，<strong>即使窗口为0时也可以发送紧急数据</strong>。</p>
<p>15） <strong><em>\</em><mark>选项</mark>**</strong>    长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<p>​    TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie）。注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</p>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>TCP连接传输分为三个阶段：</p>
<ol>
<li>连接建立</li>
<li>数据传送</li>
<li>连接释放</li>
</ol>
<p>TCP连接的建立采用<mark>客户服务器方式</mark>。</p>
<p>客户：主动发起连接建立的应用进程</p>
<p>服务器：被动等待连接建立的应用程序</p>
<h5 id="TCP连接过程-三次握手"><a href="#TCP连接过程-三次握手" class="headerlink" title="TCP连接过程 三次握手"></a>TCP连接过程 三次握手</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105204948685.png" alt="image-20210105204948685"></p>
<p>假设主机A运行TCP客户程序，B运行TCP服务器程序，连接过程是这样的：</p>
<ol>
<li><p>A的TCP客户进程首先创建<strong>传输控制模块TCB</strong>，此时，打算建立TCP连接的时候，向B发出<strong>连接请求报文段</strong></p>
<p>这个时候<mark>首部</mark>的<strong>同步位SYN = 1</strong>,同时选择一个<strong>初始序号seq = x</strong>。SYN报文段（即SYN = 1的报文段）不能携带数据，但会<strong>消耗一个序号</strong>。</p>
<p>这个时候，TCP客户进程进入了<mark>SYN-SENT（同步已发送）</mark>状态</p>
</li>
<li><p>B收到连接请求报文段后，如果同意建立连接，就向A发送确认。</p>
<p>在确认报文段中<strong>同步位SYN和确认值ACK = 1</strong>，然后<strong>确认编号ack = x +1</strong>，同时<strong>选择一个初始序号seq = y</strong>。此报文段也不能携带数据，但需要消耗一个序号。</p>
<p>TCP服务器进程进入<mark>SYN-RCYD（同步收到）</mark>状态</p>
</li>
<li><p>TCP客户进程收到B的确认之后，需要向B给出确认。</p>
<p><strong>确认报文段的ACK = 1，确认编号ack = y + 1,自己的序号seq = x + 1</strong></p>
<p>这个时候，TCP连接已经建立了，A进入了<mark>ESTABLISHED（已建立连接）状态</mark></p>
</li>
</ol>
<h5 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105211308051.png" alt="image-20210105211308051"></p>
<h5 id="TCP连接释放-四次挥手"><a href="#TCP连接释放-四次挥手" class="headerlink" title="TCP连接释放 四次挥手"></a>TCP连接释放 四次挥手</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105212114756.png" alt="image-20210105212114756"></p>
<p>第一段的意思是<br>FIN=1：(A)要释放连接了！<br>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的</p>
<p>第二段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）</p>
<p>第三段的意思是<br>FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）</p>
<p>第四段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据</p>
<p>为什么需要等待计时2MSL？<br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p>
<h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><ul>
<li><p>关于TCP可靠传输的很多协议放在了数据链路层的流量控制章节了</p>
</li>
<li><p>可靠：保证接收方进程从缓存区读出来的字节流与发送方发出来的字节流是完全一样的</p>
</li>
</ul>
<p>TCP实现可靠传输的机制有：校验 序号 确认 重传</p>
<h5 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h5><p>与UDP校验一样，增加一个伪首部，通过使用二进制反码计算方法判断有没有出错</p>
<h5 id="序号机制"><a href="#序号机制" class="headerlink" title="序号机制"></a>序号机制</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105220623846.png" alt="image-20210105220623846"></p>
<p>上面说了，传输层面向字节流的，因此会把文件分成字节用一个个序号标起来</p>
<p>但发出去的时候，肯定不是一个个字节发，是把多个字节放在一个形成一个报文段，再发出去</p>
<p>报文段的大小划分取决于MTU</p>
<p>其中，一个字节占一个序号。<strong>序号字段</strong>指的是一个报文段的<strong>第一个字节的序号</strong></p>
<p>有了序号就能保证数据有序提交给应用层</p>
<h5 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h5><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105221110228.png" alt="image-20210105221110228"></p>
<h5 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h5><p>重传机制是基于确认机制的，TCP的发送方在规定的时间内没有收到确认就要重传已经发送的报文段，也就是我们常说的：超时重传</p>
<p>那么对于这个重传机制来说，确定那个<mark>规定的时间</mark>就显得尤为重要了，不能太短也不能过长；</p>
<p>TCP采用<strong>自适应算法</strong>，动态改变<strong>重传时间RTTs（加权平均往返时间）</strong></p>
<p>一般来说还有<strong>冗余ACK方法</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210105222008366.png" alt="image-20210105222008366"></p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>TCP流量控制的根本目的：是控制发送方的发送速率</p>
<p>实现方法：使用基于<strong>滑动窗口协议</strong>的<mark>流量控制机制</mark></p>
<p>与数据链路层流量控制区别：</p>
<ol>
<li>传输层定义端到端用户之间流量控制，窗口大小不可动态变化</li>
<li>数据链路层定义两个中间的相邻结点的流量控制，窗口大小可动态变化</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106151936352.png" alt="image-20210106151936352"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106153111239.png" alt="image-20210106153111239"></p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>要控制拥塞，首先要明白为什么会有拥塞：</p>
<ul>
<li>出现拥塞的条件是：对资源需求的总和&gt;可用的资源</li>
</ul>
<p>具体来说就是：网络中有许多的资源同时供应不足 → 网络性能变坏 → 网络吞吐量随着输入负荷增大而下降</p>
<ul>
<li>流量控制与拥塞控制<ul>
<li><mark>相同点</mark>：都是通过控制发送方发送数据的速率来达到控制效果的</li>
<li><mark>不同点</mark><ul>
<li>拥塞控制是让网络能够承受现有的网络负荷，是一个<strong>全局性</strong>的过程，为什么说是全局性？因为涉及到了所有的主机、所有路由器、以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制则是指<strong>点对点的通信量的控制</strong>，即接收端控制发送端，所要做的是<strong>抑制发送端发送数据的速率，以便接收端来得及接受</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h5><p>背景知识储备：发送窗口={接受窗口rwnd，拥塞窗口cwnd}</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106161742663.png" alt="image-20210106161742663"></p>
<h6 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h6><ul>
<li><mark>慢开始</mark>指的是一开始的窗口很小，然后逐步在每轮传输轮次后以指数形式增大，直至达到了<strong>慢开始门限ssthresh（阈值）</strong>，然后改用<mark>拥塞避免算法</mark></li>
<li><mark>拥塞避免算法</mark>，达到阈值之后，不再用指数增加形式了，改为线性增加，然后出现一次超时（网络拥塞），就令慢开始门限等于此时的拥塞窗口的一半（乘法减小）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106164029525.png" alt="image-20210106164029525"></p>
<h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><ul>
<li><p>快重传使用了<strong>冗余ACK</strong>来检测丢包的发生</p>
<p>当发送方连续收到<strong>三个重复的ACK报文</strong>的时候，直接<strong>重传</strong>对方<strong>尚未收到</strong>的报文段，就不去等待报文段设置的<strong>重传计时器</strong>超时了</p>
</li>
<li><p>快恢复：当发送端收到<strong>三个冗余ACK（重复确认）</strong>的时候，执行<strong>乘法减小</strong>算法，慢开始门限设置为cwnd（拥塞窗口）的一半，（不同于慢开始算法的将cwnd设置为1），此时的cwnd值为慢开始门限改变后的值，后执行<strong>加法增大</strong>，使得cwnd线性增大</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106164535792.png" alt="image-20210106164535792"></p>
<h1 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><ul>
<li>应用层是对应用程序的通信提供服务</li>
</ul>
<p>在这一层的协议中应该定义以下几点：</p>
<ol>
<li>应用进程交换的<strong>报文类型</strong>，是<strong>请求</strong>还是<strong>响应</strong>？</li>
<li>各种报文类型的<strong>语法</strong>，如报文中的各个字段及其详细描述</li>
<li>字段的<strong>语义</strong>，即 包含在字段中的信息的含义</li>
<li>进程何时、如何发送报文，以及对报文进行<strong>响应的规则</strong></li>
</ol>
<p>应用层的功能有以下几点：</p>
<ul>
<li>文件传输、访问和管理</li>
<li>电子邮件</li>
<li>虚拟终端</li>
<li>查询服务和远程作业登录</li>
</ul>
<p>在这一层中重要的几个协议：</p>
<ul>
<li>FTP</li>
<li>SMTP,POP3</li>
<li>HTTP</li>
<li>DNS</li>
</ul>
<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器-C-S-模型"><a href="#客户-服务器-C-S-模型" class="headerlink" title="客户/服务器 (C/S) 模型"></a>客户/服务器 (C/S) 模型</h3><p>在这个模型中，有一个总是打开的主机<strong>服务器</strong>，它服务于许多来自其他称为<strong>客户机</strong>的主机请求，工作流程：</p>
<ol>
<li>服务器处于<strong>接受请求</strong>的状态</li>
<li><strong>客户机</strong>发出服务请求，并且等待接受结果</li>
<li><strong>服务器</strong>收到请求后，分析请求，进行必要处理，得到结果后发送给<strong>客户机</strong></li>
</ol>
<p>客户程序必须知道服务器程序的地址，然而 服务器程序并不需要知道客户程序的地址</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106183551455.png" alt="image-20210106183551455"></p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul>
<li>P2P模型中，各计算机没有固定的客户和服务器划分。任意<mark>一对计算机</mark>我们称为<mark>对等方Peer</mark></li>
<li>每个节点既能作为客户又能作为服务器</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106183913961.png" alt="image-20210106183913961"></p>
<h2 id="DNS（域名系统）"><a href="#DNS（域名系统）" class="headerlink" title="DNS（域名系统）"></a>DNS（域名系统）</h2><ul>
<li>DNS系统就是用来把特定含义的主机名（<a target="_blank" rel="noopener" href="http://www.xxx.com）转成IP地址的一个系统">www.xxx.com）转成IP地址的一个系统</a></li>
<li>DNS可分为3部分：层次域名空间、域名服务器和解析器</li>
</ul>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106192148967.png" alt="image-20210106192148967"></p>
<p>顶级域名分三大类:</p>
<ol>
<li>国家顶级域名</li>
<li>通用顶级域名</li>
<li>基础结构域名</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210106194218758.png" alt="image-20210106194218758"></p>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="ckppikufc004xp0wicn5q1pol" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-11-14T14:39:15.799Z" itemprop="datePublished">2020-11-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h1><ul>
<li><p><mark>JDK</mark></p>
<p>Java Development Kit 用作开发, 包含了JRE, 编译器和其他的工具(比如: JavaDoc，Java调试器), 可以让开发者开发、编译、执行Java应用程序.</p>
</li>
<li><p><mark>JRE</mark></p>
<p>Java 运行时环境是将要执行 Java 程序的 Java 虚拟机, （运行Java程序的用户使用的软件）可以想象成它是一个容器, JVM 是它的内容.</p>
<p>JRE = JVM + Java Packages Classes(like util, math, lang, awt,swing etc)+runtime libraries.</p>
</li>
<li><p><mark>JVM</mark></p>
<p>Java virtual machine (Java 虚拟机) 是一个可以执行 Java 编译产生的 Java class 文件 (bytecode) 的虚拟机进程, 是一个纯的运行环境.</p>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象-与-面向过程的区别"><a href="#面向对象-与-面向过程的区别" class="headerlink" title="面向对象 与 面向过程的区别"></a>面向对象 与 面向过程的区别</h2><ul>
<li><p>面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
</li>
<li><p>面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>
</li>
</ul>
<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul>
<li><p><mark>封装</mark>:一个对象他所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作,封装就是把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法</p>
</li>
<li><p><mark>继承</mark>:继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使得新类能够适应新的情况。</p>
</li>
<li><p><mark>多态</mark>:多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<p>编译时多态:方法<strong>重载</strong>实现</p>
<p>运行时多态:方法<strong>重写</strong>实现</p>
</li>
<li><p><mark>抽象</mark>:声明方法的存在而不去实现它的类被叫做抽象类</p>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>由于我们程序设计追求”高内聚，低耦合”；</p>
<p>其中<strong>高内聚</strong>指的是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用；</p>
<p>而封装，就是对数据的隐藏</p>
<p>其实在后期开发中不难发现，封装往往就是体现在定义一个pojo类，其中的属性私有，设置相应的getter/setter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些public的 get set方法</span></span><br><span class="line">    <span class="comment">//get → 获得数据</span></span><br><span class="line">    <span class="comment">//set → 给数据设置值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.提高了程序安全性，保护数据</span></span><br><span class="line"><span class="comment">    2.隐藏代码的实现细节</span></span><br><span class="line"><span class="comment">    3.统一了接口</span></span><br><span class="line"><span class="comment">    4.系统可维护性增加了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>继承的本质是对某一批类的<strong>抽象</strong>，从而实现对现实世界更好的建模</li>
<li>extends 关键字是 扩展的意思，也就是子类是父类的扩展</li>
<li>Java中类只有单继承，没有多继承，因此必须慎重考虑继承的类；比如在后期我们实现多线程可以有继承和实现接口的方法，通常使用实现接口去实现，而不选择用继承；</li>
<li>继承是<strong>类与类</strong>的一种关系，除此之外，类与类之间关系还有==依赖、组合、聚合==等</li>
<li>“is - a”关系是继承的一个明显特征</li>
<li>Java中，所有的类，都默认直接或者间接继承Object类</li>
</ul>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102143158061.png" alt="image-20201102143158061"></p>
<ul>
<li>私有的东西是无法被子类继承的</li>
</ul>
<p>super需要注意的点：</p>
<ol>
<li><p>super调用父类的构造方法，必须在构造方法的第一行</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102145313437.png" alt="image-20201102145313437"></p>
</li>
<li><p>super必须只能出现在子类的<strong>方法 或 构造方法</strong>中，意思就是 如果直接在子类中直接写个super 什么用都没 会报错</p>
</li>
<li><p>super 和 this 不能同时调用构造方法</p>
</li>
</ol>
<p>super 和 this区别：</p>
<ol>
<li>代表的对象不同<ol>
<li>this：代表本身调用者这个对象</li>
<li>super：代表父类对象的引用</li>
</ol>
</li>
<li>使用的前提不同<ol>
<li>this：就算不用继承也能使用</li>
<li>super：只能在继承条件下才能使用</li>
</ol>
</li>
<li>调用构造方法不同<ol>
<li>this：调用本类的构造方法</li>
<li>super：调用父类的构造</li>
</ol>
</li>
</ol>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>重写与重载是不同的；</p>
<p><strong>重写</strong>（Override）是<strong>父类与子类之间的多态性</strong>，实质是对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，<strong>不过子类函数的访问修饰权限不能小于父类的</strong>；若子类中的方法与父类中的某一方法具有<strong>相同的方法名、返回类型和参数表</strong>，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用==<strong>super</strong>==关键字。</p>
<p><strong>重载</strong>（Overload）是让类以<strong>统一的方式</strong>处理<strong>不同类型数据</strong>的一种手段，实质表现就是多个<strong>具有不同的参数个数或者类型</strong>的<code>同名函数</code>（返回值类型可随意，<strong>不能以返回类型作为重载函数的区分标准</strong>）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时<code>通过传递不同参数个数和参数类型</code>来决定具体使用哪个方法的多态性）。</p>
<p>重写需要满足的条件</p>
<ol>
<li><p>需要是继承的关系，没有继承根本没有重写一说</p>
</li>
<li><p>方法名字必须<strong>相同</strong></p>
</li>
<li><p>参数列表必须<strong>相同</strong></p>
</li>
<li><p>子类返回值必须 <strong>小于等于</strong> 父类方法返回值</p>
</li>
<li><p>子类的权限修饰符必须 <strong>大宇等于</strong> 父类方法的权限修饰符</p>
<p>其中:<strong>public &gt; protected &gt; default(也就是什么都不写) &gt; private</strong></p>
</li>
<li><p>抛出的异常 只能被缩小，不能被扩大</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>多态：即同一方法可以根据发送对象的不同而采用多种<strong>不同的</strong>行为方式</p>
</li>
<li><p>一个对象的实际类型其实是确定的，但是<strong>指向对象的引用类型</strong>有很多（仔仔细细理解这句话的意思）</p>
<p>其实这句话是什么意思呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//这个叫对象的实际类型，根据new xxx来的 new出来是什么就其实确定了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a</span><br><span class="line">B a</span><br><span class="line"><span class="comment">//这个叫指向对象的引用类型 它就不是一定的了 可以实现父类的引用 指向 子类的类型</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>关于多态 经常听到这么一句话:</p>
<p>==成员变量、静态方法==：编译和运行看<strong>左边</strong>；==非静态方法==：编译看<strong>左边</strong>、运行看<strong>右边</strong>；</p>
<p>那到底是什么意思呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行B的非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行B的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A的非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意 这里没有用@Override 因为根本就不是重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行A的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.sTest();</span><br><span class="line">        a.test();</span><br><span class="line">        System.out.println(a.n);</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.sTest();</span><br><span class="line">        b.test();</span><br><span class="line">        System.out.println(b.n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102153230843.png" alt="image-20201102153230843"></p>
<p>不难发现：如果是==static==修饰的方法以及成员对象，我们看对象左边的类型就好，和右边没什么关系；</p>
<p>而不用==static==修饰的方法，我们就看右边的类型就行，和左边没什么关系</p>
<p>我们学习<strong>不能知其然而不知其所以然</strong>，我们来探究下为什么会这样呢？</p>
<p><code>B b = new A();</code>这行代码到底代表着什么呢?</p>
<ul>
<li><p>B b;这里声明了一个变量b 是属于B这个类的</p>
</li>
<li><p>= new A(); 建立了一个A的对象，赋值给了b 那这又代表什么呢？</p>
<p>我们现在获得了一个被A类函数<strong>覆盖后的B类对象b</strong></p>
</li>
</ul>
<p>那么问题转移了，我们只需要明白类所拥有的函数和变量到底是怎么加载的就好，就能明白为什么运行出来是这个结果了。</p>
<p>由于我们只是被覆盖了方法（非静态），成员变量还是那个成员变量，因此输出出来是各自的成员变量</p>
<p>那么静态方法呢？为什么还是各自的，没有被覆盖掉呢？</p>
<p>因为==static==修饰的函数，跟随B类的加载而加载，也就是B类的函数先于对象建立之前就存在，无法再被覆盖了。</p>
<p>还有哪些关键词修饰的方法是不能被覆盖的呢？</p>
<ol>
<li>static</li>
<li>final</li>
<li>private</li>
</ol>
<h4 id="instanceof-和-类型转换"><a href="#instanceof-和-类型转换" class="headerlink" title="instanceof 和 类型转换"></a>instanceof 和 类型转换</h4><ul>
<li><strong>instanceof是一个二元运算符 类似于 == &gt; &lt;等操作符，也是Java的一个关键字</strong></li>
<li>其作用是测试它左边的<strong>对象</strong>是否是其右边的<strong>类的实例</strong>，然后返回boolean的数据类型（true of false）</li>
</ul>
<ol>
<li><p>==obj必须为引用类型，不能是基本类型==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为null==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>关于 null 类型的描述在官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1</a> 有一些介绍。</p>
<p>一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte short int long float double char boolean,一种是引用类型，包括类，接口，数组等等。</p>
<p>而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。</p>
<p>我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的<strong>特殊符号</strong>。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2">JavaSE规范</a> 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</p>
</li>
<li><p>==obj 为 class 类的实例对象==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为class接口的实现类==</p>
<p>了解Java 集合的，我们知道集合中有个上层接口 List，其有个典型实现类 ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>或者反过来也是返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==obj为class的直接或间接子类==</p>
<p>我们新建一个父类 Person.class，然后在创建它的一个子类 Man.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　Man.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Man m1 = <span class="keyword">new</span> Man();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);<span class="comment">//false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>　　注意第一种情况， <strong>p1 instanceof Man</strong> ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。</p>
</li>
<li><p>==问题==</p>
<p>前面我们说过<strong>编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</strong></p>
<p>看如下几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> String);<span class="comment">//编译报错</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List);<span class="comment">//false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;?&gt;);<span class="comment">//false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;Person&gt;);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<p>按照我们上面的说法，这里就存在问题了，Person 的对象 p1 很明显不能转换为 String 对象，那么自然 Person 的对象 p1 instanceof String 不能通过编译，但为什么 p1 instanceof List 却能通过编译呢？而 instanceof List<Person> 又不能通过编译了？</Person></p>
<p>根据 java SE 8：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/1120165-20180302000448613-26394231.png" alt="img"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">  result = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      T temp = (T) obj; <span class="comment">// checkcast</span></span><br><span class="line">      result = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">      result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说有表达式 obj instanceof T，instanceof 运算符的 obj 操作数的类型必须是引用类型或空类型; 否则，会发生编译时错误。 </p>
<p>如果 obj 强制转换为 T 时发生编译错误，则关系表达式的 instanceof 同样会产生编译时错误。 在这种情况下，表达式实例的结果永远为false。</p>
<p>在运行时，如果 T 的值不为null，并且 obj 可以转换为 T 而不引发ClassCastException，则instanceof运算符的结果为true。 否则结果是错误的</p>
<p>简单来说就是：<strong>如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。</strong></p>
<p>所以对于上面提出的问题就很好理解了，为什么 p1 instanceof String 编译报错，因为(String)p1 是不能通过编译的，而 (List)p1 可以通过编译。</p>
</li>
</ol>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul>
<li><strong>abstract修饰符</strong>可以用来修饰方法，也可以修饰类，如果修饰方法。</li>
</ul>
<h2 id="七种设计原则"><a href="#七种设计原则" class="headerlink" title="七种设计原则"></a>七种设计原则</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031214714163.png" alt="image-20201031214714163"></p>
<p><strong>面向对象七大设计原则：</strong></p>
<p>1、 ==开闭原则（OCP：Open Closed Principle）==</p>
<p><strong>核心：对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</strong></p>
<ul>
<li>根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</li>
</ul>
<p>2、 ==里氏替换原则（LSP：Liskov Substitution Principle）==</p>
<p><strong>核心：在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）</strong></p>
<ul>
<li>1.子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</li>
<li>2.子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性</li>
<li>3.覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li>
<li>4.覆盖或实现父类的方法时输出结果可以被缩小。</li>
</ul>
<p>3、 ==单一职责原则（SRP：Single responsibility principle）==</p>
<p><strong>核心：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=解耦&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">解耦</a>和增强内聚性（高内聚，低耦合）</strong></p>
<ul>
<li>类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。</li>
</ul>
<p>4、==接口隔离原则(ISP：Interface Segregation Principle)==</p>
<p><strong>核心思想：不应该强迫客户程序依赖他们不需要使用的方法。接口分离原则的意思就是：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.</strong></p>
<ul>
<li>分离接口的两种实现方法：</li>
<li>1.使用委托分离接口。（Separation through Delegation）</li>
<li>2.使用多重继承分离接口。（Separation through Multiple Inheritance）</li>
</ul>
<p>5、==依赖倒置原则(DIP：Dependence Inversion Principle)==</p>
<p><strong>核心：要依赖于抽象，不要依赖于具体的实现</strong></p>
<ul>
<li>1.高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）</li>
<li>2.抽象不应该依赖细节（具体实现）</li>
<li>3.细节（具体实现）应该依赖抽象。<br><strong>三种实现方式:</strong></li>
<li>1.通过构造函数传递依赖对象</li>
<li>2.通过setter方法传递依赖对象</li>
<li>3.接口声明实现依赖对象</li>
</ul>
<p>6、 ==迪米特原则(最少知识原则)（LOD：Law of Demeter）==</p>
<p><strong>核心思想：一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=成都&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成都</a>降到最低，促进软件的复用</strong><br>注：</p>
<ul>
<li>1.在类的划分上，应该创建有弱耦合的类；</li>
<li>2.在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</li>
<li>3.在类的设计上，只要有可能，一个类应当设计成不变；</li>
<li>4.在对其他类的引用上，一个对象对其它对象的引用应当降到最低；</li>
<li>5.尽量降低类的访问权限；</li>
<li>6.谨慎使用序列化功能；</li>
<li>7.不要暴露类成员，而应该提供相应的访问器(属性)</li>
</ul>
<p>7、 ==组合/聚合复用原则（CRP：Composite Reuse Principle）==</p>
<p><strong>核心思想：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</strong></p>
<p>复用的种类：</p>
<ul>
<li>1.继承</li>
<li>2.合成聚合</li>
</ul>
<p><strong>注：在复用时应优先考虑使用合成聚合而不是继承</strong></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="四大数据类型"><a href="#四大数据类型" class="headerlink" title="四大数据类型"></a>四大数据类型</h2><ul>
<li><p>Java是一种强类型的语言，意味着必须给每一个变量声名一种类型</p>
</li>
<li><p>Java中一共有着八种<mark>基本类型</mark></p>
<p>包含着 4种整型（<mark>int short long byte</mark>）</p>
<p>两种浮点型（<mark>float double</mark>）</p>
<p>一种字符类型（<mark>char</mark>）</p>
<p>一种表示真值的<mark>boolean</mark>类型</p>
</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>byte(位)</td>
<td>8</td>
<td>Byte</td>
<td>0</td>
<td>-128~127</td>
<td>1字节</td>
</tr>
<tr>
<td>2</td>
<td>short(短整数)</td>
<td>16</td>
<td>Short</td>
<td>0</td>
<td>-32768~32767</td>
<td>2字节</td>
</tr>
<tr>
<td>3</td>
<td>int(整数)</td>
<td>32</td>
<td>Integer</td>
<td>0</td>
<td>-2147483648~2147483647</td>
<td>4字节</td>
</tr>
<tr>
<td>4</td>
<td>long(长整数)</td>
<td>64</td>
<td>Long</td>
<td>0</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>8字节</td>
</tr>
</tbody></table>
<ol>
<li><p><mark><strong>int与Integer的区别</strong></mark></p>
<p>Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象</p>
</li>
<li><p><mark><strong>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</strong></mark></p>
<p>对于<strong>short s1 = 1; s1 = s1 + 1;</strong>由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。</p>
<p>而<strong>short s1 = 1; s1 += 1;</strong>可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
</li>
<li></li>
</ol>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>float(单精度)</td>
<td>32</td>
<td>Float</td>
<td>0.0</td>
<td>1.4E-45~3.4028235E38</td>
<td>4字节</td>
</tr>
<tr>
<td>6</td>
<td>double(双精度)</td>
<td>64</td>
<td>Double</td>
<td>0.0</td>
<td>4.9E-324~1.7976931348623157E308</td>
<td>8字节</td>
</tr>
</tbody></table>
<ul>
<li><p>double表示这种类型的数值精度是float类型的两倍</p>
</li>
<li><p>float类型的数值有一个后缀（F或者f）没有后缀F的浮点数值（3.14）总是默认为double类型</p>
</li>
<li><p>浮点数值后面也可以加后缀（D或者d）</p>
</li>
<li><p>double 精度 大于 float 因此下用上必须强转（float f = (float) 1.23d）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027170918891.png" alt="image-20201027170918891"></p>
</li>
</ul>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>char(字符)</td>
<td>16</td>
<td>Character</td>
<td>空</td>
<td>0~65535</td>
<td>2字节</td>
</tr>
</tbody></table>
<h3 id="boolean型"><a href="#boolean型" class="headerlink" title="boolean型"></a>boolean型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>数据类型</th>
<th>大小/位</th>
<th>封装类</th>
<th>默认值</th>
<th>可表示数据范围</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>boolean</td>
<td>8</td>
<td>Boolean</td>
<td>flase</td>
<td>true或false</td>
<td>1字节</td>
</tr>
</tbody></table>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031222727192.png" alt="image-20201031222727192"></p>
<p>上图中，有6个实线箭头代表着无信息丢失的转换；另外有3个虚线箭头，代表着可能会有精度的丢失；</p>
<p>比如 123456789 是个大整数，它包含的位数比float类型所能够表达的位数要多；</p>
<p>那么我们看看 如果用float 输出 这个整数会是什么情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101150109332.png" alt="image-20201101150109332"></p>
<p>我们可以看到，虽然大小差不多，但是还是损失了一点精度；</p>
<p>当用二元运算符连接2个值的时候，要把两个操作数转为一个类型，然后在进行运算，否则：</p>
<ul>
<li><p>如果两个操作数中有一个是<strong>double</strong>类型，另一个操作数将被转换为<strong>double</strong>类型。</p>
</li>
<li><p>否则，如果其中一个操作数为<strong>float</strong>类型，另一个操作数将被转换为<strong>float</strong>类型。</p>
</li>
<li><p>否则，如果其中一个操作数为<strong>long</strong>类型，另一个操作数将被转换为<strong>long</strong>类型。</p>
</li>
<li><p>否则，两个操作数都将会被转换为<strong>int</strong>类型。</p>
</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li>检查性异常：用户错误或是问题引起的异常，是程序员无法预见的</li>
<li>运行时异常：是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略掉； </li>
<li>错误ERROR：错误不是异常，而是脱离程序员控制的问题；比如栈溢出</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><ul>
<li>Java把异常当作对象来处理，并定义了一个基类 java.lang.Throwable 作为所有异常的超类</li>
<li>Java API中定义许多异常类，其中分为两大类：<strong>Error和Exception</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105211819347.png" alt="image-20201105211819347"></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul>
<li><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</p>
</li>
<li><p>Java虚拟机运行错误（Virtual MachineError），当JVM不再由继续执行操作所需的内存资源的时候，将会出现<strong>OutOfMemoryError</strong>；这些异常发生的时候，JVM一般会选择线程终止</p>
</li>
<li><p>还有的错误发生在虚拟机试图去执行应用的时候（比如类定义错误：NoClassDefFoundError），链接错误（LinkageError）</p>
<p>这些错误不可排查，因为他们在应用程序的控制和处理能力之外</p>
</li>
</ul>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>Exception分支有一个重要子类RuntimeException（运行时异常）需要我们去掌握：</p>
<ul>
<li><pre><code class="java">ArrayIndexOutOfBoundsException <span class="comment">//数组下标越界</span>
&lt;!--code￼<span class="number">17</span>--&gt;</code></pre>
</li>
<li><pre><code class="java">ArithmeticException <span class="comment">//算术异常 比如0作为除数</span>
&lt;!--code￼<span class="number">18</span>--&gt;</code></pre>
</li>
<li><pre><code class="java">ClassNotFoundException <span class="comment">//找不到类</span>
&lt;!--code￼<span class="number">19</span>--&gt;
</code></pre>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105214703569.png" alt="image-20201105214703569"></p>
<p>其实可以理解成：catch就是平常公园里那种抓金鱼的网，try中的部分就是我们的金鱼,只有你的网的大小合适，才能抓到金鱼；finally就是我们玩抓金鱼要交的门票钱，无论抓不抓得到都得给，只不过是最后给 不是一开始给而已；</p>
<p>那我们难道只能 让程序跑的时候 抓异常，不能主动去抛出异常吗？</p>
<p>不是的，接下来还有介绍关键字<strong>throw throws</strong></p>
<p>throw ≠ throws</p>
<ul>
<li>throw<ul>
<li>作用在<strong>方法内</strong>，表示抛出具体异常，由方法体内的语句处理。</li>
<li>具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了Throw一定是抛出了某种异常。</li>
</ul>
</li>
<li>throws<ul>
<li>作用在<strong>方法上</strong>，表示如果抛出异常，则由该方法的调用者来进行异常处理。</li>
<li>主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。</li>
<li>出现异常是一种可能性，但不一定会发生异常。</li>
</ul>
</li>
</ul>
<p>例子:</p>
<p>throws E1,E2,E3只是告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常E1，E2，E3可能是该函数体产生的。 throw则是明确了这个地方要抛出这个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception1,Exception3</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">                 ......</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a!=b)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span>  Exception3(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。</p>
<p>如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理。如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！”);）。所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了</p>
<p>而Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。  </p>
<p>  throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。    throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。</p>
<p>throw是具体向外抛异常的动作，所以它是抛出一个异常实例。    throws说明你有那个可能，倾向。throw的话，那就是你把那个倾向变成真实的了。</p>
<ol>
<li>throws出现在方法函数头；而throw出现在函数体。</li>
<li>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。</li>
<li>两者都是消极处理异常的方式，只是抛出/可能抛出异常，而不会去处理异常，真正的处理异常由函数的上层调用处理</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在程序中使用自定义异常，大体可以分成下面几步：</p>
<ol>
<li>创建自定义异常类</li>
<li>在方法中通过throw关键字抛出异常对象</li>
<li>如果在当前抛出异常的方法中处理异常，可以用<strong>try-catch语句</strong>进行捕获处理；否则在方法的声明处通过<strong>throws</strong>关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>在出现一场方法的调用者中捕获并且处理异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递数字 如果数字大于0 抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//toString 方法 打印信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;detail=&quot;</span> + detail +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;传递进来的参数为:&quot;</span> + a);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);<span class="comment">//这里选择了抛出 而不是捕获</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyException:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105222844568.png" alt="image-20201105222844568"></p>
<h1 id="注解和反射"><a href="#注解和反射" class="headerlink" title="注解和反射"></a>注解和反射</h1><h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><p>关于注解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/9723699.html">https://www.cnblogs.com/fnlingnzb-learner/p/9723699.html</a></p>
<p>这篇文章起始也描述的也很好，把注解形容成了标签，我觉得非常生动形象</p>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li>Annotation的作用<ul>
<li>不是车舱内光绪本身，可以对程序做出解释</li>
<li>可以被其他程序（如编译器等）读取</li>
</ul>
</li>
<li>Annotation的格式<ul>
<li>注解是以==@注释名==在代码中存在的，还可以添加一些参数值，如 @SuppressWarnings(value=”unchecked”)</li>
</ul>
</li>
<li>Annotation在哪里使用<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息</li>
<li>我们可以通过反射机制编程实现对这些元数据的访问呢</li>
</ul>
</li>
</ul>
<h3 id="内置注解（基本注解）"><a href="#内置注解（基本注解）" class="headerlink" title="内置注解（基本注解）"></a>内置注解（基本注解）</h3><ul>
<li>@Override：定义在<strong>java.lang.Override</strong>中，此注解只适用于修饰方法，表示一个方法生命打算重写超类中的另一个方法声明</li>
<li>@Deprecatd：定义在<strong>java.lang.Deprecatd</strong>中，此注释可以用于修饰方法，属性，类，表示不鼓励程序员使用这样的元素（废弃了）</li>
<li>@SuppressWarning：定义在<strong>java.lang.SuppressWarnings</strong>中，用来抑制编译时的警告信息<ul>
<li>这个注解需要添加一个参数才能使用：<ul>
<li>@SuppressWarning(“all”);</li>
<li>@SuppressWarning(“unchecked”)</li>
<li>@SuppressWarning(“value={“unchecked”, “deprecation”})</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>元注解的作用就是负责注解其他的注解，Java定义了四个标准的<strong>meta-annotation类型</strong>，他们被用来提供对其他Annotation类型的作说明</p>
</li>
<li><p>这些类型和他们所支持的类在<strong>java.lang.annotation</strong>包中</p>
</li>
<li><p>四个标准的meta-annotation类型分别是</p>
<ul>
<li><p>@Target：用于描述注解的使用范围 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105150937346.png" alt="image-20201105150937346"></p>
<ul>
<li>@Target(ElementType.TYPE)  //接口、类、枚举</li>
</ul>
</li>
<li><p>@Target(ElementType.FIELD) //字段、枚举的常量</p>
<ul>
<li>@Target(ElementType.METHOD) //方法</li>
</ul>
</li>
<li><p>@Target(ElementType.PARAMETER) //方法参数</p>
<ul>
<li>@Target(ElementType.CONSTRUCTOR) //构造函数</li>
</ul>
</li>
<li><p>@Target(ElementType.LOCAL_VARIABLE)//局部变量</p>
<ul>
<li>@Target(ElementType.ANNOTATION_TYPE)//注解</li>
</ul>
</li>
<li><p>@Target(ElementType.PACKAGE) ///包 </p>
</li>
</ul>
</li>
<li><p>@Retention：表示需要在什么级别（<strong>SOURCE &lt; CLASS &lt; RUNTIME</strong>）保存该注解信息，用于描述注解的生命周期</p>
<p>话句话说 就是我们的注解在什么地方还有效</p>
<p>运行级别 是RUNTIME PentationPolicy 包含三个值:SOURCE CLASS RUNTIME</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151251990.png" alt="image-20201105151251990"></p>
<ul>
<li>@Retention(RetentionPolicy.SOURCE)  //注解仅存在于源码中，在class字节码文件中不包含</li>
<li>@Retention(RetentionPolicy.CLASS)   // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li>
<li>@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到</li>
</ul>
<ul>
<li>@Document：表示是否将我们的注解生成在javadoc（java文档）中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151452888.png" alt="image-20201105151452888"></p>
<ul>
<li><p>@Inherited：说明子类可以<strong>继承</strong>父类中的该注解</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105151542928.png" alt="image-20201105151542928"></p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul>
<li>使用了@interface自定义注解的时候，自动继承了<strong>java.lang.annotation.Annotation接口</strong></li>
<li>如何实现的呢？<ul>
<li>@interface用来声明一个注解，格式：@interface 注解名{内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称其实就是参数的名称</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型。或是类：Class，String，enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素的时候，经常使用空字符串，0作为默认值</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105153014063.png" alt="image-20201105153014063"></p>
<h2 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h2><h3 id="静态语言-动态语言"><a href="#静态语言-动态语言" class="headerlink" title="静态语言 动态语言"></a>静态语言 动态语言</h3><ul>
<li>静态语言：运行时结构不可变的语言就是静态语言<ul>
<li>JAVA,C,C++</li>
</ul>
</li>
<li>动态语言：是一类可以在运行的时候改变其结构的语言：例如新的函数、对象、甚至代码都可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时，代码可以根据某些条件改变自身的结构<ul>
<li>Object - C，C#，JavaScript，PHP，Python</li>
</ul>
</li>
<li>Java并不是动态语言，但Java可以被称为是准动态语言，即Java有一定的动态性，我们可以利用反射机制获取类似动态语言的特性；</li>
</ul>
<h3 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h3><ul>
<li><p><strong>反射</strong>是Java被视为动态语言的关键，反射机制允许程序在执行期借助于==Reflection API==取得任何类的内部信息，并能直接操作任意对象的内部属性和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载完类了之后，在<strong>堆内存</strong>的<strong>方法区</strong>中就产生了一个==Class==类型的对象（一个类只有一个Class对象）这个对象就包含了完整的类的结构信息；</p>
<p>我们可以通过这个对象看到类的结构；通过对象 → 看到类的结构，像在照镜子，因此叫==反射==</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161526292.png" alt="image-20201105161526292"></p>
</li>
</ul>
<h4 id="反射机制的功能"><a href="#反射机制的功能" class="headerlink" title="反射机制的功能"></a>反射机制的功能</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105161638781.png" alt="image-20201105161638781"></p>
<h4 id="Java反射优缺点"><a href="#Java反射优缺点" class="headerlink" title="Java反射优缺点"></a>Java反射优缺点</h4><ul>
<li>优点：可以实现动态创建对象和编译，体现出很大的灵活性</li>
<li>缺点：对性能有一定的影响；因为我们使用反射式一种解释操作，我们可以告诉JVM，我们希望做什么，并且它满足我们的要求，这类操作总是慢于直接执行相同的操作 （一般来说用new创建对象 但是反射用forName）</li>
</ul>
<h3 id="获取反射对象"><a href="#获取反射对象" class="headerlink" title="获取反射对象"></a>获取反射对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Reflction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line">        Class c4 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个类在内存中只能有一个Class对象</span></span><br><span class="line">        <span class="comment">//类被加载后，类的整个结构会被封装在Class对象之中</span></span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pojo类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105162758160.png" alt="image-20201105162758160"></p>
<p>发现我们的hash值是一样的，代表着 一个类在内存中只会有一个Class对象；</p>
<p>此外，一个类被加载之后呢，类的整个的结构都会被封装在Class对象之中</p>
<h3 id="理解Class类并获取Class实类"><a href="#理解Class类并获取Class实类" class="headerlink" title="理解Class类并获取Class实类"></a>理解Class类并获取Class实类</h3><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>在Object类中有以下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>此方法被所有的子类继承，这个方法的返回值类型为一个Class类，而这个Class类就是Java反射的源头了；</p>
<p>换句话说，我们通过对象反射出类的名称（比如张三是个人，张三是对象，人是个类，我们通过张三就能反射出 他是个人）</p>
<p>试想一下，假如张三（对象）早上起床，去照镜子，他能看见什么呢？</p>
<ul>
<li>张三的样貌（属性）</li>
<li>张三在打哈欠（方法）</li>
<li>……</li>
</ul>
<p>反射就是如此，对象通过反射能得 某个类的属性、方法、构造器、某个类实现了哪些接口；</p>
<p>而对于每个类而言，JRE为其<strong>保留一个不变的Class类型的对象</strong>。就像是你的档案一样，包含各种信息；</p>
<p>形象点说就是，小孩子（对象）在外面走丢啦，想知道自己的父母是谁、家里在哪等等信息，可以去找公安局（Class类），让他们帮你查询信息</p>
<h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><p> 常用方法列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> getName()：返回String形式的该类的名称。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> newInstance()：根据某个Class对象产生其对应类的实例，它调用的是此类的默认构造方法(没有默认无参构造器会报错)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> getClassLoader()：返回该Class对象对应的类的类加载器。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> getSuperClass()：返回某子类所对应的直接父类所对应的Class对象</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> isArray()：判定此Class对象所对应的是否是一个数组对象</span><br><span class="line">　　</span><br><span class="line"><span class="number">6</span> getComponentType() ：如果当前类表示一个数组，则返回表示该数组组件的 Class 对象，否则返回 <span class="keyword">null</span>。</span><br><span class="line">　　</span><br><span class="line"><span class="number">7</span> getConstructor(Class[]) :返回当前 Class 对象表示的类的指定的公有构造子对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">8</span> getConstructors() :返回当前 Class 对象表示的类的所有公有构造子对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">9</span> getDeclaredConstructor(Class[]) :返回当前 Class 对象表示的类的指定已说明的一个构造子对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">10</span> getDeclaredConstructors() :返回当前 Class 对象表示的类的所有已说明的构造子对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">11</span> getDeclaredField(String) :返回当前 Class 对象表示的类或接口的指定已说明的一个域对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">12</span> getDeclaredFields() :返回当前 Class 对象表示的类或接口的所有已说明的域对象数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">13</span> getDeclaredMethod(String, Class[]) :返回当前 Class 对象表示的类或接口的指定已说明的一个方法对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">14</span> getDeclaredMethods() :返回 Class 对象表示的类或接口的所有已说明的方法数组。</span><br><span class="line">　　</span><br><span class="line"><span class="number">15</span> getField(String) :返回当前 Class 对象表示的类或接口的指定的公有成员域对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">16</span> getFields() :返回当前 Class 对象表示的类或接口的所有可访问的公有域对象数组。</span><br><span class="line"></span><br><span class="line"><span class="number">17</span> getInterfaces() :返回当前对象表示的类或接口实现的接口。</span><br><span class="line">　　</span><br><span class="line"><span class="number">18</span> getMethod(String, Class[]) :返回当前 Class 对象表示的类或接口的指定的公有成员方法对象。</span><br><span class="line">　　</span><br><span class="line"><span class="number">19</span> getMethods() :返回当前 Class 对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</span><br><span class="line">　　</span><br><span class="line"><span class="number">20</span> isInstance(Object) :此方法是 Java 语言 <span class="keyword">instanceof</span> 操作的动态等价方法。</span><br><span class="line">　　</span><br><span class="line"><span class="number">21</span> isInterface() :判定指定的 Class 对象是否表示一个接口类型</span><br><span class="line">　　</span><br><span class="line"><span class="number">22</span> isPrimitive() :判定指定的 Class 对象是否表示一个 Java 的基类型。</span><br><span class="line">　　</span><br><span class="line"><span class="number">23</span> newInstance() ：创建类的新实例</span><br></pre></td></tr></table></figure>

<h4 id="获取Class类实例"><a href="#获取Class类实例" class="headerlink" title="获取Class类实例"></a>获取Class类实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Reflction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方法1:已知具体的类（User），通过class属性获取</span></span><br><span class="line">        <span class="comment">//该方法最安全可靠，程序性能最高</span></span><br><span class="line">        Class c1 = User.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法2:已知某个类的实例（已经创建该类的对象了）</span></span><br><span class="line">        <span class="comment">//调用实例的getClass()方法获取Class对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c2 = user.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法3:已知一个类的类名了，且知道路径（包）,可通过Class的静态方法forName()获取</span></span><br><span class="line">        <span class="comment">//有可能找不到这个类，需要抛出ClassNotFoundException</span></span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.hpg.Reflction.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pojo类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105165540835.png" alt="image-20201105165540835"></p>
<p>获取类的方法:</p>
<ol>
<li><p>已知具体的类，通过class属性获取</p>
<p>该方法最安全可靠，程序性能最高</p>
</li>
<li><p>已知某个类的实例（已经创建该类的对象了）</p>
<p>调用实例的getClass()方法获取Class对象</p>
</li>
<li><p>已知一个类的类名了，且知道路径（包）,可通过Class的静态方法forName()获取</p>
<p>有可能找不到这个类，需要抛出<strong>ClassNotFoundException</strong></p>
</li>
<li><p>内置的<strong>基本数据类型</strong>可以直接使用类名.Type</p>
</li>
<li><p>还可以使用ClassLoader</p>
</li>
</ol>
<p>验证Class对象：</p>
<p>目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201118205003686.png" alt="image-20201118205003686"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(p == p2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(c == c2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        Class c3 = Person.class;</span><br><span class="line">        <span class="comment">// int.class;</span></span><br><span class="line">        <span class="comment">// String.class;</span></span><br><span class="line">        System.out.println(c == c3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式3</span></span><br><span class="line">        <span class="comment">// ClassNotFoundException</span></span><br><span class="line">        Class c4 = Class.forName(<span class="string">&quot;com.hpg.Test.Person&quot;</span>);<span class="comment">//true</span></span><br><span class="line">        System.out.println(c == c4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="keyword">false</span><span class="comment">//因为对象不同</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c2同属一个类</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c3同属一个类</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//c与c4同属一个类</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>带参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;---&quot;</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, address=&quot;</span> + address</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">&quot;com.hpg.Test.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取带参构造方法对象</span></span><br><span class="line">        <span class="comment">// public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor con = c.getConstructor(String.class, <span class="keyword">int</span>.class,	String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过带参构造方法对象创建对象</span></span><br><span class="line">        <span class="comment">// public T newInstance(Object... initargs)</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">&quot;hpg&quot;</span>, <span class="number">19</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person [name=hpg, age=19, address=深圳]</span></span><br></pre></td></tr></table></figure>

<h4 id="getDeclared、getField与setAccessible-flag"><a href="#getDeclared、getField与setAccessible-flag" class="headerlink" title="getDeclared、getField与setAccessible(flag)"></a>getDeclared、getField与setAccessible(flag)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student p = <span class="keyword">new</span> Student();</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Class c =Class.forName(&quot;com.hpg.Test.Person&quot;);</span></span><br><span class="line"></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">            <span class="comment">/*public java.lang.String com.hpg.Test.Student.name</span></span><br><span class="line"><span class="comment">              int com.hpg.Test.Student.id</span></span><br><span class="line"><span class="comment">              private int com.hpg.Test.Student.age*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;null&#x27;, id=0, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String name; 由于是public修饰的 因此直接用getField可以取得到</span></span><br><span class="line">        Field nameField =c.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//nameField.setAccessible(true); public 根本用不着去设true</span></span><br><span class="line">        nameField.set(p,<span class="string">&quot;hpg&quot;</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=0, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int id; 前面没有修饰 getField是取不到的 必须用getDeclaredField</span></span><br><span class="line">        <span class="comment">//Field addressField = c.getField(&quot;id&quot;);</span></span><br><span class="line">        Field idField = c.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// addressField.setAccessible(true); 前面没修饰 默认是public 因此其实也不用多此一举设置true</span></span><br><span class="line">        idField.set(p,<span class="number">100</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=100, age=0&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//private int age; 是私有的 必须用getDeclaredField取</span></span><br><span class="line">        Field ageField = c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);<span class="comment">//必须要设置这一步，因为是private</span></span><br><span class="line">        ageField.set(p,<span class="number">19</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Student&#123;name=&#x27;hpg&#x27;, id=100, age=19&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String com.hpg.Test.Student.name</span><br><span class="line"><span class="keyword">int</span> com.hpg.Test.Student.id</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> com.hpg.Test.Student.age</span><br><span class="line">Student&#123;name=<span class="string">&#x27;null&#x27;</span>, id=<span class="number">0</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">0</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">100</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;hpg&#x27;</span>, id=<span class="number">100</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码我们可以发现：</p>
<p>假如属性是私有的，想要用class类去获取 该属性必须用：<code>getDeclaredFields</code> 这个方法可以获取类的全部字段 </p>
<p>然而<code>getFields</code> 方法只能获取public字段</p>
<p>同时，想要通过反射去设置属性的话：如果是私有变量需要先<code>xxx.setAccessible(true);</code>否则将没有权限</p>
<p>关于setAccessible原理：</p>
<p>应该是取消了Java的语言访问检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InaccessibleObjectException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">    AccessibleObject.checkPermission();</span><br><span class="line">    <span class="keyword">if</span> (flag) checkCanSetAccessible(Reflection.getCallerClass());</span><br><span class="line">    setAccessible0(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但我觉得这会不会在某种程度上破坏了对象的封装性呢？总感觉不太好</p>
<h4 id="哪些类可以有Class对象"><a href="#哪些类可以有Class对象" class="headerlink" title="哪些类可以有Class对象"></a>哪些类可以有Class对象</h4><ul>
<li>class : 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface 接口</li>
<li>数组</li>
<li>enum 枚举</li>
<li>annotation 注解</li>
<li>primitive type 基本数据类型</li>
<li>void</li>
</ul>
<h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201105203849181.png" alt="image-20201105203849181"></p>
<h4 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h4><ul>
<li>加载：将class文件字节码内容加载到内存中，并且将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程，分为三步：<strong>验证，准备，解析</strong><ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址的过程）</li>
</ul>
</li>
<li>初始化：<ul>
<li>构造类构造器<strong><clinit>()方法</clinit></strong>（这是jvm去做的）的过程，类构造器<strong><clinit>()方法</clinit></strong>是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的<ul>
<li>ps：类构造器是构造<strong>类信息</strong>的，不是构造该类对象的构造器</li>
</ul>
</li>
<li>当初始化一个类的时候，如果该类的父类还没有进行初始化，先初始化其父类</li>
<li><strong>虚拟机</strong>会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</clinit></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(a.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类无参构造初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201108163232784.png" alt="image-20201108163232784"></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。</p>
</li>
<li><h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
</li>
<li><h4 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h4><p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，</p>
<p>由于线程类本身就是调用的Runnable接口所以你可以继承 java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。</p>
</li>
<li><h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><p>由于Java是不支持多继承的，因此我们选择继承哪个类就显得尤为重要了。同时，Java支持调用多个接口，因此更多时候往往调用Runnable接口。</p>
</li>
<li><h4 id="线程中start-和run-的区别"><a href="#线程中start-和run-的区别" class="headerlink" title="线程中start()和run()的区别"></a>线程中start()和run()的区别</h4><p>我们根据下面的代码 以及运行结果看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiffBewteenStartAndRun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread.currentThread().getName() 用于获取当前运行的线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// creating two threads for start and run method call</span></span><br><span class="line">        Thread startThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">&quot;start&quot;</span>));</span><br><span class="line">        Thread runThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(<span class="string">&quot;run&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        startThread.start();</span><br><span class="line">        <span class="comment">// new Thread</span></span><br><span class="line">        runThread.run();</span><br><span class="line">        <span class="comment">//current Thread</span></span><br><span class="line">        startThread.run();</span><br><span class="line">        <span class="comment">// current Thread;</span></span><br><span class="line">        runThread.start();</span><br><span class="line">        <span class="comment">// new Thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Simple Runnable implementation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String caller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String caller)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.caller = caller;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caller: &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; and code on this Thread is executed by : &quot;</span></span><br><span class="line">                    + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">main</span><br><span class="line">Caller: run and code on <span class="keyword">this</span> Thread is executed by : main</span><br><span class="line">Caller: start and code on <span class="keyword">this</span> Thread is executed by : Thread-<span class="number">0</span></span><br><span class="line">Caller: start and code on <span class="keyword">this</span> Thread is executed by : main</span><br><span class="line">Caller: run and code on <span class="keyword">this</span> Thread is executed by : Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由打印结果我们发现：run方法是在主线程中main中被调用的，run方法运行在主线程main上；</p>
<p>start方法会创建新的线程，而后再调用run方法，此时的run方法是运行创建的新线程上的；</p>
</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><ul>
<li><h4 id="三种创建-启动方式"><a href="#三种创建-启动方式" class="headerlink" title="三种创建 启动方式"></a>三种创建 启动方式</h4><ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><ul>
<li><p>自定义线程类继承Thread类</p>
</li>
<li><p>重写run方法</p>
</li>
<li><p>创建线程对象，调用start()启动线程（如果是run方法是当前线程中运行方法，不会创建新的线程）</p>
</li>
<li><p>启动线程:子类对象.start();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        MyThread1 mt1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        <span class="comment">//调用start方法</span></span><br><span class="line">        mt1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><ul>
<li><p>自定义线程类实现Runnable接口</p>
</li>
<li><p>重写run方法</p>
</li>
<li><p>创建<strong>线程对象</strong>（这里一定要注意，如果只创建了实现接口的对象，是无法使用start方法的，只能用run方法），调用start()启动线程（如果是run方法是当前线程中运行方法，不会创建新的线程）</p>
</li>
<li><p>启动线程：传入目标对象 → Thread对象.start();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类的实例</span></span><br><span class="line">        MyThread2 mt2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="comment">//用该实例作为Thread的target来创建Thread对象</span></span><br><span class="line">        Thread mt = <span class="keyword">new</span> Thread(mt2);</span><br><span class="line">        <span class="comment">//调用start方法</span></span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread2 is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5></li>
</ul>
</li>
</ul>
<h2 id="Thread（Runnable-target）调用哪个run方法问题"><a href="#Thread（Runnable-target）调用哪个run方法问题" class="headerlink" title="Thread（Runnable target）调用哪个run方法问题"></a>Thread（Runnable target）调用哪个run方法问题</h2><ul>
<li><p>问题引入：</p>
<p>以下代码中有两个run方法，一个是重写了Thread中的run方法（<strong>Run of Thread</strong>），一个是传入了Runnable对象，也就是现在的Target是Runnable，由该对象去实现的run方法（<strong>Run of Runnable</strong>）；（这里有涉及<strong>匿名内部类</strong>的知识，学习后再看这里会更清楚一点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Runnable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111131452144.png" alt="image-20201111131452144"></p>
</li>
<li><p>问题扩展：</p>
<p>大体与上述代码并没有什么不同，但是在重写的代码中增加了<code>super.run();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Runnable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="comment">//这是重写的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Run of Thread&quot;</span>);</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201111133808047.png" alt="image-20201111133808047"></p>
</li>
</ul>
<p>那么为什么是这样的结果呢？</p>
<p>查看JDK中Thread源码发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">		target.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法，首先检查target是否为空，如果不为空，执行target中的run方法</p>
<p>因此，我们就不难明白上述两个运行结果是怎么来的了：</p>
<p><strong>对于第一个代码：</strong></p>
<p>重写了Thread的run()方法，同时传入了一个Runnable对象，该对象也实现了run()方法。该Thread对象调用start()方法后，会执行该对象重写的run()方法，其输出结果也就是Run of Thread，输出完后，run()方法返回，该线程对象的生命周期也就结束了。</p>
<p><strong>对于第二个代码：</strong></p>
<p>首先，该线程启动运行后，执行其重写的run()方法，输出Run of Thread。</p>
<p>接下来调用super.run()，也就是调用超类的run()方法，而该超类的run()方法，也就是JDK定义的Thread类的run()，其执行如上JDK源码 所示；显然target不为空，这时候会调用该对象的run()方法，会输出Run of Runnable.。</p>
<p>如果，上面的Thread并未重写run()方法，那么，执行的结果还是一样。首先会执行该Thread的run()方法，因为此时并未重写该方法，所以还是会调用JDK定以的run()方法，也就是上面的代码段 ，在该代码段中会判断target是否为空，显然不是，所以会调用Runnable对象实现的run()方法。</p>
<p>==总结==</p>
<p>对于形如:<code>Thread(Runnable target ...)</code>,不管传入的Target是否为空，首先都会执行Thread自己的run()方法。如果重写了该方法且该方法中没有super.run()，那么是永远不会调用Runnable实现的run()方法；</p>
<p>如果没有重写该方法，则会去判断target是否为空，以此来决定调用target实现的run()方法；</p>
<p>如果重写了该方法，且该方法中有super.run()，在执行完该语句之前的所有代码后，会判断target是否为空，以此来决定调用target实现的run()方法，执行完后，接着执行该语句之后的代码。</p>
<h2 id="普通方法调用和多线程区别"><a href="#普通方法调用和多线程区别" class="headerlink" title="普通方法调用和多线程区别"></a>普通方法调用和多线程区别</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110220112099.png" alt="image-20201110220112099"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114225245322.png" alt="image-20201114225245322"></p>
<ul>
<li><p><mark>new（创建状态）</mark></p>
<p>在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread 类的构造方法来实现，例如 “Thread thread=new Thread()”。</p>
</li>
<li><p><mark>就绪状态</mark></p>
<p>新建线程对象后，调用该线程的 start() 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件。</p>
</li>
<li><p><Mark>运行状态</Mark></p>
<p>当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 run() 方法。run() 方法定义该线程的操作和功能。</p>
</li>
<li><p><mark>阻塞状态/等待状态</mark></p>
<p>一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让 CPU 暂时中止自己的执行，进入阻塞状态。在可执行状态下，如果调用sleep(),suspend(),wait() 等方法，线程都将进入阻塞状态，发生阻塞时线程不能进入排队队列，只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p>
</li>
<li><p><mark>死亡状态</mark></p>
<p>线程调用 stop() 方法时或 run() 方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。</p>
</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li><p><strong>调整线程的优先级</strong>：学过OS的同学们可能会对这个优先级比较敏感，在Java线程中优先级高（数字大）的线程拥有更多运行机会</p>
<p>Java线程中的优先级以整数形式表达:1~10，1最小，10最大</p>
<p>Thread类有以下三个静态常量：</p>
<p><mark>static int MAX_PRIORITY</mark></p>
<p>​     线程可以具有的最高优先级，取值为10。</p>
<p><mark>tatic int MIN_PRIORITY</mark></p>
<p>​     线程可以具有的最低优先级，取值为1。</p>
<p><mark>static int NORM_PRIORITY</mark></p>
<p>​     分配给线程的默认优先级，取值为5。</p>
<p>其中，Thread类设置优先级的方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriority();</span><br></pre></td></tr></table></figure>

<p>获得优先级的方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPriority();</span><br></pre></td></tr></table></figure>

<p>需要注意的是：每个线程都有默认的优先级。主线程默认优先级是<code>static int NORM_PRIORITY</code></p>
<p>线程优先级存在继承关系，A线程中创建B线程，B与A享有相同优先级</p>
</li>
<li><p><strong>线程睡眠</strong>：<strong>Thread.sleep(long millis)方法</strong>，使线程转到<strong>阻塞状态</strong>。millis参数设定睡眠的时间，以<strong>毫秒</strong>为单位。当睡眠结束后，就转为<strong>就绪（Runnable）状态</strong>。sleep()平台移植性好。</p>
</li>
<li><p><strong>线程等待</strong>：<strong>Object类中的wait()方法</strong>，导致当前的线程等待，直到其他线程调用此对象的 <strong>notify() 方法</strong>或 <strong>notifyAll()</strong> 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>
</li>
<li><p><strong>线程让步</strong>：<strong>Thread.yield() 方法</strong>，暂停当前正在执行的线程对象，把执行机会让给<strong>相同或者更高优先级</strong>的线程。</p>
</li>
<li><p><strong>线程加入</strong>：<strong>join()方法</strong>，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
</li>
<li><p><strong>线程唤醒</strong>：<strong>Object类中的notify()方法</strong>，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p>
</li>
</ul>
<h4 id="线程休眠（sleep）"><a href="#线程休眠（sleep）" class="headerlink" title="线程休眠（sleep）"></a>线程休眠（sleep）</h4><ul>
<li><p>sleep（参数）参制定了线程阻塞/等待的<strong>毫秒数</strong></p>
<p>这里当时有个疑问，欸？那我sleep(0)有啥用啊？关于这个问题，其实阅读这篇文章就可以有解答：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wl455624651/article/details/7388250">https://blog.csdn.net/wl455624651/article/details/7388250</a></p>
<p>其实简单来说就是，触发操作系统立刻重新进行一次CPU竞争，不要小看这个功能，是很有必要的</p>
</li>
<li><p>sleep存在异常<code>InterruptedException</code></p>
</li>
<li><p>sleep时间结束后，线程从阻塞/等待状态 → 就绪状态</p>
</li>
<li><p>每个对象有一个锁，而<mark><strong>sleep不会释放锁!!</strong></mark></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i + <span class="string">&quot;,日期:&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line"></span><br><span class="line">        ts1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ts2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        ts3.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ts1.start();</span><br><span class="line">        ts2.start();</span><br><span class="line">        ts3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115160241312.png" alt="image-20201115160241312"></p>
<p>通过运行结果，我们不难发现：每一组三个人名的打印顺序并不是一定的</p>
<p>这也印证了我们上面的说法：每当调用sleep函数后，线程回到了就绪队列，相当于回到了同一起跑线，需要进行新的一次CPU竞争</p>
<p>那么谁能抢到CPU呢？当然是说不定的啦，因此，打印顺序也是不一定的。</p>
<h4 id="线程礼让（yield）"><a href="#线程礼让（yield）" class="headerlink" title="线程礼让（yield）"></a>线程礼让（yield）</h4><ul>
<li>线程的礼让会使正在执行的线程<strong>暂停</strong>，但并不<strong>阻塞</strong>，也就是说该函数并<strong>不会</strong>让线程转移到<mark>等待/睡眠/阻塞</mark>状态</li>
<li>线程将会从<strong>运行态</strong> → <strong>就绪态</strong></li>
<li>之后该让哪个线程运行，由CPU进行调度，因此有可能下个运行的还是那个礼让的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;停止执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">        ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line"></span><br><span class="line">        ty1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        ty2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ty1.start();</span><br><span class="line">        ty2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201115161708654.png" alt="image-20201115161708654"></p>
<h4 id="线程加入（join）"><a href="#线程加入（join）" class="headerlink" title="线程加入（join）"></a>线程加入（join）</h4><ul>
<li>Thread.join()很霸道，调用该方法的函数将会霸占处理机，等到该线程执行完成后，再执行别的线程，其他的线程在其此间为阻塞态</li>
<li>其实就是插队</li>
<li>join函数以及原理看起来简单，但是里面有很多细枝末节需要注意</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013425438/article/details/80205693">https://blog.csdn.net/u013425438/article/details/80205693</a> 这篇文章其实解释了得蛮清楚的</p>
<p>（ps：评论区也很值得一看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br><span class="line">A-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当使用了join后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>然而，假如我们把<code>t1.join()</code>放在<code>t2.start()</code>之后，我们看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>发现，又回到了交替执行的情况了，究竟是为什么呢？</p>
<p>查看join()的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);            <span class="comment">//join()等同于join(0)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);           <span class="comment">//join(0)等同于wait(0)，即wait无限时间直到被notify</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现：join()方法的底层是利用wait()方法实现的。</p>
<p>可以看出，join方法是一个同步方法，当主线程调用t1.join()方法时，主线程先获得了t1对象的锁，随后进入方法，调用了t1对象的wait()方法，使主线程进入了t1对象的等待池，</p>
<p>此时，A线程则还在执行，并且随后的t2.start()还没被执行，因此，B线程也还没开始。</p>
<p>等到A线程执行完毕之后，主线程继续执行，走到了t2.start()，B线程才会开始执行。</p>
<p><strong>其实叽里呱啦说了一大堆，就说明了一个道理:在哪个线程调用了xxx.join()方法，只会锁那个相应的线程</strong></p>
<p><strong>比如a线程调用了t1.join()，那a就会被卡住，当然了，a会不会对别的线程有影响就另当别论了</strong></p>
<p>原文中用了一个例子来验证上述这个道理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">		ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">		ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">		t2.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">		t3.start();</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现是主线程跑完了后，ABC线程交替执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t2start</span><br><span class="line">t3start</span><br><span class="line">main end</span><br><span class="line">C-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">C-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">C-<span class="number">3</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">C-<span class="number">4</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">C-<span class="number">5</span></span><br><span class="line">B-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当我们使用了join函数后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t2end&quot;</span>);</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3end&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们发现，主线程在调用join函数的地方停住了，后面是AB线程交替执行</p>
<p>这里有人会说啦：哎呀 不是只会停止主线程吗，为什么不是ABC线程交替执行啊？</p>
<p>那是因为我们的C线程此时还没有在主线程上启动，C线程根本不存在，怎么执行呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t1end</span><br><span class="line">t2start</span><br><span class="line">t2end</span><br><span class="line">A-1</span><br><span class="line">B-1</span><br><span class="line">A-2</span><br><span class="line">B-2</span><br><span class="line">A-3</span><br><span class="line">B-3</span><br><span class="line">B-4</span><br><span class="line">A-4</span><br><span class="line">B-5</span><br><span class="line">A-5</span><br><span class="line">t3start</span><br><span class="line">t3end</span><br><span class="line">C-1</span><br><span class="line">main end</span><br><span class="line">C-2</span><br><span class="line">C-3</span><br><span class="line">C-4</span><br><span class="line">C-5</span><br></pre></td></tr></table></figure>

<p>如果你硬要改，让C也加入进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">        ThreadTest t1=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadTest t2=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadTest t3=<span class="keyword">new</span> ThreadTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1start&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t2start&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t2end&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t3start&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t3end&quot;</span>);</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">t1start</span><br><span class="line">t1end</span><br><span class="line">t2start</span><br><span class="line">t2end</span><br><span class="line">t3start</span><br><span class="line">t3end</span><br><span class="line">B-<span class="number">1</span></span><br><span class="line">A-<span class="number">1</span></span><br><span class="line">C-<span class="number">1</span></span><br><span class="line">A-<span class="number">2</span></span><br><span class="line">B-<span class="number">2</span></span><br><span class="line">A-<span class="number">3</span></span><br><span class="line">C-<span class="number">2</span></span><br><span class="line">A-<span class="number">4</span></span><br><span class="line">B-<span class="number">3</span></span><br><span class="line">A-<span class="number">5</span></span><br><span class="line">C-<span class="number">3</span></span><br><span class="line">B-<span class="number">4</span></span><br><span class="line">C-<span class="number">4</span></span><br><span class="line">B-<span class="number">5</span></span><br><span class="line">C-<span class="number">5</span></span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p>即证；</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li><p><strong>并发</strong>：同一个对象被多个线程同时操作</p>
</li>
<li><p>线程同步基本思想：由于处理多线程问题的时候往往关乎到对同一个对象的访问，修改</p>
<p>因此我们需要线程同步：线程同步是一种等待机制，多个<strong>需要同时访问这个对象的线程</strong>的<strong>线程</strong>进入了<strong>这个对象</strong>的<mark>等待池</mark></p>
<p>形成了队列，等待前面的线程使用完毕之后，下一个线程再使用</p>
</li>
<li><p>同步方法：队列 + <strong>锁</strong></p>
</li>
</ul>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理模式分为两种：静态代理和动态代理</p>
<p>什么是代理呢？按照我自己的理解就是：“夹带私货”</p>
<p>什么意思呢？就是通过代理，我们可以实现我们一开始的目的，与此同时还会有一些额外的功能</p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cC-Zhou/p/9525638.html">https://www.cnblogs.com/cC-Zhou/p/9525638.html</a></p>
<p>我们买东西虽然可以从厂家那直接拿，但一般来说都是从商店那买的；</p>
<p>他们也是从厂家那拿货，然后加一点小价钱卖给我们；</p>
<p>嗯？是不是有点熟悉，像不像我们java中的接口概念：我们和商店都实现了从xxx处买东西这一接口</p>
<p>在这个小例子中，商店就是那个代理，充当中间人角色，他加了一点小价钱 就是他夹带的私活 或者说是额外扩充的功能？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213911162" alt="这里写图片描述"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是面向对象编程中比较常见的设计模式。<br><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20170629213938736" alt="这里写图片描述"></p>
<p>这是常见代理模式常见的 UML 示意图。</p>
<p>需要注意的有下面几点：</p>
<ol>
<li>用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li>
<li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li>
<li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li>
<li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li>
</ol>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？</p>
<p>电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。</p>
<p>现在用代码来进行模拟。</p>
<p>首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;您正在观看电影 《肖申克的救赎》&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RealMovie movie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(RealMovie movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        guanggao(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line"></span><br><span class="line">        guanggao(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guanggao</span><span class="params">(<span class="keyword">boolean</span> isStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( isStart ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frank.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RealMovie realmovie = <span class="keyword">new</span> RealMovie();</span><br><span class="line"></span><br><span class="line">        Movie movie = <span class="keyword">new</span> Cinema(realmovie);</span><br><span class="line"></span><br><span class="line">        movie.play();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！</span><br><span class="line">您正在观看电影 《肖申克的救赎》</span><br><span class="line">电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃</span><br><span class="line">吧！</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final的简介"><a href="#final的简介" class="headerlink" title="final的简介"></a>final的简介</h3><p>final可以修饰<strong>变量，方法和类</strong>，用于表示所修饰的内容一旦赋值之后就不会再被改变，比如String类就是一个final类型的类。即使能够知道final具体的使用方法，我想对<strong>final在多线程中存在的重排序问题</strong>也很容易忽略，希望能够一起做下探讨。</p>
<h3 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h3><p>final能够修饰变量，方法和类，也就是final使用范围基本涵盖了java每个地方，下面就分别以锁修饰的位置：变量，方法和类分别来说一说。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在java中变量，可以分为<strong>成员变量</strong>以及方法<strong>局部变量</strong>。因此也是按照这种方式依次来说，以避免漏掉任何一个死角。</p>
<h5 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h5><p>通常每个类中的成员变量可以分为<strong>类变量（static修饰的变量）以及实例变量</strong>。</p>
<ul>
<li><p>针对这两种类型的变量赋初值的时机是不同的：</p>
<ul>
<li>类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值。</li>
<li>实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。</li>
</ul>
</li>
<li><p>即：类变量有<strong>两个时机赋初值</strong>，而实例变量则可以有<strong>三个时机赋初值</strong>。</p>
</li>
</ul>
<p>当final变量未初始化时系统不会进行隐式初始化，会出现报错。这样说起来还是比较抽象，下面用具体的代码来演示。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-768017317b5fab78.png" alt="final修饰成员变量"></p>
<p>看上面的图片已经将每种情况整理出来了，这里用截图的方式也是觉得在IDE出现红色出错的标记更能清晰的说明情况。现在我们来将这几种情况归纳整理一下：</p>
<ol>
<li><strong>类变量</strong>：必须要在<strong>静态初始化块</strong>中指定初始值或者<strong>声明该类变量时</strong>指定初始值，而且只能在这<strong>两个地方</strong>之一进行指定；</li>
<li><strong>实例变量</strong>：必须要在<strong>非静态初始化块</strong>，<strong>声明该实例变量</strong>或者在<strong>构造器中</strong>指定初始值，而且只能在这<strong>三个地方</strong>进行指定。</li>
</ol>
<h5 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h5><p>final局部变量由程序员进行显式初始化，如果final局部变量已经进行了初始化则后面就不能再次进行更改，如果final变量未进行初始化，可以进行赋值，<strong>当且仅有一次</strong>赋值，一旦赋值之后再次赋值就会出错。下面用具体的代码演示final局部变量的情况：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-7077bdb169d4d1c3.png" alt="final修饰局部变量"></p>
<p>现在我们来换一个角度进行考虑，final修饰的是基本数据类型和引用类型有区别吗？</p>
<blockquote>
<p><strong>final基本数据类型  VS final引用数据类型</strong></p>
</blockquote>
<p>通过上面的例子我们已经看出来，如果final修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果final是引用数据类型了？这个引用的对象能够改变吗？我们同样来看一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在声明final实例成员变量时进行赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Person person = <span class="keyword">new</span> Person(<span class="number">24</span>, <span class="number">170</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对final引用数据类型person进行更改</span></span><br><span class="line">        person.age = <span class="number">22</span>;</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们对final修饰的引用数据类型变量person的属性改成22，是可以成功操作的。</p>
<p>通过这个实验我们就可以看出来：</p>
<ul>
<li><p><strong>当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。</strong></p>
</li>
<li><p><strong>而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>宏变量</strong></p>
</blockquote>
<p>利用final变量的不可更改性，在满足一下三个条件时，该变量就会成为一个“宏变量”，即是一个常量。</p>
<ol>
<li>使用final修饰符修饰；</li>
<li>在定义该final变量时就指定了初始值；</li>
<li>该初始值在编译时就能够唯一指定。</li>
</ol>
<p>注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p><strong>重写？</strong></p>
</blockquote>
<p>当父类的方法被final修饰的时候，子类不能重写父类的该方法，比如在Object中，getClass()方法就是final的，我们就不能重写该方法，但是hashCode()方法就不是被final所修饰的，我们就可以重写hashCode()方法。我们还是来写一个例子来加深一下理解：<br>先定义一个父类，里面有final修饰的方法test();</p>
<pre><code>public class FinalExampleParent &#123;
    public final void test() &#123;
    &#125;
&#125;</code></pre><p>然后FinalExample继承该父类，当重写test()方法时出现报错，如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210518221631629.png" alt="image-20210518221631629"></p>
<p>通过这个现象我们就可以看出来<strong>被final修饰的方法不能够被子类所重写</strong>。</p>
<blockquote>
<p><strong>重载？</strong></p>
</blockquote>
<pre><code>public class FinalExampleParent &#123;
    public final void test() &#123;
    &#125;

    public final void test(String str) &#123;
    &#125;
&#125;</code></pre><p>可以看出被final修饰的方法是可以重载的。经过我们的分析可以得出如下结论：</p>
<p><strong>1. 父类的final方法是不能够被子类重写的</strong></p>
<p><strong>2. final方法是可以被重载的</strong></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p><strong>当一个类被final修饰时，表名该类是不能被子类继承的</strong>。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用final修饰。还是来写一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExampleParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类会被final修饰，当子类继承该父类的时候，就会报错，如下图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/2615789-835b66d960e21e2e.png" alt="final类不能继承"></p>
<h3 id="final的例子"><a href="#final的例子" class="headerlink" title="final的例子"></a>final的例子</h3><p>final经常会被用作不变类上，利用final的不可更改性。我们先来看看什么是不变类。</p>
<blockquote>
<p>不变类 </p>
</blockquote>
<p>不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：</p>
<ol>
<li>使用private和final修饰符来修饰该类的成员变量</li>
<li>提供带参的构造器用于初始化类的成员变量；</li>
<li>仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；</li>
<li>如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。</li>
</ol>
<p>JDK中提供的八个包装类和String类都是不可变类，我们来看看String的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>可以看出String的value就是final修饰的，上述其他几条性质也是吻合的。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>（final关键字）<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/196a4aa7f029?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/196a4aa7f029?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/11/14/Java%E5%9F%BA%E7%A1%80/" data-id="ckppikued001op0wi3xn75u4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/UesugiEr11.github.io/page/2/">2</a><a class="extend next" rel="next" href="/UesugiEr11.github.io/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>