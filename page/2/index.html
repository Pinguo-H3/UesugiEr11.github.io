<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Erii B1og</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="普普通通程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="Erii B1og">
<meta property="og:url" content="http://uesugier11.github.io/page/2/index.html">
<meta property="og:site_name" content="Erii B1og">
<meta property="og:description" content="普普通通程序员">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Erii">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/UesugiEr11.github.io/atom.xml" title="Erii B1og" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/UesugiEr11.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/UesugiEr11.github.io/" id="logo">Erii B1og</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/">Home</a>
        
          <a class="main-nav-link" href="/UesugiEr11.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/UesugiEr11.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://uesugier11.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/10/08/%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-10-08T13:36:12.478Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2020/10/08/%E7%AE%97%E6%B3%95/">算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><ul>
<li>二分思想其实非常简单，就是我们小时候玩的猜数字游戏：我说一个数字，你来猜，每次我会说大了或者小了，然后你根据我的回答去调整，继续猜，知道猜到为止</li>
<li>二分其实不仅仅可以二分，还可以三分，N分….这是一种思想</li>
<li>二分虽然简单，但往往越简单的东西细节越重要<ul>
<li>while（left &lt; right）还是while（left &lt;= right）？这里有什么不同，我们在什么情况该用哪种？</li>
<li>left = mid + 1 ,right = mid - 1 还是 left =  mid + 1，right = mid？到底用哪种？</li>
</ul>
</li>
</ul>
<h2 id="二分样板"><a href="#二分样板" class="headerlink" title="二分样板"></a>二分样板</h2><h3 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h3><ul>
<li><strong>场景</strong>：在nums数组中搜索一个数（target），如果存在 返回索引，不存在 返回 -1；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"><span class="comment">//退出条件 left == right + 1</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// int mid = left + ((right -left) &gt;&gt; 1) 还可以用右移操作代替除法 提高性能</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    <span class="comment">//退出条件 left == right</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// int mid = left + ((right -left) &gt;&gt; 1) 还可以用右移操作代替除法 提高性能</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>循环条件：</strong><code>left &lt;= right</code></li>
<li><strong>中间位置计算：</strong><code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1;</code></li>
<li><strong>右边界更新：</strong><code>right = mid - 1;</code></li>
<li><strong>返回值：</strong> <code>mid / -1</code></li>
<li>左右边界相遇时候 返回值只会是：<ul>
<li><code>left/mid</code> , <code>right</code> (left, mid 指向同一个数，right指向它的下一个数)</li>
<li><code>left/mid/right</code> （left, mid, right 指向同一个数）</li>
</ul>
</li>
<li><strong>为什么 while 循环的条件中是 <code>&lt;=</code>，而不是 <code>&lt;</code></strong>？</li>
</ul>
<p>因为 <strong>right</strong> = <strong>nums.length - 1</strong> ，是最后一个元素索引，而非 <strong>nums.length</strong> （数组的长度）</p>
<p>假如<strong>right</strong>取前者意味着此时的区间  为：两端都闭区间 <code>[left, right]</code>  </p>
<p>假如<strong>right</strong>取后者意味着此时的区间 为：左闭右开区间 <code>[left, right)</code></p>
<p>在while循环中，我们什么时候应该停止搜索呢？</p>
<ol>
<li><p>找到了目标值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid; </span><br></pre></td></tr></table></figure>
</li>
<li><p>没有找到目标值，while循环终止</p>
<ol>
<li><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code></p>
<p>比如right = 1，那么区间此时是<code>[2,1]</code> 在这个区间内不存在任何一个实数吧？</p>
</li>
<li><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code></p>
<p>比如right  = 1，那么区间此时是<code>[1,1]</code>，在这区间此时是存在一个数 1 的, 但我们的这个数 1 是没有被检索的 被漏掉了</p>
<p>必须要打补丁，判断一下这个left索引对应的值是否等于目标值，是的话返回索引，不然返回 -1 ;</p>
<p>ps：right 还是 length - 1 哦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ul>
<li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？</li>
</ul>
<p>因为我们的搜索区间是左闭右闭的：<code>[left, right]</code>，那么收缩的可能性就两种 向左或向右</p>
<p>向左：<code>[left, mid - 1]</code></p>
<p>向右：<code>[mid + 1, right]</code></p>
<h3 id="寻找左侧边界的二分查找"><a href="#寻找左侧边界的二分查找" class="headerlink" title="寻找左侧边界的二分查找"></a>寻找左侧边界的二分查找</h3><ul>
<li>什么叫寻找左侧边界 意思是 假如在一个<code>nums = [1,2,2,2,3]</code>中，target为2,我想要得到最左侧的2 也就是索引为 1的二分查找法</li>
<li>由于这种题我经常分不清right 和 while循环条件中的配合问题 于是我把全部的四种（2×2）方法全部写了一遍！以后再应该不会出问题了吧！！！</li>
</ul>
<h4 id="最后一位-lt-的组合"><a href="#最后一位-lt-的组合" class="headerlink" title="最后一位 + &lt; 的组合"></a>最后一位 + &lt; 的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时退出条件是：left == right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length - 1</code></li>
<li><strong>循环条件：</strong><code>left &lt; right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid</code></li>
<li><strong>返回值：</strong> <code>nums[left] == target ? left : -1</code></li>
</ul>
<h4 id="数组长度-lt-的组合"><a href="#数组长度-lt-的组合" class="headerlink" title="数组长度 + &lt;  的组合"></a>数组长度 + &lt;  的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="comment">//终止条件为left == right</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) </span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>这写法和上面不同点在于我的right取值 假如是最后一个索引而非长度，那就不需要特判 不然的话有可能越界 要特判</strong></p>
</li>
<li><p><strong>right初始值</strong>：<code>nums.length</code></p>
</li>
<li><p><strong>循环条件：</strong><code>left &lt; right</code></p>
</li>
<li><p><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></p>
</li>
<li><p><strong>左边界更新：</strong><code>left = mid + 1</code></p>
</li>
<li><p><strong>右边界更新：</strong><code>right = mid</code></p>
</li>
<li><p><strong>返回值：</strong></p>
<ul>
<li><code>if(left == nums.length) return -1;</code></li>
<li><code>else return nums[left] == target ? left : -1;</code></li>
</ul>
</li>
</ul>
<h4 id="最后一位-lt-的组合-1"><a href="#最后一位-lt-的组合-1" class="headerlink" title="最后一位 + &lt;= 的组合"></a>最后一位 + &lt;= 的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时退出条件是 left == right + 1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">//由于我们右边界是能取到的 因此必须收缩哦</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果target是大于数组里面全部数时候，left是=nums.length的 会越界 因此必</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length - 1</code></li>
<li><strong>循环条件：</strong><code>left &lt;= right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid - 1</code></li>
<li><strong>返回值：</strong><ul>
<li><code>if (left &gt;= nums.length || nums[left] != target)  return -1;</code></li>
<li><code>else return left;</code></li>
</ul>
</li>
</ul>
<h4 id="数组长度-lt-的组合-1"><a href="#数组长度-lt-的组合-1" class="headerlink" title="数组长度 + &lt;= 的组合"></a>数组长度 + &lt;= 的组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; nums.length;</span><br><span class="line">        &#x2F;&#x2F;此时退出条件是 left &#x3D;&#x3D; right + 1</span><br><span class="line">        while (left &lt;&#x3D; right) &#123;</span><br><span class="line">            int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F;防止越界</span><br><span class="line">            if(mid &#x3D;&#x3D; nums.length) break;</span><br><span class="line">            if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125; else if(nums[mid] &gt; target) &#123;</span><br><span class="line">                &#x2F;&#x2F;由于我们右边界是能取到的 因此必须收缩哦</span><br><span class="line">                right &#x3D; mid - 1;</span><br><span class="line">            &#125; else if(nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">             	right &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果target是大于数组里面全部数时候，left是&#x3D;nums.length的 会越界 因此必</span><br><span class="line">        if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target)  return -1;</span><br><span class="line">        else return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length</code></li>
<li><strong>循环条件：</strong><code>left &lt;= right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid - 1</code></li>
<li><strong>返回值：</strong> <ul>
<li><code>if (left &gt;= nums.length || nums[left] != target)  return -1;</code></li>
<li><code>else return left;</code></li>
</ul>
</li>
</ul>
<h4 id="寻找左侧-总结"><a href="#寻找左侧-总结" class="headerlink" title="寻找左侧 总结"></a>寻找左侧 总结</h4><p>我们看上面的四个Demo代码，我们不难发现，我们为了限制我们的左侧是不能被取到的，我们的配合其实无非就那么几种</p>
<p>假如while是 &lt;= ，无论初始值我们的right是多少，那么我们的right的变化就是 mid - 1保证 向左收缩</p>
<p>假如while是&lt; ，我们的right变化就是取mid；</p>
<h3 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h3><ul>
<li>什么叫寻找右侧边界 意思是 假如在一个<code>nums = [1,2,2,2,3]</code>中，target为2,我想要得到最右侧的2 也就是索引为 3 的二分查找法</li>
</ul>
<h4 id="最后一位-lt-的组合-2"><a href="#最后一位-lt-的组合-2" class="headerlink" title="最后一位 + &lt;的组合"></a>最后一位 + &lt;的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时退出条件是：left == right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">0</span> &amp;&amp; nums[right] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[right - <span class="number">1</span>] == target ? right - <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length - 1</code></li>
<li><strong>循环条件：</strong><code>left &lt; right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid</code></li>
<li><strong>返回值：</strong><ul>
<li><code>if(right == 0 &amp;&amp; nums[right] != target) return -1;</code></li>
<li><code>if(nums[right] == target) return right;</code></li>
<li><code>else return nums[right - 1] == target ? right - 1 : -1;</code></li>
</ul>
</li>
</ul>
<h4 id="数组长度-lt-的组合-2"><a href="#数组长度-lt-的组合-2" class="headerlink" title="数组长度 + &lt; 的组合"></a>数组长度 + &lt; 的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="comment">//此时退出条件是：left == right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right - <span class="number">1</span>] == target ? (right - <span class="number">1</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length</code></li>
<li><strong>循环条件：</strong><code>left &lt; right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid</code></li>
<li><strong>返回值：</strong><ul>
<li><code>if(left == 0) return -1;</code></li>
<li><code>return nums[right - 1] == target ? (right - 1) : -1;</code></li>
</ul>
</li>
</ul>
<h4 id="最后一位-lt-的组合-3"><a href="#最后一位-lt-的组合-3" class="headerlink" title="最后一位 + &lt;= 的组合"></a>最后一位 + &lt;= 的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时退出条件是：left == right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>right初始值</strong>：<code>nums.length - 1</code></p>
</li>
<li><p><strong>循环条件：</strong><code>left &lt;= right</code></p>
</li>
<li><p><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></p>
</li>
<li><p><strong>左边界更新：</strong><code>left = mid + 1</code></p>
</li>
<li><p><strong>右边界更新：</strong><code>right = mid - 1</code></p>
</li>
<li><p><strong>返回值 ：</strong> </p>
<ul>
<li><code>if(right &lt; 0 || nums[right] != target) return -1;</code></li>
<li><code>return nums[right] == target ? right : -1;</code></li>
</ul>
</li>
</ul>
<h4 id="数组长度-lt-的组合-3"><a href="#数组长度-lt-的组合-3" class="headerlink" title="数组长度 + &lt;= 的组合"></a>数组长度 + &lt;= 的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="comment">//此时退出条件是：left == right + 1;</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == nums.length) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查越界</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right &gt;= <span class="number">0</span> &amp;&amp; right &lt; nums.length &amp;&amp; nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(nums[right - <span class="number">1</span>] == target) <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>nums.length</code></li>
<li><strong>循环条件：</strong><code>left &lt;= right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid - 1</code></li>
<li><strong>返回值：</strong><ul>
<li><code>if(right &lt; 0)  return -1;</code></li>
<li><code>if(right &gt;= 0 &amp;&amp; right &lt; nums.length &amp;&amp; nums[right] == target) return right;</code></li>
<li><code>if(nums[right - 1] == target) return right - 1;return -1;</code></li>
</ul>
</li>
</ul>
<p>第四种方法比较麻烦，不是很推荐，其实写了种也不是为了把八种写法都记住；</p>
<p>只是想通过一次次排查问题找到二分的各种细节，让以后的二分之路更轻松! 最好就是用一套规范把，比如说以后都用 最后一位 + &lt;= 这种框架，然后里面细节按照题意再改就好了！</p>
<p>八种方法都测试过了：都是ok的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201020140256461.png" alt="image-20201020140256461"></p>
<h2 id="二分-LeetCode相关"><a href="#二分-LeetCode相关" class="headerlink" title="二分-LeetCode相关"></a>二分-LeetCode相关</h2><h3 id="69-X的平方根"><a href="#69-X的平方根" class="headerlink" title="69.X的平方根"></a>69.X的平方根</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201020181457188.png" alt="image-20201020181457188"></p>
<p>这题由于是找平方根嘛，那就很简单了，相当于把x这个数平铺展开成一个序列，然后找这个序列最中间的那个数，然后由于是保留整数部分，那么其实是寻找左侧边界的二分查找了</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判 不然会出现除数为0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//结束条件 left == right + 1;</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid  == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; x / mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于是向下去整，我们就取小一点的那个数，因为这题不存在什么找不到找不到这一说</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>right初始值</strong>：<code>x - 1</code></li>
<li><strong>循环条件：</strong><code>left &lt;= right</code></li>
<li><strong>中间位置计算：</strong> <code>int mid = left + (right - left) / 2;</code></li>
<li><strong>左边界更新：</strong><code>left = mid + 1</code></li>
<li><strong>右边界更新：</strong><code>right = mid - 1</code></li>
<li><strong>返回值：</strong> <code>return right</code></li>
</ul>
<p>为什么是return right呢？因为我们这题要么就直接在循环中找到mid 返回，要么就找不到退出循环；</p>
<p>而我们上面也分析了 退出循环条件：left == right + 1;</p>
<p>相当于这个数其实是被卡在了right 和 left 之间（因为此时right反而在左边，left在右边了）</p>
<p>而题目要求要舍弃小数点后的数字，那意思是向下取整了，那就返回right了！</p>
<h1 id="DP（Dynamic-Programming）"><a href="#DP（Dynamic-Programming）" class="headerlink" title="DP（Dynamic Programming）"></a>DP（Dynamic Programming）</h1><h2 id="DP思想-概念"><a href="#DP思想-概念" class="headerlink" title="DP思想/概念"></a>DP思想/概念</h2><p>技术参考：《运筹学》第三版 - 清华大学出版社</p>
<p>要明白DP首先需要明白五个名词:</p>
<ul>
<li><p><mark><strong>阶段</strong></mark>：一个大问题过程拆分成若干个<strong>有关联</strong>的<strong>阶段</strong>，用于按照一定的<mark>次序</mark>去求解问题</p>
<p>划分的依据是什么呢？比如说你要完成一个项目，我每天做一点，这就是按照时间为单位划分</p>
<p>我们写题一般以空间为单位（即数组）每个数组代表某一个特定的阶段</p>
</li>
<li><p><mark><strong>状态</strong></mark>：表示某<strong>阶段</strong>所处的状况/条件。再以数组为例：现在有一个数组<code>int money[i]</code> 这个i表示我在第i天，拥有着money[i]这么多钱</p>
<p>这句话：在第i阶段，拥有某种属性 就是状态</p>
<ul>
<li>状态应该具有的性质:<strong>无后效性</strong>，什么意思呢？简单来说就是 我未来变化只与此刻（此状态）相关，与我如何达到此刻（此状态无关）</li>
</ul>
</li>
<li><p><mark><strong>决策</strong></mark>：状态不可能一成不变，肯定是要变化的。而造成状态改变的就是<strong>决策</strong></p>
<p>而决策往往有多种选择，在写题目的时候需要我们将题目的<strong>决策/选择</strong>抽象出来。</p>
</li>
<li><p><mark><strong>策略</strong></mark>：策略是按照顺序排列的决策的集合。我们的DP方法的终极目标就是求出：<strong>最优策略/最优解</strong></p>
</li>
<li><p><mark><strong>状态转移方程</strong></mark>：决策 导致了 状态的变化，而状态转移方程就是决策的具象化，在不同题目中的转移方式多种多样（比如取两种决策中利益最大的啊，把之前的状态加在一起啊之类的）</p>
<p>这也是我们后面学习DP的重点问题！一定要重点理解</p>
</li>
<li><p>DP的<strong>最优性原理和最优性定理</strong>（理论依据）:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/9a022899dcfe81b5b2e7cccb815eea6fd11.jpg" alt="img"></p>
<p>简单来说就是:子问题最优解会直接导致到整个问题的最优解（局部最优化 → 全局最优化）</p>
<p>以下面一个例子来解释:</p>
<p>如下图所示，如果给定从A到C的最优路线（这是前提，谨记），那么最优路线上任意一点B到C的路线Ⅱ必须是B到C的最优路线。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201122202839453.png" alt="image-20201122202839453"></p>
<p>换而言之：若：弧AB+弧Ⅱ = A→C 最优解，弧Ⅱ一定是B→C的最优路线</p>
<p>证明：反证法：若弧Ⅰ是B→C是比弧Ⅱ有更小代价最小路线，那么AB+弧Ⅰ就优于AB+弧Ⅱ，这与我们的前提:给定从A到C的最优路线（AB+弧Ⅱ）是矛盾的</p>
<p><strong>QED</strong></p>
</li>
</ul>
<h2 id="DP解题思路"><a href="#DP解题思路" class="headerlink" title="DP解题思路"></a>DP解题思路</h2><ul>
<li><strong>DP解题思路</strong><ul>
<li>确定状态：由于我们解决动态规划通常需要去开一个数组，既然是数组就需要明白其中的下标<strong>i和j</strong>代表什么意思<ul>
<li>研究最优策略最后一步</li>
<li>大问题拆分成小问题，小问题划分成小小问题…</li>
</ul>
</li>
<li>转移方程：DP解决问题的精髓就是这个，由不同的题不同考虑</li>
<li>初始条件与边界条件：<ul>
<li>通常是a[0]啊a[1]的初值之类的</li>
<li>数组不能越界，因为通常会在i和j上+-，很容易不小心就越界；</li>
</ul>
</li>
<li>计算顺序：记忆化之前我们运算所得到的结果。</li>
</ul>
</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201122210755238.png" alt="image-20201122210755238"></p>
<h3 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法:"></a>暴力递归法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> func(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> func(N - <span class="number">1</span>) + func(N - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201122211510883.png" alt="image-20201122211510883"></p>
<p>不难发现，这种方法代码简单，但是可以说是十分低效了。</p>
<p>我们画一下递归树：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201122212021418.png" alt="image-20201122212021418"></p>
<p>由递归树我们也不难发现：这个算法的时间复杂度是O(2^n)，为一个指数级别</p>
<p>观察这颗树，我们发现：f（8）、f（7）….都是重复计算过了的——这就是DP问题第一个性质:<strong>重叠子问题</strong></p>
<h3 id="带备忘录递归-记忆化"><a href="#带备忘录递归-记忆化" class="headerlink" title="带备忘录递归/记忆化"></a>带备忘录递归/记忆化</h3><p>上面我们发现了单纯递归的问题:重复计算</p>
<p>接下来介绍两种记忆化方法</p>
<h4 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h4><p>为什么叫自顶向上呢？因为我一开始就想试图求出N对应的斐波那契数；</p>
<p>只不过求解该结果需要F（N-1）和F（N-2）罢了</p>
<p>那问题就转换成了 求F（N - 1）和F（N - 2）…</p>
<p>直到我们遇到了已知的F（X）(<mark>也就是我们常说的 基本状态</mark>) ，那就可以往上返回了。</p>
<p>因此叫自顶向上（带备忘录的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] memory = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        memory[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memory[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> func(memory, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>[] memory, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果记忆过了 直接return</span></span><br><span class="line">        <span class="keyword">if</span>(memory[n] != <span class="number">0</span>) <span class="keyword">return</span> memory[n];</span><br><span class="line">        <span class="comment">//不然的话就递归寻找</span></span><br><span class="line">        <span class="keyword">else</span> memory[n] = func(memory, n -<span class="number">2</span>) + func(memory, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再返回</span></span><br><span class="line">        <span class="keyword">return</span> memory[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h4><p>为什么叫自底向上呢?因为这种方法是已知了<strong>底层的值（这里指的是F（0）= 0，F（1）= 1）</strong></p>
<p>然后通过迭代的方法，用这两个basedata一步步推到N</p>
<p>换句话说：就是从已知的最底层状态并达到最理想状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//代替N = 0时的值</span></span><br><span class="line">        <span class="keyword">int</span> prev1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//代替N = 1时的值</span></span><br><span class="line">        <span class="keyword">int</span> prev2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            current = prev1 + prev2;</span><br><span class="line">            prev1 = prev2;</span><br><span class="line">            prev2 = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现了吗，这种解法与<strong>带备忘录的自顶向下递归</strong>十分类似；</p>
<p>事实上，那种方式就是在填这个DP表格。</p>
<p>有人会问，我这个代码哪里体现出了选择？或者说，哪里体现出了状态转移呢？</p>
<p>这就是状态转移方程:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125222534292.png" alt="image-20201125222534292"></p>
<p>f（n）的状态是由状态n - 1 与状态 n - 2相加转移而来的</p>
<h2 id="DP-LeetCode相关"><a href="#DP-LeetCode相关" class="headerlink" title="DP-LeetCode相关"></a>DP-LeetCode相关</h2><h3 id="剑指Offer-63-股票的最大利润"><a href="#剑指Offer-63-股票的最大利润" class="headerlink" title="剑指Offer 63.股票的最大利润"></a>剑指Offer 63.股票的最大利润</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007160636576.png" alt="image-20201007160636576"></p>
<p>这种题很容易判断出来用DP写，为什么呢，因为只可能在左侧买，右侧卖，那就不用考虑万一右边有更小的买入值怎么办了。</p>
<p>换而言之，只需要一直考虑局部最优解，那么答案肯定是整体的最优解。</p>
<p>这题思路:</p>
<p>用一个min去不停更新数组的最小值，让当前遍历到的数字去减去这个值，就是利润，与之前所得到的最大值比大小，更新最大值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意 这题不能让max = Integer.MIN_VALUE</span></span><br><span class="line">        <span class="comment">//因为如果是这样的话 假如是从大到小排序的话 max值是负数，不符合题目要求，因为自作聪明，Error了一次</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= min) &#123;</span><br><span class="line">                <span class="comment">//假如当前遍历到的值小于最小值，更新</span></span><br><span class="line">                min = prices[i];</span><br><span class="line">                <span class="comment">//暂时跳出循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较最大值，更新</span></span><br><span class="line">            max = Math.max(prices[i] - min, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013204245170.png" alt="image-20201013204245170"></p>
<p>用一个DP数组来进行动态规划</p>
<p>DP[i] 表示以nums[i]结尾的连续子数组的最大和</p>
<p>何为连续?意思是中间不能断。如何做到?遇到了数组中每个值，要么加入序列，要么就当序列的头。</p>
<ul>
<li><p><strong>确定状态</strong>：dp[i] 表示以nums[i]结尾的连续子数组的最大和</p>
</li>
<li><p><strong>转移方程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始值与边界条件：</strong>dp[0]为原数组第一个数值，因为我们的遍历是从第二个数开始的</p>
</li>
<li><p><strong>计算顺序：</strong>当遍历完整个数组的时候答案就出来了，因此是正序</p>
</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判1</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//特判2</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//要么就把它纳入序列，要么把它当作开头</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="comment">//比大小</span></span><br><span class="line">            ans = Math.max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007184400404.png" alt="image-20201007184400404"></p>
<p>这题太经典了，我写的第一道DP的题就是这个其实。</p>
<p>当时写到这个题就接触到了这种思想:</p>
<p>要爬上一层楼梯要几步?1步 对吧；两层楼梯呢？1+1步，ok，一次走两步 也ok</p>
<p>那走三层呢?三层其实就是两层基础上又多走一层呗，那就直接用上了两层的走法再加一层走法就好了；后续同理</p>
<p>所以这题最重要的就是设立子问题：走上n-1层有多少种解法，走上n-2层又有多少种解法，两个之和就是上n层可能的组合数</p>
<ul>
<li><p><strong>确定状态：</strong>dp[i]表示为走到了第n阶台阶的组合数</p>
</li>
<li><p><strong>转移方程：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始与边界条件：</strong>好像没有特别的边界条件</p>
</li>
<li><p><strong>计算顺序：</strong>正序</p>
</li>
</ul>
<p>ps：我第一次解出来这个用的是迭代 那我顺便写一下迭代写法8</p>
<p>迭代解法代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> first = <span class="number">1</span>,second = <span class="number">2</span>,third = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">                third = first+second;</span><br><span class="line">                first = second;</span><br><span class="line">                second = third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DP解法代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008142356074.png" alt="image-20201008142356074"></p>
<p>这道题第一次纯暴力直接超时，后来想到了中心扩散的办法：枚举字符串各位置然后向两边扩散，但这方法感觉不具备一般性，于是虚心学习了DP的解法，这道题最优解法应该是线性的马拉车算法，但那个太难了且不具备一般性，我以后再学吧…</p>
<p>DP思路:</p>
<p>用一个二维数据dp[I] [j]来表示字符串i….j是否为回文字符串；</p>
<ul>
<li><strong>状态转移方程</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>什么意思呢？意思就是<code>i...j</code>假如是回文串的话 等价于 两端字符相同且其中间部分也为回文字符串</p>
<ul>
<li><strong>边界条件</strong>：假如s[i] == s[j]且长度为2或者3 那么一定是回文字符串了 ；</li>
</ul>
<p>DP代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判1</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//特判2 假如是一个字符肯定是回文串</span></span><br><span class="line">        String ans = s.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][]dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j用于遍历数组 i紧随其后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="comment">//如果不相等，则为false</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] != a[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//j - i &lt; 3是什么意思呢？</span></span><br><span class="line">                    <span class="comment">//其实是当s[i..j]长度为2或3的时候 假如头尾相等那么这段肯定是回文串了</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//否则取决于中间是否为回文串</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假如首位相同 且 长度比之前的答案长度要长 则重新截取</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; ans.length())&#123;</span><br><span class="line">                    ans = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008203417632.png" alt="image-20201008203417632"></p>
<p>这题和之前的爬楼梯有异曲同工之妙，为什么呢？</p>
<p>我们爬楼梯爬n层；这题需要凑够n的数值</p>
<p>我们爬楼梯有爬1层，2层；这题是用a元，b元，c元去凑；</p>
<p>ok，我们回到这题来，怎么解决呢？</p>
<p>假设有k枚硬币：a1,a2…ak凑成了目标amount 因此存在最后一枚硬币ak，那么前面的面值加起来=amount-ak</p>
<p>没错吧？因此我们得到了<strong>原问题</strong>和子问题关系啦：<strong>最少用多少枚硬币拼成amount</strong>→<strong>最少用多少枚硬币拼成amount-ak</strong></p>
<ul>
<li><p><strong>确定状态</strong>：dp[n]表示当前的目标金额是n，至少需要dp[n]个硬币凑出该金额</p>
</li>
<li><p><strong>转移方程</strong>：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125223125406.png" alt="image-20201125223125406"></p>
<p>i 为 最少用多少枚硬币拼成 i ；</p>
<p>coin 为 我们可利用的硬币面值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始条件与边界</strong>：</p>
<ul>
<li><strong>边界</strong>:i - coin &lt; 0 意思是不存在能凑成差值的方法，定义为正无穷</li>
<li><strong>初始条件</strong>：基准值，就是不能算出来的值，需要用到这个去推理得到其他的结果的值：<strong>dp[0] = 0</strong> 为什么呢  不需要硬币肯定是0</li>
</ul>
</li>
<li><p><strong>计算顺序</strong>：到底是应该直接从最大面值开始还是最小面值开始呢？</p>
<p>为了算dp[x] 我们需要用到dp[x - 1]..d[x - 2] 因此是正序遍历</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判1</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//特判2</span></span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">0</span>) <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>, dp.length, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">//迭代器遍历 直接取出数组每个数值 外层for循环所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">//判断差值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin ; i &lt;= amount; i++) &#123;</span><br><span class="line">                <span class="comment">//假如存在可以凑成差值的组合的话</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i - coin] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="comment">//状态转移 在已经有的组合 和 拼出i - coin枚硬币数+自己的一枚中选择一个少的</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如有解的话 输出</span></span><br><span class="line">        <span class="keyword">if</span>(dp[amount] != Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题08-11-硬币"><a href="#面试题08-11-硬币" class="headerlink" title="面试题08.11. 硬币"></a>面试题08.11. 硬币</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008212810143.png" alt="image-20201008212810143"></p>
<p>为什么把这题放在零钱兑换下面呢 其实这两题大致相同，只不过一个是要在所有组合数中选择硬币数最小的；</p>
<p>而这题是统计所有的组合数</p>
<p>同样的方法:</p>
<ul>
<li><p><strong>确定状态</strong>:dp[n]为组成总面额为n的情况数</p>
</li>
<li><p><strong>转移方程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始条件与边界</strong>：dp[0] = 1 组成0的方法有1种，就是什么都不放，同时这也是边界限制条件 若 i - coin = 0 也就是面值正好时，可以只放一个硬币了 也就是1</p>
</li>
<li><p><strong>计算顺序</strong>：同样是正序遍历</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指Offer-47-礼物的最大价值"><a href="#剑指Offer-47-礼物的最大价值" class="headerlink" title="剑指Offer 47.礼物的最大价值"></a>剑指Offer 47.礼物的最大价值</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009163618327.png" alt="image-20201009163618327"></p>
<p>这题就是模拟走迷宫，边走边DP求最大值就好了</p>
<ul>
<li><p><strong>确定状态</strong>：dp[i] [j]为走到i，j处的最大值；</p>
</li>
<li><p><strong>转移方程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始条件与边界</strong>：这道题我是取了巧方法，并不是在原地图遍历的，而是额外开的一个二维数组模拟，同时我的行列都+了1，有效保证上下左右都可以走，不然还得多考虑边界问题，很麻烦。</p>
</li>
<li><p><strong>计算顺序</strong>，由于起点在左上角，终点右下角，那么正序遍历就好</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//dp数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">//到达[i,j]只有两种可能性从[i - 1][j - 1]出发后先向右再向下或先向下再向右</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里返回的就是dp[m][n]了 因为相当于把原地图放在了新dp图的左下方</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201012103255728.png" alt="image-20201012103255728"></p>
<p>这题和上面一题其实非常像，一开始我傻傻的把Max改成了min然后直接提交，结果错了，答案是3而不是7。</p>
<p>后来我仔细画图走了一遍流程发现了问题。</p>
<p>我们由于不限定最上面一行只能向右走，最左边一行只能向下走（原点除外）；</p>
<p>导致了我们会跳过那些必走的格子，直接空降了。（因为这样肯定是最小的，逃避了必须走的路）</p>
<p>因此这题和上面的最大价值不一样，必须限定边界走法，那上一题为什么不用呢？因为他是取最大值，他巴不得多走一点路。</p>
<ul>
<li><p><strong>确定状态</strong>：dp[i] [j]为走到i，j处的最小值；</p>
</li>
<li><p><strong>转移方程</strong>：</p>
<p>如果是原点，那就是原地图原点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>如果是最上面一行（除原点），那只能是由左边走到右边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j != <span class="number">1</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] +grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>如果是最左边一列（除原点），那只能是由上面走到下面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>其余的话，和之前的没变，把max改成min即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>初始条件与边界</strong>：初始条件不用说了，dp二维数组用0填充，表示价值为0，边界条件这题就不能和上一问一样不去考虑了，必须考虑最上面和最左边</p>
</li>
<li><p><strong>计算顺序</strong>：左上角是起点，右下角是终点。正序遍历。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//dp数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//最左边一列（除了原点） 只能是由上面往下走</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//最上面一行（除了原点） 只能是由左边向右走</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j != <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] +grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里返回的就是dp[m][n]了 因为相当于把原地图放在了新dp图的左下方</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673.最长递增子序列的个数"></a>673.最长递增子序列的个数</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009212657392.png" alt="image-20201009212657392"></p>
<p>这题有两个信息需要去记录：</p>
<ol>
<li>递增子序列最长可以是多少</li>
<li>以不同索引结尾的序列的长度是多少</li>
</ol>
<ul>
<li><p><strong>确定状态</strong></p>
<ul>
<li><strong>dp[i]</strong>表示以<strong>nums[i]</strong>结尾的最长递增子序列<strong>长度</strong></li>
</ul>
</li>
<li><p><strong>count[i]</strong>表示以<strong>nums[i]</strong>结尾的最长递增子序列<strong>个数</strong></p>
</li>
<li><p><strong>转移方程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> count[i] = count[j];</span><br><span class="line">or</span><br><span class="line"> count[i] += count[j];</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong>初始条件与边界</strong>：dp[i]应该全部被初始化为1，因为所有单个值可以成为一个长度为1的最长递增序列，同理count[i]也应该被初始化为1</li>
<li><strong>计算顺序</strong>：<strong>外层i遍历 [0…..n] ，内层j遍历 [0….i]  其中j &lt; i</strong></li>
</ul>
<p>这题的关键就在于统计count这个数组，count数组更新需要这几个条件:</p>
<ol>
<li><p><strong>nums[i] &gt; nums[j]</strong> 后面数值要大于前面的</p>
</li>
<li><p><strong>dp[j] &gt;= dp[i]</strong> 前面的dp数组要比后面的大 怎么可能呢?只有一种情况，那就是第一次遇到以nums[i]结尾的最长递增子序列。此时的长度就为 <strong>dp[j] + 1</strong> ，而<strong>count[i]</strong>也相应的等于<strong>count[j]</strong>；</p>
<p>以<strong>nums[i]</strong>结尾的最长递增子序列的组合数=以<strong>nums[j]结尾</strong>的最长递增子序列的组合数</p>
<p>这个可以这么理解：当 <strong>[…j]</strong> 形成的组合数是值A的话，其每一种组合结尾补上 <strong>[i]</strong> ,即<strong>[…j,i]</strong>对于组合数本身是没有增加的，还是A值，唯独只是递增子序列的长度+1了。</p>
</li>
<li><p><strong>dp[j] + 1 = dp[i]</strong>，假如之前的长度加上现在遍历到的长度=已经存在的dp[i]长度 那就证明dp[j]长度找过一次了，现在的组合数+count[j] 即可</p>
</li>
</ol>
<p>LeetCode一个大佬带图分析的 我觉得真的写的很好：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009220524667.png" alt="image-20201009220524667"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//dp[i]表示以nums[i]结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//count[i] 表示以 nums[i]结尾的最长递增子序列个数 最后加起来用的</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(count, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">//因为i先走，如果j &lt; i，那么可以把nums[j]添加到以nums[i]结尾的序列中</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="comment">//序列假如比dp[i]的要长</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j]  &gt;= dp[i]) &#123;</span><br><span class="line">                        <span class="comment">//那么就有coont[j]个长度为dp[j]的序列</span></span><br><span class="line">                        count[i] = count[j];</span><br><span class="line">                        <span class="comment">//序列长度更新</span></span><br><span class="line">                        dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//假如序列长度相等</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">                        <span class="comment">//就有count[j]个额外序列 +起来</span></span><br><span class="line">                        count[i] += count[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不停更新最长的长度</span></span><br><span class="line">            len = Math.max(len, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//假如以nums[i]结尾的序列长度为最长的 答案+上相应的种类数</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == len) ans += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1143-最长公共子序列（LCS问题）"><a href="#1143-最长公共子序列（LCS问题）" class="headerlink" title="1143.最长公共子序列（LCS问题）"></a>1143.最长公共子序列（LCS问题）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010214127838.png" alt="image-20201010214127838"></p>
<p>这题是找出最长公共子序列，意思是说不一定要在串1中找到完整的串2；而是要让串2尽量长的出现在串1之中；</p>
<p>那么也就是说，需要分别记录两个字符串不同长度的时候所得到的最长公共子序列，为了方便用一个二维数组记录就好:行代表第一个串长度，列代表第二个串长度；</p>
<p>可以这么去想：两个串从0开始逐渐增大，其中父串是一个一个单位增长，而子串在每次嵌套的循环中从0一直增长到它自己的长度。然后在嵌套循环中比较，进行dp，最后在右下角的dp值就是答案了，因为父子串都遍历完了。</p>
<ul>
<li><p><strong>确定状态</strong>：dp[i] [j]，i表示text1的前i个字符，j表示text2的前j个字符，而dp[i] [j]表示 S1前i个字符与S2前j个字符所可以得到的最长公共子序列的长度。</p>
</li>
<li><p><strong>转移方程</strong>：</p>
<p>如果字符相等（<strong>S1[i] == S2[j]</strong>）的话，就可以把这个字符算进最长公共子序列（LCS）中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果字符不相等（<strong>S1[i] != S2[j]</strong>）的话，只有2种可能性，要么是S[i]的字符不在lcs种，要么是S2[j]的字符不在lcs中。</p>
<p>问题来了 有没有可能S1[i]和S2[j]这两个字符都不在LCS中呢？当然有这种可能性，但是那样的话就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>但你想想，第三种的情况的长度一定是最小的，他永远不可能被取到。多此一举了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>边界与初始条件</strong>：dp[i] [j]初始化为0，因为一开始都没遍历。边界条件可以通过行列各增加一列去解决</p>
</li>
<li><p><strong>计算顺序</strong>：由于我们的二维数组右下角，也就是两个字符串都遍历完了就是结果，因此是正序遍历。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(text1.equals(text2)) <span class="keyword">return</span> text1.length();</span><br><span class="line">        <span class="keyword">if</span>(text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp[][]数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">//如果字符相同 纳入LCS</span></span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//选择选一个能让LCS长度尽量大的</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右下角就是答案了</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015203222620.png" alt="image-20201015203222620"></p>
<p>这题唯一有意思的点在于dp的状态转移由原来常见的2个情况变成了3个情况，但是大体其实是换汤不换药，按照老路求解就好，不算难</p>
<p>简单说下思路：用一个二维数组dp[i] [j]表示<strong>word1[0..i]到word2[0…j]转换需要的最小次数</strong>，由于i &lt;= word1长度， j &lt;= word2长度</p>
<p>因此最后是返回<strong>dp[word1长度] [word2长度]</strong>；</p>
<p>假如word1[i ] == word2[j]  表示在该处不需要变化 dp[i] [j] =dp[i - 1] [j - 1];</p>
<p>word1[i] != word2[j]，那么就有三种情况:</p>
<ol>
<li><strong>增添法</strong>：基于word1[0….i]与word2[0…j-1]的编辑距离，让word1[i + 1] =word2[j]</li>
<li><strong>删除法</strong>：基于word1[0…i - 1]与word2[0….j]的编辑距离，让word[i] = word2[j +1]</li>
<li><strong>替换法</strong>：基于word1[0….i - i]与word2[0….j - 1]的编辑距离，让word1[i] = word2[j]</li>
</ol>
<p>然后从这些方法得到的dp数组中取最小的那个</p>
<ul>
<li><p><strong>确定状态：</strong>dp[i] [j]表示<strong>word1[0..i]到word2[0…j]转换需要的最小次数</strong></p>
</li>
<li><p><strong>状态转移方程：</strong></p>
<p>word1[i] == word2[j]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>else</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始值与边界条件：</strong>考虑word1为空与word2为空两种极端情况将第一列第一行分别初始化好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如word1为空，想转成word2只能通过添加 i+1 个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//假如word2为空，想转成word2只能通过删除 i+1 个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong>计算顺序：</strong>最终返回dp[m] [n]，正序遍历即可</li>
</ul>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int m &#x3D; word1.length(), n &#x3D; word2.length();</span><br><span class="line">        if(m &#x3D;&#x3D; 0) return n;</span><br><span class="line">        if(n &#x3D;&#x3D; 0) return m;</span><br><span class="line">        &#x2F;&#x2F;dp[i][j]表示word1[0...i]到word2[0...j]转化需要的次数，因此我们最后返回值是dp[m][n]</span><br><span class="line">        int[][] dp &#x3D; new int[m + 1][n + 1];</span><br><span class="line">        &#x2F;&#x2F;假如word1为空，想转成word2只能通过添加 i+1 个字符</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            dp[0][i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;假如word2为空，想转成word2只能通过删除 i+1 个字符</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 1;i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">                if(word1.charAt(i - 1) &#x3D;&#x3D; word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="DFS思想"><a href="#DFS思想" class="headerlink" title="DFS思想"></a>DFS思想</h2><h2 id="DFS-LeetCode相关"><a href="#DFS-LeetCode相关" class="headerlink" title="DFS - LeetCode相关"></a>DFS - LeetCode相关</h2><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>思路参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43314519/article/details/107797559">https://blog.csdn.net/weixin_43314519/article/details/107797559</a></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114203057671.png" alt="image-20201114203057671"></p>
<p>对于这道题，我们首先需要把敲的数字与字母对应起来 → 用到了HashMap （当然了，用数组也是可以，用下下标表示嘛）</p>
<p>那么下一个问题，怎么进行组合配对呢？</p>
<p>想一想 假如是数字2[“abc”]，答案怎么求呢？==注意，下面的所有代码都是伪代码==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = List()</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len(<span class="string">&quot;abc&quot;</span>);i++) &#123;</span><br><span class="line">    <span class="comment">//这里的i并不是数字，而是i代表的那个字符</span></span><br><span class="line">    tmp = i</span><br><span class="line">    result.add(tmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>如果是数字23[“abc”,”def”]，答案又怎么求呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = List()</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len(<span class="string">&quot;abc&quot;</span>);i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len(<span class="string">&quot;def&quot;</span>);j++) &#123;</span><br><span class="line">    <span class="comment">//tmp 是 i字符 + j字符的组合</span></span><br><span class="line">        tmp = i+j</span><br><span class="line">        result.add(tmp)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>由此 不难发现 我们键盘输入的字符串（数字长度）决定了循环嵌套次数</p>
<p>后面就不写了，简单来说就是下面这个图的解决方式:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20200804201145912.png" alt="在这里插入图片描述"></p>
<p>我们上文并没有提到递归，为什么这个图有<strong>调用递归</strong>的字样呢?</p>
<p>想一想，我们上面提到了 字符串的长度决定了循环嵌套的层数，但我们的层数是变化的，那我们不就确定不了了嘛？</p>
<p>因此，我们使用<mark>递归<mark>，我们只需要设立一个<mark>基准线</mark>，到达基准线了，就说明递归完了，就这么简单。</mark></mark></p>
<ul>
<li><p><strong>递归终止的条件</strong>：</p>
<p>上面我们说到，如果数字字符串（23，235，2378）遍历到了最后一个了，那就说明该行程的组合都形成了，在这一层只需要把传过来的letter放在结果list里就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index记录了遍历到的字符串位置（数字字符串）</span></span><br><span class="line"><span class="comment">//长度相同 说明遍历完了 该返回了</span></span><br><span class="line"><span class="keyword">if</span>(index == str.length()) &#123;</span><br><span class="line">       res.add(letter);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>每一层递归应该进行什么处理</strong>：我们应该进行<strong>定位</strong>，把当前遍历到了哪个数字 转成相应的字符串，然后把该字符串当成我们需要研究的参数再传进下一层的递归里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line">        <span class="comment">//第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(index);</span><br><span class="line">        <span class="comment">//我们上面的c是字符，需要 - &#x27;0&#x27;转成int型 这样才能当hashmap的key用嘛</span></span><br><span class="line">        <span class="keyword">int</span> pos = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//通过pos定位，取出map中对应的字符串</span></span><br><span class="line">        String pos_letter = map.get(pos);</span><br><span class="line">        <span class="comment">//把上面一步得到的字符串拿来遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos_letter.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//要注意 现在的letter是之前的letter加上当前遍历的pos串上各字符</span></span><br><span class="line">            <span class="comment">//同时 index</span></span><br><span class="line">            DFS(str, letter + pos_letter.charAt(i), index + <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong>每一层递归返回值</strong>：由于是把结果传进一个list里，因此硬要说返回值的话 应该是结果letter吧。但是这里并没有明显的返回值</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//map 数字和字母行程映射</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存值</span></span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(digits, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(String str, String letter, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//index记录了遍历到的字符串位置（数字字符串）</span></span><br><span class="line">        <span class="comment">//长度相同 说明遍历完了 该返回了</span></span><br><span class="line">        <span class="keyword">if</span>(index == str.length()) &#123;</span><br><span class="line">            res.add(letter);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line">        <span class="comment">//第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(index);</span><br><span class="line">        <span class="comment">//我们上面的c是字符，需要 - &#x27;0&#x27;转成int型 这样才能当hashmap的key用嘛</span></span><br><span class="line">        <span class="keyword">int</span> pos = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//通过pos定位，取出map中对应的字符串</span></span><br><span class="line">        String pos_letter = map.get(pos);</span><br><span class="line">        <span class="comment">//把上面一步得到的字符串拿来遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos_letter.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//要注意 现在的letter是之前的letter加上当前遍历的pos串上各字符</span></span><br><span class="line">            <span class="comment">//同时 index</span></span><br><span class="line">            DFS(str, letter + pos_letter.charAt(i), index + <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="46-全排列Ⅰ、全排列Ⅱ"><a href="#46-全排列Ⅰ、全排列Ⅱ" class="headerlink" title="46.全排列Ⅰ、全排列Ⅱ"></a>46.全排列Ⅰ、全排列Ⅱ</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114215549798.png" alt="image-20201114215549798"></p>
<p>这题其实与上一题有异曲同工之妙，都是排列组合问题，因此我们的终止条件其实也差不多 当遍历的index == nums的长度就代表着有一种组合了，把这个组合添加进结果list就好了</p>
<p>这道题网上其实也有很多解析了，都用到了下面这个图，那我也贴上来吧：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzBiZjE4ZjliODZhMjU0MmQxZjZhYThkYjZjYzQ1NDc1ZmNlNWFhMzI5YTA3Y2EwMmE5MzU3YzJlYWQ4MWVlYzEtaW1hZ2UucG5n" alt="image.png"></p>
<p>是这么说明的：</p>
<p>1、每一个结点表示了“全排列”问题求解的不同阶段，这些阶段通过变量的“不同的值”体现；<br>2、这些变量的不同的值，也称之为“状态”；<br>3、使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；<br>4、因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；<br>5、深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，<code>path</code> 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 <code>path</code> 变量是一个栈。<br>6、深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。</p>
<p>其实这段话这么多字，关键其实就2点：</p>
<ol>
<li>DFS有回溯这一说法，因此前面设置的 用于运算的状态变量需要重置掉</li>
<li>通过回溯操作，整个运算流程其实就用了一个状态变量</li>
</ol>
<p>ok，回到这道题；</p>
<ul>
<li><p><strong>递归终止的条件:</strong></p>
<p>就像我们上面说的，index == nums.length 的时候 说明子答案产生了 ，把答案存进来就好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index == nums.length) &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(subnums));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这存在一个坑，<code>res.add(new ArrayList&lt;&gt;(subnums));</code>？为什么不是<code>res.add(subnums);</code></p>
<p>通过这里我也学到了新知识：</p>
<p>subnums变量指向的对象在递归过程中始终只有一份，而DFS每完成一次，都需要撤销之前的所有选择，因此这个变量会重新变为空</p>
<p>Java中都是值传递，对象类型变量传参过程中，复制的是<strong>变量地址</strong></p>
<p>地址添加到了res里面，而里面的列表对象又是空的，肯定是不对的。</p>
<p>因此需要进行一次拷贝/重新创建对象，把sublist传进去：<code>res.add(new ArrayList&lt;&gt;(subnums));</code>才OK</p>
</li>
<li><p><strong>每一层递归应该进行什么处理:</strong></p>
<p>首先判断遍历的数是否用过了 有就跳过，没有就判成true</p>
<p>然后遍历到的值传进subnums里 进入下一次递归中，同时 index需要+1</p>
<p>每当一次DFS结束后，别忘了手动撤销状态（包括visited数组重置，还有把subnums数组重置）；</p>
<p>这里我当时自作聪明：在每一次结束后自己还把<code>index--</code>了，结果答案出错了</p>
<p>原因在于：index会自己消减的- -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    subnums.add(nums[i]);</span><br><span class="line">    DFS(nums, subnums, index + <span class="number">1</span>, visited);</span><br><span class="line">    visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    subnums.remove(subnums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>每一层的返回值:</strong></p>
<p>同样的，好像确实没有什么返回值</p>
</li>
</ul>
<p>画了个非常非常潦草的运算流程，我自己都看不下去：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201114223620257.png" alt="image-20201114223620257"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//答案list</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放可能行程的每种组合</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//判断nums中元素是否用过了的数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        ArrayList&lt;Integer&gt; subnums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        DFS(nums, subnums, <span class="number">0</span> , visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; subnums, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(subnums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            subnums.add(nums[i]);</span><br><span class="line">            DFS(nums, subnums, index + <span class="number">1</span>, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            subnums.remove(subnums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201119170323122.png" alt="image-20201119170323122"></p>
<p>这个<strong>全排列Ⅱ</strong>与<strong>全排列Ⅰ</strong>其实并没有多大差别，只是多了个排序以及剪枝叶的步骤；</p>
<p>排序有什么用呢？假如我们不排序，只剪枝：</p>
<p>那么剪纸中的<code>nums[i] == nums[i - 1] &amp;&amp; visited[i - 1] == false</code>这一步还有啥意义呢？我挨着的不相同，但是在几个位置外还有个重复的，那不就把它纳入答案中了吗？因此如果想用<code>nums[i] == nums[i - 1] &amp;&amp; visited[i - 1] == false</code>作为判断条件，就必须排序，这样的话，如果挨着相同，就可以轻松派出这种情况了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201119171211465.png" alt="image-20201119171211465"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//判断nums中元素是否用过了的数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        ArrayList&lt;Integer&gt; subnums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里比全排列多了一步排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        DFS(nums, subnums, <span class="number">0</span> , visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; subnums, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(subnums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//与全排列Ⅰ一样，如果数用了就跳过</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//多了一步:就算前面的数是没有用过的，但是与前面的数相同了，我也不能够纳入答案里面，必须跳过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            subnums.add(nums[i]);</span><br><span class="line">            DFS(nums, subnums, index + <span class="number">1</span>, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            subnums.remove(subnums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote>
<p>八大排序分别为：直接插入排序、希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210514225141391.png" alt="image-20210514225141391"></p>
<p>排序中会经常出现一个词<strong>稳定</strong>：这个词表达的意思是，如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是 <strong>稳定</strong> 的。反之，则是 <strong>非稳定</strong> 的。</p>
<p>用一张图来概述：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20210604170246182.png" alt="十大排序算法"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<ul>
<li>基本思想: 冒泡排序，类似于水中冒泡，较大的数沉下去，较小的数慢慢冒起来，假设从小到大，即为较大的数慢慢往后排，较小的数慢慢往前排。</li>
<li>直观表达，每一趟遍历，将一个最大的数移到序列末尾。即外部循环决定遍历的趟数，内部循环每一趟确定最大数，次最大数，次次最大数…</li>
</ul>
</blockquote>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/bubble.gif" alt="img"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环控制比较的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//内层循环控制到达位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//前面的元素比后面大就交换</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>复杂度分析</strong></li>
</ul>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>什么时候最快：当输入的数据已经是正序时 O(n)</p>
<p>什么时候最慢：当输入的数据是反序时 O(n²)</p>
<p>平均时间复杂度：O(n²)</p>
<p>空间复杂度：只有缓存的temp变量需要内存空间，O(1)</p>
<p>稳定性：稳定</p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>从未排序序列中，找到关键字最小的元素</li>
<li>如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换</li>
<li>重复1、2步，直到排序结束。</li>
</ol>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-Lm9JtwbhXVOfXyecToy%2F-Lm9KQIJAMvCgJQzErQS%2F-Lm9KSObDh5VGWhPE8Wh%2FselectionSort.gif?alt=media" alt="img"></p>
<p>直观数据例子：</p>
<p>第一趟的排序过程</p>
<p>原始序列：49、38、65、97、76、13、27、49</p>
<p>1）在进行选择排序过程中分成有序和无序两个部分，开始都是无序序列</p>
<p>结果：49、38、65、97、76、13、27、49</p>
<p>2）从无序序列中取出最小的元素13，将13同无序序列第一个元素交换，此时产生仅含一个元素的有序序列，无序序列减一</p>
<p>结果：{13、}   {38、65、97、76、49、27、49}</p>
<p>3）从无序序列中取出最小的元素27，将27同无序序列第一个元素交换，此时产生仅两个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、}   {65、97、76、49、38、49}</p>
<p>4）从无序序列中取出最小的元素38，将38同无序序列第一个元素交换，此时产生含三个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、38、}   {97、76、49、65、49}</p>
<p>5）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含四个个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、38、49、}   {76、97、65、49}</p>
<p>6）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含五个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、38、49、49、}   {97、65、76}</p>
<p>7）从无序序列中取出最小的元素65，将65同无序序列第一个元素交换，此时产生含六个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、38、49、49、65}   {97、76}</p>
<p>8）从无序序列中取出最小的元素76，将76同无序序列第一个元素交换，此时产生含七个元素的有序序列，无序序列减一</p>
<p>结果：{13、27、38、49、49、65、76、}   {97}</p>
<p>9）最后一个元素肯定是最大元素，无序排序直接生产一个有序的序列</p>
<p>结果：{13、27、38、49、49、65、76、97}</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小值不等于当前值时进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[min];</span><br><span class="line">            a[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>什么时候最快：当输入的数据已经是正序时，但每次都得检查一下，因此是： O(n²)</p>
<p>什么时候最慢：当输入的数据是反序时 O(n²)</p>
<p>平均时间复杂度：O(n²)</p>
<p>空间复杂度：只有缓存的temp变量需要内存空间，O(1)</p>
<p>稳定性：不稳定</p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><blockquote>
<p>基本思想：每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。</p>
</blockquote>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20190520154334634.jpg" alt="img"></p>
<h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; num &lt; a[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul>
<li>（冒泡）<a target="_blank" rel="noopener" href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/10/08/%E7%AE%97%E6%B3%95/" data-id="ckppikuec001np0wi0ebf7z50" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaWeb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/10/01/JavaWeb/" class="article-date">
  <time datetime="2020-10-01T09:10:47.425Z" itemprop="datePublished">2020-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2020/10/01/JavaWeb/">JavaWeb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><h2 id="1-1、web开发"><a href="#1-1、web开发" class="headerlink" title="1.1、web开发"></a>1.1、web开发</h2><ul>
<li><p>什么是web？web就是网页 比如百度</p>
</li>
<li><p>静态资源和动态资源区别：</p>
<ul>
<li><p>静态资源/静态web：</p>
<ul>
<li>html，css</li>
<li>所有人看到的东西都一样</li>
</ul>
</li>
<li><p>动态资源/动态web：</p>
<ul>
<li><p>servlet、jsp、ASP</p>
</li>
<li><p>看到的东西有可能是不一样的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2、web应用程序"><a href="#1-2、web应用程序" class="headerlink" title="1.2、web应用程序"></a>1.2、web应用程序</h2><p>web应用程序是什么？是我们用可以用浏览器所访问的程序 不同于之前的用编译器然后控制台运行的程序</p>
<ul>
<li>网页：xxx.html类似于此类后缀文件</li>
<li>web应用程序的组成部分：<ul>
<li>html，css，js（静态资源）</li>
<li>jsp，servlet（动态资源）</li>
<li>jar包</li>
<li>配置文件 properties</li>
<li>java程序</li>
</ul>
</li>
</ul>
<p>web程序写完后，外界想访问 需要一个服务器进行管理</p>
<h2 id="1-3、静态web（服务器）"><a href="#1-3、静态web（服务器）" class="headerlink" title="1.3、静态web（服务器）"></a>1.3、静态web（服务器）</h2><ul>
<li>后缀为：.html 此类的 只要一直保存在服务器端 那就能直接被读取</li>
<li>此处的webserver为：apache/iis等</li>
<li><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E9%9D%99%E6%80%81web.png" alt="image-20200728024108377"></li>
<li>客户端通过发送请求到服务器端，其中webservice访问xxx.html 得到数据，通过web service这个服务再做出响应给客户端。常用的WebServer为Apache，tomcat等。</li>
<li>静态web特点：<ul>
<li>无法更新，很僵硬<ul>
<li>轮播图</li>
<li>JavaScript</li>
</ul>
</li>
<li>无法与数据库交互，数据无法持久化，用户无法交互</li>
</ul>
</li>
</ul>
<h2 id="1-4、动态web（服务器）"><a href="#1-4、动态web（服务器）" class="headerlink" title="1.4、动态web（服务器）"></a>1.4、动态web（服务器）</h2><ul>
<li>此处的webserver为：apache/iis等</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E5%8A%A8%E6%80%81web.png" alt="image-20200728025953481"></p>
<ul>
<li>动态web特点：<ul>
<li>若动态web资源出现错误，后台程序需要重新写→停机维护</li>
<li>web页面可以更新</li>
<li>可以与数据库交互，把数据持久化（注册账号，修改信息等）</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001170339068.png" alt="image-20201001170339068"></p>
<p>或是这么理解：浏览器≈客户端</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/%E7%AE%80%E7%95%A5%E5%9B%BE.png" alt="img"></p>
<h1 id="2、web服务器"><a href="#2、web服务器" class="headerlink" title="2、web服务器"></a>2、web服务器</h1><h2 id="2-1、技术讲解"><a href="#2-1、技术讲解" class="headerlink" title="2.1、技术讲解"></a>2.1、技术讲解</h2><ul>
<li><p><strong>ASP：</strong></p>
<ul>
<li><p>微软，运用的就是ASP</p>
</li>
<li><p>是HTML语言中夹杂着VB脚本，即ASP+COM:ASP做前台页面，后台使用VB COM+组件对数据进行操作</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        &lt;%&gt;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">        &lt;/%&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li>PHP<ul>
<li>开发速度快，跨平台，代码简单</li>
<li>无法承担大的访问量</li>
</ul>
</li>
<li><strong>Jsp/Servlet</strong><ul>
<li>是基于Java语言的</li>
<li>可以承载三高问题：高并发，高性能，高可用</li>
<li>语法与ASP相似</li>
</ul>
</li>
</ul>
<h2 id="2-2、web服务器与web应用服务器"><a href="#2-2、web服务器与web应用服务器" class="headerlink" title="2.2、web服务器与web应用服务器"></a>2.2、web服务器与web应用服务器</h2><p>web服务器干嘛的？由上述流程图可以看到，是用来处理用户的一些请求，给用户响应信息的。</p>
<p>web服务器分为2类：</p>
<ul>
<li>　　web服务器，如：</li>
</ul>
<p>　　　　Apache服务器</p>
<p>　　　　Nginx</p>
<p>　　　　IIS</p>
<ul>
<li>web应用服务器，如</li>
</ul>
<p>　　　　Tomcat</p>
<p>　　　　resin</p>
<p>　　　　jetty</p>
<p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源</p>
<p>并发：web服务器的并发能力远高于web应用服务器</p>
<h1 id="3、Tomcat"><a href="#3、Tomcat" class="headerlink" title="3、Tomcat"></a>3、Tomcat</h1><p><strong>引言/介绍</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E5%9B%BE%E6%A0%87.png" alt="image-20200730163105323"></p>
<ul>
<li><p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/6265">Apache</a>、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级<strong>应用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/服务器">服务器</a></strong>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。<strong>对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/标准通用标记语言/6805073">标准通用标记语言</a>下的一个应用）页面的访问请求。</strong>实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<p><strong>Tomcat 实际上运行JSP 页面和Servlet</strong>。目前Tomcat最新版本为9.0.37</p>
</li>
</ul>
<h2 id="3、1-安装Tomcat"><a href="#3、1-安装Tomcat" class="headerlink" title="3、1 安装Tomcat"></a>3、1 安装Tomcat</h2><p><strong><em>ps：要配置tomcat首先要配置好java的jdk</em></strong></p>
<p>配置java的方法:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39691535/article/details/95005254">https://blog.csdn.net/weixin_39691535/article/details/95005254</a></p>
<ul>
<li>Tomcat官网：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-90.cgi">https://tomcat.apache.org/download-90.cgi</a></li>
<li><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E5%AE%98%E7%BD%91.png" alt="image-20200730165337393"></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="image-20200730165523099"></p>
<h2 id="3、2-启动Tomcat"><a href="#3、2-启动Tomcat" class="headerlink" title="3、2 启动Tomcat"></a>3、2 启动Tomcat</h2><ul>
<li>文件夹信息作用：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png" alt="image-20200730165932307"></p>
<ul>
<li><p>启动，关闭:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917194602322.png" alt="image-20200917194602322"></p>
</li>
</ul>
<p>启动startup.bath后，浏览器搜索 “localhost:8080” 出现以下页面说明访问成功了：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A8.png" alt="image-20200731214723755"></p>
<h2 id="3、3-配置Tomcat"><a href="#3、3-配置Tomcat" class="headerlink" title="3、3 配置Tomcat"></a>3、3 配置Tomcat</h2><p>!(JavaWeb.assets/image-20200731215434250.png)</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%20index%E9%A1%B5%E9%9D%A2.png" alt="image-20200731221117828"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%20server.png" alt="image-20200731221813300"></p>
<p>这个Server.xml 文件是服务器核心配置文件 下面是其中文件内一部分</p>
<ul>
<li><p>作用:</p>
<ul>
<li>配置启动的端口号<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E7%AB%AF%E5%8F%A3.png" alt="image-20200731221940483"><ul>
<li>ps：tomcat默认端口号:8080</li>
<li>mysql默认端口号：3306</li>
<li>http默认端口号：80</li>
<li>https默认端口号：443</li>
</ul>
</li>
<li>配置主机的名字<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/Tomcat%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF.png" alt="image-20200731222208898"><ul>
<li>默认的主机名字:localhost == 127.0.0.1 (可以在hosts文件中找到)</li>
<li>默认网站应用存放位置为：webapps</li>
</ul>
</li>
<li>IP地址和端口的关系:<ul>
<li>简单理解：IP就是一个电脑节点的网络物理地址，就像你的家住的那个地址；端口是该计算机逻辑通讯接口，不同的应用程序用不同的端口，就像你家里的各个不同的房间，卧室用来睡觉，餐厅用来吃饭。</li>
</ul>
</li>
</ul>
</li>
<li><p>由此 我们可以解答一个疑问了:<strong>究竟网站是如何被访问的呢</strong>？</p>
<ul>
<li><p>第一步：输入一个域名，enter；</p>
</li>
<li><p>第二步：检查本机中 hosts配置文件 中是否含有这个域名映射；</p>
<ul>
<li><p>有：直接返回对应的ip地址 前者为ip地址 后者是域名，而我们ip地址中含有webapps 因此可以访问</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#	127.0.0.1       localhost</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有：去DNS服务器中找 DNS服务器≠本机 ，DNS通过解析把域名解析成ip 然后返回给客户端 让我们可以访问了。（其中还有交换机一类的进行处理，省略了）<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917194706889.png" alt="image-20200917194706889"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>简而言之：</p>
<pre><code>1、输入域名，域名解析(域名解析器 DNS)
2、向服务器发送http请求
3、传输层TCP协议，经过网络传输和路由解析
4、WEB服务器接收HTTP请求
5、服务器处理请求内容，并进行必要的数据交换
6、将相应的内容发回给客户端(响应)
7、浏览器解析HTML
8、显示解析好的内容</code></pre></li>
</ul>
<h2 id="3、4-引申-发布一个web网站"><a href="#3、4-引申-发布一个web网站" class="headerlink" title="3、4 引申-发布一个web网站"></a>3、4 引申-发布一个web网站</h2><ul>
<li>把自己写的网站放在服务器（此处为Tomcat）中指定的web应用文件夹（此处为webapps）下即可</li>
</ul>
<p>网站结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--webapps：Tomcat服务器的web目录</span><br><span class="line">       - ROOT</span><br><span class="line">       - XXXX,网站目录名 也就是我们所写的网站</span><br><span class="line">           - WEB-INF</span><br><span class="line">              -classes：java程序</span><br><span class="line">              -lib：web应用所依赖jar包</span><br><span class="line">              -web.xml：网站配置文件</span><br><span class="line">           - index.jsp/index.html 默认首页</span><br><span class="line">           - static</span><br><span class="line">               -css</span><br><span class="line">                 - style.css</span><br><span class="line">               -js</span><br><span class="line">               -img</span><br><span class="line">       - ...    </span><br></pre></td></tr></table></figure>

<h1 id="4、HTTP"><a href="#4、HTTP" class="headerlink" title="4、HTTP"></a>4、HTTP</h1><h2 id="4、1-什么是HTTP"><a href="#4、1-什么是HTTP" class="headerlink" title="4、1 什么是HTTP"></a>4、1 什么是HTTP</h2><p>HTTP (<strong>超文本传输协议</strong>）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<ol>
<li>文本：字符串, xxx.html</li>
<li>超文本：有链接文本</li>
<li>端口号：80</li>
</ol>
<p>HTTPs (其中的s表示security 安全)</p>
<ol>
<li>是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/身份认证/5294713">身份认证</a>保证了传输过程的安全性</li>
<li>端口号：443</li>
</ol>
<h2 id="4、2-HTTP的两个时代"><a href="#4、2-HTTP的两个时代" class="headerlink" title="4、2 HTTP的两个时代"></a>4、2 HTTP的两个时代</h2><ul>
<li>http1.0：</li>
<li>http1.1：</li>
</ul>
<h2 id="4、3-HTTP请求"><a href="#4、3-HTTP请求" class="headerlink" title="4、3 HTTP请求"></a>4、3 HTTP请求</h2><p>ps：用Chrome浏览器如果F12发现看不到数据的话需要再按一下F5刷新</p>
<ul>
<li><p>请求：客户端 → 发送请求 → 服务器</p>
</li>
<li><p>请求报文由三部分组成：<strong><em>请求行+请求头+请求体</em></strong></p>
</li>
<li><p>以百度为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">General:</span><br><span class="line">Request URL: https:<span class="comment">//www.baidu.com/  请求地址</span></span><br><span class="line">Request Method: GET   请求方法：GET方法/POST方法</span><br><span class="line">Status Code: <span class="number">200</span> OK  状态码：<span class="number">200</span></span><br><span class="line">Remote（远程） Address: <span class="number">182.61</span><span class="number">.200</span><span class="number">.6</span>:<span class="number">443</span> 服务器及其端口号</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade 协议</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902556.jpg" alt="HTTP请求报文"></p>
<h3 id="1、-请求行"><a href="#1、-请求行" class="headerlink" title="1、 请求行"></a>1、 请求行</h3><ul>
<li><p>请求行由①②③组成</p>
</li>
<li><p>请求行方式:<strong>Get Post</strong>（PUT\DELETE\HEAD\TRANSE..）后面是Rest风格的</p>
<ul>
<li>Get：可携带参数少，大小受限，浏览器URL栏内显示提交数据，不安全，但高效</li>
<li>Post：可携带参数多，大小不受限，浏览器URL栏内不显示提交数据，安全，但不高效</li>
</ul>
</li>
</ul>
<h3 id="2、-HTTP-Request-headers-消息头（请求头）"><a href="#2、-HTTP-Request-headers-消息头（请求头）" class="headerlink" title="2、 HTTP Request headers - 消息头（请求头）"></a>2、 HTTP Request headers - 消息头（请求头）</h3><ul>
<li>请求头由④组成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resquest <span class="title">Headers</span><span class="params">(请求头/消息头)</span>:</span></span><br><span class="line"><span class="function">Accept: text/html          告诉服务器，所支持数据类型</span></span><br><span class="line"><span class="function">Accept-Encoding: gzip, deflate, br 编码 → 浏览器告诉服务器，支持哪种编码格式</span></span><br><span class="line"><span class="function">Accept-Language: zh-CN,zh</span>;q=<span class="number">0.9</span>,zh-TW;q=<span class="number">0.8</span>,en-US;q=<span class="number">0.7</span>,en;q=<span class="number">0.6</span> 语言 → 支持哪种语言</span><br><span class="line">Cache-Control: max-age=<span class="number">0</span>     缓存控制 → 用来指定当前请求是否使用缓存机制</span><br><span class="line">Connection: keep-alive    连接 → 告诉服务器，请求后断开还是连接</span><br></pre></td></tr></table></figure>

<p>*<em>常用的请求头 *</em></p>
<ul>
<li>格式为 属性名：属性值</li>
</ul>
<table>
<thead>
<tr>
<th><strong>协议头</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
<th align="left"><strong>状态</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>可接受的响应内容类型（<code>Content-Types</code>）。</td>
<td>Accept: text/plain</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>可接受的字符集</td>
<td>Accept-Charset: utf-8</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的编码方式。</td>
<td>Accept-Encoding: gzip, deflate</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td>Accept-Language: en-US</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">临时</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于表示HTTP协议中需要认证资源的认证信息</td>
<td>Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td>Cache-Control: no-cache</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端（浏览器）想要优先使用的连接类型</td>
<td>Connection: keep-alive Connection: Upgrade</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Cookie</td>
<td>由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td>
<td>Cookie: $Version=1; Skin=new;</td>
<td align="left">固定：标准</td>
</tr>
<tr>
<td>Content-Length</td>
<td>以8进制表示的请求体的长度</td>
<td>Content-Length: 348</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td>
<td>Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td>
<td align="left">废弃</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的MIME类型 （用于POST和PUT请求中）</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Date</td>
<td>发送该消息的日期和时间（以<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td>
<td>Date: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Expect</td>
<td>表示客户端要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
<td align="left">固定</td>
</tr>
<tr>
<td>From</td>
<td>发起此请求的用户的邮件地址</td>
<td>From: <a href="mailto:user@itbilu.com">user@itbilu.com</a></td>
<td align="left">固定</td>
</tr>
<tr>
<td>Host</td>
<td>表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td>
<td>Host: <a target="_blank" rel="noopener" href="http://www.itbilu.com:80">www.itbilu.com:80</a> Host: <a target="_blank" rel="noopener" href="http://www.itbilu.com">www.itbilu.com</a></td>
<td align="left">固定</td>
</tr>
<tr>
<td>If-Match</td>
<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td>
<td>If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td align="left">固定</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>允许在对应的资源未被修改的情况下返回304未修改</td>
<td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记</td>
<td>If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td align="left">固定</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td>
<td>If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td align="left">固定</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td>
<td>If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制该消息可被代理及网关转发的次数。</td>
<td>Max-Forwards: 10</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个针对<a target="_blank" rel="noopener" href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td>
<td>Origin: <a target="_blank" rel="noopener" href="http://www.itbilu.com">http://www.itbilu.com</a></td>
<td align="left">固定: 标准</td>
</tr>
<tr>
<td>Pragma</td>
<td>与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td>
<td>Pragma: no-cache</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>用于向代理进行认证的认证信息。</td>
<td>Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Range</td>
<td>表示请求某个实体的一部分，字节偏移以0开始。</td>
<td>Range: bytes=500-999</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td>
<td>Referer: <a target="_blank" rel="noopener" href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td>
<td align="left">固定</td>
</tr>
<tr>
<td>TE</td>
<td>浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td>
<td>TE: trailers,deflate</td>
<td align="left">固定</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的身份标识字符串</td>
<td>User-Agent: Mozilla/……</td>
<td align="left"></td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求服务器升级到一个高版本协议。</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Via</td>
<td>告诉服务器，这个请求是由哪些代理发出的。</td>
<td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td>
<td align="left">固定</td>
</tr>
<tr>
<td>Warning</td>
<td>一个一般性的警告，表示在实体内容体中可能存在错误。</td>
<td>Warning: 199 Miscellaneous warning</td>
<td align="left">固定</td>
</tr>
</tbody></table>
<h3 id="3、-请求体"><a href="#3、-请求体" class="headerlink" title="3、 请求体"></a>3、 请求体</h3><ul>
<li><p>请求体由⑤组成</p>
</li>
<li><p>这个就是我们要上传的实质数据，比如：name=apple&amp;password=123456</p>
</li>
</ul>
<h2 id="4、4-HTTP响应"><a href="#4、4-HTTP响应" class="headerlink" title="4、4 HTTP响应"></a>4、4 HTTP响应</h2><ul>
<li><p>响应：服务器 → 做出回应 → 客户端</p>
</li>
<li><p>响应报文一般由三部分组成：<strong><em>响应行、响应头、响应体</em></strong></p>
</li>
<li><p>以百度为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response Headers:</span><br><span class="line">Cache-Control: <span class="keyword">private</span>        缓存控制</span><br><span class="line">Connection: keep-alive        连接</span><br><span class="line">Content-Encoding: gzip        编码</span><br><span class="line">Content-Type: text/html;charset=utf-<span class="number">8</span> 类型</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902557.jpg" alt="HTTP响应报文"></p>
<h3 id="1、-响应行"><a href="#1、-响应行" class="headerlink" title="1、 响应行"></a>1、 响应行</h3><ul>
<li><p>由①和②组成，其中①是报文协议和版本；②是状态码及状态描述</p>
<ul>
<li><p>状态码：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息</td>
<td>接收到请求，继续处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功</td>
<td>操作成功地收到，理解和接受</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向</td>
<td>为了完成请求，必须采取进一步措施</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误</td>
<td>请求的语法有错误，或者不能完全被满足，请求错误，责任在客户端，比如客户端请求了一个不存在的资源，或者客户端未被授权，禁止访问</td>
</tr>
<tr>
<td>5XX</td>
<td>服务端错误</td>
<td>服务器无法完成明显有效地请求，服务端抛出异常，比如路由出错，HTTP版本不支持等</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="2、-响应头"><a href="#2、-响应头" class="headerlink" title="2、 响应头"></a>2、 响应头</h3><ul>
<li><p>由③组成 格式为 属性名：属性值</p>
</li>
<li><table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
<th>实例</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Allow-Origin</td>
<td>指定哪些网站可以<code>跨域源资源共享</code></td>
<td>Access-Control-Allow-Origin: *</td>
<td>临时</td>
</tr>
<tr>
<td>Accept-Patch</td>
<td>指定服务器所支持的文档补丁格式</td>
<td>Accept-Patch: text/example;charset=utf-8</td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>服务器所支持的内容范围</td>
<td>Accept-Ranges: bytes</td>
<td>固定</td>
</tr>
<tr>
<td>Age</td>
<td>响应对象在代理缓存中存在的时间，以秒为单位</td>
<td>Age: 12</td>
<td>固定</td>
</tr>
<tr>
<td>Allow</td>
<td>对于特定资源的有效动作;</td>
<td>Allow: GET, HEAD</td>
<td>固定</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td>Cache-Control: max-age=3600</td>
<td>固定</td>
</tr>
<tr>
<td>Connection</td>
<td>针对该连接所预期的选项</td>
<td>Connection: close</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Disposition</td>
<td>对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td>
<td>Content-Disposition: attachment; filename=”fname.ext”</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>响应资源所使用的编码类型。</td>
<td>Content-Encoding: gzip</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响就内容所使用的语言</td>
<td>Content-Language: zh-cn</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应消息体的长度，用8进制字节表示</td>
<td>Content-Length: 348</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Location</td>
<td>所返回的数据的一个候选位置</td>
<td>Content-Location: /index.htm</td>
<td>固定</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>响应内容的二进制 MD5 散列值，以 Base64 方式编码</td>
<td>Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td>
<td>已淘汰</td>
</tr>
<tr>
<td>Content-Range</td>
<td>如果是响应部分消息，表示属于完整消息的哪个部分</td>
<td>Content-Range: bytes 21010-47021/47022</td>
<td>固定</td>
</tr>
<tr>
<td>Content-Type</td>
<td>当前内容的<code>MIME</code>类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
<td>固定</td>
</tr>
<tr>
<td>Date</td>
<td>此条消息被发送时的日期和时间(以<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td>
<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>ETag</td>
<td>对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
<td>固定</td>
</tr>
<tr>
<td>Expires</td>
<td>指定一个日期/时间，超过该时间则认为此回应已经过期</td>
<td>Expires: Thu, 01 Dec 1994 16:00:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td>
<td>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Link</td>
<td>用来表示与另一个资源之间的类型关系，此类型关系是在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td>
<td><code>Link:</code>; rel=”alternate”</td>
<td>固定</td>
</tr>
<tr>
<td>Location</td>
<td>用于在进行重定向，或在创建了某个新资源时使用。</td>
<td>Location: <a target="_blank" rel="noopener" href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td>
<td>固定</td>
</tr>
<tr>
<td>P3P</td>
<td>P3P策略相关设置</td>
<td>P3P: CP=”This is not a P3P policy!</td>
<td>固定</td>
</tr>
<tr>
<td>Pragma</td>
<td>与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td>
<td>Pragma: no-cache</td>
<td>固定</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>要求在访问代理时提供身份认证信息。</td>
<td>Proxy-Authenticate: Basic</td>
<td>固定</td>
</tr>
<tr>
<td>Public-Key-Pins</td>
<td>用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td>
<td>Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td>
<td>固定</td>
</tr>
<tr>
<td>Refresh</td>
<td>用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td>
<td>Refresh: 5; url=<a target="_blank" rel="noopener" href="http://itbilu.com">http://itbilu.com</a></td>
<td>固定</td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td>
<td>示例1:Retry-After: 120   示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Server</td>
<td>服务器的名称</td>
<td>Server: nginx/1.6.3</td>
<td>固定</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置<code>HTTP cookie</code></td>
<td>Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td>
<td>固定: 标准</td>
</tr>
<tr>
<td>Status</td>
<td>通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td>
<td>Status: 200 OK</td>
<td></td>
</tr>
<tr>
<td>Trailer</td>
<td><code>Trailer</code>用户说明传输中分块编码的编码信息</td>
<td>Trailer: Max-Forwards</td>
<td>固定</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td>
<td>Transfer-Encoding: chunked</td>
<td>固定</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端升级到另一个高版本协议。</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td>固定</td>
</tr>
<tr>
<td>Vary</td>
<td>告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td>
<td>Vary: *</td>
<td>固定</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理服务器的客户端，当前响应是通过什么途径发送的。</td>
<td>Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td>
<td>固定</td>
</tr>
<tr>
<td>Warning</td>
<td>一般性警告，告知在实体内容体中可能存在错误。</td>
<td>Warning: 199 Miscellaneous warning</td>
<td>固定</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表示在请求获取这个实体时应当使用的认证模式。</td>
<td>WWW-Authenticate: Basic</td>
<td>固定</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3、-响应体"><a href="#3、-响应体" class="headerlink" title="3、 响应体"></a>3、 响应体</h3><ul>
<li>由⑥组成</li>
<li>是服务器返回给客户端的文本信息</li>
</ul>
<h1 id="5、-Maven"><a href="#5、-Maven" class="headerlink" title="5、 Maven"></a>5、 Maven</h1><ol>
<li>由于在javaweb开发中我们需要用到jar包，但我们每次手动去添加会不会太麻烦了？</li>
<li>因此，我们有了Maven来帮我们自动导入jar包并配置</li>
</ol>
<h2 id="5、1-Maven项目架构管理工具"><a href="#5、1-Maven项目架构管理工具" class="headerlink" title="5、1 Maven项目架构管理工具"></a>5、1 Maven项目架构管理工具</h2><ul>
<li>maven核心思想：约定大于配置</li>
<li>maven规定了如何写java代码，不能违反规范</li>
</ul>
<h2 id="5、2-Maven下载"><a href="#5、2-Maven下载" class="headerlink" title="5、2 Maven下载"></a>5、2 Maven下载</h2><p>官网:<a target="_blank" rel="noopener" href="https://maven.apache.org/">https://maven.apache.org/</a></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200813153434784.png" alt="image-20200813153434784"></p>
<h2 id="5、3-Maven配置环境变量"><a href="#5、3-Maven配置环境变量" class="headerlink" title="5、3 Maven配置环境变量"></a>5、3 Maven配置环境变量</h2><ul>
<li><p>在“此电脑”的高级环境变量中配置如下几项内容</p>
<ol>
<li>新建系统变量 MAVEN_HOME 变量值：maven的目录</li>
<li>新建系统变量 M2_HOME 变量值：maven的lib目录</li>
<li>编辑系统变量Path 添加变量值： ;%MAVEN_HOME%\bin</li>
</ol>
</li>
<li><p>假如在cmd中查看mvn版本能出现以下情况，则为配置成功：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200813214029651.png" alt="image-20200813214029651"></p>
</li>
</ul>
<h2 id="5、4-阿里云镜像"><a href="#5、4-阿里云镜像" class="headerlink" title="5、4 阿里云镜像"></a>5、4 阿里云镜像</h2><p>镜像mirrors 用于加速我们下载</p>
<ul>
<li><p>常用 阿里云镜像：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>放置于：setting.xml中<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200814161829870.png" alt="image-20200814161829870"></p>
</li>
</ul>
<h2 id="5、5-本地仓库"><a href="#5、5-本地仓库" class="headerlink" title="5、5 本地仓库"></a>5、5 本地仓库</h2><p>远程仓库：github</p>
<p>本体仓库：localRepository</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\Users\60446\Desktop\学习文件\environment\apache-maven-3.6.3\maven-repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5、6-在IDEA中使用Maven"><a href="#5、6-在IDEA中使用Maven" class="headerlink" title="5、6 在IDEA中使用Maven"></a>5、6 在IDEA中使用Maven</h2><ol>
<li><p>启动IDEA</p>
</li>
<li><p>创建一个Maven Web项目<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200815190802551.png" alt="image-20200815190802551">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200816141500367.png" alt="image-20200816141500367">)<img src="/UesugiEr11.github.io/2020/10/01/JavaWeb/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816160644275.png" alt="image-20200816160644275"></p>
</li>
<li><p>如果是第一次配置的话 要等待下载响应配置 出现下图则搭建成功<img src="/UesugiEr11.github.io/2020/10/01/JavaWeb/C:%5CUsers%5C60446%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816163147833.png" alt="image-20200816163147833"></p>
</li>
<li><p>IDEA中Maven配置</p>
<p>ps:IDEA中配置Maven项目，Maven home会使用IDEA自带的两个版本之一，因此需要我们手动去替换，很重要!!!否则在后续创建maven项目的时候很有可能会没有src目录，这是很深刻的教训！<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200817181118677.png" alt="image-20200817181118677"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200817181831967.png" alt="image-20200817181831967"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200817183452695.png" alt="image-20200817183452695"></p>
<p>有webapp模板的maven文件：</p>
<p>WEB-INF+web.xml ：Web的配置</p>
<p>index.jsp 网页</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906180606170.png" alt="image-20200906180606170"></p>
</li>
</ol>
<h2 id="5、7-创建普通的Maven项目"><a href="#5、7-创建普通的Maven项目" class="headerlink" title="5、7 创建普通的Maven项目"></a>5、7 创建普通的Maven项目</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906180055017.png" alt="image-20200906180055017"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906180228323.png" alt="image-20200906180228323"></p>
<p>一个干净的maven项目：</p>
<p>蓝色java：放置java源代码</p>
<p>resource：放置配置文件</p>
<p>绿色java：测试使用</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906180429074.png" alt="image-20200906180429074"></p>
<h2 id="5、8-标记文件夹功能"><a href="#5、8-标记文件夹功能" class="headerlink" title="5、8 标记文件夹功能"></a>5、8 标记文件夹功能</h2><p>Sources Root：源码目录</p>
<p>Test Sources Root：测试源码目录</p>
<p>Resources Root：资源目录</p>
<p>Test Resources Root：资源测试目录</p>
<ul>
<li><p>标记方法1：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906181630896.png" alt="![image-20200906182232614](https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906182232614.png)"></p>
</li>
<li><p>标记方法2：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906182543087.png" alt="image-20200906182543087"></p>
</li>
</ul>
<h2 id="5、9-在IDEA中配置Tomcat"><a href="#5、9-在IDEA中配置Tomcat" class="headerlink" title="5、9 在IDEA中配置Tomcat"></a>5、9 在IDEA中配置Tomcat</h2><p>前序工作，选中项目：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907212946486.png" alt="image-20200907212946486"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906205444320.png" alt="image-20200906205444320"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906211324821.png" alt="image-20200906211324821"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906211236188.png" alt="image-20200906211236188"></p>
<p>为什么会有这个Warning呢？因为我们访问一个网站需要指定一个文件夹的名字</p>
<p>Warning的解决方案：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906212405085.png" alt="image-20200906212405085"></p>
<ul>
<li>测试：启动Tomact后出现<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906212533201.png" alt="image-20200906212533201"></li>
</ul>
<h2 id="5、10-POM文件"><a href="#5、10-POM文件" class="headerlink" title="5、10 POM文件"></a>5、10 POM文件</h2><ul>
<li>pom.xml 是maven项目核心</li>
<li><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906213700735.png" alt="image-20200906213700735"></li>
</ul>
<p>如果是webapp的maven项目应该有(暂时）:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906215039422.png" alt="image-20200906215039422"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200906215115986.png" alt="image-20200906215115986"></p>
<p>其中 dependencies中的依赖 我们可以在maven仓库：<a target="_blank" rel="noopener" href="https://mvnrepository.com/中搜索我们需要的依赖">https://mvnrepository.com/中搜索我们需要的依赖</a> 直接复制粘贴过来 maven会帮我们自动导入<strong>jar包</strong>及<strong>该jar包所依赖的其他jar包</strong>这就是maven的高级之处了。</p>
<h2 id="maven资源文件导出问题-解决方法"><a href="#maven资源文件导出问题-解决方法" class="headerlink" title="maven资源文件导出问题 解决方法"></a>maven资源文件导出问题 解决方法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    .......</span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h1 id="6、-Servlet"><a href="#6、-Servlet" class="headerlink" title="6、 Servlet"></a>6、 Servlet</h1><h2 id="6、1-Servlet简介"><a href="#6、1-Servlet简介" class="headerlink" title="6、1 Servlet简介"></a>6、1 Servlet简介</h2><p>Servlet接口有两个默认实现类：HttpServlet 和 GenericServlet</p>
<ul>
<li>servlet是sun公司的开发动态web的一门技术</li>
<li>sun在API中提供一个<strong>接口</strong>叫做servlet，想使用该接口需要完成两个步骤：<ul>
<li>编写一个类，去实现Servlet接口</li>
<li>把开发好的java类部署到web服务器中</li>
</ul>
</li>
</ul>
<p>因此：我们把实现了Servlet接口的【<strong>java程序</strong>】叫做 Servlet程序</p>
<h2 id="6、2-HelloServlet"><a href="#6、2-HelloServlet" class="headerlink" title="6、2 HelloServlet"></a>6、2 HelloServlet</h2><ul>
<li><p>创建一个 普通的Maven项目，删掉其中的src目录，往后在这里建立Moudle（作为父工程）；</p>
</li>
<li><p>关于Maven父子工程理解：</p>
<p>在父项目中会有</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">        此处子项目叫Son1</span><br><span class="line">        &lt;module&gt;Son1&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中会有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;Servlet&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.HPG&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>

<p>父项目中jar包子项目可以直接使用</p>
</li>
<li><p>编写一个Servle程序</p>
<ol>
<li><p>编写一个普通类</p>
</li>
<li><p>实现Servlet接口，需要extends的是HttpServlet</p>
<p>逻辑关系图：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907183432874.png" alt="image-20200907183432874"></p>
<p>源码分析:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet.class:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenericServlet.class:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HTTPServlet.class:</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HelloServlet.java:</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        PrintWriter writer &#x3D; resp.getWriter();</span><br><span class="line">        writer.print(&quot;Hello!Servlet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Servlet的映射</p>
<ul>
<li><p>为什么需要映射？因为我们写的是java程序，但需要通过浏览器访问，浏览器又需要连接web服务器，因此我们需要在web服务器中注册我们写的Servlet，并需要给web服务器一个浏览器能够访问的路径。这就叫映射。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.HPG.Servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<ul>
<li><p>配置Tomcat</p>
<p>ps:注意项目发布路径（/xxxx)</p>
</li>
<li><p>启动测试（注意看网址栏的区别）</p>
<p>不用servlet：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907211734632.png" alt></p>
</li>
</ul>
<p>  <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907211032031.png" alt="image-20200907211032031"></p>
<ul>
<li><p>用servlet:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907211713298.png" alt="image-20200907211713298"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907211050153.png" alt></p>
</li>
<li><p>注意事项：假如有多个Servlet程序，要记得在Deployment处更换包<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910163413106.png" alt="image-20200910163413106"></p>
</li>
</ul>
<h2 id="6、3-Servlet原理"><a href="#6、3-Servlet原理" class="headerlink" title="6、3 Servlet原理"></a>6、3 Servlet原理</h2><p> Servlet只有放在容器中，方可执行，且Servlet容器种类较多，如Tomcat,WebLogic等。下图为简单的 请求响应 模型:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908200355702.png" alt="image-20200908200355702"></p>
<p>逻辑：</p>
<ol>
<li>浏览器向服务器发出GET请求(请求服务器ServletA)</li>
<li>服务器上的容器逻辑接收到该url,根据该url判断为Servlet请求，此时容器逻辑将产生两个对象：请求对象(HttpServletRequest)和响应对象(HttpServletResponce)</li>
<li>容器逻辑根据url找到目标Servlet(本示例目标Servlet为ServletA),且创建一个线程A</li>
<li>容器逻辑将刚才创建的请求对象和响应对象传递给线程A</li>
<li>容器逻辑调用Servlet的service()方法</li>
<li>service()方法根据请求类型(本示例为GET请求)调用doGet()(本示例调用doGet())或doPost()方法</li>
<li>doGet()执行完后，将结果返回给容器逻辑</li>
<li>线程A被销毁或被放在线程池中</li>
</ol>
<h2 id="6、4-Mapping问题"><a href="#6、4-Mapping问题" class="headerlink" title="6、4 Mapping问题"></a>6、4 Mapping问题</h2><ol>
<li><p>一个Servlet可以指定一个映射路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>一个Servlet可以指定多个映射路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>一个Servlet可以指定通用映射路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Servlet的请求路径--&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;hello&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以指定默认请求路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Servlet的请求路径--&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>可以指定通用前缀/后缀路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Servlet的请求路径--&gt;</span><br><span class="line">&lt;!--此时*前面不能加任何东西--&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;hello&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;*.abc&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>优先级来说的话：是固有映射路径最高，找不到才走默认的</p>
<h2 id="6、5-ServletContext"><a href="#6、5-ServletContext" class="headerlink" title="6、5 ServletContext"></a>6、5 ServletContext</h2><p>web容器（Tomcat）在启动的时候，他会给每个web程序都创建一个对应的Servlet对象，他代表当前的web应用。</p>
<h3 id="ServletContext功能"><a href="#ServletContext功能" class="headerlink" title="ServletContext功能"></a>ServletContext功能</h3><h4 id="1、共享数据"><a href="#1、共享数据" class="headerlink" title="1、共享数据"></a>1、共享数据<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910163137128.png" alt="image-20200910163137128"></h4><p>举例：我把一个数据存在了ServletContext中，再用 一个Servlet去调用 让我们看看效果<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910172651611.png" alt="image-20200910172651611"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//this.getServletContext();</span></span><br><span class="line">        <span class="comment">//this.getServletConfig();</span></span><br><span class="line">        <span class="comment">//this.getInitParameter();</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = <span class="string">&quot;hpg&quot;</span>;</span><br><span class="line">        <span class="comment">//将一个数据保存在了ServletContext中。其中名字为username，值为username（hpg）</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910172711109.png" alt="image-20200910172711109"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = (String)context.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">&quot;name:&quot;</span>+username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样的 在web.xml部署路径：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910172751746.png" alt="image-20200910172751746"></p>
<p>我们先启动hello，再启动GetContext：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910172822926.png" alt="image-20200910172822926"></p>
<h4 id="2、获取初始化参数"><a href="#2、获取初始化参数" class="headerlink" title="2、获取初始化参数"></a>2、获取初始化参数</h4><p>P1,P2在web.xml中配置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911201430950.png" alt="image-20200911201430950"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911201443957.png" alt="image-20200911201443957"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911201458232.png" alt="image-20200911201458232"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo03</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String url = context.getInitParameter(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        resp.getWriter().print(url);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911201508117.png" alt="image-20200911201508117"></p>
<h4 id="3、请求转发"><a href="#3、请求转发" class="headerlink" title="3、请求转发"></a>3、请求转发</h4><p>在web.xml中配置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911203004955.png" alt="image-20200911203004955"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911203019502.png" alt="image-20200911203019502"></p>
<p>代码：</p>
<p>转发的页面是gp的页面，而转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo04</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi ServletDemo04!&quot;</span>);</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">//转发的请求路径</span></span><br><span class="line">        RequestDispatcher requestDispatcher = context.getRequestDispatcher(<span class="string">&quot;/gp&quot;</span>);</span><br><span class="line">        <span class="comment">//调用forward实现请求转发</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发的状态码 200 表示着转发成功</p>
<p>我们虽然请求的是sd4,但实际上我们走的是gp</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911203037054.png" alt="image-20200911203037054"></p>
<h5 id="请求转发和重定向的问题"><a href="#请求转发和重定向的问题" class="headerlink" title="请求转发和重定向的问题"></a>请求转发和重定向的问题</h5><p>首先让我们看一幅图：</p>
<p>A想要获取C的信息，但是无法直接获取，只能通过B去获取C信息，再经由B传给A</p>
<p>自始至终，A都没有访问到C，这就叫<strong>请求转发</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911204258154.png" alt="image-20200911204258154"></p>
<p>再让我们看一幅图：</p>
<p>A想要一个资源，去找B，B说我没有，让A去找C，于是A就去请求C了</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911204905346.png" alt="image-20200911204905346"></p>
<p>（日后再补充）</p>
<h3 id="4、-访问资源文件"><a href="#4、-访问资源文件" class="headerlink" title="4、 访问资源文件"></a>4、 访问资源文件</h3><p>说到资源文件，就不得不提到一个类 “Properties”</p>
<p>在java目录或者是resources目录下 新建xxxx.properties，都会被打包在同一个路径（classes）下，我们称该路径为classpath；</p>
<p>下面我们来演示一下如何访问资源目录</p>
<p>比如，我们在resources目录下创建好了一个db.properties后启动tomcat，我们可以在target/classes目录中发现生成一个db.properties——这是准备工作</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911213217216.png" alt="image-20200911213217216"></p>
<p>db.properties中的内容为：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911213840376.png" alt="image-20200911213840376"></p>
<p>同样的，我们首先在web.xml中配置好映射:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911213937082.png" alt="image-20200911213937082"></p>
<p>写好了一个关于访问资源文件的Servlet</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911213951172.png" alt="image-20200911213951172"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo05</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获得上下文中资源并转成一个流</span></span><br><span class="line">        InputStream ios = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//生成一个properties对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//用properties中的load方法导入流</span></span><br><span class="line">        prop.load(ios);</span><br><span class="line">        <span class="comment">//拿到properties中的属性</span></span><br><span class="line">        String username = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">//打印输出</span></span><br><span class="line">        resp.getWriter().print(username+<span class="string">&quot;:&quot;</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911214024919.png" alt="image-20200911214024919"></p>
<h2 id="6、6-HttpServletResponse"><a href="#6、6-HttpServletResponse" class="headerlink" title="6、6 HttpServletResponse"></a>6、6 HttpServletResponse</h2><p>web服务器接收到客户端的http请求，会针对该请求，分别创建一个代表请求的HttpServletRequest对象和一个代表响应的HttpServletResponse；</p>
<ul>
<li>假如我们要获取客户端请求过来的参数：找HttpServletRequest</li>
<li>假如我们需要给客户端响应一些信息：找HttpServletResponse</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="负责给浏览器发送数据的方法"><a href="#负责给浏览器发送数据的方法" class="headerlink" title="负责给浏览器发送数据的方法"></a>负责给浏览器发送数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在ServletResponse.class中</span></span><br><span class="line"><span class="comment">//写流用这个</span></span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">//写中文一般用这个</span></span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="负责给浏览器发送响应头的方法"><a href="#负责给浏览器发送响应头的方法" class="headerlink" title="负责给浏览器发送响应头的方法"></a>负责给浏览器发送响应头的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在ServletResponse.class中</span></span><br><span class="line"><span class="comment">//确保发往服务器的参数的编码格式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="comment">//设置内容长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="comment">//使浏览器区分不同种类数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="comment">//设置每次读取文件流时缓存数组的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="comment">//在HttpServletResponse.class中</span></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> var1, String var2)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendError</span><span class="params">(<span class="keyword">int</span> var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">//重定向网页，向浏览器发送一个特殊Header，由浏览器做重定向，转到指定页面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">//设置指定头名称以及日期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//添加头名称以及日期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//设置返回页面的头meta信息，这个可以有很多功能，后期可以自己上网查一下用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"><span class="comment">//添加返回页面的头meta信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"><span class="comment">//设置http文件头信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//添加http文件头信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br><span class="line"><span class="comment">//设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="响应的状态码"><a href="#响应的状态码" class="headerlink" title="响应的状态码"></a>响应的状态码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SC_CONTINUE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> SC_OK = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> SC_CREATED = <span class="number">201</span>;</span><br><span class="line"><span class="keyword">int</span> SC_ACCEPTED = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NO_CONTENT = <span class="number">204</span>;</span><br><span class="line"><span class="keyword">int</span> SC_RESET_CONTENT = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PARTIAL_CONTENT = <span class="number">206</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MULTIPLE_CHOICES = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MOVED_PERMANENTLY = <span class="number">301</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MOVED_TEMPORARILY = <span class="number">302</span>;</span><br><span class="line"><span class="keyword">int</span> SC_FOUND = <span class="number">302</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SEE_OTHER = <span class="number">303</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_MODIFIED = <span class="number">304</span>;</span><br><span class="line"><span class="keyword">int</span> SC_USE_PROXY = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</span><br><span class="line"><span class="keyword">int</span> SC_BAD_REQUEST = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> SC_UNAUTHORIZED = <span class="number">401</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PAYMENT_REQUIRED = <span class="number">402</span>;</span><br><span class="line"><span class="keyword">int</span> SC_FORBIDDEN = <span class="number">403</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line"><span class="keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_ACCEPTABLE = <span class="number">406</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_TIMEOUT = <span class="number">408</span>;</span><br><span class="line"><span class="keyword">int</span> SC_CONFLICT = <span class="number">409</span>;</span><br><span class="line"><span class="keyword">int</span> SC_GONE = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> SC_LENGTH_REQUIRED = <span class="number">411</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PRECONDITION_FAILED = <span class="number">412</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="number">414</span>;</span><br><span class="line"><span class="keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>;</span><br><span class="line"><span class="keyword">int</span> SC_EXPECTATION_FAILED = <span class="number">417</span>;</span><br><span class="line"><span class="keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_IMPLEMENTED = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> SC_BAD_GATEWAY = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="number">503</span>;</span><br><span class="line"><span class="keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="number">504</span>;</span><br><span class="line"><span class="keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="给浏览器输出各种信息"><a href="#给浏览器输出各种信息" class="headerlink" title="给浏览器输出各种信息"></a>给浏览器输出各种信息</h4><p>几秒刷一次啊 这种的，还有许多，之后再补充8.</p>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是什么</li>
<li>让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使OutputStream将缓冲区的数据输出到客户端</li>
</ol>
<p>创建一个FileServlet类去实现下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 要获取下载文件的路径,第一个方法不行，需要绝对路径</span></span><br><span class="line">        <span class="comment">//String realPath = this.getServletContext().getRealPath(&quot;/windows.png&quot;);</span></span><br><span class="line">        String realPath = <span class="string">&quot;D:\\Servlet\\response\\target\\classes\\windows.png&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载的文件名&quot;</span>+realPath);</span><br><span class="line">        <span class="comment">//2. 下载的文件名是什么</span></span><br><span class="line">        String filename = realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3. 让浏览器能够支持下载我们需要的东西</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span>+filename);</span><br><span class="line">        <span class="comment">//4. 获取下载文件的输入流</span></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="comment">//5. 创建缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//6. 获取OutputStream对象</span></span><br><span class="line">        ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="comment">//7. 将FileOutputStream流写入到buffer缓冲区</span></span><br><span class="line">        <span class="comment">//8. 使OutputStream将缓冲区的数据输出到客户端</span></span><br><span class="line">        <span class="keyword">while</span> ((len=in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同理，在web.xml中配置好映射关系</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>filedown<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.FileServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>filedown<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/filedown<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>别忘了重新配置Tomcat的deployment，启动Tomcat在浏览器中搜索响应的映射得到：</p>
<p>表示下载成功!</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914160317369.png" alt="image-20200914160317369"></p>
<h4 id="验证码功能"><a href="#验证码功能" class="headerlink" title="验证码功能"></a>验证码功能</h4><p>验证功能分两部分，一个是前端校验，一个是后端校验</p>
<p>后端校验：Java的图片类，生成一个图片</p>
<p>创建要给ImageServlet去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//浏览器3秒刷新一次</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//在内存中创建一个图片</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(<span class="number">80</span>,<span class="number">20</span>,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="comment">//得到图片 这个方法得到了一个在平面中画画的笔</span></span><br><span class="line">        Graphics2D g = (Graphics2D)image.getGraphics();</span><br><span class="line">        <span class="comment">//设置图片背景颜色</span></span><br><span class="line">        g.setColor(Color.white);</span><br><span class="line">        <span class="comment">//图片的填充范围 宽80 长20</span></span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">//给图片写数据</span></span><br><span class="line">        g.setColor(Color.BLUE);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">        g.drawString(makeNum(), <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">//设置响应头通知浏览器以图片的形式打开</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/png&quot;</span>);<span class="comment">//等同于response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);</span></span><br><span class="line">        <span class="comment">//告诉浏览器别让它缓存</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;expires&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-chche&quot;</span>);</span><br><span class="line">        <span class="comment">//把图片写给浏览器</span></span><br><span class="line">        ImageIO.write( image, <span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个随机对象</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//范围9999999</span></span><br><span class="line">        String num = random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//生成StringBUffer对象 用与</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//解释下 7 - num.length()的意义 假如不满足七位数，其余部位用0来填充 保证最后返回是七位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">7</span> - num.length() ; i++)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = sb.toString() + num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同理:在web.xml中配置映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>imageservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.ImageServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>imageservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/image<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动Tomcat ，每次刷新我们得到的图片都不同 就不再截第二张了<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915220952419.png" alt="image-20200915220952419"></p>
<h4 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h4><ul>
<li>再复习一遍重定向:A想访问一个资源，去找B，B说不在我这啊，让A去找C，这过程就叫重定向</li>
<li>常用于用户登录啊等等场景</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200911204905346.png" alt="image-20200911204905346"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>在web.xml中再配置一个映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RedirectServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.RedirectServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RedirectServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/red<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//response.setStatus(302);</span></span><br><span class="line">        <span class="comment">//response.setHeader(&quot;location&quot;, &quot;/r/image&quot;);</span></span><br><span class="line">        <span class="comment">//这里为什么是r呢？是因为我在Tomcat Deployment设置那里把Application context 改成了/r</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/r/image&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我在浏览器输入/red后 页面会跳转到：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916222212771.png" alt="image-20200916222212771"></p>
<p>表示成功！</p>
<p>面试常问：请你聊聊转发和重定向之间的异同点</p>
<ul>
<li><p>相同点：页面都会发生跳转</p>
</li>
<li><p>不同点：请求转发的时候，url不会发生变化；307</p>
<p>而重定向的时候，url会发生变化；302</p>
</li>
</ul>
<p>重定向实现登录:</p>
<p>在web.xml中配置映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Request<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.RequestTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Request<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在index.jsp中写好登录页面（一开始的时候没添加上面两行编码的代码，中文显示的全是乱码 - -）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--这里提交的路径需要找到项目的路径，这里用的那个￥&#123;&#125;需要导入js的东西，不然用不了--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span>method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写了一个假如成功就跳转到的页面 success.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;success&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>最后，创建一个Test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username+<span class="string">&quot;:&quot;</span>+password);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/r/success.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917184156408.png" alt="image-20200917184156408"></p>
<p>随便输了几个数字 点提交</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917180527012.png" alt="image-20200917180527012"></p>
<h2 id="6、7-HttpServletRequest"><a href="#6、7-HttpServletRequest" class="headerlink" title="6、7 HttpServletRequest"></a>6、7 HttpServletRequest</h2><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，Http请求中的所有信息会被封装到HttpServletRequest，通过这些HttpServletRequest的方法，获得客户端的所有信息；其中这些信息有</p>
<h3 id="获取前端传递的参数，请求转发"><a href="#获取前端传递的参数，请求转发" class="headerlink" title="获取前端传递的参数，请求转发"></a>获取前端传递的参数，请求转发</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917182702133.png" alt="image-20200917182702133"></p>
<p>老三样，在web.xml中配置好映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>login<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.HPG.Servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>login<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简陋的写了一个登录页面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--这里表单的意思是，以post方式提交表单，提交到我们的login请求--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/r/login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> required&gt; &lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;passwd&quot;</span> required&gt; &lt;br&gt;</span><br><span class="line">    爱好：</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;hobbies&quot;</span> value=<span class="string">&quot;代码&quot;</span>&gt;代码</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;hobbies&quot;</span> value=<span class="string">&quot;唱歌&quot;</span>&gt;唱歌</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;hobbies&quot;</span> value=<span class="string">&quot;电影&quot;</span>&gt;电影</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>写个LoginServlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//解决乱码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String passwd = req.getParameter(<span class="string">&quot;passwd&quot;</span>);</span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobbies&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(passwd);</span><br><span class="line">        System.out.println(hobbies.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(req.getContextPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过请求转发 假如是重定向 需要加个/xxx/ xxx在Application context自己找 但现在是请求转发 是不需要加那个的</span></span><br><span class="line">        <span class="comment">//气死我了 改了半天 这也让我知道请求转发是项目内部的 不需要写项目路径</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917195818860.png" alt="image-20200917195818860"></p>
<p>用户名填了hpg 密码123</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917195843761.png" alt="image-20200917195843761"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917195851131.png" alt="image-20200917195851131"></p>
<p>成功!</p>
<h1 id="7、Cookie、Session"><a href="#7、Cookie、Session" class="headerlink" title="7、Cookie、Session"></a>7、Cookie、Session</h1><h2 id="7、1-会话"><a href="#7、1-会话" class="headerlink" title="7、1 会话"></a>7、1 会话</h2><p><strong>会话</strong>：用户打开一个浏览器，点击很多个超链接，访问多个web资源关闭浏览器，这个过程我们可以称之为会话。</p>
<p><strong>有状态会话</strong>：一位同学曾去过一间教室，再进入这个教室的时候，就知道它曾经来过了，称为有状态会话</p>
<p>下面思考一下这个问题，你怎么证明你是一个学校的学生?</p>
<ul>
<li>学校给你发了录取通知书 —— 学校给你发</li>
<li>学校的学生名单上有你的名字 ——学校标记你</li>
</ul>
<p>那么 一个网站怎么证明你来过呢？客户端——服务器端</p>
<ol>
<li>服务器端给客户端发一个信件，下次客户访问服务器端凭借信件即可，<strong>此处的信件 即为Cookie</strong> 相当于<strong>录取通知书</strong></li>
<li>服务器端登记你，下次客户端来访问的时候进行匹配查找；<strong>这项功能即为Session</strong></li>
</ol>
<h2 id="7、2-保存会话的两种技术"><a href="#7、2-保存会话的两种技术" class="headerlink" title="7、2 保存会话的两种技术"></a>7、2 保存会话的两种技术</h2><p>cookie</p>
<ul>
<li>客户端技术（请求，响应）</li>
</ul>
<p>session</p>
<ul>
<li>服务器技术，保存用户的信息；通过Session保存信息或数据</li>
</ul>
<p>常见用途:网站登录之后，下次就不用再登录了，可以直接访问</p>
<h2 id="7、3-Cookie"><a href="#7、3-Cookie" class="headerlink" title="7、3 Cookie"></a>7、3 Cookie</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921151029168.png" alt="image-20200921151029168"></p>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器相应给客户端cookie</li>
</ol>
<ul>
<li><p>一般会保存在本地的用户目录下appData下。</p>
</li>
<li><p>由浏览器保存，不同的浏览器具有不兼容性。</p>
</li>
<li><p>由浏览器主动向服务器提供，服务端只需getCookies就行。</p>
</li>
<li><p>一个cookie只能保存一个信息</p>
</li>
<li><p>一个web站点最多存放20个cookie</p>
</li>
<li><p>cookie大小限制4kb</p>
</li>
<li><p>浏览器上限是300个cookie</p>
</li>
<li><p>不设置有效期，关闭浏览器自动失效。</p>
</li>
<li><p>控制台输入<strong>javascript:alert (document. cookie)</strong>可查看本网站下cookie</p>
</li>
<li><p>cookie中的方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies();<span class="comment">//获得cookie</span></span><br><span class="line">cookie.getName();<span class="comment">//获得cookie中的name</span></span><br><span class="line">cookie.getValue();<span class="comment">//获得cookie中的value</span></span><br><span class="line"><span class="keyword">new</span> Cookie(<span class="string">&quot;xxxx&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);<span class="comment">//新建一个cookie</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);<span class="comment">//设置cookie有效期。为0即删掉，以秒为基本单位</span></span><br><span class="line">resp.addCookie(cookie);<span class="comment">//响应给客户端一个cookie</span></span><br></pre></td></tr></table></figure>

<p>编写一个Servlet去实现 访问上一次访问事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//服务器把你上次访问来的时间封装成一个对象，你下次访问携带此对象即可</span></span><br><span class="line">        <span class="comment">//解决中文乱码 一开始用UTF-8是乱码，改成16就正常了</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cookie：服务器端从客户端获取</span></span><br><span class="line">        <span class="comment">//此处返回的是一个数组，表示cookie可能存在多个</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//判断cookie是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果存在cookie</span></span><br><span class="line">            out.write(<span class="string">&quot;你上次访问的时间是:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                Cookie cookie = cookies[i];</span><br><span class="line">                <span class="comment">//获取cookie的名字</span></span><br><span class="line">                <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;lastLoginTime&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//获取cookie 的值</span></span><br><span class="line">                    <span class="comment">//把值转换成long对象</span></span><br><span class="line">                    <span class="keyword">long</span> lastLoginTime = Long.parseLong(cookie.getValue());</span><br><span class="line">                    <span class="comment">//把long对象转换成时间</span></span><br><span class="line">                    Date date = <span class="keyword">new</span> Date(lastLoginTime);</span><br><span class="line">                    <span class="comment">//再转成字符串并输出</span></span><br><span class="line">                    out.write(date.toLocaleString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            out.write(<span class="string">&quot;第一次访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//服务器端给客户端发一个cookie</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;lastLoginTime&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给cookie设置一个有效期，不然每次关闭浏览器我们cookie都没咯 以秒为单位</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        resp.addCookie(cookie );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CookieDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.CookieDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CookieDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/c1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个注意一下，假如是第一次登录的话，访问时间应该是不显示的，要刷新一次才行；</p>
<p>同时，假如我不设置那个cookie有效时间，我只要关闭了浏览器，他就会默认你是第一次访问，但我设置了就不一样了。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920203434337.png" alt="image-20200920203434337"></p>
<h2 id="7、4-Session（重点）"><a href="#7、4-Session（重点）" class="headerlink" title="7、4 Session（重点）"></a>7、4 Session（重点）</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921151958341.png" alt="image-20200921151958341"></p>
<p>什么是Session：</p>
<ul>
<li><p>服务器给每个用户（浏览器）创建一个Session对象</p>
</li>
<li><p>一个Session独占一个浏览器，只要浏览器没关闭，这个Session就存在</p>
</li>
<li><p>用户登录之后，整个网站他都能访问；常用于保存购物车信息等</p>
</li>
<li><p>Session与cookie的区别：</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器 浏览器保存</li>
<li>Session是把用户的数据写到用户独占的Session中，在服务器端保存（保存重要的信息，减少服务器资源的浪费）</li>
<li>Session是由服务器生成的。</li>
</ul>
</li>
</ul>
<p>web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Session<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.SessionDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Session<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SessionDemo01，测试往session里面存东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//解决编码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line">        <span class="comment">//得到session</span></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//往session存东西</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        <span class="comment">//获取session的id</span></span><br><span class="line">        String id = session.getId();</span><br><span class="line">        <span class="comment">//判断session是不是新创建的</span></span><br><span class="line">        <span class="keyword">if</span>(session.isNew()) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session创建成功，ID：&quot;</span>+id);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session已经在服务器中存在了，ID：&quot;</span>+id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session创建的时候做了什么事情</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Cookie jsessionid = new Cookie(&quot;JSESSIONID&quot;, id);</span></span><br><span class="line"><span class="comment">        resp.addCookie(jsessionid);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920214027374.png" alt="image-20200920214027374"></p>
<p>再来一个</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionDemo02<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.SessionDemo02<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionDemo02<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再写一个SessionDemo02,测试从session中取东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDemo02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//解决编码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;chareset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        String name = (String) session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次访问s2时候，打印出来的是null；</p>
<p>访问完s1,往session里存放数据后再访问一次s2得到结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920214340513.png" alt="image-20200920214340513"></p>
<ul>
<li>注销Session</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDemo03</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//取消session</span></span><br><span class="line">        session.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//注销session</span></span><br><span class="line">        session.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们测试一下：一开始用s1创建 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920220004996.png" alt="image-20200920220004996"></p>
<p>s2进行打印<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920220914448.png" alt="image-20200920220914448"></p>
<p>s3注销<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920220935509.png" alt="image-20200920220935509"></p>
<p>s2再打印<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920220948845.png" alt></p>
<p>完成了注销</p>
<p>当然了，我们可以用web.xml去配置 让它会话在一定时间后自动过期：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--十分钟后session过期，这里的单位是分钟--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="8、JSP"><a href="#8、JSP" class="headerlink" title="8、JSP"></a>8、JSP</h1><h2 id="8、1-什么是JSP"><a href="#8、1-什么是JSP" class="headerlink" title="8、1 什么是JSP"></a>8、1 什么是JSP</h2><ul>
<li>JSP 即 java server pages：java服务器端页面，也和Servlet一样用于开发动态web技术</li>
<li>特点:写jsp像在写html，用标签语言进行，那么与html有什么区别呢？<ul>
<li>HTML只给用户提供静态数据</li>
<li>JSP页面中可以嵌入Java代码，为用户提供动态数据</li>
</ul>
</li>
</ul>
<h2 id="8、2-JSP原理"><a href="#8、2-JSP原理" class="headerlink" title="8、2 JSP原理"></a>8、2 JSP原理</h2><p>思路:jsp到底是怎么执行的呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921153803104.png" alt="image-20200921153803104"> </p>
<p>我们点开此文件夹一直找，直到最后我们进入：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921153947926.png" alt="image-20200921153947926"></p>
<p>我们发现页面转换成了java程序</p>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都在访问Servlet</strong></p>
<p>那么JSP最后也会转成一个java类，那么这又是为什么呢？我们点开源码分析下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921154520100.png" alt="image-20200921154520100"></p>
<p>我们再分析这个类，发现它是由HttpServlet继承的，而我们前面学习过了，HttpServlet其实是继承Servlet的，因此JSP本质上其实就是个Servlet<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921154934889.png" alt="image-20200921154934889"></p>
<p>我们比对一下源码和index.jsp，发现我们index.jsp中的页面比源码中的要美观很多，它帮我们解决了很多繁琐的事情</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921155234967.png" alt="image-20200921155234967"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921155255365.png" alt="image-20200921155255365"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//JspService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们看看这个_jspService都做了什么事情</p>
<ol>
<li><p>它做了一些请求判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;</span><br><span class="line">      <span class="keyword">final</span> java.lang.String _jspx_method = request.getMethod();</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;OPTIONS&quot;</span>.equals(_jspx_method)) &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Allow&quot;</span>,<span class="string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">&quot;GET&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="string">&quot;POST&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="string">&quot;HEAD&quot;</span>.equals(_jspx_method)) &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Allow&quot;</span>,<span class="string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="string">&quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它内置了一些对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;<span class="comment">//页面上下文</span></span><br><span class="line">    javax.servlet.http.HttpSession session = <span class="keyword">null</span>;<span class="comment">//session</span></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;<span class="comment">//applicationContext</span></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config; <span class="comment">//config</span></span><br><span class="line">    javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>; <span class="comment">//out</span></span><br><span class="line">    <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>; <span class="comment">//page：当前页</span></span><br><span class="line">    javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"> 	HttpServletRequest request <span class="comment">//请求</span></span><br><span class="line">    HttpServletResponse   <span class="comment">//响应</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出页面前增加的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>); <span class="comment">//设置响应的页面类型</span></span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>2和3中的对象,代码都能在jsp页面中直接使用</li>
</ol>
<ul>
<li>大致的流程图：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921161527740.png" alt="image-20200921161527740"></li>
</ul>
<p>在jsp中，如果是java代码会原封不动输出，如果是html语言或是其他的，会被转换为形如这样的格式，输出到前端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="9、-JavaBean"><a href="#9、-JavaBean" class="headerlink" title="9、 JavaBean"></a>9、 JavaBean</h1><p>实体类：</p>
<p>javabean别想的太复杂，其实和普通的java类没什么区别，只是他必须要带有一些特定的东西。</p>
<p>为什么呢？因为我们后面学到了框架部分，我们就知道，项目是由一个个模块，螺丝，组装起的；</p>
<p>这个时候我们就需要有一种“javabean”的思想去解决问题。</p>
<p>JavaBean有特定写法</p>
<ul>
<li><p>是公有类的 —— public class xxx</p>
</li>
<li><p>必须要有一个无参构造——public class xxxx{}</p>
</li>
<li><p>属性必须私有化 —— private String name；</p>
</li>
<li><p>必须有对应的getter/setter方法</p>
</li>
</ul>
<p>一般用来和数据库字段做映射：ORM</p>
<p>ORM：对象关系映射</p>
<ul>
<li>表→类</li>
<li>字段→属性</li>
<li>行记录→对象</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>apple</td>
<td>14</td>
<td>深圳</td>
</tr>
<tr>
<td>2</td>
<td>pear</td>
<td>33</td>
<td>广州</td>
</tr>
<tr>
<td>3</td>
<td>peach</td>
<td>53</td>
<td>宜昌</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Sting name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//伪代码，假设存在构造方法</span></span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;apple&quot;</span>,<span class="number">14</span>,<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">2</span>,<span class="string">&quot;pear&quot;</span>,<span class="number">33</span>,<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">3</span>,<span class="string">&quot;peach&quot;</span>,<span class="number">53</span>,<span class="string">&quot;宜昌&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在数据库中创建了表，表中是由相应的成员属性组成，为什么说是相应的呢，因为我们的javabean中的对象应该具有我们数据库中表的属性，也就是形成了一一对应的关系。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200921221756158.png" alt="image-20200921221756158"></p>
<p>下面我们写一个javabean 再写一个相应的jsp页面感受一下：</p>
<p>Person.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>javabean.jsp:</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">//    Person person = new Person();</span></span><br><span class="line"><span class="comment">//    person.setAddress(&quot;深圳&quot;);</span></span><br><span class="line"><span class="comment">//    person.setAge(3);</span></span><br><span class="line"><span class="comment">//    person.setId(1);</span></span><br><span class="line"><span class="comment">//    person.setName(&quot;apple&quot;);</span></span><br><span class="line">%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--等价于上面的java代码，<span class="keyword">new</span>了一个Person对象 <span class="class"><span class="keyword">class</span>其实就是映射的路径--%&gt;</span></span><br><span class="line"><span class="class">&lt;%--<span class="title">name</span>是<span class="title">id</span>,<span class="title">property</span>是属性，<span class="title">value</span>是值--%&gt;</span></span><br><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.hpg.pojo.Person&quot; scope=&quot;page&quot;/&gt;</span><br><span class="line">&lt;%--这四行代码等价与上述的set代码--%&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;address&quot;</span> value=<span class="string">&quot;深圳&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;3&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;apple&quot;</span>/&gt;</span><br><span class="line">&lt;%--输出信息--%&gt;</span><br><span class="line">姓名：&lt;jsp:getProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">id：&lt;jsp:getProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">年龄：&lt;jsp:getProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">地址：&lt;jsp:getProperty name=<span class="string">&quot;person&quot;</span> property=<span class="string">&quot;address&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出页面:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200922194913829.png" alt="image-20200922194913829"></p>
<h1 id="10、-MVC三层架构"><a href="#10、-MVC三层架构" class="headerlink" title="10、 MVC三层架构"></a>10、 MVC三层架构</h1><ul>
<li>什么是MVC：Model View Controller-模型视图控制器</li>
</ul>
<h2 id="10、1-早期架构"><a href="#10、1-早期架构" class="headerlink" title="10、1 早期架构"></a>10、1 早期架构</h2><p>我们上面学到了其实Jsp就是Servlet，那为什么还要区分这两个呢？</p>
<p>其实是为了方便维护；</p>
<p><strong>Servlet专注于处理请求以及控制视图跳转；</strong></p>
<p><strong>Jsp专注于显示数据</strong></p>
<p>早期架构图:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200922205842751.png" alt="image-20200922205842751"></p>
<p>用户直接访问控制层，控制层就可以直接操作数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Servlet--CRUD--&gt;数据库</span><br><span class="line">弊端：程序很臃肿，耦合度高，不利于维护</span><br><span class="line">Servlet的代码功能：处理请求，响应，视图跳转，处理JDBC，处理业务代码，处理逻辑代码 </span><br><span class="line">架构思想：我们需要在耦合度高的地方&quot;加一层&quot;</span><br><span class="line">比如说有很多个数据库：Mysql，Oracle...我们就需要要统一的接口JDBC来管理</span><br></pre></td></tr></table></figure>

<h2 id="10、2-MVC三层架构"><a href="#10、2-MVC三层架构" class="headerlink" title="10、2 MVC三层架构"></a>10、2 MVC三层架构</h2><p>现在的呢？mvc架构图：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200922210408685.png" alt="image-20200922210408685"></p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul>
<li>业务处理层：业务逻辑（Service）</li>
<li>数据持久层：CRUD（Dao）</li>
</ul>
<h3 id="VIEW"><a href="#VIEW" class="headerlink" title="VIEW"></a>VIEW</h3><ul>
<li>展示数据</li>
<li>提供链接发起下一步Servlet请求/提供用户交互</li>
</ul>
<h3 id="Controller（Servlet）"><a href="#Controller（Servlet）" class="headerlink" title="Controller（Servlet）"></a>Controller（Servlet）</h3><ul>
<li><p>接受用户的请求：req:请求参数，session信息  </p>
</li>
<li><p>交给业务层处理对应的代码</p>
</li>
<li><p>控制视图的跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录---&gt;接受用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）---&gt;交给业务层处理登录业务（判断用户名密码的是否正确:事务)---&gt;Dao层查询用户名和密码是否正确---&gt;查询数据库</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="11、-（重点）Filter过滤器"><a href="#11、-（重点）Filter过滤器" class="headerlink" title="11、 （重点）Filter过滤器"></a>11、 （重点）Filter过滤器</h1><h2 id="11、1-什么是过滤器"><a href="#11、1-什么是过滤器" class="headerlink" title="11、1 什么是过滤器"></a>11、1 什么是过滤器</h2><p>Filter：过滤器，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200925222623344.png" alt="image-20200925222623344"></p>
<h2 id="11、2-Filter开发步骤"><a href="#11、2-Filter开发步骤" class="headerlink" title="11、2 Filter开发步骤"></a>11、2 Filter开发步骤</h2><ol>
<li>导包</li>
<li>编写过滤器</li>
<li>编写java类实现Filter接口，并实现其doFilter方法。</li>
<li>在web.xml 文件中使用<filter>和<filter-mapping>元素对编写的filter类进行注册，并设置它所能拦截的资源。</filter-mapping></filter></li>
</ol>
<p>注意：导包不能导错:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br></pre></td></tr></table></figure>

<p>应用的例子:</p>
<p>编写一个过滤编码的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hpg.filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化 web服务器启动 就已经被初始化了 以准备随时等待过滤对象出现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//chain 链</span></span><br><span class="line">    <span class="comment">//1.过滤器中的所有代码，在过滤特定请求的时候都会执行</span></span><br><span class="line">    <span class="comment">//2.必须要让过滤器继续同行 就是这行filterChain.doFilter(servletRequest, servletResponse);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line">        servletResponse.setCharacterEncoding(<span class="string">&quot;utf-16&quot;</span>);</span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);<span class="comment">//一定要写的，如果不写程序到这就会被拦截</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁:当web服务器关闭的时候，过滤器会被销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//resp.setCharacterEncoding(&quot;utf-16&quot;);</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;你好你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.ShowServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这样就没过滤器的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ShowServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这样就有过滤器的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/show/ShowServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hpg.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只要是/show/路径下的任何请求，都会经过这个过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/show/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一开始走ShowServlet的时候</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928222031228.png" alt="image-20200928222031228"></p>
<p>走通过过滤器筛过的路径的时候</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928222053078.png" alt="image-20200928222053078"></p>
<p>整个生命周期：</p>
<p>启动Tomcat就开始初始化了，进一次页面就会执行一次，最后关闭服务器就销毁；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928222106630.png" alt="image-20200928222106630"></p>
<h1 id="12、监听器Listener"><a href="#12、监听器Listener" class="headerlink" title="12、监听器Listener"></a>12、监听器Listener</h1><h2 id="12、1-什么是监听器"><a href="#12、1-什么是监听器" class="headerlink" title="12、1 什么是监听器"></a>12、1 什么是监听器</h2><ul>
<li>监听器就是一个实现<strong>特定接口的普通java程序</strong>，这个程序专门用于<strong>监听另一个java对象的方法调用或属性改变</strong>，当被监听对象<strong>发生上述事件</strong>后，<strong>监听器某个方法将立即被执行</strong>。</li>
</ul>
<h2 id="12、2-监听原理"><a href="#12、2-监听原理" class="headerlink" title="12、2 监听原理"></a>12、2 监听原理</h2><ol>
<li>存在事件源</li>
<li>提供监听器</li>
<li>为事件源注册监听器</li>
<li>操作事件源，产生事件对象，将事件对象传递给监听器，并且执行监听器相应监听方法</li>
</ol>
<h2 id="12、3-应用例子测试"><a href="#12、3-应用例子测试" class="headerlink" title="12、3 应用例子测试"></a>12、3 应用例子测试</h2><ol>
<li><p>编写一个监听器——实现监听器接口，重写里面的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineCountListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//创建session监听：看你的一举一动，一旦创建session，就会触发一次这事件;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到上下文</span></span><br><span class="line">        ServletContext ctx = httpSessionEvent.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">        System.out.println(httpSessionEvent.getSession().getId());</span><br><span class="line">        <span class="comment">//在线人数</span></span><br><span class="line">        Integer onlineCount = (Integer) ctx.getAttribute(<span class="string">&quot;OnlineCount&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(onlineCount == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//假如没有用户 那么new一个新的用户</span></span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则加一</span></span><br><span class="line">            <span class="keyword">int</span> count = onlineCount.intValue();</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setAttribute(<span class="string">&quot;OnlineCount&quot;</span>,onlineCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//销毁session监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        ServletContext ctx = httpSessionEvent.getSession().getServletContext();</span><br><span class="line">        Integer onlineCount = (Integer) ctx.getAttribute(<span class="string">&quot;OnlineCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(onlineCount == <span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = onlineCount.intValue();</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(count - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setAttribute(<span class="string">&quot;OnlineCount&quot;</span>, onlineCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在web.xml中注册监听器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册监听器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.hpg.listener.OnlineCountListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>看情况是否使用</p>
</li>
</ol>
<p>chrome打开</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929171506843.png" alt="image-20200929171506843"></p>
<p>再添加一个edge打开：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929171552721.png" alt="image-20200929171552721"></p>
<h1 id="13、-过滤器-监听器-常见应用"><a href="#13、-过滤器-监听器-常见应用" class="headerlink" title="13、 过滤器 监听器 常见应用"></a>13、 过滤器 监听器 常见应用</h1><h2 id="13、1-监听器GUI"><a href="#13、1-监听器GUI" class="headerlink" title="13、1 监听器GUI"></a>13、1 监听器GUI</h2><ul>
<li>我们可以创建一个图形化界面去实现监听的效果</li>
</ul>
<p>例子:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929190247510.png" alt="image-20200929190247510"></p>
<p>缩小窗口，打开窗口，关闭窗口 都有不同的表现：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929190351615.png" alt="image-20200929190351615"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPanel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//panel是面板的意思</span></span><br><span class="line">        <span class="comment">//新建一个窗体</span></span><br><span class="line">        Frame hello = <span class="keyword">new</span> Frame(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">//设置一个面板</span></span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//设置窗体的布局</span></span><br><span class="line">        hello.setLayout(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//设置细节</span></span><br><span class="line">        <span class="comment">//设置坐标</span></span><br><span class="line">        hello.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//设置背景颜色</span></span><br><span class="line">        hello.setBackground(<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">        <span class="comment">//设置坐标</span></span><br><span class="line">        panel.setBounds(<span class="number">50</span>,<span class="number">50</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        <span class="comment">//设置背景颜色</span></span><br><span class="line">        panel.setBackground(<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//嵌套进去</span></span><br><span class="line">        hello.add(panel);</span><br><span class="line">        <span class="comment">//设置可见性</span></span><br><span class="line">        hello.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//如果不加监听，发现点击X没反应</span></span><br><span class="line">        hello.addWindowListener(<span class="keyword">new</span> WindowListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;closing&quot;</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;closed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Activated&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;None Activated&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13、2-Filter实现权限拦截"><a href="#13、2-Filter实现权限拦截" class="headerlink" title="13、2 Filter实现权限拦截"></a>13、2 Filter实现权限拦截</h2><ul>
<li>用户登录之后才能进入主页，用户注销后不能进入主页；就算你一开始进去过主页了，并且保存了你的成功的网页，但你注销了，如果在url中直接复制网址，也不能进去！</li>
</ul>
<p>如何实现呢？</p>
<ol>
<li>用户登录之后，向Session中存放用户的数据</li>
<li>进入主页时候判断用户是否已经登录了（可以在jsp中实现，但最好最好用过滤器实现！！）</li>
</ol>
<p>代码:</p>
<p>首先 一个登录界面（login.jsp):</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/servlet/login&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>登录成功后进入的主页面(success.jsp):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--&lt;%--%&gt;</span><br><span class="line">&lt;%--    Object user_session = request.getSession().getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);--%&gt;</span><br><span class="line">&lt;%--    <span class="keyword">if</span>(user_session == <span class="keyword">null</span>) &#123;--%&gt;</span><br><span class="line">&lt;%--        response.sendRedirect(<span class="string">&quot;/login.jsp&quot;</span>);--%&gt;</span><br><span class="line">&lt;%--    &#125;--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--%&gt;--%&gt;</span><br><span class="line">&lt;h1&gt;主页&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;/servlet/logout&quot;&gt;注销&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>登录失败的页面(error.jsp):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;错误&lt;/h1&gt;</span><br><span class="line">    &lt;h3&gt;没有权限，用户名错误&lt;/h3&gt;</span><br><span class="line">    &lt;a href=&quot;/login.jsp&quot;&gt;返回登录页面&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>ok，接下来是登录和登出的两个Servlet</p>
<p>登录(LoginServlet):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取前端请求的参数</span></span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//若登陆成功</span></span><br><span class="line">        <span class="keyword">if</span> (username.equals(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//把id存在session里面</span></span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;USER_SESSION&quot;</span>,req.getSession().getId());</span><br><span class="line">            <span class="comment">//重定向</span></span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/sys/success.jsp&quot;</span>);</span><br><span class="line">            <span class="comment">//登录失败的话</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/error.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>登出（LogOut）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogOut</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Object user_session = req.getSession().getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user_session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//移除session</span></span><br><span class="line">            req.getSession().removeAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line">            <span class="comment">//重定向到登录界面</span></span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时，为了能够成功实现权限拦截，需要用到Filter</p>
<p>SysFilter.java（意思是，所有Sys下的页面都必须经由这个过滤器筛过才能进入）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest Request, ServletResponse Response, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) Request;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) Response;</span><br><span class="line">        <span class="comment">//如果是直接复制网址的，不是靠着登录进来的话，就回到错误</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/error.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(Request,Response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一步：在web.xml好配置好路径映射以及过滤器</p>
<p>一定要注意好我们的url-pattern里的路径是要与各自的.jsp中的相对应</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LogOut<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.hpg.servlet.LogOut<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LogOut<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/logout<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>过滤器:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sys下的页面都会被在这个过滤器筛一遍--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SysFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hpg.listener.SysFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SysFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/sys/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>登录:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929220409618.png" alt="image-20200929220409618"></p>
<p>登录失败：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929220445992.png" alt="image-20200929220445992"></p>
<p>点击返回登录页面就可以重新回到登录主页</p>
<p>登录成功：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929220519404.png" alt="image-20200929220519404"></p>
<p><strong>此时，假如我直接保存我们的成功网址，然后点注销，再直接复制网址进入的话：</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929220555863.png" alt="image-20200929220555863"></p>
<p>大功告成！目录结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200929220640030.png" alt="image-20200929220640030"></p>
<h1 id="14、-JDBC"><a href="#14、-JDBC" class="headerlink" title="14、 JDBC"></a>14、 JDBC</h1><ul>
<li>什么是JDBC？ Java连接数据库</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001195512972.png" alt="image-20201001195512972"></p>
<p>需要jar包的支持：</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-connector-java 连接驱动必须要导入的包</li>
</ul>
<h2 id="14、1-JDBC固定步骤"><a href="#14、1-JDBC固定步骤" class="headerlink" title="14、1 JDBC固定步骤"></a>14、1 JDBC固定步骤</h2><ol>
<li>加载驱动</li>
<li>连接数据库，代表数据库</li>
<li>向数据库发送SQL的对象statement 用于CRUD</li>
<li>编写SQL →不同业务，不同SQL</li>
<li>执行SQL</li>
<li>关闭连接</li>
</ol>
<p>应用例子:</p>
<p>下载了SQLyog后 在其中创建一个表:JDBC</p>
<p>然后创建表，写数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	‘<span class="keyword">name</span>‘ <span class="built_in">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">	‘<span class="keyword">password</span>‘ <span class="built_in">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">	email <span class="built_in">VARCHAR</span>(<span class="number">60</span>),</span><br><span class="line">	birthday <span class="built_in">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(<span class="keyword">id</span>,‘<span class="keyword">name</span>‘,‘<span class="keyword">password</span>‘,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;zs@qq,com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(<span class="keyword">id</span>,‘<span class="keyword">name</span>‘,‘<span class="keyword">password</span>‘,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;ls@qq,com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(<span class="keyword">id</span>,‘<span class="keyword">name</span>‘,‘<span class="keyword">password</span>‘,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;ww@qq,com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>

<p>创建出的表:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008155922109.png" alt="image-20201008155922109"></p>
<p>在IDEA中连接好数据库</p>
<p>TestJDBC.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码问题</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        String password = <span class="string">&quot;gakki3323&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.连接数据库，代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3.向数据库发送SQL的对象statement  能用来CRUD/增删改查</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//4.编写Sql</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from users&quot;</span>;</span><br><span class="line">        <span class="comment">//5.执行查询sql→返回一个结果集</span></span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.关闭连接，释放资源，一定要做的！！先开的后关</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008160035554.png" alt="image-20201008160035554"></p>
<p>插入的Test：</p>
<p>TestJDBC2.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码问题</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        String password = <span class="string">&quot;gakki3323&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.连接数据库，代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3.编写SQL</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;</span>;</span><br><span class="line">        <span class="comment">//4.预编译</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>,<span class="number">4</span>);<span class="comment">//给第一个占位符？的值赋值为1</span></span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>,<span class="string">&quot;hpg&quot;</span>);<span class="comment">//给第二个占位符？的值赋值为hpg</span></span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>,<span class="string">&quot;123456&quot;</span>);<span class="comment">//给第三个占位符？的值赋值为123456</span></span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>,<span class="string">&quot;123@qq.com&quot;</span>);<span class="comment">//给第四个占位符？的值赋值为123@qq.com</span></span><br><span class="line">        preparedStatement.setDate(<span class="number">5</span>,<span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));<span class="comment">//给第五个占位符？的值赋值为new Date(new java.util.Date().getTime())</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行sql</span></span><br><span class="line">        <span class="keyword">int</span> i = preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//6.关闭连接，释放资源，一定要做的！！先开的后关</span></span><br><span class="line"></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008161729066.png" alt="image-20201008161729066"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008161734949.png" alt="image-20201008161734949"></p>
<h2 id="14、2-JDBC事务"><a href="#14、2-JDBC事务" class="headerlink" title="14、2  JDBC事务"></a>14、2  JDBC事务</h2><ul>
<li>要么都成功，要么都失败</li>
<li>ACID原则——保证了数据的安全<ul>
<li><strong>A(原子性)</strong>：一个事务的所有系列操作步骤被看成一个动作，所有的步骤要么全部完成，要么一个也不会完成。如果在事务过程中发生错误，则会回滚到事务开始前的状态，将要被改变的数据库记录不会被改变。</li>
<li><strong>C(一致性)</strong>：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏，即数据库事务不能破坏关系数据的完整性及业务逻辑上的一致性。</li>
<li><strong>I(隔离性)</strong>：主要用于实现并发控制，隔离能够确保并发执行的事务按顺序一个接一个地执行。通过隔离，一个未完成事务不会影响另外一个未完成事务。</li>
<li><strong>D(持久性)</strong>：一旦一个事务被提交，它应该持久保存，不会因为与其他操作冲突而取消这个事务。</li>
</ul>
</li>
</ul>
<h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p>引入依赖 pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单测试:</p>
<p>@Test注解只在方法上有效，只要加了这个注解的方法，就可以直接运行</p>
<p>JDBCTest.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成果:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008163254905.png" alt></p>
<h3 id="JDBC事务回滚"><a href="#JDBC事务回滚" class="headerlink" title="JDBC事务回滚"></a>JDBC事务回滚</h3><p>首先在数据库中创建好表：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008170654754.png" alt="image-20201008170654754"></p>
<p>编写测试类:</p>
<p>JDBCTest3.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码问题</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        String password = <span class="string">&quot;gakki3323&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.连接数据库，代表数据库</span></span><br><span class="line">            connection = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.通知数据库开启事务 false 开启</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.编写sql</span></span><br><span class="line">            String sql = <span class="string">&quot;update account set money = money - 100 where name = &#x27;A&#x27;&quot;</span>;</span><br><span class="line">            <span class="comment">//5.提交</span></span><br><span class="line">            connection.prepareStatement(sql).executeUpdate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//制造错误</span></span><br><span class="line">            <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">            <span class="comment">//编写sql</span></span><br><span class="line">            String sql2 = <span class="string">&quot;update account set money = money + 100 where name = &#x27;B&#x27;&quot;</span>;</span><br><span class="line">            <span class="comment">//提交</span></span><br><span class="line">            connection.prepareStatement(sql2).executeUpdate();</span><br><span class="line"></span><br><span class="line">            connection.commit();<span class="comment">//以上两条都成功了就提交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//出现异常 通知数据库回滚</span></span><br><span class="line">                    connection.rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                    throwables.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如我的编写错误那行代码不注释掉，执行后的结果是：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008170818909.png" alt="image-20201008170818909"></p>
<p>表的数据是没有变的</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008170831932.png" alt="image-20201008170831932"></p>
<p>注释掉后:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008170914182.png" alt="image-20201008170914182"></p>
<p>表的数据改变：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008170933029.png" alt="image-20201008170933029"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/10/01/JavaWeb/" data-id="ckppikuen002dp0wi6bx6c8na" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-09-25T13:25:56.311Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>估算程序指令的执行次数/执行时间</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul>
<li>估算程序指令所需占用的存储空间</li>
</ul>
<h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>有了时间复杂度，空间复杂度，那么究竟该用什么来表示其大小呢？我们因此衍生了一种表示方式——<strong>大O表示法</strong></p>
<p>什么是大O表示法呢？表示的是数据规模n对应的复杂度</p>
<ul>
<li>公式:T(n) = O( f(n) )<ul>
<li>n为数据规模，即是函数中变量n</li>
<li>f(n)为代码总执行次数与数据规模关系</li>
<li>T(n)为代码执行时间</li>
</ul>
</li>
</ul>
<p>判断方式:</p>
<ul>
<li><p>由于在一个程序中可能由多个函数组成，其大O是多个复杂度累计的，那么我们只需要关心最复杂的那个即可，因此我们需要去：<strong>忽略常数，系数，低阶</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量阶O(1)) &lt; 对数阶O(logn) &lt;  线性阶O(n) &lt; 线性对数阶O(nlogn) &lt; 平方阶O(n²)...立方阶O(n³)...k方阶 &lt; 指数阶O(2^n) &lt; 阶乘阶O(n!) &lt;n的n次方阶级O(n^n)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><ul>
<li>线性表是具有N个相同类型元素的有限序列（N&gt;=0）</li>
</ul>
<p>（数组，链表，栈，队列，哈希表/散列表）</p>
<h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><ul>
<li>数组是一种<strong>顺序存储</strong>的线性表，所有元素的内存地址是<strong>连续</strong>的<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910210432530.png" alt="image-20200910210432530"></li>
</ul>
<h3 id="ArrayList动态数组"><a href="#ArrayList动态数组" class="headerlink" title="ArrayList动态数组"></a>ArrayList动态数组</h3><ul>
<li>ArrayList函数接口<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910211154393.png" alt="image-20200910211154393"></li>
</ul>
<h4 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">// 缺省容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 缺省空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 元素数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 实际元素大小，默认为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 最大数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><h6 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时我们创建的ArrayList对象中的elementData长度是1，size为0，只有当第一次进行add时候，elementData变成默认长度10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h6 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h6><ul>
<li>传参构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//参数大于等于0，就用那个参数，否则抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Collection对象 构造</li>
<li>下文提到了一个概念：<strong>深拷贝和浅拷贝</strong> 关于这个的话可以看这个：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94dbef2de298">https://www.jianshu.com/p/94dbef2de298</a> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将collection对象转换成数组，然后将数组的地址的赋给elementData。</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//大于 0 则用Arrays.copy方法，把collection对象内容拷贝到elemD</span></span><br><span class="line">    <span class="comment">//ps：这里是深拷贝，意思是只复制了内容而不是地址，意思是原来的东西变化并不会影响到我复制后的</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假如size = 0 直接把空对象地址给elemD</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h6><ul>
<li><strong>带参数的add方法</strong></li>
<li><strong>不带参数的add方法</strong></li>
</ul>
<h3 id="LeetCode-数组相关"><a href="#LeetCode-数组相关" class="headerlink" title="LeetCode-数组相关"></a>LeetCode-数组相关</h3><ul>
<li>首先我们要明白用数组解题，或者题目中牵扯到数组的优势与劣势与特点</li>
<li>优势：我们是知道数组的首末索引的，可以方便我们查找遍历</li>
<li>劣势：由于数组每个位置上都有东西，我们有时候插入删除有点麻烦</li>
</ul>
<h4 id="LeetCode-88-合并两个有序数组"><a href="#LeetCode-88-合并两个有序数组" class="headerlink" title="LeetCode 88.合并两个有序数组"></a>LeetCode 88.合并两个有序数组<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200907141226830.png" alt="image-20200907141226830"></h4><p>采用了双指针的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p3 = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[p3--] = nums2[p2--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[p3--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt;= nums2[p2])&#123;</span><br><span class="line">                nums1[p3--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[p3--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p1，p2各自指向数组中最后一个数据；p3指向合并后最后一个位置；</p>
<p>当p1,p2遍历完各自的数组时，结束循环。</p>
<p>当如果p1（下标）&lt;0，意味着第一个数组遍历完了，那么就p3指向的位置存放p2的数据，反之则存放p1的数据。</p>
<p>如果p1指向数据大于p2指向数据，那么p3指向位置存放p1的数据，反之则存放p2的数据。</p>
<h4 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode 75.颜色分类"></a>LeetCode 75.颜色分类<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908134006968.png" alt="image-20200908134006968"></h4><p>采用三指针解法，一个用于记录索引，一个头指针，一个尾指针<br>如果是0，则给left，如果是1则不变，如果是2则给right<br>遍历的结果保证了:left左边全是0（不包括left），right右边全是2（不包括right）;</p>
<p>当i &gt; right了，则断，否则要把刚交换得到的1，2交换回去了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i++] = nums[left];</span><br><span class="line">                nums[left++] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="comment">//换过来的right代表的数可能是0，因此i是不能++的</span></span><br><span class="line">                nums[i] = nums[right];</span><br><span class="line">                nums[right--] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977.有序数组的平方"></a>LeetCode 977.有序数组的平方</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909171343270.png" alt="image-20200909171343270"></p>
<p>本来简单点，可以直接把他们全部平方了，然后用sort直接排序，但是那样就没意思了。</p>
<p>同样使用三指针，一个记录索引，一个左指针，一个右指针。</p>
<p>由于是从小到大排序，因此索引要在最右边向左走。</p>
<p>终止条件:当left与right交错时；</p>
<p>假如左指针的数值+右指针数值&gt;0，那么代表右指针数组更大，此时这个位置应该填右指针数值的平方，反之填左指针数值的平方；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> i = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[left] + A[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans[i--] = A[right]*A[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i--] = A[left]*A[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LeeCode-面试题16-16-部分排序"><a href="#LeeCode-面试题16-16-部分排序" class="headerlink" title="LeeCode 面试题16.16. 部分排序"></a>LeeCode 面试题16.16. 部分排序</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200910151328344.png" alt="image-20200910151328344"></p>
<p>首先我们看看问题 要求 n - m 尽量最小，意思是要找到符合要求的左端点中最大的，和符合要求的右端点中最小的。那么又有个问题，什么叫符合要求呢？</p>
<p>首先，对于一个数，假如其左边数都比他小，右边数都比他小，就不包含在需要排序的部分内。</p>
<p>那么符合要求即，对于<strong>左端点m</strong>来说，其右边存在一个<strong>小于他的数</strong>；反之，对于<strong>右端点n</strong>来说，其左边存在一个<strong>大于他的数</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span> , -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//正向遍历一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt;= max)&#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反向遍历一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = array.length -<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= min)&#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left , right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表（List）"><a href="#链表（List）" class="headerlink" title="链表（List）"></a>链表（List）</h2><h3 id="链表概念"><a href="#链表概念" class="headerlink" title="链表概念"></a>链表概念</h3><ul>
<li>由于动态数组有个明显缺点：可能会造成内存的大量浪费。那么有没有一种方法能做到——我们用多少空间就申请多少内存呢？当然有，就是用<strong>链表</strong>了！</li>
<li>链表是一种<strong>链式存储</strong>的线性表，其元素的内存地址不一定是连续的。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913182644224.png" alt></li>
</ul>
<h3 id="LeetCode-链表相关"><a href="#LeetCode-链表相关" class="headerlink" title="LeetCode-链表相关"></a>LeetCode-链表相关</h3><ul>
<li>首先明白链表解题的特点/优势/劣势</li>
<li>优势：链表的连接方式是通过next指针，因此我们只需要修改指向即可轻松的插入与删除</li>
<li>劣势：链表不存在索引这一说，因此我们要查找某个特定元素，只能通过遍历，不能直接找到</li>
<li>特点：我们常常会使用多指针进行操作</li>
</ul>
<h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913211912842.png" alt="image-20200913211912842"></p>
<p>采用新建一个链表的解法，可以有效解决假如头节点就是要删除的元素带来的麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newhead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        newhead.next = head;</span><br><span class="line">        ListNode tmp = newhead;</span><br><span class="line">        <span class="keyword">while</span>(tmp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.next.val == val)&#123;</span><br><span class="line">                tmp.next = tmp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86.分割链表"></a>86.分割链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913212252808.png" alt="image-20200913212252808"></p>
<p>这题比较简单，用两条链表分别保存小于x的和大于等于x部分。然后最后把两条链表一拼就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存小于x的链表</span></span><br><span class="line">        ListNode fronthead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p1 = fronthead;</span><br><span class="line">        <span class="comment">//保存大于等于x的链表</span></span><br><span class="line">        ListNode backhead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p2 = backhead;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                p1.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = backhead.next;</span><br><span class="line">        <span class="keyword">return</span> fronthead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914214153713.png" alt="image-20200914214153713"></p>
<p>这道题其实有点脑筋急转弯的味道。</p>
<p>我们想想 假如各有一个指针分别在A链表和B链表同时出发，假如他们最后能在某一点相交，那么意味着什么，是不是代表着他们行走的总路程是一样的？（因为每次只走一格，相当于速度相同，而时间又相同，那么速度X时间就是路程了）</p>
<p>假如没有相交呢？那么代表着各个指针走了一遍A又走了一遍B，最后走到了null，代表没有交点咯。</p>
<p>好了 代码如下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span>) ? headB : p1.next;</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span>) ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指Offer-24-反转链表"><a href="#剑指Offer-24-反转链表" class="headerlink" title="剑指Offer 24.反转链表"></a>剑指Offer 24.反转链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png" alt></p>
<p>所谓的单链表反转，就是把每个节点的指针域由原来的指向下一个节点变为指向其前一个节点。</p>
<p>但是单链表并没有一个指向前一个节点的指针域，因此准备一个指针pre用于存储每个节点前一个节点</p>
<p>还需要一个指针next保存当前下一个节点。</p>
<p>在遍历过程中：先保存要修改的节点的下一个节点（很关键 顺序不能错咯）然后修改当前节点的下一个指向，然后把pre指针和head指针都向后移动即可。最后返回的是pre 这也不能搞错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200915193926482.png" alt="image-20200915193926482"></p>
<p>这道题的解法综合性很强（在我看来）</p>
<p>整体思路:用快慢指针方法找到中间结点，然后将后半部分链表翻转过来，然后将所得的链表与原链表前半部分进行比较</p>
<p>其中快慢指针就不讲了，翻转链表怎么翻转呢？详情请看 <strong>剑指Offer 24.反转链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//偶数的话就是前者情况 奇数就是后者情况</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转后半部分链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != pre.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200917221620390.png" alt="image-20200917221620390"></p>
<p>这题我的思路是先不管那个进位的事情，先单纯把对应的数加起来放在一个链表上（在这里我假设放在L1上），然后再另外写一个函数去处理那个数</p>
<p>这题其实有个好的地方，就是各链表上的数是<strong>逆序存储</strong>的，相当于加法的时候帮我们自动对齐了。太好了。</p>
<p>那么这道题我们要考虑的其实就四种情况：</p>
<ol>
<li>L1长度 &gt;= L2长度 </li>
<li>L1长度 &lt; L2长度</li>
<li>末位不需要进位（这里的末位其实是头 自己知道就好）</li>
<li>末位需要进位（这里的末位其实是头 自己知道就好）</li>
</ol>
<p>其中第一种情况其实是最好解决的，就一个末位假如大于10进位就好了。</p>
<p>第二种的方法我们可以把提前结束的地方直接接l2上，也可以解决</p>
<p>第三种末位不需要进位就不说了</p>
<p>第四种需要进位，就在新建一个头，放进位的1就ok</p>
<p>假如你问我 为什么进位肯定是1啊？你想想..最大就是9+9=18 肯定是1啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1.val += p2.val;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//l2长度大于l1 那么直接把p2接p1后面 而且因为没了 直接break</span></span><br><span class="line">            <span class="keyword">if</span>(p1.next == <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1.next = p2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        func(l1);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                head.val = head.val%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//假如是末位 大于10 那么就需要新建一个头 放1用</span></span><br><span class="line">                    head.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                head.next.val += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><h3 id="栈概念"><a href="#栈概念" class="headerlink" title="栈概念"></a>栈概念</h3><h3 id="栈源码分析"><a href="#栈源码分析" class="headerlink" title="栈源码分析"></a>栈源码分析</h3><h3 id="LeetCode-栈相关"><a href="#LeetCode-栈相关" class="headerlink" title="LeetCode-栈相关"></a>LeetCode-栈相关</h3><h4 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a>面试题 03.02. 栈的最小值</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924161616748.png" alt="image-20200924161616748"></p>
<p>这题可以用双栈的方法去解，分为主栈和副栈；</p>
<ul>
<li><p>主栈：和正常的栈一样进行<strong>push&amp;pop</strong>；</p>
</li>
<li><p>副栈：对我们<strong>push和pop的值进行特判</strong>，假如符合才进行相应操作，副栈维护着一个特殊的序列；</p>
</li>
</ul>
<p>那么对于本题，我们的副栈有着什么特殊的地方呢？</p>
<ol>
<li>我们所要<strong>push的值</strong>必须要小于/等于此时的栈顶元素</li>
<li>我们所要<strong>pop的值</strong>必须是辅助栈的栈顶元素我们才让辅助栈也pop，只有这样我们才能保证pop掉留下的元素是其次第二小，第三小…的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; MainStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; Helper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        MainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(!Helper.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Helper.peek()&gt;=x)&#123;</span><br><span class="line">                Helper.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Helper.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = MainStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp == Helper.peek())&#123;</span><br><span class="line">            Helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  MainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Helper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924190753703.png" alt="image-20200924190753703"></p>
<p>引入概念 <strong>单调栈</strong></p>
<ul>
<li>单调递增栈：栈中数据<strong>出栈</strong>的序列为单调递增序列</li>
<li>单调递减栈：栈中数据<strong>出栈</strong>的序列为单调递减序列</li>
</ul>
<p>ps：这里不需要保证在栈中的元素要保持单调递增/递减的顺序</p>
<p>那么这题怎么用单调栈的方法来解呢？准确的说用单调递增栈的方法来解呢？</p>
<p>这题的意思就是找到每个位置离他最近的那个比他大的数，那么我们遇到比自己小的就存栈里，碰到一个大的就把自己栈顶的数据弹出来与当前的下标进行减法运算，即为差值，也就是我们需要等待的日子。</p>
<p>不要忘了，当前遍历到的这个数也有可能比之前没弹出来的数要大，所以要while（）挨个看看，而不是if（）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(T.length == <span class="number">0</span> || T.length == <span class="number">1</span> || T == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造栈</span></span><br><span class="line">        Stack&lt;Integer&gt; helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//答案数组</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; T.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//记得这里是while不是if，因为遇到了一个大的有可能比之前的没弹出来的也要大，要都判断一次;</span></span><br><span class="line">            <span class="keyword">while</span>(! helper.isEmpty() &amp;&amp; T[helper.peek()] &lt; T[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> day = helper.pop();</span><br><span class="line">                ans[day] = i - day;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            helper.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指Offer09-用两个栈实现队列"><a href="#剑指Offer09-用两个栈实现队列" class="headerlink" title="剑指Offer09.用两个栈实现队列"></a>剑指Offer09.用两个栈实现队列</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200925211651494.png" alt="image-20200925211651494"></p>
<p>这题其实比较简单，一个栈正常存，另一个用来维护成队列的特性即可；</p>
<p>在push数据的时候<strong>S1</strong>正常存，然后假如要删了把第一个栈存储数据逆序存在<strong>S2</strong>中，然后再pop<strong>S2</strong>的数据出去即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="comment">//初始化栈，一个用于正常存，一个是辅助栈;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常存</span></span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假如s2有数据</span></span><br><span class="line">        <span class="keyword">if</span>(!s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如s2没数据，s1有数据，就把s1数据存进来</span></span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty() &amp;&amp; !s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假如s2没数据，s1没数据，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(s1.isEmpty() &amp;&amp; s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列概念"><a href="#队列概念" class="headerlink" title="队列概念"></a>队列概念</h3><h3 id="LeetCode-队列相关"><a href="#LeetCode-队列相关" class="headerlink" title="LeetCode-队列相关"></a>LeetCode-队列相关</h3><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924171609555.png" alt="image-20200924171609555"></p>
<p>这道题分析一下，我们的窗口随着移动，前面先进来的数要先被窗口卡在外面，那么符合先进先出，是队列；</p>
<p>我们要考虑一个区间内的最大值，又有一点栈的味道，那到底这题要用哪种呢，能不能都用呢？</p>
<p>由此，我们可不可以有一种数据结构是包含了队列的（FIFO）和栈的（FILO）的特点的呢？</p>
<p><strong>双向队列</strong>：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924172108383.png" alt="image-20200924172108383"></p>
<p>我们遍历数组，把数组放在队列中，而且我们的头要保证是每一趟中最大的，把头的值给到我们的结果数组，遍历完成后，我们的结果数组也形成了。</p>
<p>那么解决这道题，我们首先要形成题目中的”窗口”：用L和R分别表示左右边框。</p>
<ul>
<li>R=i，就是遍历的下标</li>
<li>L=i-k+1，也就是右边框减去窗口的宽再加1</li>
</ul>
<p>我们遍历途中，遇到了一个数，假如我们之前的数值都是小于该数的，那么全部弹出，并且保存该数，判断该数有没有被窗口卡住，假如此时已经形成窗口了，就把该数赋给我们的结果数组。</p>
<p>我们这有个问题：为什么我们的双向队列不直接存数呢？直接把那个数给数组不是更简单，为什么要多此一举，存下标，然后再把该下标放进数组里，把值传过去呢？</p>
<p>好问题，因为我们要判断我们的队首元素有没有被窗口卡在外面，而去判断有没有卡在外面依据，就是我们的下标与下标进行比较，只要符合了，就把该下标所在的值赋予结果数组即可；而反过来，我们存放数据的话，就要用map映射去找下标，然后比较，不是更麻烦吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//建立一个双向队列存储窗口的下标，而不是值;</span></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用i代表当前滑窗的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ; i &lt; nums.length ; i++) &#123;</span><br><span class="line">                <span class="comment">//为了保证从小到大，把之前小于现在遍历到的值的数全部弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加当前值对应的数组下标</span></span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                <span class="comment">//判断该值所在的下标是否被窗口卡在外面</span></span><br><span class="line">                <span class="keyword">if</span>(queue.peekFirst() &lt;= i - k)&#123;</span><br><span class="line">           		    queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//假如此时的窗口长度刚好成型或已经成型的时候，保存当前窗口最大值</span></span><br><span class="line">                <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    result[i - k + <span class="number">1</span>] = nums[queue.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005180356129.png" alt></p>
<p>看到这种最长上升，我下意识想到了单调栈的解法，但后来写了发现有些地方的pop很繁琐，那么我就想到了另一种方法，<strong>单调队列</strong>；</p>
<p>我们用一个数组去维护成一个单调队列，保证其是单调递增的，在遍历数组的时候，如果遇到比尾部的数字还大的，那么就肯定比队列前面已经存在的数字都要大，那么就直接插入在尾部；如果碰到了比尾部小的，我们找到前面第一个比他大的位子，替换掉；</p>
<p>这里有个巧妙地方法就是引入了二分法去找该插入的位子，关于二分的话在算法篇我们再详细讲讲左右区间选择问题和最后到底用左端点还是右端点，这里学问还是有很多的。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不停更新这个数组 维护一个伪队列 保持其单调递增</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//len+1就是最长的序列了</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存放第一个数 用于后续比较</span></span><br><span class="line">        a[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，如果大于单调队列的尾部 就直接加入尾部</span></span><br><span class="line">        <span class="comment">//如果小于的话 就找到第一个比他比他大的数，把它换掉，保留了后续增长的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//如果比尾部大，直接加尾部</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; a[len]) &#123;</span><br><span class="line">                a[++len] = nums[i];</span><br><span class="line">                <span class="comment">//否则用二分找位子</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = len + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//如果这个数过大 那么就换右区间找</span></span><br><span class="line">                    <span class="keyword">if</span>(a[m] &lt; nums[i]) l = m + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//反之 换左区间</span></span><br><span class="line">                    <span class="keyword">else</span> r = m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了 退出循环 替换数字</span></span><br><span class="line">                a[r] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><p>（二叉树，AVL树，红黑树，B树，堆，Trie哈夫曼树，并查集）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/927750-20191124112314705-322764513.png" alt="img"></p>
<h2 id="LeetCode-树相关"><a href="#LeetCode-树相关" class="headerlink" title="LeetCode-树相关"></a>LeetCode-树相关</h2><ul>
<li>我们可以先不考虑整个树应该怎么解，可以考虑假如就三个结点（根 左子树 右子树）这个时候应该怎么求解，然后把这个解题思路放大 映射到整个树结构；</li>
<li>树解题一般都要用到递归的方法 那么就要明白递归最重要的三部曲</li>
<li>递归的终止条件</li>
<li>每一层递归要进行什么处理</li>
<li>每一层递归的返回值是什么</li>
</ul>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004160328789.png" alt="image-20201004160328789"></p>
<ul>
<li><p>这题要点在于，是不是把是不是子树问题转换成了是不是同树问题；</p>
<p>判断同树的方法就算：要么都为空，要么值相等，其他情况肯定都不是同树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果子树为空 肯定是主树的子树了</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果主树为空，由于此题的子树一定部位空，那么就不属于子树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断一下 此时是否是同树</span></span><br><span class="line">        <span class="keyword">if</span>(isSametree(s,t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//返回要么是左子树要么右子树，否则就都不是</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSametree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处都为空，都遍历到头了 就有可能是树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//一个未空一个不为空，肯定不是同树</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//值不同，不可能为同树</span></span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断左边和右边</span></span><br><span class="line">        <span class="keyword">return</span> isSametree(s.left, t.left) &amp;&amp; isSametree(s.right, t.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201027131924221.png" alt="image-20201027131924221"></p>
<p>首先要明确什么最近公共祖先的概念，不然你遍历的时候做什么处理都不清楚</p>
<ul>
<li><p><mark>最近公共祖先</mark>：<strong>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先；或者是一个结点本身就是p或者q，其左子树或右子树出现了q或者p，那么p/q本身就是最近的公共祖先</strong></p>
</li>
<li><p>递归的终止条件：比叶子结点还深的话就返回null，假如现在的root就是p/q的话就返回root，用于后续判断；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：由于要遍历整个树，因此每一层递归应该开启左右子树的递归，因此我们要把传入的参数由</p>
<p>root 改为 root.left 和 root.right</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：这个其实是这道题的困难点，我们到底该返回什么值?依据又是什么呢？</p>
<p>回到我们这题 <strong>最经公共祖先</strong> 的定义，由于我们的终止条件中可以得到我们下面的返回值，这返回值其实就是我们的判断依据</p>
<p>假如我们的左右子树都有返回值代表着什么?代表我们现在处于的这个根就是我们要找的 <strong>最近公共祖先</strong> 啦</p>
<p>假如都没有 那很可惜 只能返回NULL了</p>
<p>假如有一边不为空 那也不赖了 我们至少找到了用于判断 <strong>最近公共祖先</strong> 的一半条件了，我们就把不为空的那部分返回了，另一部分继续找就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回值就两种情况 要么就是值 要么就是空的 换句话说 假如一个根左右两边返回上来的值都不为空 那么这个跟肯定就是pq的最近公共祖先了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029222130128.png" alt="image-20201029222130128"></p>
<p>如果用递归写，那就没意思了，我们下面试试用迭代来遍历</p>
<p>首先要明白 前序遍历是怎么遍历的：<code>根节点 - 左节点 - 右节点</code></p>
<p>OK，接下来由于我们需要去把遍历出来的结果保存在数组里面返回，那么思路就出来了：</p>
<p>用一个栈去辅助遍历：</p>
<ul>
<li>当前遍历结点不为空，直接加入数组，然后压入栈中，向左子树进发</li>
<li>如果未空，返回之前保存的栈顶，然后遍历右子树（也就是遍历这个未空节点的兄弟节点）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030112007435.png" alt="image-20201030112007435"></p>
<p>同样的，我们来想想中序遍历顺序：<code>左节点 → 根节点 → 右节点</code></p>
<p>我们和前序遍历使用了相同模板，只不过里面的细节变了些:</p>
<ul>
<li>如果遍历的结点不为空，别急着把值加入数组，压入栈中，继续向左子树进发</li>
<li>如果未空，说明到了最左边啦，那首先弹出栈顶（返回上一级）然后把这个值存入数组，同时向右子树进发</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中序遍历：左 → 根 → 右</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030130346848.png" alt="image-20201030130346848"></p>
<p>后序遍历的遍历顺序：<code>左节点 → 右节点 → 根节点</code></p>
<p>看起来比较难以实现吧？那我们换一种思路:</p>
<p>我们知道先序遍历是：<code>根节点 → 左节点 → 右节点</code></p>
<p>那我们如果反过来遍历就是：<code>右节点 → 左节点 → 根节点</code></p>
<p>由于我们先便利的左节点 再遍历 右节点得到这个结果</p>
<p>那么我们假如先遍历右节点，再遍历左节点：<code>左节点 → 右节点 → 根节点</code> ，这正好是我们后序遍历结果</p>
<p>那么如何实现呢？可以使用头插法来实现第一步，而后调整遍历左右节点顺序来实现第二步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                list.addFirst(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030135230070.png" alt="image-20201030135230070"></p>
<p>这道题由于要返回一个二维数组，可以理解成每个元素里的内容是每一层的左右结点；</p>
<p>那么层次遍历是怎么遍历的呢：根结点 → 左子树A → 右子树 B→ 左子树A的左子树 → 左子树A的右子树 →右子树B的左子树 → 右子树B的右子树……</p>
<p>那就可以用队列来实现啦：</p>
<ul>
<li>先把根结点假如队列中，如果不为空 就加入数组中</li>
<li>判断该结点是否有子树（先判断左 再判断右），有的话加入队列之中</li>
<li>我们可以通过<code>queue.size()</code>得到队列的大小，也就是一层有多少个结点，通过这个就可以知道我们的子数组有几个元素了</li>
<li>在每一次的循环结束后，把我们得到的这一层的子数组都加入我们结果数组即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>) queue.offer(cur);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = queue.size();</span><br><span class="line">            List&lt;Integer&gt; sublist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (curSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                sublist.add(curr.val);</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                curSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sublist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031202611983.png" alt="image-20201031202611983"></p>
<p>什么叫对称的二叉树?很简单，如果根结点为空 是对称，如果不为空，那么判断其左右子树是否==对称==，如果==对称==，那么这个树是==对称==的；</p>
<p>那么怎么知道他们的左右子树是不是==对称==的呢？很简单，左子树的左孩子与右子树的右孩子==对称==，左子树的右孩子与右子树的左孩子==对称==，那么这个树是对称的…</p>
<p>那么问题又来了…怎么知道他们的…ok，打住，看到这我们已经非常清楚递归的每一步应该干什么了吧？</p>
<ul>
<li><p>递归的终止条件：左结点为空，判断右结点是否为空；右结点为空，判断左结点是否为空；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right == <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left == <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：分别传入新的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：真值【true or false】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> left.val == right.val</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-验证二叉树"><a href="#98-验证二叉树" class="headerlink" title="98.验证二叉树"></a>98.验证二叉树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031210034522.png" alt="image-20201031210034522"></p>
<p>这道题其实让我学到了新知识：那就是二叉搜索树的中序遍历是一个递增的序列；</p>
<p>那么这道题就可以利用这个特性了，解题思路:中序遍历得到一个序列，判断是不是递增的 → 树是不是二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &gt;= list.get(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inOrder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inOrder(node.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201031212019514.png" alt="image-20201031212019514"></p>
<p>上面我们学到了怎么把搜索树转换成一个有序数组，那么接下来让我们反着来，把一个有序数组转换成二叉搜索树</p>
<p>二叉搜索树有什么特性？我们再复习一次：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>现在我们的数组是一个==有序数组==，意味着他已经是排序好了的（升序）；也就是选定一个下标，其左边的值一定小于他，其右边的值一定大于他。在其左边的部分和右边部分亦是如此。</p>
<p>那难道我们这个下标可以随便选嘛？不是的，这道题还有个条件：平衡</p>
<ul>
<li><em>平衡要求左右子树高度差的绝对值不超过1。</em></li>
</ul>
<p>那我们就得用二分法，把相对高度控制在1了</p>
<ul>
<li><p>递归的终止条件：把二分的终止条件拿来用 → left &gt; right；用于控制相对高度差为1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：首先需要计算出中值，然后创建一个新的节点，把中值交给他，同时数组左半边就是他的左子树了，同理，数组右半边就是它的右子树了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">root.left = biuldBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">root.right = biuldBST(nums, mid + <span class="number">1</span>, right);</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归的返回值是什么：构建二叉树嘛，那返回值自然是结点了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        TreeNode root = biuldBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">biuldBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = biuldBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = biuldBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99.恢复二叉搜索树"></a>99.恢复二叉搜索树</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201106182812384.png" alt="image-20201106182812384"></p>
<p>看到二叉搜索树，条件发生想起来：<strong>中序遍历是升序数组</strong></p>
<p>这题要恢复二搜索树，无非就是把升序数组中，影响了升序这个条件的两个值交换即可；</p>
<p>比如一个序列：<code>1、2、3、4、5</code> 他是有序的，而<code>1、3、2、4、5</code>是无序的，其中的2和3就是影响了升序的那两匹<strong>害群之马s</strong></p>
<p>由于少不了要与之前的值进行比较，因此少不了一个pre结点，用于记录上次遍历的结点</p>
<p>又由于要恢复，因此不仅仅要找到这两个值，还需要记录这两个值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上次遍历的结点</span></span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="comment">//第一个错的结点</span></span><br><span class="line">TreeNode first;</span><br><span class="line"><span class="comment">//第二个错的结点</span></span><br><span class="line">TreeNode second;</span><br></pre></td></tr></table></figure>

<p>而要整理出升序数组，需要中序遍历，当然了，在中序的时候应该进行一些操作 去找出那两个奇怪的值；</p>
<p>那么中序遍历中：</p>
<ul>
<li><p>递归的终止条件：结点为空的时候终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一层递归要进行什么处理：正常中序遍历的同时，需要将上次遍历的结点的值与当前遍历到的结点的值进行比较</p>
<p>如果==pre.val &gt; root.val，即之前结点的值大于当前的==，就pre结点就是第一个出问题的结点</p>
<p>ok，重点来了，为什么<code>second = root</code> 没有在if条件中进行，而是单独的呢？</p>
<p>因为假如我们出问题的两个数值并不相连，比如<code>1、5、3、4、2、6、7</code>序列中出问题的是<strong>5和2</strong>；</p>
<p>first 是 5，没有问题，但假如second = root写在if中，second 就是3了；</p>
<p>因此 当下一次判断出前面的值比后面的值大了，出问题的（second的值）就不是前面那个值（比如说上述序列中的4）</p>
<p>而是后面的root代表的值（比如上面说的2）；因此second才是正确的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">   <span class="keyword">if</span>(first == <span class="keyword">null</span>) first = pre;</span><br><span class="line">   second = root;</span><br><span class="line">&#125;</span><br><span class="line">pre = root;</span><br><span class="line">inOrder(root.right);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>每一层递归的返回值是什么：由于这个函数的功能主要是用于找出结点，也不是建立什么树，因此无须返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上次遍历的结点</span></span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="comment">//第一个错的结点</span></span><br><span class="line">    TreeNode first;</span><br><span class="line">    <span class="comment">//第二个错的结点</span></span><br><span class="line">    TreeNode second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">int</span> temp = first.val;</span><br><span class="line">        first.val = second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="keyword">null</span>) first = pre;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="串结构"><a href="#串结构" class="headerlink" title="串结构"></a>串结构</h1><h2 id="LeetCod-串相关"><a href="#LeetCod-串相关" class="headerlink" title="LeetCod-串相关"></a>LeetCod-串相关</h2><ul>
<li>串的问题一般都需要用到DP的思想去解决</li>
</ul>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004161742293.png" alt="image-20201004161742293"></p>
<p>这题一开始我想到的是用类似于异或运算的方法去解决，用一个数组去表示答案，遍历两个字符串，如果有相同的就消掉为0，最后再遍历一次数组，假如发现有不是0的 代表两个字符串并不是字母异位的。</p>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判 假如字符串长度都不同，也就没有比的必要了</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//为什么是26个呢 因为26个单词嘛 26个多一个保险点</span></span><br><span class="line">        <span class="comment">//都转成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] a1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] a2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="comment">//一个加</span></span><br><span class="line">            arr[a1[i] - <span class="number">97</span>]++;</span><br><span class="line">            <span class="comment">//一个减少</span></span><br><span class="line">            arr[a2[i] - <span class="number">97</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//有不是0的代表没消掉</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来看答案，好像有个方法可以直接排序后直接比较 学到了</p>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] a1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] a2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(a1);</span><br><span class="line">        Arrays.sort(a2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(a1, a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201004172342276.png" alt="image-20201004172342276"></p>
<p>看到这种翻转题，我条件反射就想到了用栈，FILO的性质太适合了。</p>
<p>那么怎么用栈呢？整体思路就是：遇到了空格 那么前面肯定是一个单词了，把他push进栈里面；</p>
<p>整个遍历结束后，用一个字符串接受答案，一个接一个pop出来就好；</p>
<p>这题的小细节很多，比如，我们可以在尾部加一个空格方便判断是单词</p>
<p>由于题目要求，保证前面是不能有空格的，那么就得先pop一个出来，再添加后续的单词；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//倒序输出 很自然想到了栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//为了保证判断的一致性 在尾部添加一个空格</span></span><br><span class="line">        s += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果遇到空格 发现是一个单词了 就把之前的push</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    stack.push(tmp.toString());</span><br><span class="line">                    <span class="comment">//别忘了重置tmp</span></span><br><span class="line">                    tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没遇到空格 就把遇到的单词拼在一起</span></span><br><span class="line">                tmp.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈为空 说明就是个空串</span></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//答案字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//由于末尾的空格是不要的 那么就得先pop掉最上面的</span></span><br><span class="line">        res.append(stack.pop());</span><br><span class="line">        <span class="comment">//遍历栈 不停的加</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            res.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            res.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h1><p>（邻接矩阵，邻接表)</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表概念"><a href="#哈希表概念" class="headerlink" title="哈希表概念"></a>哈希表概念</h2><h2 id="哈希表方法"><a href="#哈希表方法" class="headerlink" title="哈希表方法"></a>哈希表方法</h2><h2 id="哈希表源码-实现"><a href="#哈希表源码-实现" class="headerlink" title="哈希表源码 实现"></a>哈希表源码 实现</h2><h2 id="LeetCode-哈希表相关"><a href="#LeetCode-哈希表相关" class="headerlink" title="LeetCode-哈希表相关"></a>LeetCode-哈希表相关</h2><h3 id="3-无重复的最长字符串"><a href="#3-无重复的最长字符串" class="headerlink" title="3.无重复的最长字符串"></a>3.无重复的最长字符串</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009174019820.png" alt="image-20201009174019820"></p>
<p>一开始看到这题有想到用数组去模拟哈希表，但是想借此机会学习一下哈希表，毕竟从来没有用过哈希表，只听过它和大概用途；</p>
<p>哈希表其实就是用于检查冲突的，然后很多功能都是基于Key和Value映射关系；我们用哈希表做题就是利用了这个特性</p>
<p>那么怎么用哈希表来解决这道题呢？</p>
<ul>
<li>思路：用哈希表存储字符串中每个字符在第几个索引中出现，边遍历边存，假如发现有重复的字符，找到该字符位置，然后<strong>窗口</strong>的左端向右平移一个单位。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果存在了这个字符 就取偏右方的那个</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a[i])) &#123;</span><br><span class="line">                <span class="comment">//map.get返回的是key的索引 为什么要+1呢 是因为假如有重复的字符了 就要向右偏移一位</span></span><br><span class="line">                left = Math.max(left, map.get(a[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//map.put方法 把 a[i]放到i的位子上</span></span><br><span class="line">            map.put(a[i], i);</span><br><span class="line">            ans = Math.max(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckppikue2000np0wicgil77u6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/UesugiEr11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-09-08T03:35:02.615Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a>►<a class="article-category-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/UesugiEr11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h1><h2 id="操作系统目标及作用"><a href="#操作系统目标及作用" class="headerlink" title="操作系统目标及作用"></a>操作系统目标及作用</h2><p>现代计算机中的计算机硬件:输入设备+输出设备+存储器+运算器+控制器</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200908184220320.png" alt="image-20200908184220320"></p>
<ul>
<li>操作系统（Operating System，OS）：是管理计算机硬件与软件资源的系统软件，也是计算机系统的内核与基石。<ul>
<li>操作系统处理管理与配置内存</li>
<li>决定系统资源供需的优先次序</li>
<li>控制输入与输出设备</li>
<li>操作网络与管理文件系统等基本事务</li>
<li>提供一个让用户与系统交互的操作界面</li>
</ul>
</li>
</ul>
<h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的<strong>目标</strong></h3><ol>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ol>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的<strong>作用</strong></h3><ol>
<li>作为用户与计算机硬件系统之间的接口：OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200909195136530.png" alt="image-20200909195136530"></li>
<li>作为计算机系统资源的管理者：管理计算机资源，这些资源包括CPU、内存、磁盘驱动器、打印机等。</li>
<li>实现了对计算机资源的抽象：为其他软件软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li>
</ol>
<h2 id="操作系统发展过程"><a href="#操作系统发展过程" class="headerlink" title="操作系统发展过程"></a>操作系统发展过程</h2><h3 id="未配置操作系统计算机系统"><a href="#未配置操作系统计算机系统" class="headerlink" title="未配置操作系统计算机系统"></a>未配置操作系统计算机系统</h3><ol>
<li>人工操作</li>
<li>脱机输入/输出（Off-Line I/O）方式<ol>
<li>脱机IO：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存；</li>
<li>联机IO：在主机的直接控制下进行输入/输出的方式，称为联机输入/输出（On-Line I/O）方式</li>
</ol>
</li>
</ol>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><ul>
<li><p>具体的工作过程是首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给作业；该作业处理完时，又把控制权交给监督程序，再由监督程序把磁带的第二个作业调入内存等等。可以看成是串行的。</p>
</li>
<li><p>优点：解决人机矛盾和CPU与IO设备速度不匹配问题，提高系统资源的利用率和系统吞吐量。</p>
</li>
<li><p>缺点：不能充分的利用系统资源，现很少使用。</p>
</li>
</ul>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li>用户所提交的作业先放在外存上，并排成一个<strong>队列（后备队列）</strong>，由作业调度程序按照一定的算法，从后备队列中选择若干个作业调入内存，使其共享CPU和系统中的各种资源。同时在内存中装入若干程序，这样可以在A程序运行时，利用其IO操作而暂停的CPU空挡时间，再调度另一道程序B运行，同样可以利用B程序在IO操作时调用CPU空档调用程序C运行，<strong>使用多道程序交替运行，始终保持CPU忙碌的状态。</strong></li>
<li><mark>优势</mark>：资源利用率高，使CPU始终处于忙碌的状态，<strong>提高内存的利用率，提高IO利用率</strong>；系统<strong>吞吐量大</strong>（CPU和其资源始终保持忙碌的状态，仅在作业完成时或者运行不下去的时候才切换，系统开销小）。</li>
<li><mark>缺点</mark>：<strong>平均周转时间长，无交互能力。</strong></li>
</ul>
<h3 id="分时系统（Time-Sharing-System"><a href="#分时系统（Time-Sharing-System" class="headerlink" title="分时系统（Time Sharing System)"></a>分时系统（Time Sharing System)</h3><h4 id="分时系统概念"><a href="#分时系统概念" class="headerlink" title="分时系统概念"></a>分时系统概念</h4><p>在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<h4 id="分时系统特征"><a href="#分时系统特征" class="headerlink" title="分时系统特征"></a>分时系统特征</h4><ol>
<li>多路性：多用户同时在各自终端上使用同一CPU。 </li>
<li>独立性：用户可彼此独立操作，互不干扰，互不混淆。 </li>
<li>及时性：用户在短时间内可得到系统的及时回答。 </li>
<li>交互性：用户与系统进行人机对话。 </li>
</ol>
<h3 id="实时系统（Real-Time-System）"><a href="#实时系统（Real-Time-System）" class="headerlink" title="实时系统（Real Time System）"></a>实时系统（Real Time System）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170212997.png" alt="image-20201219170212997"></p>
<h4 id="实时系统概念"><a href="#实时系统概念" class="headerlink" title="实时系统概念"></a>实时系统概念</h4><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<h4 id="实时系统的类型"><a href="#实时系统的类型" class="headerlink" title="实时系统的类型"></a>实时系统的类型</h4><ol>
<li>工业（武器）控制系统</li>
<li>信息查询系统</li>
<li>多媒体系统</li>
<li>嵌入式系统</li>
</ol>
<h4 id="实时任务的类型"><a href="#实时任务的类型" class="headerlink" title="实时任务的类型"></a>实时任务的类型</h4><ol>
<li>周期性实行任务和非周期性实时任务。</li>
<li>硬实时任务和软实时任务。</li>
</ol>
<h4 id="实时任务特征"><a href="#实时任务特征" class="headerlink" title="实时任务特征"></a>实时任务特征</h4><ol>
<li><strong>多任务：</strong>由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。</li>
<li><strong>抢占调度：</strong>真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级，在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。</li>
<li><strong>任务间的通讯与同步：</strong>在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。</li>
<li><strong>任务与中断之间的通信：</strong>尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要在任务级和中断级之间存在通信。</li>
</ol>
<h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913173604664.png" alt="image-20200913173604664"></p>
<h3 id="并发（Concurrence）"><a href="#并发（Concurrence）" class="headerlink" title="并发（Concurrence）"></a>并发（Concurrence）</h3><ul>
<li><p>并行：指两个或多个事件在<strong>同一时刻发生</strong>；</p>
</li>
<li><p>并发：指两个或多个事件在<strong>同一时间间隔内</strong>发生</p>
</li>
<li><p>具体地说：并发指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故在微观上这些程序是分时地交替执行。<br>若计算机系统有多个处理机，这些可以并发执行的程序便可以被分配到多个处理机上，实现并行执行。即利用每一个处理机来处理一个可并发执行的程序。</p>
</li>
<li><p>引入概念<strong>【进程】</strong>：指在系统中能独立运行 并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p>
</li>
<li><p>在一个没有引入进程的系统中，属于同一个应用程序的计算机程序和 I/O程序之间只能是顺序执行，也就是计算机程序执行告一段落后，才允许I/O程序执行；反之，在程序执行I/O操作时，计算程序也不能执行。———–为计算程序和I/O程序分别建立一个进程（Process）后，这两个程序就可以 并发执行。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913161252525.png" alt="image-20200913161252525"></p>
<h3 id="共享（Sharing）"><a href="#共享（Sharing）" class="headerlink" title="共享（Sharing）"></a>共享（Sharing）</h3><ul>
<li>在OS环境下的资源共享或称为资源复用，指的是系统中的资源可供内存中多个并发执行的进程共同使用。  ——-在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。</li>
<li>实现资源共享的两种方式<ul>
<li><strong>互斥共享方式</strong>：系统中的某些资源：如打印机、磁带机等，虽然可以提供给多个进程（线程）使用，但是应规定在一段时间内，只允许一个进程访问该资源。<pre><code>-------“临界资源”：一段时间内只允许一个进程访问的资源</code></pre></li>
<li><strong>同时共享方式</strong>：系统中还有另外一些资源，允许在一段时间内由多个进程“同时”对它们进行访问。  ——这里的“同时”也就是前面讲的在微观下交替进行的。<pre><code>典型的例子：磁盘设备！</code></pre></li>
</ul>
</li>
</ul>
<p>*<em>并发和共享是OS的两个最基本的特征！没有并发和共享就谈不上虚拟和异步； *</em></p>
<h3 id="虚拟（Virtual）"><a href="#虚拟（Virtual）" class="headerlink" title="虚拟（Virtual）"></a>虚拟（Virtual）</h3><p>虚拟和异步是依赖于并发特性的。</p>
<p>所谓虚拟（Virtual）是指通过某种技术把一个物理实体变成为若干个逻辑上的对应物。<br>物理实体是实际存在的东西，逻辑实体是虚的，它并不存在，但是用户却感觉它存在。<br>用于实现虚拟的技术称为虚拟技术，在操作系统中利用了两种方式实现虚拟技术：时分复用技术和空分复用技术。</p>
<h4 id="时分复用技术"><a href="#时分复用技术" class="headerlink" title="时分复用技术"></a>时分复用技术</h4><p>时分复用技术概念:将资源在不同的时间片内分配给各进程以使该资源被重复利用，从而提高资源的利用率。如采用时分复用的虚拟处理机，能够在不同的时间片内处理多个用户的请求，从而使得用户感觉自己独占主机，而处理机在这期间也被充分的利用。</p>
<ol>
<li><strong>虚拟处理机技术</strong>：一台处理机，通过时分复用的方法，能实现同时（宏观上）为多个用户服务，亦即，利用多道程序设计技术，可将一台物理上的处理机虚拟为多台逻辑上的处理机 —- 虚拟处理机。</li>
<li><strong>虚拟设备技术</strong>：通过时分复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备。</li>
</ol>
<ul>
<li><p>这样可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户“同时”访问的共享设备</p>
</li>
<li><p>当一种资源在时间上复用时，不同的程序或用户轮流使用它。时分复用技术通过利用处理及的空闲时间运行其他程序，提高了处理机的利用率</p>
</li>
</ul>
<h4 id="空分复用技术"><a href="#空分复用技术" class="headerlink" title="空分复用技术"></a>空分复用技术</h4><ul>
<li><p>实质上就是每次只把用户程序的一部分调入内存运行，运行完成后将该部分换出，再换入另一部分到内存中执行，通过这样的<strong>置换</strong>功能，实现了用户程序的各个部分分时地进入内存运行。</p>
</li>
<li><p>让同一个频段在不同的空间内得到重复利用。空分复用技术利用存储器的空闲空间分区域分存放和运行其他多道程序，以此来提高内存的利用率。</p>
</li>
</ul>
<p><strong>注意：采用分时复用技术，每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N，同理，采用空分复用技术，一台虚拟设备平均占用的空间必然等于或低于物理设备所拥有空间的1/N</strong></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li><p>由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“走走停停”的方式运行。</p>
<p>对于内存中的每个进程，在何时能获得处理机执行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，<strong>每道程序总共需要多少时间才能完成等等，都是不可预知的</strong>。</p>
<p>进程是以人们不可预知的速度向前推进的，此即进程的<strong>异步性</strong>。</p>
</li>
</ul>
<h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022162226039.png" alt="image-20201022162226039"></p>
<h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><p>操作系统关于进程方面管理任务有如下几种：<strong>进程控制</strong>，<strong>进程同步</strong>，<strong>进程通信</strong>，<strong>调度</strong></p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul>
<li>为作业创建进程、撤销（终止）已结束的进程，控制进程在运行过程中的状态转换。</li>
</ul>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ul>
<li>为了使多进程同时运行时协调，有两种方式<ul>
<li><strong>进程互斥方式</strong>：进程在对临界资源进行访问时，应采用互斥方式。（<strong>临界资源加锁实现，关锁时禁止访问；锁开时允许访问。</strong>）</li>
<li><strong>进程同步方式</strong>：相互合作去完成共同任务的进程间，由同步机构对他们的执行次序加以协调。（<strong>信号量机制</strong>）</li>
</ul>
</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul>
<li>实现相互合作进程之间的信息交换。</li>
</ul>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ol>
<li><strong>作业调度</strong>：从后备队列中按照一定算法选择出若干个作业，为他们分配运行所需资源，讲作业调入内存后，分别建立与之对应的进程，使它们成为可能获得处理机的就绪进程，并将他们插入就绪队列中。</li>
<li><strong>进程调度</strong>：从进程就绪队列中按照一定算法选出一个进程，将处理机分配给他，并为他设置运行现场，使其投入执行。</li>
</ol>
<h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>内存管理主要功能：<strong>内存分配</strong>，<strong>内存保护</strong>，<strong>地址映射</strong>，<strong>内存扩充</strong></p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ol>
<li><strong>作用</strong>：为每道程序分配内存空间；提高存储器利用率，尽量减少内存空间碎片。</li>
<li><strong>两种内存分配方式</strong>：<ol>
<li><strong>动态内存分配</strong>：每个作业所要求的基本内存空间也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。</li>
<li><strong>静态内存分配</strong>：每个作业的内存空间是在作业装入时确定的；在作业装入后的整个运行期间，不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”。</li>
</ol>
</li>
<li><strong>内存分配机制应具有的结构和功能</strong>：内存分配数据结构、内存分配功能、内存回收功能。</li>
</ol>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><ol>
<li><strong>主要作用</strong>：确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；绝不允许用户程序访问操作系统的程序和数据；也不允许用户程序转移到非共享的其它用户程序中去执行。</li>
<li><strong>内存保护机制</strong>：设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。系统对每条指令所要访问的地址进行检查，如果发生越界，产生越界中断请求，停止该程序的执行。</li>
</ol>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><ul>
<li>程序的逻辑地址通常从0开始，而物理地址不从0开始，因此需要一个映射转换过程。主要功能即为：将地址空间的逻辑地址转换为内存空间与之对应的物理地址。</li>
</ul>
<h4 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h4><ol>
<li>借助于虚拟存储技术，从逻辑上去扩充内存容量。</li>
<li>为了能在逻辑上扩充内存，系统必须具有内存扩充机制，用于实现下述各功能：<ol>
<li><strong>请求调入功能</strong>:允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向 OS 发出请求，由 OS 从磁盘中将所需部分调入内存，以便继续运行。</li>
<li><strong>置换功能</strong>：若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内存。</li>
</ol>
</li>
</ol>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><ul>
<li><strong>主要任务</strong>：<ul>
<li>完成用户进程提出的I/O请求；为用户进程分配其所需的I/O设备；</li>
<li>提高CPU和I/O设备的利用率；提高I/O速度；方便用户使用I/O设备。</li>
</ul>
</li>
<li>为此，设备管理应具有<strong>缓冲管理</strong>、<strong>设备分配</strong>和<strong>设备处理</strong>等功能。</li>
</ul>
<h4 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h4><ul>
<li>CPU运行的高速性和I/O低速性间的矛盾自计算机诞生时起便已存在。<br>如果在I/O设备和CPU之间引入缓冲，则可有效地缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量。<br>因此，在现代计算机系统中， 都毫无例外地在<strong>内存中设置了缓冲区</strong>，而且还可通过<strong>增加缓冲区容量的方法，来改善系统的性能</strong>。</li>
</ul>
<h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><ul>
<li>设备分配的基本任务，是根据用户进程的I/O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。如果在I/O设备和CPU之间，还存在着设备控制器和I/O通道时，还须为分配出去的设备分配相应的控制器和通道。</li>
</ul>
<h4 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h4><ul>
<li>设备处理程序又称为设备驱动程序。基本任务是<strong>用于实现CPU和设备控制器之间的通信</strong>，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作；反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。</li>
<li>处理过程是：设备处理程序首先检查I/O请求的合法性，了解设备状态是否是空闲的，了解有关的传递参数及设置设备的工作方式。然后向设备控制器发出I/O命令，启动I/O设备去完成指定的I/O操作。</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><ul>
<li>文件管理的主要任务是对<strong>用户文件和系统文件进行管理以方便用户使用</strong>，<strong>并保证文件的安全性。</strong><br>为此，文件管理应具有对<strong>文件存储空间的管理</strong>、<strong>目录管理</strong>、<strong>文件的读/写管理</strong>以及<strong>文件的共享与保护等功能。</strong></li>
</ul>
<h4 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h4><ul>
<li>由文件系统对诸多文件及文件的存储空间，实施统一的管理。其主要任务是<strong>为每个文件分配必要的外存空间</strong>，提高外存的利用率，进而提高文件系统的存、取速度。</li>
<li>为此，系统中应设置用于记录<strong>文件存储空间使用情况的数据结构</strong>，以供分配存储空间时参考，<strong>还应具备对存储空间进行分配和回收的功能</strong>。</li>
</ul>
<h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><ul>
<li>目录管理的主要任务，是为每个文件建立一个目录项，并对众多的目录项加以有效的组织，以实现方便的按名存取。</li>
<li>通常由系统为每个文件建立一个目录项。目录项包括文件名、文件属性、文件在磁盘上的物理位置等。由若干个目录项又可构成一个目录文件。即用户只须提供文件名， 即可对该文件进行存取。</li>
</ul>
<h4 id="文件的读-写管理"><a href="#文件的读-写管理" class="headerlink" title="文件的读/写管理"></a>文件的读/写管理</h4><ul>
<li>该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。由于读和写操作不会同时进行，故可合用一个读/写指针。</li>
</ul>
<h4 id="文件的共享与保护"><a href="#文件的共享与保护" class="headerlink" title="文件的共享与保护"></a>文件的共享与保护</h4><ul>
<li>防止未经核准的用户存取文件；防止冒名顶替存取文件；防止以不正确的方式使用文件。</li>
</ul>
<h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><ul>
<li><p>引题：<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171719035.png" alt="image-20200913171719035"></p>
</li>
<li><p>包含关系:<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913172420937.png" alt="image-20200913172420937"></p>
</li>
</ul>
<h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><ul>
<li>为了方便用户<strong>直接/间接</strong>控制自己的作业，操作系统提供了<strong>命令接口</strong>，该接口又分为<strong>联机用户接口</strong>、<strong>脱机用户接口</strong>和<strong>图形用户接口</strong>3种</li>
</ul>
<h5 id="联机用户接口"><a href="#联机用户接口" class="headerlink" title="联机用户接口"></a>联机用户接口</h5><ul>
<li><strong>用户说一句，系统做一句。</strong>用户可通过先后键入不同命令的方式，来实现对作业的控制，直至作业完成。</li>
<li><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170246761.png" alt="image-20200913170246761"></li>
</ul>
<h5 id="脱机用户接口"><a href="#脱机用户接口" class="headerlink" title="脱机用户接口"></a>脱机用户接口</h5><ul>
<li><strong>用户说一堆，系统做一堆。</strong>该接口是为批处理<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913170618948.png" alt="image-20200913170618948"></li>
</ul>
<h5 id="图形用户接口"><a href="#图形用户接口" class="headerlink" title="图形用户接口"></a>图形用户接口</h5><ul>
<li>采用图形化操作界面。</li>
</ul>
<h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><ul>
<li>由一组系统调用命令（简称系统调用，也称广义指令）组成。</li>
<li>系统调用的目的：<strong>请求系统服务</strong></li>
<li>系统调用/程序接口/程序接口 是<strong>操作系统提供给编程人员的接口</strong> 选C<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175632848.png" alt="image-20200913175632848"></li>
<li><strong>系统调用≠库函数 选A</strong><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913175227658.png" alt="image-20200913175227658"></li>
</ul>
<p>注意事项:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200913171920463.png" alt="image-20200913171920463"></p>
<h2 id="操作系统的运行机制与结构"><a href="#操作系统的运行机制与结构" class="headerlink" title="操作系统的运行机制与结构"></a>操作系统的运行机制与结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>简单这么理解：一个程序要跑，需要调用一定的指令对吧？但是并不是所有指令都能为我们所用，有一些特定指令需要有特定的<strong>权限身份</strong></p>
<p>也就是<strong>处理机状态</strong>，比如说 我要跑一个内核程序，需要调用特权指令，那么我能在用户态下进行吗？显然不可以，需要在核心态中执行。</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>要明白操作系统的运行机制，首先需要有一个关于<strong>指令</strong>的相关知识储备</p>
<p><mark>指令</mark>要与代码区分开，一个代码可能会被翻译成多个机器语言指令</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170458068.png" alt></p>
<p>简单来说，<mark>指令</mark>是让（CPU）能识别、执行的最基本命令（比如加法指令 就是让CPU进行加法运算）</p>
<h4 id="处理机状态"><a href="#处理机状态" class="headerlink" title="处理机状态"></a>处理机状态</h4><p>由于有一些指令涉及到了内核，如果让操作计算机的用户去使用就很危险，于是我们设立了<strong>权限</strong></p>
<p>将处理机分为两种状态，让一些指令只允许特定的状态处理机调用</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170801720.png" alt="image-20201219170801720"></p>
<h4 id="程序状态"><a href="#程序状态" class="headerlink" title="程序状态"></a>程序状态</h4><p>有了两种处理机状态，相应的就有两种程序状态：</p>
<p>也就是<strong>内核程序和应用程序</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219170850126.png" alt="image-20201219170850126"></p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172008907.png" alt="image-20201219172008907"></p>
<ul>
<li>操作系统内核是计算机上配置的<strong>底层软件</strong>，是操作系统<mark>最基本、最核心</mark>的部分</li>
<li>实现操作系统内核功能的那些程序我们称之为<strong>内核程序</strong></li>
</ul>
<p>一般来说操作系统的内核可分为以下几部分：</p>
<ol>
<li>时钟管理：实现计时功能</li>
<li>中断处理：实现中断机制</li>
<li>原语<ol>
<li>是一种特殊的程序</li>
<li>处于操作系统最底层，最接近硬件的部分</li>
<li>这种程序的运行具有<strong>原子性</strong>，也就是运行只能够一气呵成，不可中断</li>
<li>运行时间短，使用频繁</li>
</ol>
</li>
<li>为系统资源进行管理的功能<ol>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol>
</li>
</ol>
<h4 id="传统OS结构"><a href="#传统OS结构" class="headerlink" title="传统OS结构"></a>传统OS结构</h4><h5 id="无结构OS"><a href="#无结构OS" class="headerlink" title="无结构OS"></a>无结构OS</h5><ul>
<li>OS的各部分是以最基本的过程存在，每个过程都可随意地调用其他过程</li>
</ul>
<h5 id="模块化结构OS"><a href="#模块化结构OS" class="headerlink" title="模块化结构OS"></a>模块化结构OS</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><ul>
<li>对OS的各部分经过了划分，行程若干个具有一定独立性和大小的模块</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914164420048.png" alt="image-20200914164420048"></p>
<h6 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h6><ul>
<li>模块划分过小→降低本身复杂性，但会引起<strong>模块之间联系过多</strong>，造成系统混乱</li>
<li>模块划分过大→增加模块内部复杂性，使<strong>内部联系增加</strong></li>
<li>内聚性：指模块内部各部分间联系的亲密程度。<strong>内聚性高→模块独立性强</strong></li>
<li>耦合度：指模块间相互联系和相互影响的程度。<strong>耦合度低→模块独立性强。</strong></li>
</ul>
<h6 id="模块接口法的优缺点"><a href="#模块接口法的优缺点" class="headerlink" title="模块接口法的优缺点"></a>模块接口法的优缺点</h6><ul>
<li>优点<ul>
<li>提高OS设计的正确性、可理解性和可维护性</li>
<li>增强OS的可适应性</li>
<li>加速OS的开发过程</li>
</ul>
</li>
<li>不足/存在的问题<ul>
<li>接口规定困难</li>
<li>存在无序性</li>
</ul>
</li>
</ul>
<h5 id="分层式结构OS"><a href="#分层式结构OS" class="headerlink" title="分层式结构OS"></a>分层式结构OS</h5><h6 id="分层式结构概念"><a href="#分层式结构概念" class="headerlink" title="分层式结构概念"></a>分层式结构概念</h6><ul>
<li>目标系统An和裸机系统A0之间有许多层次软件：A1，A2，A3….An-1，使An通过这几层最终能在A0上运行。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914170157431.png" alt="image-20200914170157431"></p>
<h6 id="分层结构的优缺点"><a href="#分层结构的优缺点" class="headerlink" title="分层结构的优缺点"></a>分层结构的优缺点</h6><ul>
<li>优点<ul>
<li><strong>易保证系统的正确性</strong>：自下而上的设计方式使所有设计的决定都是有序的或者说是建立在较为可靠的基础上的，这样比较容易保证整个系统的正确性。</li>
<li><strong>具有易扩充和易维护性</strong>：在系统中增加、修改或替换一个层次中模块或整个层次时，只要不改变相应层次间接口，就不会影响其他层次，这就使得维护和扩充变得easy。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>系统效率降低</strong>：由于层次结构是分层单项依赖的，必须在每层间都建立层次间的通信机制，OS执行一个功能就得由上到下穿越多层次，就会增加系统通信开销，从而导致系统效率降低。</li>
</ul>
</li>
</ul>
<h4 id="客户端-服务端"><a href="#客户端-服务端" class="headerlink" title="客户端/服务端"></a>客户端/服务端</h4><h5 id="客户-服务器模式由来、组成和类型"><a href="#客户-服务器模式由来、组成和类型" class="headerlink" title="客户/服务器模式由来、组成和类型"></a>客户/服务器模式由来、组成和类型</h5><ul>
<li><strong>客户机</strong>：每台客户机都是一个自主计算机，具有一定处理能力，客户进程在其上运行，平时处理一些本地业务，也可以发送一个消息给服务器用以请求某项服务</li>
<li><strong>服务器</strong>：通常是一台规模较大的机器，含有网络文件系统或数据库系统，应能为网上所有用户提供一种或多种服务。</li>
<li><strong>网络系统</strong>：用于连接所有客户机和服务器，实现他们之间通信和网络资源共享的系统</li>
</ul>
<h5 id="客户-服务器之间交互"><a href="#客户-服务器之间交互" class="headerlink" title="客户/服务器之间交互"></a>客户/服务器之间交互</h5><p>一次完整的交互过程可以分成以下四步：</p>
<ol>
<li><strong>客户发送请求消息</strong></li>
<li><strong>服务器接收消息</strong></li>
<li><strong>服务器回送信息</strong></li>
<li><strong>客户机接收消息</strong></li>
</ol>
<h5 id="客户-服务器模式优点"><a href="#客户-服务器模式优点" class="headerlink" title="客户/服务器模式优点"></a>客户/服务器模式优点</h5><ol>
<li>数据的分布处理和存储</li>
<li>便于集中管理</li>
<li>灵活性和可扩充性</li>
<li>便于改编应用软件</li>
</ol>
<p>ps：经常会问到 在微内核OS中，为什么要采用客户/服务器模式？我们答客户/服务器模式的优点即可</p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>为什么要有微内核，肯定是由于<strong>大内核不够好</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201219172044943.png" alt="image-20201219172044943"></p>
<h5 id="微内核OS的基本概念"><a href="#微内核OS的基本概念" class="headerlink" title="微内核OS的基本概念"></a>微内核OS的基本概念</h5><p>微内核技术——把操作系统中更多的成分和功能放到更高的层次（用户模式）中去运行，而留下一个尽量小的内核，<strong>用它来完成操作系统最基本的核心功能。</strong></p>
<p>基于微内核OS结构是建立在<strong><mark>模块化和层次化</mark></strong>结构的基础上的；</p>
<ol>
<li>足够小的内核：微内核≠一个完整的OS，含有：<ol>
<li>与硬件处理紧密相关的部分</li>
<li>一些较基本的功能</li>
<li>客户和服务器之间的通信</li>
</ol>
</li>
<li>基于【<mark>客户/服务器模式</mark>】<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200914173409746.png" alt="image-20200914173409746"></li>
<li>应用”机制和策略分离”原理<ol>
<li>机制：是指在实现某一功能时的具体规定或说原则</li>
<li>策略：在机制的基础上，借助某些参数和算法，用以实现该功能的优化，或达到不同的目标</li>
</ol>
</li>
<li>采用面向对象技术</li>
</ol>
<h5 id="微内核的基本功能"><a href="#微内核的基本功能" class="headerlink" title="微内核的基本功能"></a>微内核的基本功能</h5><p>基于【机制与策略分离】的原理，将机制部分以及与硬件紧密相关的部分放入微内核中。由此微内核通常具有如下几个方面功能：</p>
<ol>
<li>进程（线程）管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ol>
<h5 id="微内核操作系统的优点"><a href="#微内核操作系统的优点" class="headerlink" title="微内核操作系统的优点"></a>微内核操作系统的优点</h5><ol>
<li>提高了系统的可扩展性</li>
<li>增强了系统的可靠性</li>
<li>可移植性强</li>
<li>提供了对分布式系统的支持</li>
<li>新技术——融入了面向对象技术</li>
</ol>
<h5 id="微内核操作系统存在的问题"><a href="#微内核操作系统存在的问题" class="headerlink" title="微内核操作系统存在的问题"></a>微内核操作系统存在的问题</h5><ol>
<li>缺点:微内核操作系统的运行效率相较早期操作系统有所降低</li>
<li>改进方法:可以把一些常用的操作系统基本功能由服务器移入微内核中</li>
</ol>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><ul>
<li>前趋图(Precedence Graph)是指一个有向无循环图，可记为DAG，用于描述进程之间执行的先后顺序</li>
</ul>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><ul>
<li>特征：<ul>
<li><strong>顺序性</strong>：所谓顺序性是指，处理机严格的按照程序所规定的顺序执行，<strong>一个操作的开始必须在其前一个操作结束之后。</strong></li>
<li><strong>封闭性</strong>：所谓封闭性是指，程序在执行的时候<strong>独占全机的资源</strong>。</li>
<li><strong>可再现性</strong>：所谓可再现性是指，只要<strong>初始条件</strong>和<strong>运行环境系统</strong>相同，其<strong>运行结果</strong>一定是一样的。</li>
</ul>
</li>
</ul>
<h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><ul>
<li><p>事实上，只有不存在前趋关系的程序之间才有可能并发执行，否则无法并发执行</p>
</li>
<li><p>特征：</p>
<ul>
<li><strong>间断性</strong>：所谓间断性指的是，由于多个程序对资源的要求产生的制约性，而导致的某一个程序在运行时等待资源的情况。 比如有两个程序都需要使用打印机这个资源，如果其中的一个程序已经占用，而另一个必须等待。这样后者表现出来的就是程序运行时的间断性。</li>
<li><strong>失去封闭性</strong>：所谓失去封闭性指的是，<strong>由于多个程序并发执行会共享资源</strong>，从而导致各个程序运行环境会失去封闭性。</li>
<li><strong>不可再现性</strong>：所谓不可再现性是指相同的输入，由于资源的共享，导致最后的输出结果不同。</li>
</ul>
</li>
</ul>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161832422.png" alt="image-20201022161832422"></p>
<h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>程序：是静态的，是一个存放在磁盘里的可执行文件，是一系列的指令集合</p>
</li>
<li><p>进程：是动态的，是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p>其中，进程实体包含三部分：<strong>程序段</strong>，<strong>相关的数据段</strong>和<strong>PCB</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193349420.png" alt></p>
</li>
<li><p>程序进程关系:一个程序多次执行会对应多个进程，比如说QQ可以登录三个账号。那么既然都是QQ，那OS是怎么区分不同进程的呢？当进程被创建的时候，OS会为该进程分配一个<strong>唯一的，不重复</strong>的<strong>身份证</strong>——<strong>PID（Process ID，进程ID）</strong><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193516137.png" alt="image-20200916193516137"></p>
</li>
<li><p><strong>进程控制块（PCB）</strong>：OS需要记录进程PID，分配了哪些资源，运行情况，那么这些信息需要记录到哪里呢？答案就是进程控制块——PCB。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916192007658.png" alt="image-20200916192007658"></p>
<ul>
<li>作用：PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。下面是具体作用：<ul>
<li>作为独立运行基本单位的标志：在进程的整个生命周期中，系统总是通过PCB对进程进行控制的，亦即系统是根据 进程的PCB感知该进程的存在的，<strong>所以，PCB是进程存在的唯一标志。</strong></li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其他进程的同步与通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>主要由：<strong>动态性，并发性，独立性，异步性，结构性</strong>组成。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916193752881.png" alt="image-20200916193752881"></p>
<h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161752742.png" alt="image-20201022161752742"></p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态有五种:<strong>创建状态，就绪状态，执行状态，阻塞状态，终止状态</strong>；其中<strong>就绪、执行、阻塞</strong>是三种基本状态。</p>
<h4 id="创建态、就绪态"><a href="#创建态、就绪态" class="headerlink" title="创建态、就绪态"></a>创建态、就绪态</h4><ul>
<li><strong>创建状态</strong>:对于处于创建态的进程，当其获得了所需的资源以及对其PCB的初始化工作完成后，便可由创建态转入就绪态</li>
<li><strong>就绪状态</strong>：进程已经处于准备好运行的状态了，只需要CPU临门一脚便可以立即执行。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916194852489.png" alt></p>
<h4 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h4><ul>
<li><strong>运行态</strong>：指进程已经获CPU，其程序正在执行的状态。在单处理机系统中，只有一个进程处于执行状态，而在多处理机系统中，有多个进程处于执行状态。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916195133485.png" alt="image-20200916195133485"></p>
<h4 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h4><ul>
<li><strong>阻塞态</strong>：指正在执行的进程由于发生某事件（I/O请求，申请缓冲区失败等）暂时无法继续执行时的状态，亦即进程的执行收到阻塞。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916203322409.png" alt="image-20200916203322409"></li>
</ul>
<h4 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h4><ul>
<li><p><strong>终止态</strong>：即一个进程达到了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204018353.png" alt="image-20200916204018353"></p>
</li>
</ul>
<h3 id="进程的转换"><a href="#进程的转换" class="headerlink" title="进程的转换"></a>进程的转换</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><ul>
<li>基本的三态模型</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161914285.png" alt="image-20201213161914285"></p>
<h4 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h4><ul>
<li>未引入挂起的五态模型:</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/03/31/Aryfbt.png" alt></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200916204307618.png" alt="image-20200916204307618"></p>
<p>引起进程状态转换的具体原因如下：</p>
<ul>
<li>NULL→新建态：执行一个程序，创建一个子进程。</li>
</ul>
<ul>
<li><p>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</p>
</li>
<li><p>就绪态→运行态：进程被调度</p>
</li>
<li><p>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</p>
</li>
</ul>
<ul>
<li><p>运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
</li>
<li><p>运行态→阻塞态：等待使用资源；如等待外设传输；等待人工干预。</p>
</li>
<li><p>阻塞态→就绪态：申请资源被分配，或等待的事件已经发生了</p>
</li>
<li><p>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>
</li>
</ul>
<ul>
<li>阻塞态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</li>
</ul>
<ul>
<li>终止态→NULL：完成善后操作。</li>
</ul>
<h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><p>接下来，我们引入了两个操作：挂起和激活</p>
<p>当挂起操作作用于某个进程时，该进程将被将被挂起，意味着此时该进程处于静止状态；</p>
<p>假如进程正在执行，他将暂停执行。</p>
<p>假如进程原本就处于就绪状态，则该进程此时暂不接受调度。</p>
<p>与挂起操作对应的就是激活啦。</p>
<ul>
<li>引入挂起后的进程状态转换五态模型:</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161938789.png" alt="image-20201213161938789"></p>
<ul>
<li><p>引入创建和终止——七态模型:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151351838.png" alt="image-20201005151351838"></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/20171208095743596" alt="这里写图片描述"></p>
<p>引起进程状态转换的具体原因如下：</p>
<ul>
<li>等待态—→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</li>
<li>挂起等待态—→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态。</li>
<li>挂起就绪态—→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</li>
<li>就绪态—→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</li>
<li>挂起等待态—→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</li>
<li>运行态—→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 CPU，，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</li>
<li>新建态—→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</li>
</ul>
<h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><h3 id="线性方式"><a href="#线性方式" class="headerlink" title="线性方式"></a>线性方式</h3><ul>
<li>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</li>
</ul>
<h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><ul>
<li>系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213505282.png" alt="image-20200919213505282"></li>
</ul>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919213530758.png" alt="image-20200919213530758"></li>
</ul>
<h2 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能；</p>
<p>简单来说，进程控制→实现进程状态转换。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161725493.png" alt="image-20201022161725493"></p>
<ul>
<li><p>简单的流程图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005155458987.png" alt="image-20201005155458987"></p>
</li>
</ul>
<h3 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919214807617.png" alt="image-20200919214807617"></p>
<p>与硬件紧密相关的模块、各种常用的设备的驱动程序以及运行频率较高的模块，安排在紧靠硬件的软件层次中，将它们常驻内存，通常被称为<strong>OS内核</strong>；<strong>也就是OS内核其实本质上是各个模块</strong>。</p>
<h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><ul>
<li>我们知道原语的执行具有原子性，它执行过程只能一气呵成，不允许被打断，那么为什么要一气呵成呢？下图即为解释<strong>，假如不一气呵成，就会导致操作系统某些关键的数据结构信息不统一，就会影响操作系统进行别的管理工作</strong>。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215018317.png" alt="image-20200919215018317"></li>
<li>如何实现原语的原子性呢？其实是利用了“<strong>关中断指令</strong>“和”<strong>开中断指令</strong>“;</li>
<li>CPU执行了关中断指令后，不会再check中断信号，直到遇到了开中断指令才会再去check；</li>
<li>因此关——开中断之间的指令是连续的，不可中断的，这就实现了原子性；<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919215955758.png" alt="image-20200919215955758"></li>
</ul>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>创建原语：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配所需的资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ol>
<p>哪里会用到进程创建呢？</p>
<ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919220556546.png" alt="image-20200919220556546"></p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>终止/撤销原语:</p>
<ol>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若该进程正在运行，立刻剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程所拥有的所有资源还给父进程或操作系统</li>
<li>删除PCB</li>
</ol>
<p>哪里会用到进程终止呢？</p>
<ol>
<li>正常结束：进程自己请求终止</li>
<li>异常结束：非法使用特权指令</li>
<li>外界干预：用户自己选择杀某进程</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222346641.png" alt="image-20200919222346641"></p>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p>被什么事件所阻塞就会被该事件所唤醒</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200919222900878.png" alt="image-20200919222900878"></p>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p>切换原语:</p>
<ol>
<li>将<strong>运行环境信息</strong>存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复<strong>进程所需的运行环境</strong></li>
</ol>
<p>这里有一个地方：<strong>进程所需的运行环境</strong>是什么东西呢?</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920180827278.png" alt="image-20200920180827278"></p>
<p>首先回顾一下我们程序是如何运行的：是通过把我们的代码保存到硬盘然后转入内存，然后CPU去从内存中读取一条条指令，然后我们的程序就跑起来了。</p>
<p>那么CPU中有个东西 叫做<strong>寄存器</strong>。它们有不同的功能，<strong>比如可以存放下一条指令地址，也可以存放正在执行的指令，也可以保存暂时运算得到的结果</strong>；</p>
<p>然而我们知道寄存器并不是很专一的，他有可能会随时被其他的进程使用，那我们之前运算的结果啊，什么保存的指令啊，岂不是都不见了吗？</p>
<p><strong>这个时候就会用到我们的PCB了</strong>，它能够保持关键的一些信息，也就是运行环境，这样等我们的寄存器又空闲下来了的时候，我们就可以继续我们未完成的指令啦。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200920181231409.png" alt="image-20200920181231409"></p>
<h2 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160937233.png" alt="image-20201022160937233"></p>
<h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><p>首先，我们回顾一下我们之前学的进程异步问题，由于并发执行的进程以<strong>各自独立，不可预知速度</strong>向前推进，我们所得到的结果往往也会不一样，而我们往往有时候需要控制一个事件的发生在一个事件前，那么就需要<strong>进程同步</strong>啦</p>
<p>同步也称为<strong>直接制约关系</strong>，是指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的<strong>制约关系</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203323774.png" alt="image-20200924203323774"></p>
<p>有进程同步就有进程互斥，那么进程互斥又是什么呢？</p>
<p>要明白互斥，就引入了一个概念：<strong>临界资源</strong></p>
<ul>
<li><strong>临界资源</strong>，即一个时间段内只允许一个进程使用的资源。对于该资源我们必须互斥的访问，也就是我访问，你不能访问，反之亦然；因此</li>
<li><strong>进程互斥</strong>，即指当一个进程访问某临界资源时，另一个想访问此<strong>临界资源</strong>的进程<strong>必须要等待</strong>，只有当我正在访问该资源的进程访问结束了，释放掉了，下一个进程才能去访问该资源。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924203831680.png" alt="image-20200924203831680"></p>
<p>那么我们一般是如何进行对临界资源的访问的呢?<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924204737502.png" alt="image-20200924204737502"></p>
<ul>
<li>进入区：负责检查是否可以进入临界区（上锁）</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区：用于将临界区正被访问的标志恢复为未被访问的标志</li>
<li>剩余区：做其他处理</li>
</ul>
<p>ps：临界区是进程中访问临界资源的代码段；<strong>进入区</strong>和退出区是<strong>负责实现互斥</strong>的代码段；<strong>临界区</strong>也被称为”<strong>临界段</strong>“</p>
<h3 id="同步机制遵循的规则"><a href="#同步机制遵循的规则" class="headerlink" title="同步机制遵循的规则"></a>同步机制遵循的规则</h3><ul>
<li>空闲让进：多中选一</li>
<li>忙则等待：互斥访问</li>
<li>有限等待：避免死等</li>
<li>让权等待：避免忙等</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924205632915.png" alt="image-20200924205632915"></p>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><p>让硬件同步即为进程互斥的硬件实现方法：<strong>中断屏蔽方法，TestAndSet，Swap指令</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160746350.png" alt="image-20201022160746350"></p>
<h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><ul>
<li>在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200924211536165.png" alt="image-20200924211536165"></p>
<h4 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h4><p>简称TS指令，也有称TestAndSetLock指令，或TSL指令</p>
<p>用TS指令管理临界区的时候，为每个临界资源设置一个布尔变量lock；</p>
<p>用lock的布尔值就可以判断资源是否空闲，进程能否访问。</p>
<ul>
<li>优点:实现简单；适用于多处理机的环境</li>
<li>缺点:不满足让权等待</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153906850.png" alt="image-20201005153906850"></p>
<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>有的地方称为Exchange指令，或XCHG指令；Swap指令用硬件实现，不允许被中断</p>
<p>Swap指令与TS指令在逻辑上其实差不多，但Swap需要两个参数，不需要返回值，TS需要一个共享的变量实现互斥，因此在不同的地方就要用不同的方式去进行进程互斥。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153942707.png" alt="image-20201005153942707"></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160710930.png" alt="image-20201022160710930"></p>
<h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p> <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927175523422.png" alt="image-20200927175523422"></p>
<p>由于之前的措施方案无法实现进程的“让权等待”问题，因此我们引出了信号量这个概念进行解决；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200927220306063.png" alt="image-20200927220306063"></p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><ul>
<li>Dijkstra把整型信号量定义为一个用于表示资源数目的整形量S，它仅能通过P\V操作进行访问。（P\V 即 wait ＆ signal）这两个操作是原子操作，是不可以在执行过程中被中断的。</li>
<li>整形信号量存在的问题:不满足让权等待原则</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172546935.png" alt="image-20201204172546935"></p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><ul>
<li><p>对于每次的<strong>wait</strong>操作，意味着进程请求一个单位的该类资源，使系统中可供分配的<strong>该类资源数减少一个</strong>，因此描述为<strong>S→value–;</strong>当<strong>S→value &lt; 0</strong>时，表 示该类<strong>资源已分配完毕</strong>，因此进程应调用<strong>block原语进行自我阻塞</strong>，放弃处理机，<strong>并插入到信号量链表S→list中</strong>；</p>
</li>
<li><p>对于每次的<strong>signal</strong>操作，意味着执行<strong>进程释放一个单位资源</strong>，使<strong>系统中可供分配的该类资源数增加一个</strong>，故<strong>S→value++操作表示资源数目+1</strong>。若+1后还是<strong>S→value &lt;= 0</strong>,表示在该信号量链表中<strong>仍有等待该资源的进程被阻塞了</strong>，故应该调用<strong>wakeup</strong>原语，将<strong>S→list链表中的第一个等待进程</strong>唤醒。(被唤醒进程从阻塞态→就绪态)</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154049852.png" alt="image-20201005154049852"></p>
</li>
</ul>
<p>ps：记录型信号量可实现进程互斥、进程同步；如果出现了P(S),V(S)的操作，除非默认说明，默认S为记录型信号量</p>
<h4 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160633374.png" alt="image-20201022160633374"></p>
<h5 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172456487.png" alt="image-20201204172456487"></p>
<ul>
<li>为使得<strong>多个进程互斥访问某临界资源</strong>【目的】，为该资源设置 <strong>互斥信号量【mutex】</strong>，初始值为1</li>
<li>将该资源置于P、V操作之间；</li>
<li>注意：利用信号量机制去实现进程互斥时必须保证我们的P\V操作是成对出现的<ul>
<li>缺少P会导致系统混乱，不能保证对临界资源互斥访问</li>
<li>缺少V将会使临界资源永远不被释放，导致临界资源永远不被释放，从而使因等待该资源的阻塞的进程不能被唤醒</li>
</ul>
</li>
</ul>
<h5 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h5><ul>
<li>进程同步：要让各并发进程按要求有序地推进</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928160518569.png" alt="image-20200928160518569"></p>
<p>现在P1,P2并发执行，由于存在异步性，二者交替推进次序无法控制，是不确定的；</p>
<p>假如我P2的代码4需要用到P1的代码1、2、3运行结果才能执行的话，我就得保证代码4是在代码3后执行；</p>
<p>此即进程同步问题：<strong>让本异步并发的进程互相配合，有序推进。</strong></p>
<p>重点：在前操作之后执行V（S），在后操作之前执行P（S）； </p>
<p><mark>技巧口诀</mark>：前P后V</p>
<p>理解：信号量S表示某种资源，一开始没有这种资源；一开始的时候P2需要使用该资源，但是没有，只能由P1来产生（释放）该资源</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171002706.png" alt="image-20201204171002706"></p>
<h5 id="实现前趋关系"><a href="#实现前趋关系" class="headerlink" title="实现前趋关系"></a>实现前趋关系</h5><p>每一对的前趋关系都是一个进程同步的问题（为了保证一前一后的操作）</p>
<p>为了实现这个目标，我们需要做的事情</p>
<ol>
<li>为每一对前趋关系各设置一个同步信号量</li>
<li>在【<strong>前操作</strong>】的之后<strong>相对应的</strong>同步信号量执行<strong>V</strong></li>
<li>在【<strong>后操作</strong>】的之前<strong>相对应的</strong>同步信号量执行<strong>P</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171026404.png" alt="image-20201204171026404"></p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160532798.png" alt="image-20201022160532798"></p>
<h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><ul>
<li>为什么要引入管程？因为信号量机制存在一定的问题:编写程序困难，容易出错（那是肯定的，这么多PV操作，想不错都难）因此我们在1973年引入管程机制进行处理；</li>
</ul>
<h4 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h4><p><strong>代表资源的数据结构</strong>以及由对该共享数据结构实施操作的一组过程<strong>所造成的资源管理程序</strong>共同构成了一个<strong>操作系统的资源管理模块</strong>——<strong>管程</strong>。</p>
<p>管程是一种特殊的软件模块，由以下部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的一组过程（就是函数）</li>
<li>对局部于管程的共享数据设置初始值的语句【对数据结构初始化的语句】</li>
<li>管程有一个名字</li>
</ol>
<p>发现了吗，管程和我们面向对象的<strong>类</strong>有点相似——可以定义一些数据，可以定义一些对这些数据操作的函数，对属性初始化的语句。</p>
<h4 id="管程的基本特征"><a href="#管程的基本特征" class="headerlink" title="管程的基本特征"></a>管程的基本特征</h4><ol>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<p>什么意思呢？通过<strong>1+2</strong>我们可以知道，假如我们要<strong>修改管程内的数据结构</strong>，我们只能够通过调用<strong>管程内封装好的方法（函数）</strong>去修改数据结构；而<strong>3则实现了进程互斥</strong>；</p>
<h4 id="管程中的条件变量"><a href="#管程中的条件变量" class="headerlink" title="管程中的条件变量"></a>管程中的条件变量</h4><p>我们使用管程实现进程同步需要用到同步工具，如wait，signal；</p>
<p>但仅仅有这两个是不够的，我们知道，每次仅能有一个进程进入管程，假如某进程在管程中被挂起或阻塞就得等很久了，那么解决这问题就引入了——<strong>条件变量 condition</strong>。</p>
<p>怎么用呢？管程中对每个条件变量以说明<strong>：condition x，y</strong>；条件变量的操作是wait，signal；</p>
<p>每个<strong>条件变量保存一个链表</strong>，用以记录因为这条件变量所阻塞的所有进程，提供2个操作：</p>
<p><strong>x.wait 和 x.signal</strong></p>
<ul>
<li>x.wait：正在调用管程的进程因为<strong>x条件需要被阻塞或者挂起</strong>，调用<strong>x.wait</strong>将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其他进程可以使用该管程——让出了入口。</li>
<li>x.signal：若正在调用管程的进程<strong>发现x条件发生了变化</strong>，则调用<strong>x.signal</strong>，<strong>重新启动一个因x条件而阻塞或挂起的进程</strong>，如果存在多个这样的进程，则选择一个，如果没有，则继续执行原进程，而不产生任何结果。<ul>
<li>注意了 这与信号量机制的signal操作不能混为一谈，信号量中的signal需要s++操作，信号量改变了。</li>
</ul>
</li>
</ul>
<h4 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h4><p>管程中设置条件变量和等待唤醒操作，以解决同步问题。（condition xxx）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171155511.png" alt="image-20201204171155511"></p>
<ol>
<li>假如两个生产者进程并发执行，依次调用insert过程的话：<ol>
<li>第一个生产者进程可以顺利执行完insert函数</li>
<li>假如在第一个生产者进程还未结束的时候，第二个生产者进程插入进来了，就会把第二个进程阻塞在insert函数后面，排队 </li>
</ol>
</li>
<li>假如两个消费者进程先执行，生产者进程后执行的话：<ol>
<li>第一个进程进来，发现count = 0，那么就执行wait操作，就等待在empty变量相关的队列中</li>
<li>同样的，第二个就排在了empty变量相关的队列中</li>
<li>此时假如有个生产者进程进来了，进行生产，把生产品放在了缓冲区当中，假如发现自己的产品是第一个产品，那么此时有可能有别的消费者进程在等待产品，就执行一个唤醒操作，唤醒一个消费者进程。</li>
<li>然后count- -，同时检查拿走前缓冲区是否是满的，假如之前是满的，那么现在取走了一个，代表着可以再放一个（再由生产者生产一个），那生产者进程需要被唤醒了，就来一个signal（full）操作。</li>
</ol>
</li>
</ol>
<h4 id="Java中类似管程的机制"><a href="#Java中类似管程的机制" class="headerlink" title="Java中类似管程的机制"></a>Java中类似管程的机制</h4><p>Java中，如果用关键字【synchronized】描述一个函数，那么这个函数同一个时间段只能被一个线程调用。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001164432414.png" alt="image-20201001164432414"></p>
<h3 id="经典的进程同步问题"><a href="#经典的进程同步问题" class="headerlink" title="经典的进程同步问题"></a>经典的进程同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154151145.png" alt="image-20201005154151145"></p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>缓冲区未空（有产品）V→P消费者消费</li>
<li>缓冲区未满V→P生产者生产</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20200928204830509.png" alt="image-20200928204830509"></p>
<h5 id="问题的解法步骤"><a href="#问题的解法步骤" class="headerlink" title="问题的解法步骤"></a>问题的解法步骤</h5><ol>
<li>关系分析，找出题目中描述的各个进程，分析他们之间的同步、互斥关系</li>
<li>根据各进程的操作流程去确定P、V的大致顺序</li>
<li>设置信号量，根据题目条件设信号量初值<ol>
<li>互斥信号量初值一般为1</li>
<li>同步信号量的初值看对应的资源初值值（0/n…)</li>
</ol>
</li>
</ol>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ol>
<li>设置好信号量<ol>
<li>互斥信号量 = 1：实现对缓冲区的互斥访问</li>
<li>同步信号量<strong>empty</strong> = n：实现空闲缓冲区的数量</li>
<li>同步信号量<strong>full</strong> = 0：代表产品的数量，也即非空缓冲区的数量</li>
</ol>
</li>
<li>分别在生产者，消费者中放置P、V操作（注意顺序，以及操作的哪个信号量）</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171241240.png" alt="image-20201204171241240"></p>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><ul>
<li>想一想 能不能改变相邻P、V操作的顺序呢？</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154232845.png" alt="image-20201005154232845"></p>
<p>得出结论了：<strong>实现互斥的P操作必须放在实现同步的P操作之后；</strong>由于<strong>V操作并不会导致进程阻塞，因此两个V操作顺序可以交换</strong>；</p>
<h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171306215.png" alt="image-20201204171306215"></p>
<p>注意 这里的多生产者的多 代表的不是数量 而是多个类型</p>
<h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li>互斥关系:对缓冲区(盘子)的访问要互斥的进行</li>
<li>同步关系：父亲放苹果，女儿才能取苹果；母亲放橘子，儿子才能取橘子；盘子为空时，父/母才能放水果，因此需要儿/女进行从盘子取水果；</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序<ul>
<li>实现互斥:在临界区前后分别P、V</li>
<li>实现同步:前操作后V，后操作前P</li>
</ul>
</li>
<li>设置信号量</li>
</ul>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><ul>
<li>实现互斥访问盘子:mutex = 1</li>
<li>多少个苹果 apple = 0</li>
<li>多少个橘子 orange = 0</li>
<li>盘子中还能放多少水果 plate = 1</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171402041.png" alt="image-20201204171402041"></p>
<p>以父亲和女儿举例：</p>
<p>父亲首先应该P盘子，查看是否为空，如果为空，则V苹果（苹果++)；女儿首先P苹果，查看是否准备好了，有的话就取出，V盘子（盘子++)；为了保证互斥，必须在P、V操作之中加入对互斥信号量mutex 的 P、V操作。</p>
<h5 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h5><p>可不可以不要互斥信号量mutex？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005153712342.png" alt="image-20201005153712342"></p>
<p>由于缓冲区大小为1，因此orange，apple，plate三者中最多只有一个是1；这样的话最多只有一个进程的P操作不会被阻塞，可以顺利进入临界区，因此可以顺利执行；</p>
<p>那么假如缓冲区（plate）数量为2呢？</p>
<p>那么父亲和母亲都能访问盘子，有可能出现不同进程写入缓冲区的数据相互覆盖的问题；</p>
<p>得出结论:如果<strong>缓冲区的大小大于1</strong>，那么就必须<strong>专门设置一个互斥信号量mutex</strong>来保证互斥的访问缓冲区</p>
<h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171447979.png" alt="image-20201204171447979"></p>
<h5 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li>同步关系:桌上有组合1→第一个抽烟者取走；组合2→第二个抽烟者取走；组合3→第三个抽烟者取走</li>
<li>互斥关系:桌子只有一个，可以理解为容量为1的缓冲区需要互斥访问</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171522562.png" alt="image-20201204171522562"></p>
<h5 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h5><ul>
<li>桌上组合1、2、3分别为 offer1 offer2 offer3，他们的初值都是0</li>
<li>设置一个<strong>信号量i</strong>，用于实现三个抽烟者轮流吸烟</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163817853.png" alt="image-20201010163817853"></p>
<p>以smoker1为例，首先P（offer1）检查是否有需要的组合1，有的话就拿走去抽，并且告诉供给者抽完了，然后供给者i++，p一下finish，并将下一个组合放在桌上然后v下一个组合；</p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165136258.png" alt="image-20201010165136258"></p>
<h5 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li><strong>互斥关系</strong>：<strong>写进程-写进程</strong> <strong>写进程-读进程</strong> 这两者存在互斥关系。而<strong>读进程-读进程</strong>不存在互斥</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量<ul>
<li><strong>一个互斥信号量RW</strong>：写者访问文件的前后执行PV，读者访问前后执行PV</li>
<li><strong>整型变量count</strong> 记录当前有几个读进程在访问文件</li>
<li><strong>一个互斥信号量 mutex</strong> ：保证对count变量的互斥访问</li>
<li><strong>一个互斥信号量 w</strong> ：用于实现写优先</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010165807840.png" alt="image-20201010165807840"></p>
<h5 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171424288.png" alt="image-20201010171424288"></p>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010171711073.png" alt="image-20201010171711073"></p>
<h5 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h5><ul>
<li>找出题目描述的各进程，分析它们之间同步、互斥关系；<ul>
<li><strong>互斥关系</strong>：五位哲学家与左右邻居对其中间筷子的访问是互斥的</li>
</ul>
</li>
<li>根据进程的操作流程确定P、V操作大致顺序</li>
<li>设置信号量<ul>
<li><strong>一个互斥信号量组chopstick[5]</strong>：用于实现对五个筷子的互斥访问。其中哲学家编号<strong>[0…4]</strong>，各哲学家i的左边筷子编号为<strong>i</strong>，右边筷子编号为<strong>（i+1）%5</strong></li>
</ul>
</li>
</ul>
<p>然而我们发现 这样子会导致死锁的现象</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010172704302.png" alt="image-20201010172704302"></p>
<h5 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h5><p>按照之前的方法会发生死锁现象，那我们怎么解决呢？</p>
<p>有三种方法:</p>
<ol>
<li>最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子；偶数号哲学家相反。这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭的话，只有有其中一个可以拿起第一只筷子，而另一个因为拿不到第一个筷子就直接阻塞了。</li>
<li>仅当一个哲学家左右两只筷子都可用时才允许他抓筷子【这也是后面的<strong>破坏请求和保持条件</strong> 方法】</li>
</ol>
<p>下面以第三种方法为例，进行解决</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010174404648.png" alt="image-20201010174404648"></p>
<h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161648794.png" alt="image-20201022161648794"></p>
<h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><ul>
<li>进程通信是指进程之间的信息交换。</li>
<li>进程所拥有的内存地址空间相互独立，换而言之，进程不能直接访问另一个进程的地址空间，然而有时候有需要信息交换，那该怎么办呢？OS提供了一些方法给我们。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171611497.png" alt="image-20201204171611497"></p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p><strong>前提：两个进程对于共享空间的访问必须是互斥的。</strong></p>
<ul>
<li>基于数据结构共享：各进程公用某些数据结构，实现各进程的信息交换：如生产者-消费者问题中的有界缓冲区。是低级通信方式。</li>
<li>基于存储区共享：在内存中画一片共享存储区，数据形式和存放位置由进程控制而非OS。是高级通信方式。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171629840.png" alt="image-20201204171629840"></p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><ul>
<li>【管道 pipe文件】是指用于连接读写进程的一个共享文件，本质是内存空间中开辟的一个固定大小的缓冲区</li>
<li>管道采取半双工通信，一个时间段内只能实现单向传输；</li>
<li>进程互斥访问管道</li>
<li>管道写满时，写进程的系统调用被阻塞；管道为空时，读进程的系统调用被阻塞</li>
<li>没写满不准读，没读空不准写。</li>
<li>管道数据被读出后被抛弃，意味着读进程最多只能有一个，不然可能会读错数据。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154325305.png" alt="image-20201005154325305"></p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>进程通过【格式化的消息】为单位，将通信的数据封装在消息中，通过OS提供的发送接收原语，在进程间进行消息传递，完成进程的数据交换。是一种高级通信方式。</p>
<ul>
<li><p><strong>直接通信方式</strong>:发送进程利用OS提供的发送原语直接把消息发给接收进程/消息直接挂到接收方的消息队列中。</p>
</li>
<li><p><strong>间接通信方式/信箱通信方式</strong>:发送进程先发送到中间实体（信箱）中，接受进程再去接收，完成进程间的通信。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154353653.png" alt="image-20201005154353653"></p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161600061.png" alt="image-20201022161600061"></p>
<h3 id="线程的概念和特点"><a href="#线程的概念和特点" class="headerlink" title="线程的概念和特点"></a>线程的概念和特点</h3><ul>
<li>什么是线程?为什么要引入线程?</li>
</ul>
<p>假设现在有三个进程，他们所占用不同的空间内存和系统资源；假如我们要切换进程的时候，需要用保存/恢复运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销非常大，因此，人们引入了<strong>线程机制</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204171755001.png" alt="image-20201204171755001"></p>
<ul>
<li>引入了线程之后，线程是<strong>CPU调度</strong>的<strong>基本单位</strong>。一个进程里面可以包含多个线程。线程之间可以并发进行。</li>
<li>但是进程依旧是<strong>资源分配</strong>的<strong>基本单位</strong>，从属一进程的各线程共享使用进程的资源。</li>
<li>同一个进程内各个线程程间并发，不需要切换进程运行环境和内存地址空间，省时省力。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001180053003.png" alt="image-20201001180053003"></p>
<h3 id="引入线程后的变化"><a href="#引入线程后的变化" class="headerlink" title="引入线程后的变化"></a>引入线程后的变化</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154628052.png" alt="image-20201005154628052"></p>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154719829.png" alt="image-20201005154719829"></p>
<h3 id="线程的特性与优点"><a href="#线程的特性与优点" class="headerlink" title="线程的特性与优点"></a>线程的特性与优点</h3><ul>
<li><p>进程间并发，开销很大；线程间并发，开销很小</p>
</li>
<li><p>引入线程机制之后，并发带来的系统开销降低，系统并发性提升</p>
</li>
</ul>
<p>ps：从属于不同进程的线程间切换，也会导致进程间切换，开销也会很大。</p>
<ul>
<li>从属于同一进程的各个线程共享进程所拥有的资源。</li>
<li>进程间通信必须请求操作系统服务（CPU需要切换到核心态），开销大；同进程下线程通信，无需OS干预，开销更小；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201001193612876.png" alt="image-20201001193612876"></p>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172035911.png" alt="image-20201204172035911"></p>
<ol>
<li><strong>线程的管理工作是由谁完成的？</strong><ol>
<li>答 线程的管理工作由应用程序通过线程库来完成的，不是通过OS完成的</li>
</ol>
</li>
<li><strong>线程切换是否需要CPU从用户态转换为内核态?</strong><ol>
<li>答 在用户态下，由应用程序通过线程库就可以进行线程切换了</li>
</ol>
</li>
<li><strong>OS是否能意识到用户级线程的存在?</strong><ol>
<li>答 意识不到，只有用户能意识到有多个线程</li>
</ol>
</li>
<li><strong>用户级线程有什么优点和缺点？</strong><ol>
<li>答 优点：用户级线程的切换在用户态可以完成，不需要切换到核心态，系统开销小，效率高</li>
<li>缺点：假如其中某一个线程被阻塞了，其他线程都会被阻塞，并发度不高；</li>
</ol>
</li>
</ol>
<h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172104616.png" alt="image-20201204172104616"></p>
<ol>
<li>线程的管理工作由谁来完成?<ol>
<li>答 由OS内核完成</li>
</ol>
</li>
<li>线程切换是否需要CPU从用户态转换到内核态？<ol>
<li>答 由于线程调度、切换工作由内核负责，因此在内核级线程的线程切换时需要从用户态转换到内核态的。</li>
</ol>
</li>
<li>OS能否意识到内核级线程的存在?<ol>
<li>答 OS会为每个内核级线程建立对应TCB，然后通过TCB对线程进行管理，因此，OS能够意识到内核级线程的存在</li>
</ol>
</li>
<li>内核级线程的实现方式的优缺点？<ol>
<li>答 优点:内核级线程是<strong>处理机调度的基本单位</strong>，而进程只作<strong>为资源分配的基本单位</strong>；因此在多核CPU中，这几个线程可以被分配在多个不同cpu中并发执行，其中一个线程被阻塞了，其他的也能正常执行；</li>
<li>缺点:一个用户进程会占用多个内核级线程，线程切换由OS内核完成，由于用户态到核心态的转换需要开销，因此线程管理成本高，开销大。</li>
</ol>
</li>
</ol>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li><strong>一对一模型</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172255596.png" alt="image-20201204172255596"></p>
<ul>
<li><strong>多对一模型</strong></li>
</ul>
<p>操作系统只能看的见内核级线程，因此只有内核级线程才是处理机分配的单位</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172233221.png" alt="image-20201204172233221"></p>
<ul>
<li><strong>多对多模型</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201003171220652.png" alt="image-20201003171220652"></p>
<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161521827.png" alt="image-20201022161521827"></p>
<h3 id="调度基本概念"><a href="#调度基本概念" class="headerlink" title="调度基本概念"></a>调度基本概念</h3><ul>
<li>当有一堆任务需要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来决定<strong>处理这些任务的顺序</strong>，这就是<strong>调度</strong>所研究的问题，简单来说就是：<strong>按照某种算法选择一个进程将处理机分配给他</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204172349110.png" alt="image-20201204172349110"></p>
<h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154801232.png" alt="image-20201005154801232"></p>
<ul>
<li><p><strong>高级调度/长程调度/作业调度</strong>，调度对象为作业；</p>
</li>
<li><p>高级调度主要用于多道批处理系统中，什么是多道批系统呢？虽然前面讲过了 再复习一遍吧：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005144635558.png" alt="image-20201005144635558"></p>
</li>
<li><p>高级调度根据<strong>某种算法/一定的原则</strong>从处于<strong>后备队列</strong>的作业中<strong>挑选一个/多个作业</strong>，分配内存等资源，建立PCB，使他们<strong>获得竞争处理机的权利</strong>。</p>
</li>
<li><p>高级调度是<strong>外存与内存</strong>之间的调度，每个作业只调入一次，调出一次。调入时创建相应PCB，作业调出时又撤销PCB。由于调出的时机一定是作业运行结束的时候，因此<strong>高级调度主要是解决调入的问题</strong>。</p>
</li>
</ul>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005154819601.png" alt="image-20201005154819601"></p>
<ul>
<li><p><strong>中级调度/内存调度</strong>，引入这个调度的<strong>目的</strong>是为了<strong>提高内存的利用率和系统的吞吐量</strong>。</p>
</li>
<li><p>引入虚拟存储技术后，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为：<strong>就绪驻外存状态（挂起状态）</strong>，等它们已具备运行条件且内存又稍有空闲时，<strong>由中级调度决定</strong>，重新<strong>调入内存</strong>，<strong>并修改状态为就绪状态</strong>，挂在<strong>就绪队列上等待</strong>。</p>
<p>ps：PCB并不会一起被调到外存，而是常驻内存。<strong>OS</strong>通过<strong>内存中的PCB</strong>保持对各进程的<strong>监控和管理</strong>。</p>
</li>
</ul>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005151550183.png" alt="image-20201005151550183"></p>
<ul>
<li><strong>低级调度/进程调度/短程调度</strong>：调度对象是<strong>进程</strong>（或内核级线程）；</li>
<li>主要功能是根据某种<strong>算法/方法/策略</strong>，决定<strong>就绪队列</strong>中哪个进程应该获得处理机，将处理机分配给它。</li>
<li>这种调度方式是OS中<strong>最基本的一种调度</strong>，在<strong>多道批、实时和分时</strong>三种类型OS中<strong>必须</strong>配置这级调度；</li>
<li>低级调度的频率很高，一般几十毫秒一次；</li>
</ul>
<h4 id="三种调度方式的联系、对比"><a href="#三种调度方式的联系、对比" class="headerlink" title="三种调度方式的联系、对比"></a>三种调度方式的联系、对比</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152354921.png" alt="image-20201005152354921">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005152256817.png" alt="image-20201005152256817"></p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161258242.png" alt></p>
<h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160523382.png" alt="image-20201005160523382"></p>
<ul>
<li><p>这个地方有人会说:那么进程处于临界区时，不能进行处理机调度咯? 这个说法是错的 为什么呢？</p>
<ul>
<li><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源。</li>
<li><strong>临界区</strong>：访问临界资源的那段代码</li>
<li><strong>内核程序临界区</strong>：一般是用来访问某种内核数据结构的（比如进程的就绪队列，由各就绪队列PCB租成）</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005160815845.png" alt="image-20201005160815845"></p>
</li>
</ul>
<h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><h5 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161431904.png" alt="image-20201005161431904"></p>
<p>在采用这种方式时，可能<strong>引起进程调度的因素</strong>归结为:</p>
<ol>
<li>正在执行的进程运行完毕，或因发生某事件而使其无法再继续执行；</li>
<li>正在执行中的进程因提出I/O请求而暂停执行；</li>
<li>在进程通信/同步过程中，执行某原语操作；</li>
</ol>
<h5 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005161437212.png" alt="image-20201005161437212"></p>
<p>抢占<strong>并非是任意</strong>的，必须遵循一定原则。包括：</p>
<ol>
<li><strong>优先权原则：</strong>指允许优先级高的新进程抢占当前进程的处理机；</li>
<li><strong>短进程优先原则：</strong>指允许新的短进程可以抢占当前长进程的处理机；</li>
<li><strong>时间片原则：</strong>即各进程按时间片轮转运行时，当正在执行的进程一个时间片用完时，便停止该进程的执行而重新进行调度；</li>
</ol>
<h4 id="进程调度的切换与过程"><a href="#进程调度的切换与过程" class="headerlink" title="进程调度的切换与过程"></a>进程调度的切换与过程</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005162732619.png" alt="image-20201005162732619"></p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161204191.png" alt="image-20201022161204191"></p>
<h6 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163718195.png" alt="image-20201005163718195"></p>
<h6 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005163838042.png" alt="image-20201005163838042"></p>
<h6 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164349602.png" alt="image-20201005164349602"></p>
<ul>
<li><p>对于每个用户而言，都希望自己作业的周转时间短一点，然而对于OS，则向作业周转时间平均值小；那么引入了概念：带权周转时间，平均带权周转时间；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005164734068.png" alt="image-20201005164734068"></p>
</li>
</ul>
<h6 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165031694.png" alt="image-20201005165031694"></p>
<h6 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201005165627506.png" alt="image-20201005165627506"></p>
<h4 id="调度算法种类"><a href="#调度算法种类" class="headerlink" title="调度算法种类"></a>调度算法种类</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161053467.png" alt="image-20201022161053467"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022161135651.png" alt="image-20201022161135651"></p>
<h5 id="FCFS-先来先服务算法"><a href="#FCFS-先来先服务算法" class="headerlink" title="FCFS-先来先服务算法"></a>FCFS-先来先服务算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173524434.png" alt="    "></p>
<ul>
<li><p>FCFS例题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007173555912.png" alt="image-20201007173555912"></p>
</li>
</ul>
<h5 id="SJF-短作业优先算法"><a href="#SJF-短作业优先算法" class="headerlink" title="SJF-短作业优先算法"></a>SJF-短作业优先算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174950265.png" alt="image-20201007174950265"></p>
<ul>
<li><p>SJF例题:</p>
<ul>
<li><p>非抢占式：</p>
<p>在0时刻，只有P1进来了，在他运行的时间7内，P2,P3,P4都进来了，在P1结束后选择运行时间最短的P3执行，后续同理；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174045837.png" alt="image-20201007174045837"></p>
</li>
<li><p>抢占式：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174549414.png" alt="image-20201007174549414">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007174614069.png" alt></p>
</li>
</ul>
</li>
</ul>
<h5 id="HRRN-高相应比优先算法"><a href="#HRRN-高相应比优先算法" class="headerlink" title="HRRN-高相应比优先算法"></a>HRRN-高相应比优先算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007175748653.png" alt="image-20201007175748653"></p>
<ul>
<li>HRRN例题：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201007180105263.png" alt="image-20201007180105263"></p>
<h5 id="RR时间片轮转调度算法"><a href="#RR时间片轮转调度算法" class="headerlink" title="RR时间片轮转调度算法"></a>RR时间片轮转调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150220842.png" alt="image-20201008150220842"></p>
<ul>
<li><p>RR例题</p>
<ul>
<li><p><mark>时间片大小为2情况<mark>：</mark></mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145601465.png" alt="image-20201008145601465">)<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145627089.png" alt="image-20201008145627089"></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145644629.png" alt="image-20201008145644629"></p>
<p>最后的运行流程图：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145757946.png" alt="image-20201008145757946"></p>
<ul>
<li><p><mark>时间片大小为5情况</mark>：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008145938524.png" alt="image-20201008145938524"></p>
</li>
</ul>
</li>
</ul>
<p>补充:</p>
<ul>
<li>时间片太大的影响：如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法会退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>
<li>时间片太小的影响：如果时间片太小，我们知道，进程调度、切换是有时间代价的（保存、恢复运行环境），因此这样的话会导致进程切换过于频繁，系统会花大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。</li>
<li>因此时间片的大小应该取<strong>略大于一次典型交互的时间</strong></li>
</ul>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008152411598.png" alt="image-20201008152411598"></p>
<ul>
<li><p>例题</p>
<ul>
<li><p>非抢占式的优先级调度算法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008150852742.png" alt="image-20201008150852742"></p>
</li>
<li><p>抢占式的优先级调度算法：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008151221693.png" alt="image-20201008151221693"></p>
</li>
</ul>
</li>
</ul>
<p><strong>extra</strong>：</p>
<ul>
<li>就绪队列未必是只有一个的，可以按照不同优先级来组织；另外也可以把优先级高的进程排在更靠近对头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种；<ul>
<li>静态优先级:创建进程时确定，之后一直不变</li>
<li>动态优先级:创建进程时有一个初始值，之后根据情况动态地调整优先级</li>
</ul>
</li>
<li>如何合理设置各进程优先级呢？通常来说<ul>
<li><strong>系统进程</strong>优先级高于<strong>用户进程</strong></li>
<li><strong>前台进程</strong>优先级高于<strong>后台进程</strong></li>
<li><strong>I/0进程</strong>优先级高于<strong>计算型进程</strong></li>
</ul>
</li>
<li>若采用动态优先级，什么时候该调整？<ul>
<li>如果某进程在<strong>就绪队列中等待</strong>了很久，适当<strong>提升</strong>优先级</li>
<li>如果某进程<strong>占用处理机运行</strong>了很久，适当<strong>降低</strong>优先级</li>
<li>如果发现一个进程<strong>频繁进行I/0操作</strong>，适当<strong>提升</strong>优先级</li>
</ul>
</li>
</ul>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153258694.png" alt="image-20201008153258694"></p>
<ul>
<li><p>例题：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201008153117802.png" alt="image-20201008153117802"></p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160457079.png" alt="image-20201022160457079"></p>
<h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009145923563.png" alt="image-20201009145923563"></p>
<ul>
<li>简单来说，当一组进程发生死锁的情况下，这组<strong>死锁进程中的每个进程</strong>，都在<strong>等待另一个死锁进程所占有的资源</strong>，或者说每个进程所<strong>等待的事件</strong>是该组中<strong>其他进程释放所占有</strong>的<strong>资源</strong>。</li>
</ul>
<h3 id="死锁，饥饿，死循环"><a href="#死锁，饥饿，死循环" class="headerlink" title="死锁，饥饿，死循环"></a>死锁，饥饿，死循环</h3><ul>
<li><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
<li><strong>饥饿</strong>：由于长期得不到想要的资源，某进程无法向前推进的现象。eg.SPF算法中的如果短进程一直进来，长进程得不到处理机就会饥饿。</li>
<li><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序bug，有时候是故意写出来的。(pv操作)</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009150936475.png" alt="image-20201009150936475"></p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009151437016.png" alt="image-20201009151437016"></p>
<ol>
<li><strong>互斥条件</strong>：在一段时间内，某<strong>资源只能被一个进程所占有</strong>，若<strong>其他进程请求</strong>该资源，那就只能<strong>等待</strong>，直到占有<strong>该资源的进程用完释放</strong></li>
<li><strong>不可抢占条件</strong>：进程<strong>已获得的资源</strong>在<strong>未使用完</strong>之前<strong>不能被抢占</strong>，<strong>只能</strong>在进程使用完时<strong>由自己释放</strong></li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又<strong>提出了新的资源请求</strong>，而该<strong>资源</strong>又被<strong>其他进程占有</strong>，此时请求进程被<strong>阻塞</strong>，但又对自己已有的资源<strong>保持不放</strong>。</li>
<li><strong>循环等待条件</strong>：在发生死锁时，必然存在一个【<strong>进程-资源</strong>】的循环链，即进程集合{P0,P1,P2…..Pn}中：<strong>P0等待P1占用的资源，P1等待P2占用的资源…..Pn等待P0占用的资源</strong>；</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009152417463.png" alt="image-20201009152417463"></p>
<ul>
<li><strong>对不可剥夺资源的不合理分配，可能导致死锁</strong></li>
</ul>
<h3 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p>整体思路：破坏死锁产生的四个必要条件中的一个或几个</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160437390.png" alt="image-20201022160437390"></p>
<h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li><strong>破坏策略</strong>：把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li>
<li><strong>缺点</strong>：并不是所有的资源都可以改造成共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性。因此很多的时候是无法破坏互斥条件的。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009153658886.png" alt="image-20201009153658886"></p>
<h5 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h5><ul>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li><strong>破坏策略</strong>：<ul>
<li>当某个进程请求新的资源得不到满足的时候，必须立刻释放保持的所有资源，待以后需要时候再重新申请，即：<strong>即使某些资源尚未用完，也需要主动释放</strong>，从而破坏了不可剥夺条件。</li>
<li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，<strong>将想要的资源强行剥夺</strong>。这种方法需要考虑各进程的优先级。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>实现起来复杂</li>
<li>释放已获得的资源可能造成前一阶段的失效，因此这种方法一般只适用于容易保存和恢复状态的资源（CPU）</li>
<li>反复申请和释放资源增加系统开销，降低系统吞吐量</li>
<li>使用第一个方案，表示只要暂时得不到某资源，前面所获得资源全都得需要放弃，以后再申请。假如这种情况常发生，进程会饥饿。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154244423.png" alt="image-20201009154244423"></p>
<h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><ul>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>破坏策略</strong>：采用静态分配方法，即进程在运行前一次申请完所需要的全部资源，在它资源尚未满足前，不让它投入运行。一旦投入运行，这些资源就一直归他所有，该进程就不会再请求别的任何资源。</li>
<li><strong>缺点</strong>：有些资源可能只需要用很短时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也可能导致某些进程饥饿。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009154702673.png" alt="image-20201009154702673"></p>
<p>正因为这种方法缺点太明显，因此衍生出了<strong>第二种方法</strong>:</p>
<p><strong>它允许一个进程只获得初期所需的资源后，便开始运行。在运行过程中逐步释放已分配给自己的、且用毕的全部资源，然后再请求新的所需资源。</strong></p>
<h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><ul>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被下一个进程所请求</li>
<li><strong>破坏策略</strong>：采用顺序资源分配法<ul>
<li>给系统中资源编号</li>
<li>规定每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同资源）一次申请完</li>
<li>一个进程只有占有了小编号资源才有资格申请大编号资源</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>不方便添加新设备，有可能要重新分配编号嘛</li>
<li>进程实际使用资源顺序可能与编号递增顺序不同，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦（谢谢你啊 还替我考虑那么多</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009155649878.png" alt="image-20201009155649878"></p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><ul>
<li>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
</ul>
<h5 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h5><p><strong>安全序列</strong>：是指如果<strong>系统按照这种序列分配资源</strong>，则<strong>每个进程都能顺利完成</strong>。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能会有多个</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009160734369.png" alt="image-20201009160734369"></p>
<ul>
<li><strong>不安全状态</strong>：如果分配了资源之后系统<strong>找不出任何一个安全序列</strong>，系统就进入了<strong>不安全状态</strong>。意味着之后<strong>可能</strong>所有进程都无法顺利执行下去了。为什么说是可能呢？因为<strong>假如存在进程提前归还了资源</strong>，那么系统也有可能重新<strong>回到安全状态</strong>。</li>
<li><strong>安全状态、不安全状态、死锁</strong><ul>
<li>系统处于<strong>安全状态一定不会发生死锁</strong></li>
<li>系统处于<strong>不安全状态</strong>，<strong>有可能</strong>发生了<strong>死锁</strong></li>
<li>如果发生了<strong>死锁</strong>，<strong>一定</strong>处于<strong>不安全状态</strong></li>
</ul>
</li>
</ul>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><ul>
<li><strong>核心思想</strong>：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求</li>
<li>引例：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221753621.png" alt="image-20201009221753621"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009221808544.png" alt="image-20201009221808544"></p>
<p>那么对于上述这个例子，OS是怎么做的呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201009222819458.png" alt="image-20201009222819458"></p>
<ul>
<li><p>准备的数据结构:</p>
<ul>
<li><strong>长度为m</strong>的<strong>一维数组Available</strong>表示还有<strong>多少可用资源</strong></li>
<li><strong>n*m矩阵Max</strong>表示各进程对资源的<strong>最大需求数</strong></li>
<li><strong>n*m矩阵Allocation</strong>表示已经给各进程<strong>分配了多少资源</strong></li>
<li><strong>Max  - Allocation = Need 矩阵</strong>表示<strong>各进程最多还需要多少资源</strong></li>
<li><strong>长度为m</strong>的<strong>一维数组Request</strong>表示<strong>进程此次申请的各种资源数</strong></li>
</ul>
</li>
<li><p>银行家算法步骤:</p>
<ul>
<li>检查此次申请是否超过之前声明的最大需求数</li>
<li>检查此次系统剩余的可用资源是否还能满足此次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ul>
</li>
<li><p>安全性算法步骤：</p>
<p>检查当前剩余的可用资源是否能够满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</p>
</li>
</ul>
<p>例题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">     Allocation　　　Max　　　Available</span><br><span class="line"> 　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> P1   ００１４　　  ０６５６　　１５２０　</span><br><span class="line"> P2　 １４３２　　  １９４２　</span><br><span class="line"> P3　 １３５４　  　１３５６</span><br><span class="line"> P4 　１０００　　  １７５０</span><br><span class="line">我们会看到一个资源分配表，要判断是否为安全状态，首先先找出它的Need，Need即Max(最多需要多少资源)减去Allocation(原本已经分配出去的资源)，计算结果如下：</span><br><span class="line"></span><br><span class="line">   NEED</span><br><span class="line"> ＡＢＣＤ</span><br><span class="line"> ０６４２　</span><br><span class="line"> ０５１０</span><br><span class="line"> ０００２</span><br><span class="line"> ０７５０</span><br><span class="line">然后加一个全都为false的字段</span><br><span class="line"></span><br><span class="line"> FINISH</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line">接下来找出need比available小的(千万不能把它当成4位数 他是4个不同的数)</span><br><span class="line"></span><br><span class="line">   NEED　　  Available</span><br><span class="line"> ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> ０６４２　　１５２０</span><br><span class="line"> ０５１０&lt;-</span><br><span class="line"> ０００２</span><br><span class="line"> ０７５０</span><br><span class="line">P2的需求小于能用的，所以配置给他再回收</span><br><span class="line"></span><br><span class="line">  NEED　　   Available</span><br><span class="line"> ＡＢＣＤ　　ＡＢＣＤ</span><br><span class="line"> ０６４２　　１５２０</span><br><span class="line"> ００００　＋１４３２</span><br><span class="line"> ０００２－－－－－－－</span><br><span class="line"> ０７５０　　２９５２</span><br><span class="line">此时P2 FINISH的false要改成true(己完成)</span><br><span class="line"></span><br><span class="line"> FINISH</span><br><span class="line"> false</span><br><span class="line"> true</span><br><span class="line"> false</span><br><span class="line"> false</span><br><span class="line">接下来继续往下找，发现P3的需求为0002，小于能用的2952，所以资源配置给他再回收</span><br><span class="line"></span><br><span class="line"> 　NEED　　    Available</span><br><span class="line"> ＡＢＣＤ　　Ａ　Ｂ　Ｃ　Ｄ</span><br><span class="line"> ０６４２　　２　９　５　２</span><br><span class="line"> ００００　＋１　３　５　４</span><br><span class="line"> ００００－－－－－－－－－－</span><br><span class="line"> ０７５０　　３　12　10　6</span><br><span class="line"></span><br><span class="line">依此类推，做完P4→P1，当全部的FINISH都变成true时，就是安全状态。</span><br></pre></td></tr></table></figure>



<h4 id="检测和解除死锁"><a href="#检测和解除死锁" class="headerlink" title="检测和解除死锁"></a>检测和解除死锁</h4><ul>
<li>允许死锁的发生，不过OS会负责检测出死锁的发生，然后采取某种措施解决死锁</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160411857.png" alt="image-20201022160411857"></p>
<h5 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010161009559.png" alt></p>
<ul>
<li>检测死锁的算法</li>
</ul>
<p>简单来说就是<strong>依次消除与不阻塞进程相连的边</strong>，<strong>直到无边可消</strong>；但你要是非说严谨的话就是下面几步</p>
<ol>
<li>在资源分配图中，找出<strong>既不阻塞又不是孤点</strong>的进程<strong>Pi</strong> （不阻塞—— 所申请的资源数量必须小于等于系统中已有空闲资源数量；不是孤点——与该进程至少有一个边相连）。然后消去它的所有<strong>请求边，分配边</strong>，使之变为孤点</li>
<li>进程Pi释放的资源，可以唤醒某些因为等待这些资源而阻塞的进程——原来<strong>阻塞进程</strong>可能变为<strong>非阻塞进程</strong>；</li>
<li>若剩下进程都能按照如上操作，消去图中所有的边，<strong>所有</strong>的进程结点都变成<strong>孤点</strong>，那称该图是 <strong>可完全简化</strong> 的；反之则称该图是 <strong>不可完全简化</strong>的</li>
</ol>
<ul>
<li>死锁定理：如果某时刻系统的资源分配图是 <strong>不可完全简化</strong>的，那么此时<strong>系统死锁</strong></li>
</ul>
<h5 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201010163137747.png" alt></p>
<p>解除死锁的方法：</p>
<ol>
<li><strong>资源剥夺法</strong>：挂起某些死锁进程，并抢夺它的资源，将这些资源分配给其他的死锁进程</li>
<li><strong>撤销进程法/终止进程法</strong>：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</li>
<li><strong>进程回退法</strong>：让一个或多个死锁进程回退到足以避免死锁的地步</li>
</ol>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160329434.png" alt="image-20201022160329434"></p>
<ul>
<li><p>什么是内存？内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013164419312.png" alt="image-20201013164419312"></p>
</li>
</ul>
<h3 id="进程运行原理-指令"><a href="#进程运行原理-指令" class="headerlink" title="进程运行原理-指令"></a>进程运行原理-指令</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013165458590.png" alt="image-20201013165458590"></p>
<p>由 x = x + 1这个代码为例，它被编译后为三条指令；</p>
<p>第一条指令是让CPU进行数据传送，把内存单元为<strong>01001111</strong>的数据取出来取到地址为<strong>00000011</strong>的寄存器当中</p>
<p>第二条指令是让地址为<strong>00000011</strong>的寄存器上的数据+1</p>
<p>第三条指令是让CPU进行数据传送，把地址为<strong>00000011</strong>上的数据传送到地址为<strong>01001111</strong>的地方.</p>
<p>于是实现了 x = x + 1操作</p>
<p>ps：上述指令不是严谨的二进制指令，仅供参考。</p>
<h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>由于后续的学习，经常要进行内存之间的运算，而我们的单位往往需要统一，那么接下来就讲讲单位换算</p>
<ul>
<li><p>1B=8b=2^3b</p>
</li>
<li><p>1KB=1024B=2^10B</p>
</li>
<li><p>1MB=1024KB=2^10^KB= 2^20^B</p>
</li>
<li><p>1GB=1024MB = 2^10^MB= 2^20^KB= 2^30^B</p>
</li>
<li><p>1TB=1024GB=2^10^GB= 2^20^MB= 2^30^KB= 2^40^B</p>
</li>
</ul>
<h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>上面的指令操作提到了逻辑地址，那么什么是逻辑地址呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013171208992.png" alt="image-20201013171208992"></p>
<p>eg. 0号同学入住的是房号为5（N=5）的房间，那么3（M=3）号同学入住的就是8（N+M=5+3=8）号房间；</p>
<h3 id="写程序-运行程序"><a href="#写程序-运行程序" class="headerlink" title="写程序-运行程序"></a>写程序-运行程序</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013172103828.png" alt="image-20201013172103828"></p>
<ul>
<li>编辑：程序员编辑代码</li>
<li>编译：代码编译成若干个目标模块（把<strong>高级语言</strong>翻译为<strong>机器语言</strong>）</li>
<li>链接：由链接程序把 <strong>目标模块与所需库函数</strong> 连接在一起，形成一个<strong>完整的装入模块</strong></li>
<li>装入\装载：由<strong>装入程序</strong>将<strong>装入模块装入内存</strong>运行</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><ul>
<li>装入前链接成一个完整装入模块</li>
<li>在程序执行<strong>之前</strong>，先将<strong>目标模块以及它们所需的库函数</strong>连接成一个<strong>完整的可执行文件</strong>（装入模块），之后<strong>不再拆开</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191036437.png" alt="image-20201013191036437"></p>
<h5 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h5><ul>
<li><p>运行前边装入边链接</p>
</li>
<li><p>将各目标模块装入内存时，边装入边链接的链接方式</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191117077.png" alt="image-20201013191117077"></p>
</li>
</ul>
<h5 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h5><ul>
<li>运行时需要目标模块才装入并链接</li>
<li>在程序执行中需要该目标模块时，才对它进行链接。其<strong>优点</strong>是便于<strong>修改和更新</strong>，便于实现对<strong>目标模块的共享</strong>。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013191223728.png" alt="image-20201013191223728"></p>
<h4 id="装入-装载"><a href="#装入-装载" class="headerlink" title="装入\装载"></a>装入\装载</h4><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5><ul>
<li>编译时产生绝对地址</li>
<li>地址由编译器产生，而不是OS</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013183938535.png" alt="image-20201013183938535"></p>
<h5 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h5><ul>
<li>装入时逻辑地址转换为物理地址/绝对地址</li>
<li>转换过程由装入程序负责进行，装入程序是OS的一部分</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190449917.png" alt="image-20201013190449917"></p>
<h5 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h5><ul>
<li>运行时将逻辑地址转换为物理地址，并设置重定位寄存器</li>
<li>采用动态重定位方式装入的作业，其地址变换工作是在<strong>每执行一条指令时</strong>完成的</li>
<li>执行中允许<strong>OS有条件地</strong>将其移动</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201013190842596.png" alt="image-20201013190842596"></p>
<h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160304377.png" alt="image-20201022160304377"></p>
<h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><ul>
<li>OS需要负责内存空间的分配与回收<ul>
<li>记录哪些内存区域已经被分配出去了，哪些又属于空闲状态</li>
<li>当进程运行结束之后，将进程占用的内存空间回收</li>
<li>内存这么大，有很多位置可以放置内存，那么又该怎么分配内存空间？</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015211348937.png" alt="image-20201015211348937"></p>
<h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul>
<li>连续分配：指为用户进程分配的必须是一个连续的内存空间</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160222327.png" alt="image-20201022160222327"></p>
<h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><ul>
<li>在这种分法中，内存被分为系统区和用户区</li>
<li><strong>系统区</strong>：用于存放OS相关数据</li>
<li><strong>用户区</strong>：存放用户进程相关数据</li>
<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>
<li><strong>优点</strong>:实现简单，无外部碎片；</li>
<li><strong>缺点</strong>:只能用于单用户、单任务的OS中，有内部碎片，存储区利用率极低</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155052815.png" alt="image-20201017155052815"></p>
<h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><ul>
<li>固定分区<strong>目的</strong>：为了能在内存中装入多道程序，且这些程序之间又不会相互打扰</li>
<li><strong>如何实现</strong>：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</li>
<li>固定分区分配<strong>有两种方法</strong><ul>
<li>分区大小<strong>相等：</strong>缺乏灵活性，但适合用于用一台计算机控制多个相同对象的场合</li>
<li>分区大小<strong>不等：</strong>增加灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017155506303.png" alt="image-20201017155506303"></p>
<p>那么固定分区分配又是如何实现的呢？</p>
<ul>
<li><p>操作系统需要建立一个数据结构 —— <strong>分区说明表</strong>，实现各个分区的分配与回收。每个表象对应一个分区，通常按照分区大小排列。每个表包含对应分区的：<strong>大小、起始地址、状态</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017162252431.png" alt="image-20201017162252431"></p>
</li>
<li><p>当某用户程序要装入内存的时候，由OS内核程序根据用户程序大小检索该表，从中找到一个能满足大小、未分配的分区。将之分配给该程序，然后修改状态为“已分配”</p>
</li>
<li><p><strong>优点</strong>：实现简单，无外部碎片</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>当用户程序太大的时候，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这会降低性能</li>
<li><strong>会产生内部碎片，内存利用率低</strong></li>
</ul>
</li>
</ul>
<h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><ul>
<li><p>动态分区分配又称为可变分区分配。</p>
</li>
<li><p>这种分配方式<strong>不会预先划分内存分区</strong>，而是在<strong>进程装入内存的时候</strong>，根据进程的大小<strong>动态地建立分区</strong>，并使分区的大小正好适合进程的需要。</p>
</li>
<li><p>系统分区的大小和数目是可变的</p>
</li>
<li><p><strong>缺点</strong>：会产生很多外部碎片，虽然可以用【紧凑】技术去处理，但紧凑的时间代价很高</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163335963.png" alt="image-20201017163335963"></p>
</li>
</ul>
<p>下面思考三个问题：</p>
<ol>
<li><p>系统要用什么样的数据结构记录内存的使用情况?</p>
<p>通常使用 <strong>空闲分区表</strong>或者是<strong>空闲分区链</strong></p>
<p><strong>空闲分区表</strong>：每个空闲分区对应一个表项</p>
<p><strong>空闲分区链</strong>：每个分区的起始部分和末尾部分分别设置前向指针和后向指针</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017163635023.png" alt="image-20201017163635023"></p>
</li>
<li><p>当很多个空闲分区都能满足需求的时候，应该选择哪个分区进行分配呢？</p>
<p>把一个新作业装入内存的时候，需要按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（空闲分区链）中选出一个分区分配给该作业。</p>
</li>
<li><p>如何进行分区的分配与回收操作？</p>
<p><strong>分配:</strong></p>
<p>在上面的图示中，假如我们把一个4mb进程分配在了20MB处的话，我们只需要修改分区大小和起始地址即可</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017164819366.png" alt="image-20201017164819366"></p>
<p>假如我们分配在了4MB处的话，状态由空闲变为忙碌，则该行应该被删除，假如用空闲分区链的话，就把该节点删除</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165013499.png" alt="image-20201017165013499"></p>
<p><strong>回收</strong>：</p>
<p>假设一开始有个进程占据了14MB处（10+4），跑完了需要回收，<strong>回收区的后面/前面有一个相邻的空闲分区，那么就合并</strong></p>
</li>
</ol>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165628159.png" alt="image-20201017165628159"></p>
<p>   <strong>假如回收区的前、后各有一个相邻的空闲分区的话</strong></p>
<p>   例：在20和10mb中间有一个4mb的进程需要进行回收</p>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017165906305.png" alt="image-20201017165906305"></p>
<p>   <strong>假如回收区的前后都没有相邻的空闲分区的话</strong></p>
<p>   假设有一个进程占满了14mb的地方，此进程需要被回收</p>
<p>   <img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170134212.png" alt="image-20201017170134212"></p>
<ul>
<li><p>内部碎片，外部碎片</p>
<ul>
<li>内部碎片：位于一个<strong>操作系统分配的用于装载进程的内存区域</strong>或页面内部的空闲区域。</li>
<li>外部碎片：位于任何两个<strong>操作系统分配的用于装载进程的内存区域</strong>或页面之间的空闲区域，可以用紧凑技术进行解决</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017170829341.png" alt="image-20201017170829341"></p>
</li>
</ul>
<h6 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h6><ul>
<li><strong>算法思想</strong>:每次都从低地址开始查找，找到第一个能满足大小的空闲分区</li>
<li><strong>如何实现</strong>:空闲分区以<strong>地址递增的次序排列</strong>，每次分配内存的时候顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019154035820.png" alt="image-20201019154035820"></p>
<h6 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h6><ul>
<li><strong>算法思想</strong>:动态分区分配是一种连续分配的管理方式，因此为各进程分配的空间必须也是连续的一整片区域。因此为了保证当大进程进来的时候有能连续的大片空间，可以尽可能多的留下大片空闲区，换句话说，就是大片的先不用，优先的把小空闲区给用了先。</li>
<li><strong>如何实现</strong>:空闲分区按<strong>容量递增次序链接</strong>，每次分配内存的时候顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区</li>
<li><strong>缺点</strong>：会产生很多的<strong>外部碎片</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019155759288.png" alt="image-20201019155759288"></p>
<h6 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h6><p>为了解决上述出现的 产生很多外部碎片 这个问题，我们衍生出了新的与之相对的算法：<strong>最坏适应算法</strong></p>
<ul>
<li><strong>算法思想：</strong>每次分配的时候优先使用最大的连续空闲区，使得分配后剩余的空闲区不会太小，方便使用；</li>
<li><strong>如何实现：</strong>空闲分区<strong>容量递减次序链接</strong>。每次分配内存时候按照顺序查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</li>
<li><strong>缺点</strong>：每次都选最大的分区进行分配，会导致较大的连续空闲区被迅速消耗掉，有大进程来了，就没内存空间可以用了。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019160300060.png" alt="image-20201019160300060"></p>
<h6 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h6><p>我们每次算法讲到最后一个都是综合类的算法，结合了前面算法的特点综合的算法</p>
<p>不例外，我们这次也一样：<strong>临近适应算法</strong></p>
<ul>
<li><strong>算法思想:</strong>回想一下 ，首次适应算法是从链头开始找，低地址部分会出现小的空闲分区（外部碎片），而这些空闲分区部分我们往往用不上，因此会增加查找的开销。那么加入我们查找不从头开始，而是从上次查找结束的位置开始检索（因为后面是还没用到的部分，可以用的几率大点)，就能减少查找开销。</li>
<li><strong>如何实现</strong>：空闲分区以<strong>递增递增的顺序排列</strong>（可排成一个循环链表），每次分配内存的时候从上次查找结束的位置开始查找<strong>空闲分区链</strong>（or<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019161625044.png" alt="image-20201019161625044"></p>
<h6 id="四种算法总结"><a href="#四种算法总结" class="headerlink" title="四种算法总结"></a>四种算法总结</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019162144683.png" alt="image-20201019162144683"></p>
<h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160151687.png" alt="image-20201022160151687"></p>
<h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h6><ul>
<li><p>分页存储管理其实就是将<mark>一个进程</mark>的逻辑地址空间分成若干个大小相等的<strong>片</strong>；</p>
<p>这些<strong>片</strong>称为<strong>页</strong>或者<strong>页面</strong> 从零开始编号</p>
<p>相应的把内存空间分成与页面相同大小的若干个存储块 - 物理块/页框 同样 从0开始编号</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019163349804.png" alt="image-20201019163349804"></p>
<h6 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h6><p>回想我们之前所学的，进程在内存中连续存放的时候，OS是如何实现逻辑地址到物理地址的转换的呢？</p>
<p>是通过<strong>重定位寄存器</strong>去保存 装入模块存放的 <strong>起始位置</strong> + 目标内存单元相对于起始位置的<strong>偏移量</strong></p>
<p>我们就能得到该在物理地址（绝对地址）中，我们的目标存放的地址了，同理，我们把这种思想转移到了分页技术中地址的转换</p>
<p>结合之前的同学去住酒店问题，可以这么理解：</p>
<p>A同学是个傻子，只知道自己要住在离B同学X个房号的房间，这个X就是<mark>偏移量</mark>，A同学如何才能顺利的住进自己的房间呢？只需要B同学先找到自己的房间（<mark>起始位置</mark>），然后A同学就能顺藤摸瓜找到自己的房间啦。</p>
<p>以下面为例：</p>
<ul>
<li><strong>页号</strong>：逻辑地址 / 页面长度 取整 （本题中：页号=80/50 = 1</li>
<li><strong>业内偏移量</strong>：逻辑地址 % 页面长度 （本题中：页内偏移量=80 % 50 = 30</li>
<li><strong>页面在内存中的起始位置</strong>：OS用某种数据结构去进行记录的 （本题中一号页在内存中存放的起始位置=450</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019165134603.png" alt="image-20201019165134603"></p>
<p>为了方便计算页号、业内偏移量，页面大小一般取2的整数幂，那么接下来我们就来看看这种情况是什么样子的</p>
<p>红色部分前20位，表示了是第几页；（这里的<mark>前</mark>指的是从<strong>左往右</strong>数，如果严格按照二进制来说应该是后20位</p>
<p>后面12位是偏移值（这的<mark>后</mark>指的是从<strong>左往右</strong>数，如果严格按照二进制来说应该是前12位</p>
<p>加入我们知道了N号页在内存中的起始地址（假设为X），那么我就知道我们已知的逻辑地址所对应的物理地址了</p>
<ul>
<li>结论:若每个页面大小为<strong>2^K B</strong>,用二进制数表达逻辑地址，那么末尾K位是<strong>页内偏移量</strong>。其余部分代表<strong>页号</strong>；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019170219137.png" alt="image-20201019170219137"></p>
<h6 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><ul>
<li><p>分页存储管理的逻辑地质结构由：<strong>页内偏移量</strong>和<strong>页号</strong>组成</p>
</li>
<li><p>若由K位表示<strong>页内偏移量</strong>，说明系统中一个<strong>页面大小是2^K 个内存单元</strong></p>
</li>
<li><p>若由M位表示<strong>页号</strong>，说明系统中，一个<strong>进程最多允许2^M个页面</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019171609549.png" alt="image-20201019171609549"></p>
<h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><p>上述我们有个遗留问题，我们如何知道<strong>页号对应页面</strong> 在 内存中的<strong>起始地址</strong>呢？</p>
<p>其实是通过<strong>页表</strong>知道的，下面看看什么是<strong>页表</strong></p>
<p>其实页表可以结合之前的住酒店问题一起理解：</p>
<p>还是那个傻子A同学，之前说了，他只知道自己住在某同学（假设B同学）的旁边X位，他需要知道B同学住哪才能找到自己的房间。而这个页表可以帮助A同学找到那个<strong>B同学</strong>；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019202912635.png" alt="image-20201019202912635"></p>
<ol>
<li><p>一个进程对应一张页表</p>
</li>
<li><p>进程的每一页对应一个页表项</p>
</li>
<li><p>每个页表项由【<strong>页号</strong>】和【<strong>块号</strong>】组成</p>
</li>
<li><p>页表记录<strong>进程页面和实际存放的内存块之间的对应关系</strong></p>
</li>
<li><p>物理内存大小 / 页面大小 = 内存块 / 页表项（多少个 也就是能分成多少页号）</p>
</li>
<li><p>页表项 × 页表项长度 = 页表的大小（页表在内存中占用的大小）</p>
</li>
<li><p>页表的大小 /  页面大小 = 页表项个数（页框个数）</p>
</li>
<li><p>页面的数目 = 进程的大小 / 页面的大小 = 逻辑地址表示的大小 / 页面的大小 </p>
</li>
<li><p>每个页表项的长度是相同的，页号是隐含的</p>
<p>这句话是说明意思呢？意思是说 我们能够通过<strong>页表存放的起始地址</strong>和<strong>页表项长度</strong>，就可以找到各页号所对应的页表存放的位置</p>
</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201019203053285.png" alt="image-20201019203053285"></p>
<p>是不是说的很绕呢？那么可以这么理解：</p>
<ul>
<li><p>页 - 一个数组</p>
<p>页的大小 表现为 2^N  这N位叫做页内偏移量 = 业内地址用N位来表示</p>
</li>
<li><p>页表项 - 构成数组的最小单位，页号相当于下标，块号相当于存的值</p>
</li>
<li><p>页表项  × 页表项大小 = 页表大小 <strong>等价于</strong></p>
<p>数组个数  ×  单个元素大小 = 整个数组大小</p>
</li>
<li><p>物理地址 / 页面大小 = 物理块的个数 → 知道了内存块号的取值范围</p>
</li>
<li><p>逻辑地址 / 页面大小 = 页面的数目 → 知道了页号的取值范围</p>
</li>
</ul>
<p>再结合那个例子理解：页面大小 决定了 页内偏移量（不是等于，因为是通过取余运算得到的），也就是距离B同学多远；而页号就是那个B同学了，B同学只需要找到自己房间号，A同学就能通过页内偏移量找到自己房间了。</p>
<h6 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160101385.png" alt="image-20201022160101385"></p>
<ul>
<li>基本地址变换机构可以借助进程的页表将<strong>逻辑地址</strong>转换为<strong>物理地址</strong></li>
<li>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong>,存放页表<strong>在内存中的起始地址F</strong>和<strong>页表长度M</strong>；</li>
<li>进程未执行的时候，<strong>页表的起始地址</strong>和<strong>页表长度</strong>放在<strong>进程控制块PCB</strong>中，当进程被<strong>调度的时候</strong>，<strong>OS内核</strong>会把他们放在<strong>页表寄存器</strong>中</li>
</ul>
<p>（页面大小为2的整数幂）</p>
<p>设页面大小为L，逻辑地址A到物理地址E的变换过程:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025172149372.png" alt="image-20201025172149372"></p>
<ol>
<li><p>计算<strong>页号P</strong>和<strong>页内偏移量W</strong>（以十进制为例：*<em>页号P = 逻辑地址A / 页面大小L ;页内偏移量W = 逻辑地址A % 页面大小L *</em> 但计算机实际运行的时候，逻辑地址结构是固定不变的，因此计算机硬件可以更快得到二进制表示的页号和页内偏移量）</p>
</li>
<li><p>比较<strong>页号P</strong>和<strong>页表长度M</strong>，如果<strong>P&gt;=M</strong>，就产生越界中断，否则继续执行 （为什么等号也会算作越界中断呢?因为页号是从0开始的，而页表长度至少是1，因此P = M也会中断哦 类似于数组越界）</p>
</li>
<li><p>页表中<strong>页表P</strong>对应的<strong>页表项地址 = 页表起始地址F + 页号P * 页表项长度</strong>；取出该<strong>页表项内容b</strong>，即为<strong>内存块号</strong>。</p>
<p>页表<strong>长度</strong>：指的是这个页表中总共有<strong>几个页表项</strong>，就是有多少页</p>
<p>页表<strong>项长度</strong>：指的是每个页表项占据了多大的<strong>存储空间</strong></p>
<p>页面<strong>大小</strong>：一个页面占多大的<strong>存储空间</strong></p>
</li>
<li><p>计算<strong>物理地址E = 内存块号b * 页面大小L + 页内偏移量W</strong> ,用得到的物理地址E去访存</p>
</li>
</ol>
<p>说了那么多，感觉是不是云里雾里的，知道了一堆名词，计算方式，但真正计算的时候仍然不会用？下面就来一道例题去实践一下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022154324120.png" alt="image-20201022154324120"></p>
<ul>
<li>页号P = 逻辑地址A / 页面大小L = 2500 / 1024 = 2 ； 页内偏移量W = 逻辑地址A % 页面大小L = 2500 % 1024 = 452</li>
<li>判断越界:页号P对应内存块号为8 没越界</li>
<li>物理地址 E = 内存块号 * 页面大小 + 页内偏移量 = 8 * 1024 + 452 = 8644 就是最后结果了</li>
</ul>
<h6 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h6><p>要去了解具有快表的地址变换机构前，首先要去理解一个概念 ： <strong>局部性原理</strong></p>
<ul>
<li><mark>局部性原理</mark><ul>
<li><mark>时间局部性</mark>：如果执行了程序中的某条指令，那么不久之后这条指令很有可能被再次执行；如果某个数据被 访问过，不久之后该数据很可能被再次访问。（程序中存在大量循环）</li>
<li><mark>空间局部性</mark>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（许多数据在内存中是连续存放的）</li>
<li>那么我们<strong>具有快表的地址变换机构</strong>与这<strong>局部性原理</strong>又有什么关系呢？我们上面介绍的<strong>基本地址变换机构</strong>中，每次要访问一个逻辑地址，都需要查询<strong>内存中的页表</strong>。而由于局部性原理，可能连续很多次查到的都是<strong>同一个页表项</strong>；当我们认识到了<strong>局部性原理</strong>之后，我们能否结合这个特性减少访问</li>
</ul>
</li>
</ul>
<p>在了解完局部性原理后，我们就可以正式开始学习<strong>快表</strong>了</p>
<ul>
<li><p><strong>快表</strong>，又称<strong>联想寄存器（TLB）</strong>,是一种访问速度比内存块很多的高速缓冲寄存器（存放在更高速存储器中）</p>
<p>用于存放当前访问的若干项页表项，以加速地址变换的过程</p>
<p>与此对应，<strong>内存中的页表</strong>常被称为<strong>慢表</strong>（存放在内存中）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024151157653.png" alt="image-20201024151157653"></p>
<p>下面我们根据上方图，仔细理顺一下 <strong>引入快表之后，地址的变换过程</strong></p>
<ol>
<li>CPU给出逻辑地址，由某硬件算出页号、页内偏移量，由地址变换机构自动地将<strong>页号P</strong>送入<strong>高速缓冲寄存器</strong>，并将此页号与<strong>高速缓冲寄存器/快表</strong>中的所有页号进行比较</li>
<li>若其中有与此相匹配的页号，说明要访问的页表项在快表中有副本，于是直接从快表中读出该页对应的<strong>内存块号/物理块号</strong>，再将内存块号与页内偏移量拼接成物理地址，然后访问该物理地址对应的<strong>内存单元</strong>。（一次）</li>
<li>若其中没有与此匹配的页号，则需要访问<strong>内存中的页表</strong>，（<strong>第一次访问内存</strong>）找到对应的页表项，得到页面存放的<strong>内存块号/物理块号</strong>，访问该物理对应的内存单元（<strong>第二次访问内存</strong>）；（找到页表项后，应同时将其存入快表的一个寄存器单元中，假如联想寄存器已经满了，OS必须找到一个老的且已经被认为是不再需要的页表项，将他换出来）</li>
<li>发现了吗？如果<strong>快表命中了，则访问某个逻辑地址只需要一次访存</strong>。如果<strong>没命中</strong>，则需要<strong>两次访存</strong></li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024152935605.png" alt="image-20201024152935605"></p>
<ul>
<li><p>有无快表的地址变换机构区别</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024153201118.png" alt="image-20201024153201118"></p>
</li>
</ul>
<h6 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152405530.png" alt="image-20201025152405530"></p>
<ul>
<li><p>我们为什么要引入新的存储管理方式呢？往往都是因为之前的多多少少存在一点问题，那么与两级页表对应的就是单级页表了，单机页表存在什么问题呢？</p>
<p>首先：页表必须连续存放，因此当页表很大的时候，需要占用多个连续页框</p>
<p>其次：没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定页面</p>
</li>
<li><p>解决方案：将页表进行分组，使每个内存块刚好放入一个<strong>分组</strong>（比如，页面大小4KB，页表项大小4B，那么可以存1K个页表项，那么把连续的1K个页表项认定为一组），把各组<strong>离散</strong>存放到各内存块中</p>
<p>然后为离散分配的页表<strong>再额外建立一张页表</strong>，我们称之为:<strong>页目录表/外层页表/顶层页表</strong></p>
</li>
</ul>
<p>我们把中间这个<strong>大页表</strong>拆分成了左边这个<strong>小页表</strong> 1024个页表项为一组</p>
<p>为什么要这么分呢？我们知道一个分页存储管理是把一个进程分成若干个页面然后存储 对吧？那么就有可能出现页号特别特别多的情况，因此我们把这些页号又再分一次，形成了一个二级页表；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201024162203398.png" alt="image-20201024162203398"></p>
<p>我们现在知道了 二级页表的来由了 那么<strong>二级页表</strong>又是如何<strong>实现地址转换</strong>的呢？</p>
<ol>
<li>按照地址结构将逻辑地址拆成三个部分<ol>
<li><strong>一级页号</strong></li>
<li><strong>二级页号</strong></li>
<li><strong>页内偏移量</strong></li>
</ol>
</li>
<li>从PCB中读取<strong>页目录起始地址</strong>，根据<strong>一级页号</strong>查页目录表，找到<strong>下一级页表（二级页表）</strong>在内存中存放的位置</li>
<li>根据二级页号查表，找到最终想要访问的<strong>内存块号</strong></li>
<li>结合<strong>页内偏移量</strong>得到物理地址</li>
</ol>
<p>也就是需要3次的访存：<strong>第一次</strong>是访问<strong>内存中页目录表</strong> <strong>第二次</strong>是访问<strong>内存中二级页表</strong> <strong>第三次</strong>才是<strong>访问目标内存单元</strong></p>
<p>有点套娃的意思；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/18464438-d40bb24f98b9fcab.png" alt="img"></p>
<p>下面来一道例题来看看一些细节问题</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152348367.png" alt="image-20201025152348367"></p>
<h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025202529712.png" alt="image-20201025202529712"></p>
<h6 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h6><ul>
<li><p>进程的地址空间：按照程序<strong>自身的逻辑关系</strong>划分成了<strong>若干个段</strong>，每个段有一个<strong>段名</strong></p>
<p>编译程序会将<strong>段名</strong>转换为<strong>段号</strong></p>
<p>每段从 <strong>0</strong> 开始编制</p>
</li>
<li><p>内存分配规则：以段为单位进行分配，每个段在内存中<strong>占据连续空间</strong>，但<strong>各段之间可以不相邻</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025152836465.png" alt="image-20201025152836465"></p>
<ul>
<li>分段细节</li>
</ul>
<p>分段系统的<strong>逻辑地址结构</strong>由<strong>段号</strong>和<strong>段内地址（段内偏移量）</strong>所组成</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153507064.png" alt="image-20201025153507064"></p>
<ul>
<li><p><strong>段号的位数</strong>：决定了每个进程最多可以分几个段</p>
</li>
<li><p><strong>段内地址位数</strong>：决定了每个段的最大长度是多少</p>
</li>
<li><p>以上图为例：段号与段内地址都是16位，因此每个进程最多有<strong>2^16=64K个段</strong>，每个段的最大长度是<strong>2^16=64KB</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153813924.png" alt="image-20201025153813924"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025153804900.png" alt="image-20201025153804900"></p>
</li>
</ul>
<h6 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h6><p>上面我们学习了基本分页存储管理，有提到<strong>页表</strong>一概念，那么与之对应的，我们的基本分段存储管理是否也有<strong>段表</strong>一概念呢？答案是肯定的</p>
<ul>
<li>段表:程序分成多个段，直接离散地装入内存，为了保证程序可以正常运行，就必须能从物理内存中找到各<strong>逻辑段</strong>存放的位置，为此，需要为每个进程建立一张<strong>段映射表</strong>. 这个<strong>段映射表</strong>就是我们的<strong>段表</strong></li>
<li>每个<strong>段</strong>在表中占有一个<strong>表项</strong>，记录了<strong>该段在内存中的起始位置（基址）</strong>和<strong>段的长度</strong>；各表项长度是相同的</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025171024271.png" alt="image-20201025171024271"></p>
<h6 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025194631660.png" alt="image-20201025194631660"></p>
<p>根据上方流程图我们来理一下地址变换的思路，其实是与分页存储管理的地址变换差不太多的</p>
<ol>
<li>根据<strong>逻辑地址A</strong>得到<strong>段号S</strong>和<strong>段内地址W</strong></li>
<li>判断<strong>段号S</strong>是否越界，如果<strong>段号S≥段表长度M</strong>，就发生越界中断，否则继续</li>
<li>查询段表，找到对应的段表项，<strong>段表项</strong>的存放地址为<strong>段表起始地址F+段号S×段表项长度</strong></li>
<li>检查<strong>段内地址W</strong>是否超过段号所对应的<strong>段长C</strong>，如果<strong>段内地址W≥段长C</strong>，则产生越界中断，否则继续</li>
<li>计算得到<strong>物理地址 = 段基址b + 段内地址w</strong></li>
<li>访问目标内存单元</li>
</ol>
<h6 id="分段分页管理对比"><a href="#分段分页管理对比" class="headerlink" title="分段分页管理对比"></a>分段分页管理对比</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025200044600.png" alt="image-20201025200044600"></p>
<ul>
<li><p><strong>页</strong>是<mark>信息的物理单位</mark>；分页的主要目的是为了实现离散分配，提高内存利用率；</p>
<p>分页仅仅是系统管理上的需要，完全是<strong>系统行为</strong>，对于用户是<strong>不可见的</strong>；</p>
<p>分页的用户进程<strong>地址空间是一维的</strong>，程序员只需要给出一个记忆符即可表示一个地址；</p>
<p>页的<strong>大小固定</strong>，且由系统决定。</p>
</li>
<li><p><strong>段</strong>是<mark>信息的逻辑单位</mark>；分段的主要目的是更好地满足用户需求。</p>
<p>一个段通常包含着一组属于一个逻辑模块的信息。</p>
<p>分段对用户是可见的，用户编程的时候需要显示给出段名；</p>
<p>分段的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段名地址。</p>
<p>段的长度不固定，决定于用户编写的程序。</p>
</li>
<li><p>访问一个逻辑地址需要几次访问内存呢？</p>
<ul>
<li>分页（单级页表）：<strong>第一次访问内存</strong>——查询内存中的页表，<strong>第二次访问内存</strong>——访问目标内存单元</li>
<li>分段：<strong>第一次访问内存</strong>——查内存中段表，<strong>第二次访问内存</strong>——访问目标内存单元</li>
</ul>
</li>
</ul>
<h6 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h6><p>分段比分页更容易实现<strong>信息的共享和保护</strong></p>
<p>首先引入一个概念叫做纯代码，纯代码/可重入代码 是 <strong>不能被修改的代码</strong>；这种类型的代码是可以共享的，而可修改的代码是不能进行共享的（比如一个代码段有很多变量，多进程并发地同时访问会导致数据地不一致）</p>
<p>那么如果进程是分段存储管理的 几句可以很好的进行信息地共享了，因为只需要改变进程地段表项，指向同一个段即可；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201025201533670.png" alt="image-20201025201533670"></p>
<h5 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026171616190.png" alt="image-20201026171616190"></p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>段页式存储，顾名思义，肯定是利用到了<strong>页式存储+段式存储</strong>，那么既然是两者结合，肯定取其精华，去其糟粕吧，那我们先复习一下段式存储和页式存储各自优缺点都有什么</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026154027329.png" alt="image-20201026154027329"></p>
<h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><ul>
<li>那么我们的段页存储管理又是如何进行的呢？究竟是先分段还是先分页呢？</li>
<li>我们的进程首先按照<strong>逻辑模块分段</strong>，再将分成的<strong>段</strong>分<strong>页</strong></li>
<li>将<strong>内存空间</strong>分为大小<strong>相同的内存块/页框/页帧/物理块</strong></li>
<li>进程将各页面分别装如个内存块中</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026161147295.png" alt="image-20201026161147295"></p>
<h6 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026162123383.png" alt="image-20201026162123383"></p>
<ul>
<li>段页式系统的逻辑地址结构由<strong>段号、页号、页内地址（页内偏移量）</strong>所组成</li>
<li><strong>段号</strong>：段号的位数决定了每个进程最多可以分几个段</li>
<li><strong>页号</strong>：页号的位数决定了每个段最大有多少页</li>
<li><strong>页内偏移量</strong>：页内偏移量决定了页面大小、内存块大小是多少</li>
</ul>
<h6 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h6><p>看下面这张图是否感觉有点眼熟？感觉与二级页表类似；</p>
<p>只不过把中间的那个页表替换成了一个段表，借此机会我们再来理顺一次思路:</p>
<p>一个进程对应一个段表   一个段表对应多个页表 换而言之，进程对应了多个页表</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026163818291.png" alt="image-20201026163818291"></p>
<h6 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h6><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201026165005382.png" alt="image-20201026165005382"></p>
<p>像之前的两种存储管理的地址变换过程一样 ，我们也来理一次过程：</p>
<ol>
<li>根据<strong>逻辑地址A</strong>得到<strong>段号S</strong>、<strong>页号P</strong>和<strong>页内偏移量W</strong></li>
<li>判断<strong>段号S</strong>与<strong>段表长度M</strong>关系，如果S≥M，发生越界中断，否则继续进行（第一次检查越界）</li>
<li>查询段表，进行运算：<strong>段表项 = 段表始址F + S × 段表项长度</strong> → 找到对应的<strong>段表项</strong><mark>（第一次访问内存）</mark></li>
<li>判断页号P与页表长度的关系，如果页号P≥页表长度，发生越界中断，否则继续进行（第二次检查越界）</li>
<li>根据<strong>页表存放块号和页号P</strong>计算得到查询页表，找到对应的<strong>页表项</strong><mark>（第二次访问内存）</mark></li>
<li>页表项存储着该页所在的<strong>物理块号b</strong>，再利用<strong>物理块号b</strong>和<strong>页内偏移量W</strong>构成最终的物理地址</li>
<li>最后访问目标内存单元<mark>（第三次访问内存）</mark></li>
</ol>
<h3 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h3><ul>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li>
<li>通常有三种技术：<ul>
<li>覆盖技术</li>
<li>交换技术</li>
<li>虚拟存储技术</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015213523284.png" alt="image-20201015213523284"></p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ul>
<li>OS需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li>
<li>绝对装入-编译时产生绝对地址</li>
<li>可重定位装入-装入时将逻辑地址转换为物理地址</li>
<li>动态运行时装入-运行时将逻辑地址转换为物理地址，需要设计重定位寄存器</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015214304047.png" alt="image-20201015214304047"></p>
<h3 id="内存保护-1"><a href="#内存保护-1" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存保护可采取两种办法</p>
<ul>
<li><p>方法一：在CPU种设置一对上、下限寄存器，寄存进程的上、下限地址。进程的指令要访问某个地址的时候，CPU检查是否越界</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215116282.png" alt="image-20201015215116282"></p>
</li>
<li><p>方法二：采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。其中，<strong>重定位寄存器</strong>中存放的是<strong>进程的起始物理地址</strong>，<strong>界地址寄存器</strong>中存放的是<strong>进程的最大逻辑地址</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015215232038.png" alt="image-20201015215232038"></p>
<h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201022160240209.png" alt="image-20201022160240209"></p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul>
<li><p>覆盖是在同一个进程或程序中的</p>
</li>
<li><p>思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要的时候才调入内存</p>
<p>内存分为一个固定去和若干个覆盖区</p>
<p><strong>需要常驻内存的段</strong>放在<strong>固定区</strong>中，调入后就<strong>不再调出</strong></p>
<p><strong>不常用的段</strong>放在<strong>覆盖区</strong>，<strong>需要用</strong>的时候<strong>调入内存</strong>，<strong>用不到</strong>的时候<strong>调出内存</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201015220730717.png" alt="image-20201015220730717"></p>
<ul>
<li>如下图所示，假如程序A执行需要走如下几个程序B、C….</li>
<li>B、C不能同时执行，我们就在物理内存中设置一个覆盖区 用于存放B或者C，其中其大小是B、C中较大内存决定</li>
<li>同理D、E、F也不能同时执行，因此也设立一个覆盖区用于存储</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017150834371.png" alt="image-20201017150834371"></p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li><p>交换是在不同进程(作业)之间的</p>
</li>
<li><p>设计思想：内存空间紧张的时候，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
</li>
<li><p>这种技术其实在上面的处理机调度一节层次调度中的中级调度我们也有了解过了 </p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152832202.png" alt="image-20201017152832202"></p>
</li>
<li><p>暂时换出外存等待的进程状态为挂起状态（挂起态）</p>
</li>
<li><p>挂起态可以细分为就绪挂起和阻塞挂起两种状态 - 复习下7态模型吧</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201017152921895.png" alt="image-20201017152921895"></p>
</li>
</ul>
<p>下面思考三个问题</p>
<ol>
<li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p>
<p>答：具有兑换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分；</p>
<p><strong>文件区</strong>主要用于存放文件，主要<strong>追求存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong></p>
<p><strong>对换区</strong>空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区，由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要<strong>追求换入换出速度</strong>，因此通常采用<strong>连续分配方式</strong></p>
<p>对换区的I/O速度比文件区的更快</p>
</li>
<li><p>什么时候应该交换？</p>
<p>答：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生<strong>缺页</strong>，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p>
</li>
<li><p>应该换出哪些进程？</p>
<ol>
<li>可优先换出阻塞进程</li>
<li>可换出优先级低的进程</li>
<li>为了放置优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间</li>
<li>PCB会常驻内存，是不会被换出外存的</li>
</ol>
</li>
</ol>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029202753739.png" alt="image-20201029202753739"></p>
<h3 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029162940481.png" alt="image-20201029162940481"></p>
<ul>
<li><strong>一次性</strong>：是指作业必须一次性地全部装入内存后方能开始运行<ul>
<li>造成问题<ul>
<li>作业很大的时候，不能全部装入内存，导致大作业无法运行</li>
<li>当大量作业要求运行的时候，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li>
</ul>
</li>
</ul>
</li>
<li><strong>驻留性</strong>：是指作业被装入内存之后，整个作业都一直驻留在内存中，其中任何部分都不会被换出，直至作业运行结束。<ul>
<li>造成问题<ul>
<li>往往在一个时间段内，只需要访问作业的一小部分数据就可以正常运行，但偏偏会把其他不需要的部分也强行装入内存，这就导致了内存中会驻留大量、暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>而要解决传统存储管理的这些特征带来的问题，我们就引入了虚拟存储技术，而虚拟存储技术依靠【局部性原理】</p>
<p>关于局部性原理，在上述已经说过了，这里直接照搬上面的内容：</p>
<p><mark>局部性原理</mark></p>
<ul>
<li><mark>时间局部性</mark>：如果执行了程序中的某条指令，那么不久之后这条指令很有可能被再次执行；如果某个数据被 访问过，不久之后该数据很可能被再次访问。（程序中存在大量循环）</li>
<li><mark>空间局部性</mark>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（许多数据在内存中是连续存放的）</li>
</ul>
<h3 id="高速缓冲技术"><a href="#高速缓冲技术" class="headerlink" title="高速缓冲技术"></a>高速缓冲技术</h3><p>高速缓冲技术其实就算应用了局部性原理</p>
<ul>
<li><p>高速缓冲技术的思想： 将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029172212611.png" alt="image-20201029172212611"></p>
</li>
</ul>
<h3 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>虚拟内存/虚拟存储器</strong>，是指具有<mark>请求调入功能和置换功能</mark>，能从<strong>逻辑上</strong>(而不是物理上)对内存容量加以扩充的一种<marK>存储器系统。</marK></p>
<p>那么虚拟内存是如何”增大”内存的呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029195651658.png" alt="image-20201029195651658"></p>
<p>基于局部性原理，在程序<strong>装入</strong>的时候，将程序中很快会用到的部分装入内存，暂时用不到的部分就留在外存，就可以让程序开始执行；</p>
<p>在程序执行的过程中，当所访问的信息不在内存时候，由OS负责将所需的信息从<strong>外存</strong>调入<strong>内存</strong>，然后继续执行程序；</p>
<p>假如内存空间不够，由<strong>OS</strong>负责将内存中<strong>暂时用不到的信息</strong>换出到外存；</p>
<p>你看 有用的在内存中，暂时用不到的在外存，是不是在用户看来是把整个程序塞入内存里了呢？</p>
<p>注意：</p>
<ul>
<li><p>虚拟内存的<strong>最大容量</strong>由计算机的地质结构（CPU的寻址范围）确定的</p>
<p>比如某计算机地址结构为32位，按照字节编址，内存大小位512MB，外存大小为2GB；</p>
<p>则虚拟内存的<strong>最大容量</strong>  2^32^B= 4GB</p>
</li>
<li><p>虚拟内存的<strong>实际容量</strong> = min(内存和外存容量之和， CPU寻址范围)</p>
<p>依旧是上述例子</p>
<p>则虚拟内存的<strong>实际容量</strong>=min（2^32^B, 512MB + 2GB）= 2GB +512MB；</p>
</li>
</ul>
<h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul>
<li><mark>多次性</mark>：是相对于传统存储管理方式的<strong>一次性</strong>而言的，是指一个作业中程序和数据无需在作业运行的时候一次性全部装入内存，而是允许被分成多次调入内存运行。多次性是虚拟存储器最重要的特征，是任何其他的存储管理方式所不具有的。因此，虚拟存储器其实是具有多次性特征的存储器管理系统。</li>
<li><mark>对换性</mark>：是相对于传统存储管理方式的<strong>常驻性</strong>而言的，是指一个作业中的程序和数据，无须在作业运行的时候一直常驻内存，而是允许在作业的运行过程中进行换入换出。</li>
<li><mark>虚拟性</mark>：虚拟性是指能够从逻辑上扩充内存容量，使得用户所看到的内存容量远远大于实际的内存容量。虚拟性是以多次性和对换性为基础的，正是由于系统允许将作业多次调入内存，并且能把内存中暂时不允许程序、数据、进程调至外存，才有可能实现了虚拟存储器；</li>
</ul>
<h3 id="虚拟内存的实现方法"><a href="#虚拟内存的实现方法" class="headerlink" title="虚拟内存的实现方法"></a>虚拟内存的实现方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205625258.png" alt="image-20201029205625258"></p>
<p>我们知道，管理系统要实现<mark>虚拟性</mark>必须满足<mark>对换性和多次性</mark>，那么如何要满足<mark>对换性和多次性</mark>，又有什么要求呢？答案是必须建立在<strong>离散分配</strong>的内存管理方式基础上。那么现在有什么管理方式能实现虚拟存储器呢？</p>
<h4 id="分页请求系统"><a href="#分页请求系统" class="headerlink" title="分页请求系统"></a>分页请求系统</h4><ul>
<li>分页请求系统 = 分页系统的基础 + 请求调页功能 + 页面置换功能</li>
<li>用户程序装入少数页面程序和数据就能运行，之后再通过上述两个功能把即将运行<strong>页面</strong> → 内存，暂时不运行的<strong>页面</strong> → 外存</li>
<li>为了实现这两个功能，系统需要提供必要硬件支持和实现请求分页的软件<ul>
<li><strong>硬件支持</strong>：<ul>
<li>请求分页的页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
<li><strong>请求分页软件</strong>：<ul>
<li>在硬件支持下，将程序正在运行时所需页面 → 内存，内存中不用的页面从内存 → 磁盘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h4><ul>
<li>分页请求系统 = 分段系统的基础 + 请求调段功能 + 分段置换功能</li>
<li>用户程序装入少数段的程序和数据就能运行，之后再通过上述两个功能把即将运行的<strong>段</strong>→ 内存，暂时不运行的<strong>段</strong> → 外存</li>
<li>为了实现这两个功能，系统需要提供必要硬件支持和实现请求分段的软件<ul>
<li>硬件支持<ul>
<li>请求分段的段表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
<li>软件支持<ul>
<li>在硬件支持下，将内存中暂时不用的段从内存 → 磁盘，程序运行时所需要的段 → 内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029220042435.png" alt="image-20201029220042435"></p>
<h4 id="请求页表机制"><a href="#请求页表机制" class="headerlink" title="请求页表机制"></a>请求页表机制</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029205653568.png" alt="image-20201029205653568"></p>
<table>
<thead>
<tr>
<th>页号</th>
<th>物理块号</th>
<th>状态位P</th>
<th>访问字段A</th>
<th>修改位M</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>　　状态位P：该页是否已调入内存 0 表示没有被调入 1表示被调入</p>
<p>　　访问字段A：本页在一段时间内被访问的次数，供页面置换算法使用</p>
<p>　　修改位M：标识该页在调入内存后是否被修改过</p>
<p>　　外存地址：该页在外存上的地址，供调入该页时参考</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>缺页中断机构的大致流程如下：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030200249404.png" alt="image-20201030200249404"></p>
<ul>
<li><p>缺页中断是因为当前指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>
</li>
<li><p>一条指令在执行期间，可能产生多次缺页中断</p>
<p>比如copy A to B，而A、B属于不同页面，那就有可能产生多次的中断：因为指令本身跨多个页面，A、B又是分别一个数据块；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212923663.png" alt="image-20201029212923663"></p>
</li>
<li><p>中断的分类如下</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029212844294.png" alt="image-20201029212844294"></p>
</li>
</ul>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213124769.png" alt="image-20201029213124769"></p>
<p>由于逻辑地址到物理地址映射过程写过很多次了，这里不再赘述；</p>
<p>但这里需要注意的点是：</p>
<p>快表中有的页面一定是在内存中的，如果某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面；</p>
<p>找到对应的页表项之后，假如对应页面还没有调入内存，那就产生缺页中断，之后由OS的缺页中断处理程序进行处理</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201029213649586.png" alt="image-20201029213649586"></p>
<p>细节补充:</p>
<ul>
<li><p>只有写指令才需要修改【修改位】，而且一般来说只需要修改快表中的数据，只有要将快表项删除的时候才需要写回内存中的慢表；</p>
<p>这样可以减少访存次数</p>
</li>
<li><p>缺页中断处理依旧需要保持CPU现场</p>
</li>
<li><p>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销</p>
</li>
<li><p>页面调入内存中，需要修改慢表，同时也需要将表项复制到快表中</p>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>请求分页管理存储与基本分页存储管理的主要区别:</p>
<p>程序执行的过程中，当所访问的信息不在内存的时候，由OS负责将所需要的信息从外存调入内存，然后继续执行</p>
<p>假如内存空间不够，就由OS负责将内存中暂时用不到的信息换出到外存</p>
<p>而由于我们的页面换入、换出需要磁盘I/O，有较大开销，因此好的页面置换算法的评价指标就是更少的缺页率</p>
<p>我们主要学习五种页面置换算法：<strong>最佳置换算法、先进先出置换算法、最近最久未使用置换算法、时钟置换算法、改进型的时钟置换算法</strong></p>
<h3 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030184237366.png" alt="image-20201030184237366"></p>
<ul>
<li>最佳置换算法：每次选择淘汰的页面将是以后永不使用，或者再最长时间内不再被访问的页面，这样可以保证最低的缺页率；</li>
<li>缺页中断未必一定会发生页面置换，假如有空闲的内存块就不用进行页面置换</li>
<li>缺页率的计算 :<strong>缺页率 = 缺页中断发生的次数 / 访问页面的总次数 × 100 ％</strong></li>
<li>最佳置换算法是理想算法，因为只有在进程执行的过程中才能知道接下来会访问什么页面，OS无法提前预判页面访问序列，因此最佳置换算法是无法实现的。</li>
</ul>
<h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030185335274.png" alt="image-20201030185335274"></p>
<ul>
<li><p>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面</p>
</li>
<li><p>如何实现的呢？先进先出，学过数据结构的朋友们都清楚，应该使用<strong>队列</strong>这种数据结构。把调入内存的页面按调入的<strong>先后顺序排成一个队列</strong>，当新来的页面需要进行页面置换的时候，<strong>poll掉头页面</strong>即可；</p>
<p>ps：队列的最长长度取决于系统为进程分配多少内存块</p>
</li>
<li><p><strong>Belady（贝莱迪）异常</strong>：  一般来说，缓存越大，命中率越高，缺页率越低。但有一个计算机学者，名字叫Belady。在1969年研究FIFO算法时，发现了一个反例，使用4个页框时的缺页次数比3个页框时的缺页多，因此这种奇怪的情况称为Belady异常。</p>
<p>这种异常的原因是对于FIFO算法来说，在同一时刻，使用4个页框时缓存中保存的页面并不完全包含使用3个页框时保存的页面，二者不是超集子集关系，造成都某些特殊的页面请求序列，4个页框命中率反而低。</p>
<p>只有FIFO算法会产生这个异常，此外，FIFO实现简单，但是有可能先进入的进程也会被经常访问，因此算法性能差。</p>
</li>
</ul>
<h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030191211411.png" alt="image-20201030191211411"></p>
<ul>
<li><p>最近最久未使用置换算法（LRU）：每次淘汰的页面是最近最久未使用的页面</p>
</li>
<li><p>实现方法：赋予每个页面对应的<strong>页表项</strong>，用访问字段记录该页面<strong>自上次被访问以来所经历的时间t</strong></p>
<p>如果需要淘汰页面，就选择现有的页面<strong>中t值最大的</strong>，即最近最久没有使用的页面</p>
</li>
<li><p>该算法需要专门的硬件支持（寄存器，栈），虽然算法性能好，但是实现也很困难，开销也很大</p>
</li>
</ul>
<h3 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202108812.png" alt="image-20201030202108812"></p>
<h4 id="简单的CLOCK算法"><a href="#简单的CLOCK算法" class="headerlink" title="简单的CLOCK算法"></a>简单的CLOCK算法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030193731094.png" alt="image-20201030193731094"></p>
<ul>
<li>时钟置换算法/最近未用算法：通过循环队列将未访问页面置换的算法</li>
<li>简单的CLOCK实现方法：为每个页面设置一个访问位——用于标志最近是否访问过（如果该进程被访问了就从0被标志为1），然后将内存中各页面通过链接指针链接成一各<strong>循环队列</strong>；当访问新页面，需要置换页面的时候，通过检查页的访问位去置换：如果是0 → 换该页面，<strong>同时指针指向下一个页面</strong>；如果是1 → 置为0，给第二次留在内存的机会。</li>
</ul>
<h4 id="改进型的CLOCK算法"><a href="#改进型的CLOCK算法" class="headerlink" title="改进型的CLOCK算法"></a>改进型的CLOCK算法</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201030202052642.png" alt="image-20201030202052642"></p>
<ul>
<li><p>改进型CLOCK置换算法:我们将一个页面换出的时候，假如它是修改过的，那么其修改后的数据需要重新写回外存中，如果没有被修改过，就不需要拷回外存。</p>
<p>说人话就是：对于一个换出的页面，如果其被修改过，那么它换出的开销比没有被修改过的要大，那么换他出去就划不来了。</p>
</li>
<li><p>那我们以什么为指标去评判一个页面该不该被置换呢？显然易见：<mark>有没有被访问过 + 有没有被修改过</mark></p>
<ul>
<li>（访问位A， 修饰位M）</li>
<li>（A = 0，M = 0）= 最近既没被访问 + 又没被修改过 ，被置换的优先级最高</li>
<li>（A = 0，M = 1）= 最近没被访问 + 已经被修改了，并不是很好的置换选项，优先级第二</li>
<li>（A = 1，M = 0）= 最近已经被访问了 + 但没被修改过 ，那么这个页面有可能还会被访问，优先级低三</li>
<li>（A = 1，M = 1）= 最近已经被访问 + 已经被修改，被置换的优先级最低（第四）</li>
</ul>
</li>
<li><p>那这个访问位，修饰位凭什么作为依据呢？这与我们的扫描过程有关</p>
<ul>
<li>第一轮去找（0，0），不改变标志位</li>
<li>第一轮没找到，找第二轮，把扫描过的访问位置0，我们这轮找第一个（0，1）</li>
<li>第二轮没找到，找第三轮，我们找（0，0），也不改变标志位</li>
<li>第三轮没找到，我们找第四轮，找第一个（0，1）</li>
</ul>
<p>发现了吗，这与我们上面的优先级正好是吻合的，优先级低的相当于有多一次的<mark>免死金牌</mark>，多在内存里苟活一段时间；</p>
</li>
</ul>
<h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132105189.png" alt="image-20201102132105189"></p>
<h3 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h3><ul>
<li>驻留集：指请求分页存储管理中给进程分配的<strong>物理块的集合</strong>，在采用了虚拟存储技术的系统中，驻留集大小一般<strong>小于</strong>进程的总大小</li>
</ul>
<p>由上面的概念我们可以发现：</p>
<ul>
<li>如果我们的驻留集太小了，会导致缺页非常的频繁，而这会导致系统要花大量时间处理缺页，开销就很大，而且用于进程推进的时间就很少了；</li>
<li>如果我们的驻留集太大了，又会导致多道程序的并发度下降，资源的利用率就降低了</li>
</ul>
<p>因此，不难发现，选择一个合适的驻留集大小就是非常必要的了，因此我们有了两种选择驻留集大小的分配方式</p>
<ul>
<li><strong>固定分配</strong>：OS为每一个进程分配一组固定数目的物理块，在进程运行期间不再改变；<mark>即，驻留集大小不变</mark></li>
<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可以根据情况做适当的增加或减少；<mark>即，驻留集大小可变</mark></li>
</ul>
<p>置换策略：</p>
<ul>
<li><strong>局部置换</strong>：发生缺页的时候只能选择<mark>进程自己的物理块</mark>进行置换</li>
<li><strong>全局置换</strong>：可以将OS保留的空闲物理块分配给缺页进程，也可以将<mark>别的进程持有的物理块置换到外存，再分配给缺页进程</mark></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101153719062.png" alt="image-20201101153719062"></p>
<p>我们下面对三种分配置换组合进行讲解：</p>
<ol>
<li><p><mark>固定分配局部置换</mark>：系统为每个进程分配一定数量物理块，在整个运行期间都不改变；若进程在运行过程中发生缺页，只能从该进程在内存中的页面选出一页换出，然后再调入需要的页面；</p>
<p>缺点：很难在刚开始就确定应该为每个进程分配多少个物理块才合理（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101154502336.png" alt="image-20201101154502336"></p>
</li>
<li><p><mark>可变分配全局置换</mark>：刚开始会给每个进程分配一定数量物理块。OS会保持一个空闲物理块队列，当某进程发生缺页的时候，从空闲物理块取出一块分配给该进程；</p>
<p>若没有空闲物理块，就选择一个<mark>未锁定</mark>（系统会锁定一些页面，这些页面中的内容不能被置换出外存 比如，重要的内核数据就可以设置为<strong>“锁定”</strong>）的页面换出外存，再将该物理块分配给缺页的进程。使用这种策略的话，只要某个进程发生了缺页，都将获得新的物理块，仅当空闲物理块用完的时候，系统才选择一个<mark>未锁定</mark>的页面调出。被选择调出的页可能是系统中任何一个进程的页，因此这个<mark>被选中的进程</mark>所<strong>拥有的物理块</strong>会减少，<strong>缺页率</strong>也会增加。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101155052393.png" alt="image-20201101155052393"></p>
</li>
<li><p>==可变分配全局置换==：刚开始会给每个进程分配一定数量的物理块。当某进程发生缺页的时候，只允许从该进程自己的物理块选出一个换出外存。</p>
<p>缺点：如果进程在运行中频繁地缺页，系统会给该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可以适当减少分配给该进程的物理块    也就是说 这点体现出了<strong>可变分配</strong>的概念</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201101215351728.png" alt="image-20201101215351728"></p>
</li>
</ol>
<p>不难发现：</p>
<ul>
<li>可变分配<strong>全局</strong>置换：只要缺页就分配新物理块</li>
<li>可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来==动态地增加或减少==进程的物理块</li>
</ul>
<h3 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h3><ol>
<li><p><strong>预调页策略</strong>：根据局部性原理（空间局部性），一次调入若干个相邻地页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将他们<strong>预先调入内存</strong>，但目前预调页的成功率仅仅只有50%；</p>
<p>故这种策略主要用于进程的首次调入（运行前调入），由程序员指出应该先调入哪些部分；</p>
</li>
<li><p><strong>请求调页策略</strong>：进程在运行期间发现缺页的时候才将所缺页面调入内存（运行时调入），由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，每次调页都需要磁盘的I/O操作，因此I/O开销大。</p>
</li>
</ol>
<h3 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h3><ol>
<li><p>系统<mark>拥有</mark>足够对换区空间：页面的调入、调出都是在<strong>内存与对换区之间</strong>进行，这样可以保证页面的调入、调出的速度<strong>很快</strong>；</p>
<p>在<strong>进程运行前</strong>，需要将进程相关的数据从<strong>文件区</strong>复制到<strong>对换区</strong>。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125345951.png" alt="image-20201102125345951"></p>
</li>
<li><p>系统<mark>缺少</mark>足够对换区空间：</p>
<p>凡是不会被修改的数据都直接从<strong>文件区</strong>调入，由于这些页面不会被修改，因此换出的时候是不必被写回磁盘的，下次需要的时候再从<strong>文件区</strong>调入即可。</p>
<p>对于可能被修改的部分，换出的时候需要写回<strong>磁盘对换区</strong>，下次需要的时候再从<strong>对换区</strong>调入。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125517438.png" alt="image-20201102125517438"></p>
</li>
<li><p>UNIX方式：<strong>运行之前</strong>进程有关的数据全部放在<strong>文件区</strong>，故<strong>未使用过的页面</strong>，都可以从<strong>文件区</strong>调入。</p>
<p>若被<strong>使用过的页面</strong>需要换出，则写回<strong>对换区</strong>，下次需要的时候从<strong>对换区</strong>调入；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102125945650.png" alt="image-20201102125945650"></p>
</li>
</ol>
<h3 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>；</p>
<p>产生<strong>抖动</strong>主要原因是<strong>进程频繁访问的页面数量<mark>高于</mark>可用的物理块数</strong></p>
<p>抖动的发生与<strong>页面置换算法、页的大小和分配的内存页面数</strong>有关，与<strong>内存大小</strong>无关</p>
<p>上面我们提到了，分配的物理块太少和太多带来的影响，因此为了研究每个进程分配多少个物理块这个问题，引入新概念<strong>工作集</strong></p>
<ul>
<li>驻留集：指的是请求分页存储管理中给进程分配的内存块的集合；</li>
<li>工作集：指的是某段时间间隔内，进程<strong>实际</strong>访问页面的集合；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102131739128.png" alt="image-20201102131739128"></p>
<p>OS根据窗口尺寸来算出工作集</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201102132004226.png" alt="image-20201102132004226"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194047847.png" alt="image-20201103194047847"></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>一个文件应该有哪些属性呢？</li>
</ul>
<ol>
<li><strong>文件名</strong>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li>
<li><strong>标识符</strong>：OS用于区分各个文件的一种内部名称</li>
<li><strong>文件类型</strong>：可以用不同的角度来规定文件的类型，如源文件、目标文件以及可执行文件等</li>
<li><strong>文件的位置</strong>：文件存放的路径、在外存中的地址</li>
<li><strong>文件的大小/长度</strong>：指的是文件的大小或是长度，长度单位可以是字节、字或块</li>
<li><strong>文件的的建立时间</strong>：指最后一次的修改时间等</li>
<li><strong>文件的保护信息</strong>：对文件进行保护的访问控制信息</li>
</ol>
<h3 id="文件内部数据组织"><a href="#文件内部数据组织" class="headerlink" title="文件内部数据组织"></a>文件内部数据组织</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103171557320.png" alt="image-20201103171557320"></p>
<ul>
<li>无结构文件（如文本文件： 由一些二进制或者是字符组成，又称为“流式文件”</li>
<li>有结构文件（如数据库表)：由一组相似的记录（<strong>记录</strong>是一组<strong>相关数据项</strong>的集合（<strong>数据项</strong>是文件系统中<strong>最基本的数据单位</strong>））组成，又称为”记录式文件”</li>
</ul>
<h3 id="文件是如何组织起来的"><a href="#文件是如何组织起来的" class="headerlink" title="文件是如何组织起来的"></a>文件是如何组织起来的</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103194753217.png" alt="image-20201103194753217"></p>
<ul>
<li>用户可以创建一层一层的目录，各层目录中存放<strong>相应的文件</strong>，系统中的各个文件就通过一层层的目录合理有序的组织起来了</li>
<li>所谓目录 即我们熟悉的<strong>文件夹</strong>，是一种特殊的有结构文件</li>
</ul>
<h3 id="OS向上提供的功能"><a href="#OS向上提供的功能" class="headerlink" title="OS向上提供的功能"></a>OS向上提供的功能</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195126301.png" alt="image-20201103195126301"></p>
<h3 id="文件存放在外存的方法"><a href="#文件存放在外存的方法" class="headerlink" title="文件存放在外存的方法"></a>文件存放在外存的方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201103195845754.png" alt="image-20201103195845754"></p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>按照文件是否有结构分类，可以分为<strong>无结构文件，有结构文件</strong>两种</p>
<h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><ul>
<li><p>文件内部的数据就是一系列二进制流或是字符流组成，又称为<strong>流式文件</strong></p>
<p>如Window操作系统种的<strong>.txt文件</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222307176.png" alt="image-20201109222307176"></p>
<h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><ul>
<li><p>由一组相似的记录组成，又称为<strong>记录式文件</strong>。每条记录由若干个数据项组成</p>
<p>如：数据库表文件（一般来说每条记录有一个数据项作为关键字去识别不同记录的ID）</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222534791.png" alt="image-20201109222534791"></p>
<p>根据各条记录的长度（占用的存储空间）是否相等，又可以细分为：定长记录 和 可变长记录两种</p>
<ul>
<li><p>定长记录：</p>
<p>每条记录的长度都是相同的，各数据项都处在记录中相同的位置，具有相同的顺序和长度</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222721478.png" alt="image-20201109222721478"></p>
</li>
<li><p>可变长记录:</p>
<p>由于记录的数据项的长度是不确定的，因此各记录条的长度同样也是不确定的；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109222809031.png" alt="image-20201109222809031"></p>
</li>
</ul>
<h4 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210117983.png" alt="image-20201110210117983"></p>
<h5 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h5><ul>
<li><p>文件种的记录一个接一个地顺序排列（逻辑上)，记录可以是<strong>定长的或是可变长的</strong></p>
</li>
<li><p>各个记录在物理上可以是<strong>顺序存储</strong>或是<strong>链式存储</strong></p>
<ul>
<li><p>顺序存储：逻辑上相邻的记录，物理上也相邻（类似于顺序表）</p>
<p>对于<strong>可变长记录</strong>，无法实现随机存取，每次都只能从第一个记录开始依次往后找</p>
<p>对于<strong>定长记录</strong>，可以做到随机存取，若记录的长度为L（每个记录的长度模块是L）,那么第i个记录存放的相对位置就是<strong>i×L</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223441980.png" alt="image-20201109223441980"></p>
</li>
<li><p>链式存储：逻辑上相邻的记录，物理上不一定相邻（类似于链表）</p>
<p>无论是定长或是可变长记录，都是无法实现随机存取的，每次都只能从第一个记录开始依次往后找</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201109223453210.png" alt="image-20201109223453210"></p>
</li>
</ul>
</li>
</ul>
<h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><ul>
<li>索引表其实很像之前学习的页表，就是通过索引号去快速映射到我们需要的逻辑文件上</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110204932034.png" alt="image-20201110204932034"></p>
<h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><ul>
<li>可以把索引顺序文件这种管理方式看成前面学习的二级页表的管理方式</li>
<li>把键值那一栏看成目录，查找目录总比查找一项项内容要来得快</li>
<li>打个比方，我们都查过字典吧？我们需要查一个字，不可能直接就翻页翻到那一页，而是先翻目录，确定那个字大概在哪，然后再翻到那一部分，第二次查找，去找那个字</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110205536840.png" alt="image-20201110205536840"></p>
<p>有时候，我们只分两层还是不够，需要多级索引</p>
<p>因此衍生出来了：<strong>多级索引顺序文件</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110210047209.png" alt="image-20201110210047209"></p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112201410070.png" alt="image-20201112201410070"></p>
<h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201217211254729.png" alt="image-20201217211254729"></p>
<p>目录文件中的一条条记录就是一个个的<strong>文件控制块（FCB）</strong></p>
<p>同理：<strong>FCB</strong>的有序集合称为<mark>文件目录</mark>，一个<strong>FCB</strong>就是一个<mark>文件目录项</mark></p>
<p><strong>FCB</strong>实现了文件名和文件之间的映射，使得用户可以实现【按名存取】</p>
<p><strong>FCB</strong>中包含了：</p>
<ol>
<li><strong>文件的基本信息</strong><ol>
<li>文件名</li>
<li>物理地址</li>
<li>逻辑结构</li>
<li>物理结构</li>
<li>….</li>
</ol>
</li>
<li><strong>存取控制信息</strong><ol>
<li>是否可读/可写</li>
<li>禁止访问的用户名</li>
<li>…</li>
</ol>
</li>
<li><strong>实用信息</strong><ol>
<li>文件的建立时间</li>
<li>修改时间</li>
<li>…</li>
</ol>
</li>
</ol>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><ul>
<li><strong>单机文件目录</strong>其实非常好理解：就是在文件系统中只建立一张<strong>目录表</strong>，目录表存放多个文件，然后各文件各占一个目录项，目录项中又包含文件名、文件类型等等属性</li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>文件类型</th>
<th>文件长度</th>
</tr>
</thead>
<tbody><tr>
<td>文件名1</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>文件名2</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>文件名3</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>是简单，但仅仅只能做到<strong>按名存取</strong>，他有着三个缺点：</p>
<ul>
<li><p>查找速度慢</p>
</li>
<li><p>不允许重名</p>
</li>
<li><p>不便于实现文件共享</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110211948655.png" alt="image-20201110211948655"></p>
</li>
</ul>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110212749873.png" alt="image-20201110212749873"></p>
<h3 id="多级（树形）目录结构"><a href="#多级（树形）目录结构" class="headerlink" title="多级（树形）目录结构"></a>多级（树形）目录结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201110213226336.png" alt="image-20201110213226336"></p>
<h4 id="路径名-和-当前目录"><a href="#路径名-和-当前目录" class="headerlink" title="路径名 和 当前目录"></a>路径名 和 当前目录</h4><ul>
<li><p><mark>路径名（path name）</mark>：多级目录（树形目录）中，从根目录出发，找到一项数据文件的路径是唯一的。在该路径上，从树的根开始，直到遍历到数据文件结束，途中经历的全部目录文件名和数据文件名用 <code>/</code>进行连接，就构成了数据文件唯一的路径名了</p>
</li>
<li><p><mark>当前目录（Current Directory）</mark>：由于每个文件的路径名是唯一的，那难道每次访问它都得从根开始吗？显然不可能。</p>
<p>因此衍生出<strong>当前目录</strong>这个概念帮我们解决这个问题。</p>
</li>
</ul>
<h3 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h3><ul>
<li><p>树形目录结构可以方便对文件进行分类，层次结构清晰，也能够有效的进行文件的管理和保护</p>
<p>但是，树形结构不便于实现文件的共享，为此，提出了<strong>无环图目录结构</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195220519.png" alt="image-20201112195220519"></p>
<h3 id="索引结点（FCB的改进）"><a href="#索引结点（FCB的改进）" class="headerlink" title="索引结点（FCB的改进）"></a>索引结点（FCB的改进）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112195928484.png" alt="image-20201112195928484"></p>
<p>OS书上还说明了另外一个原因 阐明为什么要引入索引结点</p>
<p>当一个文件被多个文件共享的时候，假如我在其中一个目录访问该文件，并向该文件添加新内容，必须要增加相应的盘块；</p>
<p>而这些新增加的盘块只会出现在我位于的目录中，其他目录是不会相应增加的；</p>
<p>因此这新增的部分是不能被共享的，因此引入了索引结点；</p>
<p>索引结点中记录了文件的各种信息：包括文件在外存中的存放位置和其他的文件属性等信息；</p>
<p>这些信息之前是放在目录项中的，而如今放在索引结点中。</p>
<p>当任何用户对共享的文件进行修改的时候，其相应节点内容都会改变，由于是目录存储了指针，那这些变化对于所有用户都是可见的，因此可以实现共享； </p>
<ul>
<li><p>存放在外存中的索引结点我们称为<strong>磁盘索引结点</strong>，当索引结点<strong>放入内存</strong>后称为<strong>内存索引结点</strong></p>
</li>
<li><p>相比之下，内存索引结点中需要增加一些信息，比如：文件是否被修改，此时有几个进程正在访问该文件。</p>
</li>
</ul>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><h3 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h3><p>类似于我们的内存分配，磁盘（外存）中的存储单元也会被分成一个个的<strong>块/磁盘块/物理块</strong></p>
<p>而在很多操作系统中，磁盘块的大小通常与内存块、页面的大小相同</p>
<ul>
<li>内存与磁盘之间的数据交换：</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204211931.png" alt="image-20201112204211931"></p>
<p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式</p>
<p>操作系统为文件分配存储空间都是以<strong>块</strong>为单位</p>
<p>而用户通过逻辑地址来操作自己的文件，操作系统负责实现<strong>从逻辑地址到物理地址的映射</strong></p>
<h3 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213342204.png" alt="image-20201117213342204"></p>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201112204626251.png" alt="image-20201112204626251"></p>
<p>用户通过逻辑地址来操作自己的文件；</p>
<p><strong>（逻辑块号，块内地址） → （物理块号，块内地址）</strong>，只需要转换块号即可，块内地址保持不变</p>
<p>用户给出了要访问的逻辑块号，操作系统找到该文件对应的<strong>目录项（FCB）</strong></p>
<p><mark>物理块号 = 起始块号 + 逻辑块号</mark>（逻辑块号 需要小于 长度）</p>
<p>由于可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（随机访问）</strong></p>
<ul>
<li><p><strong>连续分配方式的优点</strong>：由于读取某个磁盘块的时候，需要移动磁头；因此访问的两个磁盘块相隔越远，那么移动磁头所需要的时间就越长；而如果文件采取连续分配方式，那么文件就是连续的，因此<strong>连续分配的文件在顺序读/写时速度最快</strong></p>
</li>
<li><p><strong>连续分配方式的缺点</strong>：如果文件A需要拓展，而其后面没有相邻的空闲块，那么就需要<strong>举家迁移</strong>到一个可以放下连续磁盘块的空闲区域</p>
<p>因此，<strong>连续分配的缺点1</strong>：文件不方便拓展</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170336498.png" alt="image-20201113170336498"></p>
</li>
</ul>
<p>假如磁盘中空闲区域并不是连续的，那么就算空闲区域加起来足够放下文件，文件也不能放入磁盘中</p>
<p>因此，<strong>连续分配的缺点2</strong>：存储空间利用率低，会产生难以利用的磁盘碎片（虽然可以用紧凑处理，但耗费很大时间代价）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113170652168.png" alt="image-20201113170652168"></p>
<h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113174225789.png" alt="image-20201113174225789"></p>
<p>链接分配优点：（其实和链表的优点大同小异）</p>
<ul>
<li>消除了磁盘的外部碎片，提高外存的利用率</li>
<li>对插入、删除和修改记录都非常容易</li>
<li>能适应文件的动态增长，无需事先知道文件的大小</li>
</ul>
<h5 id="隐式分配"><a href="#隐式分配" class="headerlink" title="隐式分配"></a>隐式分配</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113172110369.png" alt="image-20201113172110369"></p>
<p>采用链式分配（链表形式/隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低</p>
<p>同时，指向下一个盘块的指针也需要消耗少量的存储空间；</p>
<p>但是，采用隐式链接这个方式，可以方便的拓展文件，如果学过链表的同学就知道，我们可以使用尾插法，在这里就是修改结束块号</p>
<p>因此，所有的空闲磁盘块都可以被利用，不会有碎片问题，外村利用率提高</p>
<h5 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h5><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201113173221037.png" alt="image-20201113173221037"></p>
<p>显式链接类似于数据结构中的静态链表，也就是利用数组去存储下一个块号的下标；</p>
<p>这样子的话，我们只需要知道起始块号，就能找到该文件包含的所有磁盘块了。</p>
<ul>
<li>那么如何实现逻辑块号到物理块号的转变呢？</li>
</ul>
<p>假设用户需要访问逻辑块号i，OS会找到该文件对应的<mark>目录项（FCB）</mark>，FCB中存储了很多信息，其中就包含<strong>起始块号</strong></p>
<p>接着查询<strong>内存中的文件分配表FAT</strong>，往后找i到i号逻辑块对应的物理块号。（相当于查询数组下标了）</p>
<p>这里需要注意，逻辑块号转换到物理块号这一过程是不需要读磁盘操作的</p>
<p>链式分配（显示链接）的文件，支持顺序访问和随机访问，由于块号转换过程不需要访问磁盘，因此相比于隐式链接，访问速度要快很多</p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117204230180.png" alt="image-20201117204230180"></p>
<ul>
<li>索引分配允许文件离散分配在各磁盘块之中，系统会为每个文件建立一张<mark>索引表</mark></li>
<li><mark>索引表</mark>记录了文件的各个<mark>逻辑块</mark>对应的<mark>物理块</mark><ul>
<li>索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页面之间的映射关系</li>
</ul>
</li>
<li><mark>索引表</mark>存放的磁盘块称为<mark>索引块</mark></li>
<li>文件数据存放的磁盘称为<mark>数据块</mark></li>
<li>区别于<strong>显式链接</strong>，索引分配的表是一个文件一张，而<strong>显式链接</strong>中是一个磁盘对应一张（磁盘中包含多个文件，也就是说可能磁盘采取索引分配的话，可能会有多张索引表）</li>
<li>索引分配方式支持<strong>随机访问</strong>，文件拓展也容易实现（给文件分配一个空闲块，再加一个索引表项即可）</li>
<li>但是索引表需要占用一定的<strong>存储空间</strong></li>
</ul>
<h5 id="索引分配方案"><a href="#索引分配方案" class="headerlink" title="索引分配方案"></a>索引分配方案</h5><p>想一想，假如一个文件太大了，一个单独的磁盘块（索引块）装不下文件的整张索引表，那该怎么办呢？</p>
<p>我们有三种解决方案：<strong>链接方案、多层索引、混合索引</strong></p>
<ul>
<li><h4 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117210500055.png" alt="image-20201117210500055"></p>
<p>其实其基本思想与数据结构中的链表无二，就是将块离散的 存储，而后通过链接的方式串起来</p>
<p>但这个方式也与链表的弊端一样，就是我们的查找非常的麻烦，极端一点想，我们只想访问文件最后一个索引块</p>
<p>就不得不遍历整个索引块，十分麻烦且低效</p>
<p>而且中小型文件，本身就不大了，还得为他分配索引块，可见，小文件采用这种方式，索引块利用率很低；</p>
</li>
<li><h4 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117211041743.png" alt="image-20201117211041743"></p>
<p>为解决上述问题，我们类如了类似于多级页表的<strong>多层索引</strong>；</p>
<p>也就是用顶级索引表去查次级索引表，以此类推</p>
<p>其访问方式是：用逻辑块号÷表项数 得到次级表是哪一块，用逻辑块号%表项数得到偏移地址</p>
<p><strong>采用K层索引结构，且顶级索引表未调入内存的时候，访问一个数据块需要 ==k+1==次读磁盘操作</strong></p>
<p>这种方式的优点是：大大加快了对大型文件的查找速度</p>
<p>缺点是：假如文件很小，但其所在的索引技术很大，我访问这个盘块的时候依旧得按照这种方式，太麻烦了；</p>
</li>
<li><h4 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117212311990.png" alt="image-20201117212311990"></p>
<p>我们知道OS最喜欢干的事情就是把各种方法的优点结合起来，然后美名其曰叫“混合xxxx“ 呵呵</p>
<p>混合索引就是既采用了<strong>直接地址索引</strong>，又采用了<strong>多层索引</strong></p>
<p>这样的话，小文件用直接地址索引；大文件用多层索引；十分方便</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117213253389.png" alt="image-20201117213253389"></p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201117214435447.png" alt="image-20201117214435447"></p>
<h3 id="存储空间管理方法"><a href="#存储空间管理方法" class="headerlink" title="存储空间管理方法"></a>存储空间管理方法</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p>空闲表法 属于 <mark>连续分配方式</mark></p>
<p>与内存的动态方式差不太多，为每个内存分配一块<strong>连续的存储空间</strong></p>
<p>同时为外存上的所有空闲区建立一张空闲表：</p>
<p>每个空闲区对应一个空闲表项——空闲表项又包括：<strong>表项序号</strong>、<strong>该空闲区第一个盘块号</strong>、<strong>该区的空闲盘块数</strong></p>
<p>而文件分配在哪个区间的方法与内存分区（动态）分配方式类似:</p>
<p>采用：<mark>首次适应、最佳适应、最坏适应等算法</mark></p>
<p>对于文件系统来说，文件较小（盘块1-4个时），采用<strong>连续分配方式</strong>，为文件分配相邻接的几个盘块；</p>
<p>当文件较大的时候，采用<strong>离散分配方式</strong>；此外，对于<strong>多媒体文件</strong>，为减少磁头寻道时间，采用<strong>连续分配方式</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120170855920.png" alt="image-20201120170855920"></p>
<h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p>空闲链表法中，形成链表的结点有两种组成形式:<strong>盘块和盘区</strong></p>
<ul>
<li>盘区：每个盘区可包含若干个盘块</li>
<li>空闲链表法：把空闲的结点串在一起，当有文件申请N个盘块的时候，从链表头开始检索，之后的分配方式根据结点是盘块还是盘区决定</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120172927583.png" alt="image-20201120172927583"></p>
<h5 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h5><ul>
<li>OS保存链头链尾指针</li>
<li><mark>分配方式</mark>：从链头开始，边遍历边分配指针</li>
<li><mark>回收方式</mark>：将回收的盘块依次使用尾插法</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120173654373.png" alt></p>
<h5 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h5><ul>
<li><p>OS保存链头、链尾指针</p>
</li>
<li><p><mark>分配方式</mark>：与上一种方式不同，不会边遍历边分配，而是依旧不同算法规则找到一个<strong>合适</strong>的盘区分配给文件</p>
<p>若是不存在这种盘区，则将不同盘区的盘块摘取同时分配给一个文件</p>
</li>
<li><p><mark>回收方式</mark>：若回收区与某空闲盘相邻，则合并到空闲盘区中；若不相邻，则作为单独结点（盘区）使用尾插法</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201120174129662.png" alt="image-20201120174129662"></p>
<h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>位示图使用0/1其中一位表示对应盘块空闲，另一位表示已分配</p>
<p>位示图形如二维数组，那么行列肯定有其代表的意义</p>
<ul>
<li>行：字号</li>
<li>列：位号</li>
<li>map[m,n]表示盘块号</li>
</ul>
<p>若盘块号、字号、位号由0开始：</p>
<ul>
<li>字号（行号）i，位号（列号）j的二进制位对应的<strong>盘块号b = n（一个字的字长）× i + j</strong></li>
<li>b盘块号对应的<strong>字号i = b / n</strong>，</li>
</ul>
<p>若从1开始：</p>
<ul>
<li>字号（行号）i，位号（列号）j的二进制位对应的<strong>盘块号b = n（一个字的字长）× （i - 1） + j</strong></li>
<li><mark>分配方式</mark>：若文件需要K个块<ul>
<li>顺序扫描位示图，找到K个相邻或不相邻的0（这里0表示空闲，有可能在另外一种表达方式里1代表空闲）</li>
<li>根据字号、位号(行、列)计算出对应盘块号，将相应盘块分配给文件</li>
<li>将相应位设置为“1”</li>
</ul>
</li>
<li><mark>回收方式</mark>：根据回收的盘块号计算出对应字号位号，设置为0</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201121130707136.png" alt="image-20201121130707136"></p>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124220831037.png" alt="image-20201124220831037"></p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221136257.png" alt="image-20201124221136257"></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124221532748.png" alt="image-20201124221532748"></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124222804765.png" alt="image-20201124222804765"></p>
<p>通常来说，打开文件表又分为两种：系统的打开文件表和用户进程的打开文件表</p>
<p>用户进程的打开文件表包含:读写指针 用于 记录该进程对文件的读/写操作进行到的位置</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201124223414879.png" alt="image-20201124223414879"></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211157912.png" alt="image-20201125211157912"></p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211417892.png" alt="image-20201125211417892"></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211550210.png" alt="image-20201125211550210"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125211631423.png" alt="image-20201125211631423"></p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125215953551.png" alt="image-20201125215953551"></p>
<p>文件共享的意义:让多个用户共享地使用同一个文件</p>
<p>ps：多个用户共享同一个文件，表示系统中只有一份文件数据，只要某一用户修改该文件数据，其他用户也可以看到文件数据的变化</p>
<p>而假如多个用户复制同一份文件，在各自复制的文件上修改，是对其他用户的文件数据无影响的</p>
<p>文件共享分为两种方式</p>
<ul>
<li>基于索引结点的共享方式 - 硬链接</li>
<li>基于符号链的共享方式 - 软链接</li>
</ul>
<h3 id="基于索引结点的共享方式-硬链接"><a href="#基于索引结点的共享方式-硬链接" class="headerlink" title="基于索引结点的共享方式 - 硬链接"></a>基于索引结点的共享方式 - 硬链接</h3><p>将文件的物理地址以及其他的文件属性等信息 不再放在目录项之中，而是放在索引结点中；</p>
<p>这样的话，文件目录就只会包含：文件名 和 指向索引结点的指针（二级目录？</p>
<p>用户对于文件的修改，是改变了结点内容的改变，而没影响到指针的指向，因此实现了用户的文件共享功能</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125213642244.png" alt="image-20201125213642244"></p>
<h3 id="基于符号链的共享方式-软链接"><a href="#基于符号链的共享方式-软链接" class="headerlink" title="基于符号链的共享方式 - 软链接"></a>基于符号链的共享方式 - 软链接</h3><p>利用符号链实现文件共享的基本思想是：是允许一个文件或子目录有多个父目录，但其中仅有一个作为<strong>主父目录</strong></p>
<p>其他的父目录是通过<strong>符号链接方式</strong>与该文件进行链接</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201125214428159.png" alt="image-20201125214428159"></p>
<p>比如说快捷方式，就是一种软链接</p>
<p>当我们启动快捷方式的时候，一层层检索目录结构，最后运行实质上的真正程序。</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>文件保护有三种方式：口令保护、加密保护、访问控制</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174955785.png" alt="image-20201126174955785"></p>
<h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p><strong>基本思想</strong>：为文件设置一个口令（密匙？）用户请求访问该文件时需要提供该口令</p>
<p><strong>口令存储位置</strong>：一般来说存放在文件对应的<strong>FCB</strong>(文件控制块，包含了文件各种信息)或者<strong>索引结点</strong>中。用户访问文件之前输入口令，OS根据用户所输入的口令与FCB中口令进行对比；若正确，则允许该用户访问文件</p>
<p><strong>优点</strong>：保存口令的空间开销不多，验证口令的时间开销也小</p>
<p><strong>缺点</strong>：正确的口令存放在系统内部，不够安全</p>
<h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p>加密保护的实质是运用了加密算法，对原始数据进行处理，使之成为新数据；</p>
<p>只有使用对应的解密算法才能把数据还原成原始数据；</p>
<p>比如下例用的是异或运算（相同为0，不一样为1）</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126173619641.png" alt="image-20201126173619641"></p>
<p>优点：保密性强，不需要在系统中存储密码</p>
<p>缺点：编码/译码，加密/解密 需要一定时间</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在文件的FBC或索引结点中 + 一个访问控制列表（玩权限）</p>
<p>记录各用户能对该文件进行的操作</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174324167.png" alt="image-20201126174324167"></p>
<p>精简访问列表:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126174800002.png" alt="image-20201126174800002"></p>
<h2 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h2><p>文件系统层次结构由上至下分别为:</p>
<p><mark>用户接口→文件目录系统→存取控制模块→逻辑文件系统与文件系统缓冲区→物理文件系统→（辅助分配模块/设备管理模块→设备）</mark></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201126205049927.png" alt="image-20201126205049927"></p>
<p><strong>用户接口</strong>：文件系统需要向上层的用户提供一些简单易用的功能接口；这层就是用于处理用户发出的<strong>系统调用请求（Read、Write、Open、Close等系统调用）</strong></p>
<p><strong>文件目录系统</strong>：用户是通过文件路径来访问文件的，==因此这一层需要根据用户给出的文件路径找到相应的==<strong>FCB</strong>或者<strong>索引结点</strong></p>
<p>所有的目录、目录项相关的管理工作都在本层完成。如：管理活跃的文件目录表、管理打开文件表等。</p>
<p><strong>存取控制模块</strong>：为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了<strong>文件保护相关功能</strong></p>
<p><strong>逻辑文件系统与文件信息缓冲区</strong>：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址。</p>
<p><strong>物理文件系统</strong>：这一层需要把上一层提供的文件逻辑地址→实际的物理地址</p>
<p><strong>辅助分配模块</strong>：负责文件存储空间的管理，即负责分配和回收存储空间</p>
<p><strong>设备管理模块</strong>：直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等。</p>
<p>用一个例子进行记忆的话：</p>
<p>假设某用户需要删除<mark>D:/工作目录/学生信息.xlsx的<strong>最后100条记录</strong></mark></p>
<p>则：</p>
<ol>
<li>用户需要通过OS提供的接口发出上述请求 —— <strong>用户接口</strong></li>
<li>由于用户提供的是文件的存放路径，因此需要OS一层层查找目录，找到对应的目录项 —— <strong>文件目录系统</strong></li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限 —— <strong>存取控制模块（存取控制验证层）</strong></li>
<li>验证了用户的访问权限之后，需要把用户提供的”记录号”转变为对应的逻辑地址 —— <strong>逻辑文件系统与文件信息缓冲区</strong></li>
<li>知道了目录记录对应的逻辑地址之后，需要转换成实际的物理地址 —— <strong>物理文件系统</strong></li>
<li>要删除记录，需要与磁盘设备发出请求 —— <strong>设备管理程序模块</strong></li>
<li>删除记录后，那么就会有一些盘块变为空闲状态，因此要将空闲盘块进行回收 —— <strong>辅助分配模块</strong></li>
</ol>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127165917726.png" alt="image-20201127165917726"></p>
<h4 id="磁盘-磁道-扇区"><a href="#磁盘-磁道-扇区" class="headerlink" title="磁盘 磁道 扇区"></a>磁盘 磁道 扇区</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155825907.png" alt="image-20201127155825907"></p>
<ul>
<li><p><strong>磁盘</strong>：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
</li>
<li><p><strong>磁道</strong>：磁盘的盘面呗划分成一个个磁道，一个圈（环）就是一个磁道。</p>
<p>磁道类似跑道，可以这样记忆。</p>
</li>
<li><p><strong>扇区</strong>：一个磁道又被划分成一个个扇区，每个扇区就是一个<strong>磁盘块</strong>。各个扇区存放的数据量相同</p>
</li>
</ul>
<h4 id="如何读写数据"><a href="#如何读写数据" class="headerlink" title="如何读写数据"></a>如何读写数据</h4><p>内部结构：</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127155902299.png" alt="image-20201127155902299"></p>
<p>读取数据的过程是这样的：</p>
<p>首先把磁头移动到想要读/写扇区的所在的<strong>磁道</strong>上。然后转动磁盘，目标扇区从磁头下划过的时候，就完成了对扇区的读/写操作了。</p>
<p>有点类似于留声机?</p>
<h4 id="盘面、柱面"><a href="#盘面、柱面" class="headerlink" title="盘面、柱面"></a>盘面、柱面</h4><ul>
<li><p><strong>盘面</strong>：一个盘片可能有2各盘面</p>
</li>
<li><p><strong>柱面</strong>：所有盘面中相对位置相同的<strong>磁道</strong>组成柱面</p>
<p>什么意思呢？想象一下空间内有一个盘面（圆）从内到外分成很多个圆环。这些圆环各向垂直于面的方向延申，形成了一个个圆柱面</p>
<p>这就是柱面</p>
</li>
</ul>
<h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201127162936159.png" alt="image-20201127162936159"></p>
<p>上述我们提到了柱面、扇面、扇区</p>
<p>那就有对应的柱面号，扇面号和扇区号了。磁盘块的物理地址就是靠这三个属性进行定位</p>
<p>定位过程:</p>
<ol>
<li>首先磁臂内外移动 —— 定位柱面</li>
<li>激活相应的磁头 —— 定位扇面</li>
<li>旋转磁盘，扇区从磁头下划过 —— 定位扇区号</li>
</ol>
<h4 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h4><ul>
<li>按照磁头可不可以移动来分<ul>
<li>磁头可移动：活动头磁盘，磁臂可以来回伸缩带动磁头定位磁道</li>
<li>磁头不可移动：固定头磁盘，磁盘中每个磁道都有一个磁头</li>
</ul>
</li>
<li>按照盘片可不可以更换来分<ul>
<li>盘片可以更换：可换片磁盘</li>
<li>盘片不可更换：固定盘磁盘</li>
</ul>
</li>
</ul>
<h3 id="磁盘调度算法（重点"><a href="#磁盘调度算法（重点" class="headerlink" title="磁盘调度算法（重点)"></a>磁盘调度算法（重点)</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175628500.png" alt="image-20201128175628500"></p>
<h4 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读/写操作需要的时间"></a>一次磁盘读/写操作需要的时间</h4><p>要明白算法的调优方式，必须先明白读写的时间开销在哪，才能对症下药</p>
<p><strong>总花费时间  = 寻找时间/寻道时间 + 延迟时间 + 传输时间</strong></p>
<ul>
<li><mark>寻道时间</mark>：磁头定位磁道所花时间</li>
<li><mark>延迟时间</mark>：旋转转盘，磁头定位到扇区所花时间</li>
<li><mark>传输时间</mark>：从磁盘读出/向磁盘写入数据所花时间</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128170619688.png" alt="image-20201128170619688"></p>
<h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><p>这种算法就是按照进程的请求到达顺序，磁头依次移动；</p>
<ul>
<li>优点：公平，假如请求访问的磁道较为集中，算法性能不算太差</li>
<li>缺点：若有大量进程竞争使用磁盘，请求访问磁道分散，则磁头需要移动的磁道数将会很大，此算法性能就会很差。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171229955.png" alt="image-20201128171229955"></p>
<h4 id="最短寻找时间优先算法（SSTF）"><a href="#最短寻找时间优先算法（SSTF）" class="headerlink" title="最短寻找时间优先算法（SSTF）"></a>最短寻找时间优先算法（SSTF）</h4><p>这个算法只会着眼于眼前的最近磁道（贪心算法），保证单次寻道时间最短。</p>
<ul>
<li><p>优点:性能好，平均寻道时间短</p>
</li>
<li><p>缺点:可能造成【饥饿】现象</p>
<p>什么意思呢？假如处理某处磁道的访问请求时，本来应该处理下一个磁道请求了，但来了一个更近的，就不得不先处理更近的了。这种情况一旦多了，就会导致一些磁道访问请求迟迟得不到处理，造成了饥饿现象。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128171832768.png" alt="image-20201128171832768"></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 磁盘调度算法;</span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//最短寻道时间优先</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSTF</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> visit[];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nearIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sstf(<span class="keyword">int</span> queue[],<span class="keyword">int</span> start)&#123;</span><br><span class="line">		<span class="keyword">int</span> nearNum=<span class="number">9999</span>;</span><br><span class="line">		visit=<span class="keyword">new</span> <span class="keyword">int</span>[queue.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queue.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queue.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(queue[j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			visit[i]=nearNum;</span><br><span class="line">			queue[nearIndex]=-<span class="number">1</span>;</span><br><span class="line">			start=nearNum;</span><br><span class="line">			nearNum=<span class="number">9999</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> visit;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> visit[],<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">		System.out.print(<span class="string">&quot;访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;visit.length;i++)&#123;</span><br><span class="line">			System.out.print(visit[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			sum=Math.abs(visit[i]-start)+sum;</span><br><span class="line">			start=visit[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;经过的磁道总数：&quot;</span>+sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均寻道长度：&quot;</span>+sum/visit.length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求序列长度：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] queue=<span class="keyword">new</span> <span class="keyword">int</span>[a];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">			queue[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		SSTF sstf=<span class="keyword">new</span> SSTF();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入读写头起始位置：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> start=sc.nextInt();</span><br><span class="line">		sstf.print(sstf.sstf(queue, start),start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h4><p>扫描算法是用于解决SSTF算法产生的饥饿问题的。</p>
<p>SSTF算法的饥饿问题是由于磁头有可能仅在一个小区域内移动，因此，扫描算法规定了扫描的方式：</p>
<p><strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能向外移动</strong></p>
<ul>
<li><p>优点：性能较好，平均寻道时间短，不会产生饥饿现象(不会发生磁头只在一个小区域内移动的问题)</p>
</li>
<li><p>缺点：只有到达最边上的磁道时才能改变磁道移动方向（有时候外侧磁道是没有请求的，因此移动是无意义的）</p>
<p>SCAN算法对各位置磁道的<strong>相应频率</strong>不平均，有一些磁道刚被从左往右移动磁头访问了，没过多久就又会被从右往左返回的磁头再次访问，而有一些磁道就得等很久才能被再次访问。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128172906549.png" alt="image-20201128172906549"></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 磁盘调度算法<span class="number">2</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SCAN</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> visit[];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nearIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] scan(<span class="keyword">int</span> queue[],<span class="keyword">int</span> start,<span class="keyword">int</span> direction)&#123;</span><br><span class="line">		<span class="keyword">int</span> nearNum=<span class="number">9999</span>;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		visit=<span class="keyword">new</span> <span class="keyword">int</span>[queue.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queue.length;i++)&#123;</span><br><span class="line">			index=-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queue.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(queue[j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>((direction==<span class="number">1</span>)&amp;&amp;(queue[j]&gt;start)&amp;&amp;(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start)))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">						index=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>((direction==<span class="number">0</span>)&amp;&amp;(queue[j]&lt;start)&amp;&amp;(Math.abs(nearNum-start)&gt;Math.abs(queue[j]-start)))&#123;</span><br><span class="line">						nearNum=queue[j];</span><br><span class="line">						nearIndex=j;</span><br><span class="line">						index=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((direction==<span class="number">1</span>)&amp;&amp;(index==-<span class="number">1</span>))&#123;</span><br><span class="line">				direction=<span class="number">0</span>;</span><br><span class="line">				i=i-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((direction==<span class="number">0</span>)&amp;&amp;(index==-<span class="number">1</span>))&#123;</span><br><span class="line">				direction=<span class="number">1</span>;</span><br><span class="line">				i=i-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">				visit[i]=nearNum;</span><br><span class="line">				queue[nearIndex]=-<span class="number">1</span>;</span><br><span class="line">				start=nearNum;</span><br><span class="line">				nearNum=<span class="number">9999</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> visit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> visit[],<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">		System.out.print(<span class="string">&quot;访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;visit.length;i++)&#123;</span><br><span class="line">			System.out.print(visit[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			sum=Math.abs(visit[i]-start)+sum;</span><br><span class="line">			start=visit[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;经过的磁道总数：&quot;</span>+sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均寻道长度：&quot;</span>+sum/visit.length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求序列长度：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入磁盘请求访问序列：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] queue=<span class="keyword">new</span> <span class="keyword">int</span>[a];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">			queue[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		SCAN scan=<span class="keyword">new</span> SCAN();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入读写头起始位置：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> start=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;磁道增加的方向：（0向磁道号减少的方向移动,1向磁道号增加的方向移动）&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> direction=sc.nextInt();</span><br><span class="line">		scan.print(scan.scan(queue, start,direction),start);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h4><p>扫描算法虽然解决了饥饿问题，但是出现了有一些没必要的移动问题。</p>
<p>那么LOOK算法就是解决这个问题的：</p>
<p>若磁头行进路径方向上没有其他请求了，就立刻改变磁头移动方向，减少了无意义的移动。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174043814.png" alt="image-20201128174043814"></p>
<h4 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h4><p>扫描算法还有一个问题，就是各个位置磁道的响应频率不平均</p>
<p>循环扫描算法就是解决这一问题：</p>
<p>它规定了一个方向，只有沿着这个方向移动的磁头才会对磁道访问请求进行处理，而反方向时只快速移动，而不做任何处理</p>
<ul>
<li>优点：各个位置磁道的响应频率很平均</li>
<li>缺点：还是老问题，它到达最边上磁道才会反向移动，多了无意义的移动。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128174540760.png" alt="image-20201128174540760"></p>
<h4 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h4><p>回想一下之前的LOOK算法，假如磁头行进路径方向上没有其他请求了，就立刻返回。</p>
<p>那么C-LOOK算法也是如此，而且它加上了循环扫描算法的特点：它规定了一个方向，只有沿着这个方向移动的磁头才会对磁道访问请求进行处理，而反方向时只快速移动，而不做任何处理</p>
<p><strong>也就是 C-SCAN算法 + LOOK算法 = C-LOOK算法</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128175558729.png" alt="image-20201128175558729"></p>
<h3 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182703444.png" alt="image-20201128182703444"></p>
<ul>
<li>延迟时间：将目标扇区转到磁头下面所花的时间</li>
</ul>
<p>由于磁头读入扇区数据后需要一定时间处理，而在这时间段内，磁盘并不会因此而停下，而是接着旋转。</p>
<p>因此逻辑相邻的扇区恰好在物理上也相邻，那么想处理连续逻辑扇区的时候，就不得不等磁盘转到下一个扇区，因此有可能需要很长的延迟时间。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128180104677.png" alt="image-20201128180104677"></p>
<p>解决方案1:</p>
<p>可以采取交替编号策略，使得逻辑上相邻的扇区在物理上不一定要相邻，而是有一定的间隔，这样的话，有可能磁头在转到下一个扇区的时候，上一个扇区的数据已经读取完毕，准备好读下一个了。</p>
<p>解决方案2：</p>
<p>采取错位命名的策略，使得相邻盘面的相对位置相同的扇区编号不同；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128182645509.png" alt="image-20201128182645509"></p>
<h3 id="磁盘地址结构设计"><a href="#磁盘地址结构设计" class="headerlink" title="磁盘地址结构设计"></a>磁盘地址结构设计</h3><p>思考一个问题，为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而非（盘面号，柱面号，扇区号）呢？</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181834131.png" alt="image-20201128181834131"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128181851581.png" alt="image-20201128181851581"></p>
<p>根据之前的学习，我们知道磁头臂之所以要移动是为了切换柱面，也就是切换磁道号；</p>
<p>盘面号，柱面号，扇区号 ：这种记录方式，需要移动磁头臂</p>
<p>柱面号，盘面号，扇区号：这种记录方式只需要激活不同盘面的磁头，不需要移动磁头臂</p>
<p>而上一节我们也知道了，移动磁头笔的时间我们称为寻道时间，</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193846941.png" alt="image-20201128193846941"></p>
<h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><p>磁盘初始化分为三步：低级格式化 磁盘分区 逻辑格式化</p>
<ul>
<li><p><mark>低级格式化/物理格式化</mark>：将磁盘各磁道划分为扇区，扇区包含三个区域—— 头、数据区域、尾三部分</p>
<p>其中，头尾用于存储管理扇区的数据结构（如扇区校验码）</p>
</li>
<li><p><mark>分区</mark>：第一步分好了扇区，第二部则是用若干柱面将扇区填充好（磁盘分盘：C盘、D盘、E盘）</p>
</li>
<li><p><mark>逻辑格式化</mark>：创建文件系统 —— 创建文件系统的根目录、初始化存储管理空间所用的数据结构</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128192121698.png" alt="image-20201128192121698"></p>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>ROM：初始化程序可以放在ROM（只读存储器）中。ROM中的数据在厂的时候就写入了，并且之后不能再修改</p>
<p>ROM一般是出厂的时候，就集成在主板上</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201128193411250.png" alt="image-20201128193411250"></p>
<h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><p>坏块：即坏了，无法使用的扇区；属于硬件故障，OS无法修复，针对坏块能做的只有标记坏块，避免使用到。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201213161756659.png" alt></p>
<h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="IO设备概念和分类"><a href="#IO设备概念和分类" class="headerlink" title="IO设备概念和分类"></a>IO设备概念和分类</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220130343.png" alt="image-20201130220130343"></p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>什么是IO设备?</li>
</ul>
<p>IO设备就是可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备，是计算机中的硬件部件</p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p>
<p>比如:Write操作——向外部设备写出数据；Read操作:从外部设备读入数据</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130214951871.png" alt="image-20201130214951871"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按照<mark>使用特性</mark>分类：<ul>
<li>人机交互类外部设备：数据传输速度慢</li>
<li>存储设备：数据传输速度快</li>
<li>网络通信设备：数据传输速度介于两者之间</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215834935.png" alt="image-20201130215834935"></p>
<hr>
<ul>
<li>按照<mark>传输速率</mark>分类：<ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130215811961.png" alt="image-20201130215811961"></p>
<hr>
<ul>
<li>按照<mark>信息交换的单位</mark>分类<ul>
<li>块设备：传输速率较高，可寻址，对它可以随机地读/写任一块</li>
<li>字符设备：传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220114190.png" alt="image-20201130220114190"></p>
<h2 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I-O控制器"></a>I-O控制器</h2><ul>
<li>I/O设备分为两部分：机械部件和电子部件（I/O控制器、设备控制器）</li>
</ul>
<h3 id="机械部件"><a href="#机械部件" class="headerlink" title="机械部件"></a>机械部件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130220615924.png" alt="image-20201130220615924"></p>
<h3 id="电子部件（I-O控制器）"><a href="#电子部件（I-O控制器）" class="headerlink" title="电子部件（I/O控制器）"></a>电子部件（I/O控制器）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202131444915.png" alt="image-20201202131444915"></p>
<p>由于CPU无法直接控制I/O设备地机械部件，解决这种问题 经典方案：<mark>加一层</mark></p>
<p>让<strong>电子部件</strong>充当CPU和I/O设备机械部件之间的中介，用于实现CPU对设备地控制</p>
<p>这个<strong>电子部件</strong>就是<mark>I/O控制器</mark>，又称为<mark>设备控制器</mark>，CPU可以控制这个I/O控制器，由这个来控制设备的机械部件</p>
<h4 id="I-O控制器功能"><a href="#I-O控制器功能" class="headerlink" title="I/O控制器功能"></a>I/O控制器功能</h4><ul>
<li><p><strong>接受和识别CPU发出的命令</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222052883.png" alt="image-20201130222052883"></p>
</li>
<li><p><strong>向CPU报告设备的状态</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222059739.png" alt="image-20201130222059739"></p>
</li>
<li><p><strong>数据交换</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222106107.png" alt="image-20201130222106107"></p>
</li>
<li><p><strong>地址识别</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130222210248.png" alt="image-20201130222210248"></p>
</li>
<li><p><strong>数据缓冲</strong></p>
<p>I/O设备的速率较低，而CPU和内存速率很高，因此在控制器中要设置一个缓冲区。（好像就是数据寄存器？）</p>
</li>
<li><p><strong>差错控制</strong></p>
<p>对于I/O设备传过来的数据，设备管理器还需要进行差错检测。如果有错误，就需要将差错检测码置位，并向CPU报告，CPU会把这次传过来的数据作废，并重新进行一次传送，以保证数据输入的正确性。</p>
</li>
</ul>
<h4 id="I-O控制器组成"><a href="#I-O控制器组成" class="headerlink" title="I/O控制器组成"></a>I/O控制器组成</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201130223413367.png" alt="image-20201130223413367"></p>
<ol>
<li>一个I/O控制器可能会对应多个设备</li>
<li>数据寄存器、控制寄存器、状态寄存器可能会有多个（如：每个控制/状态寄存器会对应一个具体的设备），且这些寄存器都需要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为<mark>内存映像I/O</mark>；另一些计算机则采用I/O专用地址，即<mark>寄存器独立编址</mark>。</li>
</ol>
<h3 id="内存映像I-O-寄存器独立编址"><a href="#内存映像I-O-寄存器独立编址" class="headerlink" title="内存映像I/O | 寄存器独立编址"></a>内存映像I/O | 寄存器独立编址</h3><p>左图是内存映像（映射）I/O ，右图采用寄存器独立编址；</p>
<ul>
<li><p><strong>内存映射I/O</strong>：编址上不再区分内存单元和设备控制器中的寄存器地址，都用N记录；</p>
<p>当地址处于0 ~ (N - 1) 范围 被认为是内存地址，大于等于N时候，认为是某控制器的寄存器地址</p>
</li>
<li><p><strong>寄存器独立编址</strong>：这种方法采用特定的I/O指令:</p>
<ul>
<li><code>cpu-reg</code>是CPU某个寄存器 <code>dev-no</code>是指定设备，即控制器地址；<code>dev-reg</code>指定控制器中的寄存器</li>
<li>CPU寄存器中的内容复制到控制寄存器中指令:<code>io-store cpu-reg, dev-no,dev-reg</code></li>
<li>CPU寄存器中内容存入内存某单元指令:<code>Store cpu-reg,k</code></li>
</ul>
<p>这种方法的主要缺点就是：访问内存和访问设备需要两种不同指令。</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202130124223.png" alt="image-20201202130124223"></p>
<h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221506579.png" alt="image-20201202221506579"></p>
<ul>
<li>I/O控制方式分为:<strong>程序直接控制方式、中断驱动方式、DMA方式、通道控制方式</strong></li>
</ul>
<h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133214862.png" alt="image-20201202133214862"></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202133541738.png" alt="image-20201202133541738"></p>
<ul>
<li>CPU干预的频率：非常频繁，I/O操作开始之前、完成之后需要CPU接收，并且在等待I/O完成的过程中CPU需要不停地轮询检查</li>
<li>数据传送的单位：每次读/写<strong>一个字</strong></li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备 → CPU（CPU的寄存器） → 内存</li>
<li>写操作（数据输出）：内存 → CPU（CPU的寄存器）→ I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可</li>
<li>缺点：CPU和I/O只能串行工作（也就是不能并行工作）；CPU需要已知轮询检查，长期处于<strong>忙等</strong>状态,CPU利用率低。</li>
</ul>
</li>
</ul>
<h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202134152591.png" alt="image-20201202134152591"></p>
<ul>
<li>CPU干预的频率：每次I/O操作开始之前、完成之后需要CPU介入；等待I/O完成的过程中CPU可以切换到别的进程执行。</li>
<li>数据传送的单位：每次读/写<strong>一个字</strong></li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备 → CPU（CPU的寄存器） → 内存</li>
<li>写操作（数据输出）：内存 → CPU（CPU的寄存器）→ I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：与<strong>程序直接控制方式</strong>相比，在<strong>中断驱动方式</strong>中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停轮询</li>
<li>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li>
</ul>
</li>
</ul>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202135117348.png" alt="image-20201202135117348"></p>
<h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>DMA控制器包含以下部分:</p>
<ul>
<li><mark>DR（Data Register ， 数据寄存器）</mark>：暂存从设备到内存，或从内存到设备的数据。</li>
<li><mark>MAR（Memory Address Register，内存地址寄存器）</mark>：在输入时，MAR表示数据应放在内存中的什么位置；输出的时候，MAR表示要输出的数据放在内存中的上面位置</li>
<li><mark>DC（Data Counter， 数据计数器）</mark>：表示剩余要读/写的字节数</li>
<li><mark>CR（Command Register，命令/状态寄存器）</mark>：用于存放CPU发来的I/O命令，或设备的状态信息。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202215012157.png" alt="image-20201202215012157"></p>
<ul>
<li>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
<li>数据传送的单位：每次读/写<strong>一个或多个块</strong>（ps：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li>
<li>数据的流向（不需要流经CPU）<ul>
<li>读操作（数据输入）：I/O设备 → 内存</li>
<li>写操作（数据输出）：内存 → I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：数据传输以<strong>块</strong>为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的<strong>并行性</strong>得到提升。</li>
<li>缺点：CPU每发出一条指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</li>
</ul>
</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221208007.png" alt="image-20201202221208007"></p>
<ul>
<li>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU的干预</li>
<li>数据传送的单位：每次读/写<strong>一组数据块</strong></li>
<li>数据的流向（在通道的控制下进行）<ul>
<li>读操作（数据输入）：I/O设备 → 内存</li>
<li>写操作（数据输出）：内存 → I/O设备</li>
</ul>
</li>
<li>主要优缺点<ul>
<li>优点：CPU、通道、I/O设备可并行工作，资源利用率很高。</li>
<li>缺点：实现复杂，需要专门的通道硬件支持</li>
</ul>
</li>
</ul>
<h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I/O软件层次结构"></a>I/O软件层次结构</h2><p>大体从上至下分为:用户层软件，设备独立性软件，设备驱动程序，中断处理程序和硬件</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202221809697.png" alt="image-20201202221809697"></p>
<h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202222126442.png" alt="image-20201202222126442"></p>
<h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><p>设备独立性软件（又称为设备无关性软件）。与设备硬件特性无关的功能几乎都在这一层实现</p>
<p>它所主要实现的功能如下：</p>
<ol>
<li><p>向上层<strong>提供统一的调用接口</strong>（如read/write系统调用）</p>
</li>
<li><p><strong>设备的保护</strong>：原理类似于文件保护。设备被看作是一种特殊的文件，不同用户对于各文件的访问权限也是不同的。同理，对设备的访问权限也不一样。</p>
</li>
<li><p><strong>差错处理</strong>：设备独立性软件需要对一些设备的错误进行处理</p>
</li>
<li><p><strong>设备的分配与回收</strong>：很多设备是临界资源，不能同时分配给多个进程，需要回收。</p>
</li>
<li><p><strong>数据缓冲区管理</strong>：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li><p><strong>建立<mark>逻辑设备名</mark>到<mark>物理设备名</mark>的映射关系</strong>；根据设备类型选择调用相应的驱动程序。（打印店打印的时候，一台电脑可以对应多个打印机（打印机1，打印机2…，这些就是<strong>逻辑设备名</strong>）</p>
<p>设备独立性软件需要通过<strong>逻辑设备表（LUT,Logical Unit Table）</strong>来确定逻辑设备对应的物理设备；并找到该设备对应的<strong>设备驱动程序</strong></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201202223154354.png" alt="image-20201202223154354"></p>
</li>
</ol>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>由于不同的I/O设备有不同的硬件特性，因此需要根据设备不同硬件特性提供相应的驱动程序。</p>
<p>这些驱动程序将上层传达下来的命令<mark>翻译</mark>成下层特定设备能听得懂的操作。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161331778.png" alt="image-20201203161331778"></p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203161549430.png" alt="image-20201203161549430"></p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>执行I/O操作，由机械部件、电子部件组成。</li>
</ul>
<h2 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I/O核心子系统"></a>I/O核心子系统</h2><p>I/O核心子系统属于操作系统的内核部分；</p>
<h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h3><ul>
<li><p>I/O调度:用某种算法确定一个好的顺序来处理各个I/O请求。</p>
</li>
<li><p>如:磁盘调度(先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法)。当多个磁盘I/O请求到来时,用某种调度算法确定满足I/O请求的顺序。<br>冋理,打卬机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序。</p>
</li>
</ul>
<h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p>操作系统需要实现文件保护功能,不同的用户对各个文件有不同的访问权限(如:只读、读和写等在UNIX系统中,设备被看做是一种特殊的文件,每个设备也会有对应的FCB。当用户请求访问某个设备时,系统根据FCB中记录的信息来判断该用户是否有相应的访问权限,以此实现“设备保护”的功能。(参考“文件保护”小节)</p>
<h3 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h3><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171706471.png" alt="image-20201203171706471"></p>
<p>要知道什么是假脱机技术，就得先了解脱机技术：</p>
<ul>
<li>脱机IO技术：事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围控制机的控制下，把纸带上的数据输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存；</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203164159076.png" alt="image-20201203164159076"></p>
<p>那么假脱机技术又是什么呢?</p>
<p>在脱机技术中，用户程序和数据是预先存在了磁带中，进而通过控制机来输入和输出数据，</p>
<p>因此假脱机技术就是仿造这种方式：</p>
<ul>
<li><p>用 输入进程 <strong>模拟</strong> 脱机输入时的外围控制机</p>
</li>
<li><p>用 输出进程 <strong>模拟</strong> 脱机输出时的外围控制机</p>
</li>
<li><p>用 输入井 <strong>模拟</strong> 脱机输入时的磁带，用于收容I/O设备输入的数据</p>
</li>
<li><p>用 输出井 <strong>模拟</strong> 脱机输出时的磁带，用于收容用户进程输出的数据</p>
</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165450142.png" alt="image-20201203165450142"></p>
<p>在内存中不仅仅有输入和输出进程，还有输入缓冲区和输出缓冲区</p>
<p>缓冲区相当于一个中转站，给数据传输的进行喘一口气</p>
<ul>
<li>输入缓冲区：暂存从输入设备输入的数据，之后转存到输入井中</li>
<li>输出缓冲区：暂存从输出井送进来的数据，之后再传送到输出设备上</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203165501947.png" alt="image-20201203165501947"></p>
<h4 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h4><ul>
<li>独占式设备一一只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求</li>
<li>共享设备一一允许多个进程“同时”使用的设备(宏观上同时使用,微观上可能是交替使用)。可以同时满足多个进程的使用请求。</li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203171351378.png" alt="image-20201203171351378"></p>
<p>通过这种方式，虽然系统中只有一台打印机，但每个进程提出打印请求的时候，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使得每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p>SPOOLing技术把一台物理设备<strong>虚拟</strong>成了逻辑上的多台设备，可将独占式设备改造成了共享设备。</p>
<h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180248315.png" alt="image-20201203180248315"></p>
<h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><p>考虑因素分三大因素:设备的固有属性、设备分配算法、设备分配中的安全性</p>
<h4 id="设备固有属性因素"><a href="#设备固有属性因素" class="headerlink" title="设备固有属性因素"></a>设备固有属性因素</h4><p>设备的固有属性可分为三种：<strong>独占设备、共享设备、虚拟设备</strong></p>
<p>独占式设备：一个时间段只能分配给一个进程<br>共享式设备：可同时分配给多个进程使用，各个进程往往是宏观上同时共享使用设备，微观上交替使用。<br>虚拟设备：采用假脱机技术将独占式设备改造成虚拟共享设备，可同时分配给多个进程使用。（如采用SPOOLing技术实现的共享打印机）</p>
<h4 id="设备分配算法因素"><a href="#设备分配算法因素" class="headerlink" title="设备分配算法因素"></a>设备分配算法因素</h4><p>先来先服务算法、短作业优先算法，优先级高优先算法等。</p>
<h4 id="设备分配安全性因素"><a href="#设备分配安全性因素" class="headerlink" title="设备分配安全性因素"></a>设备分配安全性因素</h4><p>从进程运行的安全性上考虑，设备分配有两种方式：</p>
<ul>
<li><mark>安全分配方式</mark>：为进程分配一个设备后就将进程阻塞，本次IO完成后才将这个进程唤醒。(打印机例子)<ul>
<li>优点：这种方式是安全的破坏了“请求和保持条件”，不会发生死锁。</li>
<li>缺点：但是对于一个进程来说，CPU和IO设备只能串行工作。系统资源利用率低，进程执行效率低。</li>
</ul>
</li>
<li><mark>不安全分配方式</mark>：进程发出IO请求后，系统为其分配IO设备，进程可以继续执行，之后还可以发出新的IO请求。只有某个IO请求得不到满足的情况下才将进程阻塞。<ul>
<li>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</li>
<li>缺点：有可能发生死锁（就需要：死锁避免、死锁的检测和解除）</li>
</ul>
</li>
</ul>
<h3 id="设备分配方式"><a href="#设备分配方式" class="headerlink" title="设备分配方式"></a>设备分配方式</h3><p>分为：静态分配和动态分配 两种分配方式</p>
<ul>
<li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了<mark>请求和保持</mark>条件，不会发生死锁）</li>
<li>动态分配：进程运行过程中动态申请设备资源</li>
</ul>
<h3 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h3><p>设备与控制器通道之间的关系。<br>一个通道可以有多个控制器，一个控制器又能控制多台设备。所以他们三者之间是一对多的关系，也就可以用树状结构来描述。<img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174336130.png" alt="image-20201203174336130"></p>
<h4 id="设备控制表DCT"><a href="#设备控制表DCT" class="headerlink" title="设备控制表DCT"></a>设备控制表DCT</h4><ul>
<li><strong>设备控制表 - <mark>D</mark>evice <mark>C</mark>ontrol <mark>T</mark>able - DCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174727508.png" alt="image-20201203174727508"></p>
<h4 id="控制器控制表COCT"><a href="#控制器控制表COCT" class="headerlink" title="控制器控制表COCT"></a>控制器控制表COCT</h4><ul>
<li><strong>控制器控制表 - <mark>Co</mark>ntroller <mark>C</mark>ontrol <mark>T</mark>able - COCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203174925206.png" alt="image-20201203174925206"></p>
<h4 id="通道控制表CHCT"><a href="#通道控制表CHCT" class="headerlink" title="通道控制表CHCT"></a>通道控制表CHCT</h4><ul>
<li><strong>通道控制表 - <mark>Ch</mark>annel <mark>C</mark>ontrol <mark>T</mark>able - CHCT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175015208.png" alt="image-20201203175015208"></p>
<h4 id="系统设备表SDT"><a href="#系统设备表SDT" class="headerlink" title="系统设备表SDT"></a>系统设备表SDT</h4><ul>
<li><strong>系统设备表 - <mark>S</mark>ystem <mark>D</mark>evice <mark>T</mark>able - SDT</strong></li>
</ul>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175109971.png" alt="image-20201203175109971"></p>
<h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><ul>
<li>自下到上的查表，分配</li>
</ul>
<ol>
<li>按照进程请求的物理设备名查找<strong>SDT（系统设备表）</strong></li>
<li>根据系统设备表找到<strong>DCT（设备控制表）</strong>，若设备忙碌则将进程挂到设备等待队列中，不忙碌则将设备分配给进程。</li>
<li>根据设备控制表找到<strong>COCT（控制器控制表）</strong>，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据<strong>COCT（控制器控制表）</strong>找到<strong>CHCT（通道控制表）</strong>，若通道忙碌则将PCB挂到通达等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<p><strong>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可以启动IO设备进行数据传送</strong></p>
<p>缺点：</p>
<ol>
<li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法执行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ol>
<h3 id="设备分配的改进方式"><a href="#设备分配的改进方式" class="headerlink" title="设备分配的改进方式"></a>设备分配的改进方式</h3><p>改进思想：通过建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名就可以找到物理设备名。</p>
<p>①根据进程请求的逻辑设备名查找SDT（<strong>注：用户编程时提供的逻辑设备名其实就是“设备类型”</strong>）<br>②查找SDT，找到用户进程<strong>指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</strong><br>③根据DCT找到COCT，若控制器忙碌，则将PCB挂到控制器等待队列中；不忙碌，则将控制器分配给进程。<br>④根据COCT找到CHCT，若通道忙碌，则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</p>
<p>上述步骤提到了一个<mark>逻辑设备表LUT</mark>。那么什么是LUT呢？</p>
<p>还记得改进思想吗？建立映射，这个LUT就是用来<strong>建立映射</strong>（将逻辑设备名映射为物理设备名）的。</p>
<p>用户编程时使用逻辑设备名申请设备，操作系统负责实现从逻辑设备名到物理设备名的映射。<strong>LUT（逻辑设备表）</strong><br><code>如果整个系统只有一张LUT：各个用户所用的逻辑设备名不能重复，如果每个用户一张LUT：各个用户的逻辑设备名可以重复。</code></p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203175918544.png" alt="image-20201203175918544"></p>
<p>上面步骤是第一次通过逻辑设备名申请使用一个设备，假如之后进程再以相同的逻辑设备名来请求使用设备的话:</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203180225450.png" alt="image-20201203180225450"></p>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165851742.png" alt="image-20201204165851742"></p>
<h3 id="缓冲区概述"><a href="#缓冲区概述" class="headerlink" title="缓冲区概述"></a>缓冲区概述</h3><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<p>使用<mark>硬件</mark>作为缓冲区的成本较高，容量小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的<strong>联想寄存器</strong>，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况，更多是利用<mark>内存</mark>作为缓冲区，<strong>设备独立性软件</strong>的缓冲区管理就是要组织管理好这些缓冲区。</p>
<h3 id="缓冲区作用"><a href="#缓冲区作用" class="headerlink" title="缓冲区作用"></a>缓冲区作用</h3><p>缓冲区有什么作用呢？</p>
<ol>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201203215628038.png" alt="image-20201203215628038"></p>
<h3 id="缓冲区管理策略"><a href="#缓冲区管理策略" class="headerlink" title="缓冲区管理策略"></a>缓冲区管理策略</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>背景/什么时候需要用到缓冲：假设某用户进程请求某种块设备读入若干块的数据</p>
<p>此时若采用单缓冲的策略：操作系统会在<strong>主存</strong>中为其分配一个缓冲区</p>
<p>其中要注意:</p>
<ol>
<li>当缓冲区数据<strong>非空（满）</strong>时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</li>
<li>当缓冲区<strong>为空</strong>时，可以往缓冲区冲入输入，但必须把缓冲区充满之后，才能从缓冲区当数据传出</li>
</ol>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204160730604.png" alt="image-20201204160730604"></p>
<p>假设输入数据的时间为<strong>T</strong>，CPU处理数据的时间为<strong>C</strong>，缓冲区传送数据到工作区的时间为<strong>M</strong></p>
<p>若<mark>T&gt;C（输入数据时间比CPU处理时间开销长）</mark>：由<strong>限制2</strong>我们可以知道CPU处理完数据后并不能将下一块数据从缓冲区传送到工作区，必须等缓冲区中冲满数据才可以进行下一组数据的处理</p>
<p>若<mark>T&lt;C（CPU处理时间比输入数据时间开销长）</mark>：由<strong>限制1</strong>我们可以知道当缓冲区的数据被冲满后，并不能继续冲入下一块数据，必须等待CPU处理结束后，才能将数据从缓冲区传送到工作区。</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204155830464.png" alt="image-20201204155830464"></p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>背景/什么时候需要用到缓冲：假设某用户进程请求某种块设备读入若干块的数据</p>
<p>此时若采用单缓冲的策略：操作系统会在<strong>主存</strong>中为其分配两个缓冲区</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204162120223.png" alt="image-20201204162120223"></p>
<p>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</p>
<p>假设输入数据的时间为<strong>T</strong>，CPU处理数据的时间为<strong>C</strong>，缓冲区传送数据到工作区的时间为<strong>M</strong></p>
<ul>
<li><p>若<mark>T &gt; C + M（数据输入时间大于CPU处理时间加上缓冲区传送数据时间）</mark></p>
<p>首先满缓冲区开始传送数据到工作区，交由CPU处理；传送数据开始的时候，设备向空缓冲区冲入数据；新的满缓冲区向工作区传送数据，交由CPU处理；同理，另一个空缓冲区也同步冲入数据；由此反复…</p>
</li>
</ul>
<p>处理一块数据的平均用时为 T</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163502759.png" alt="image-20201204163502759"></p>
<ul>
<li><p>若<mark>T &lt; C + M（数据输入时间小于CPU处理时间加上缓冲区传送数据时间）</mark></p>
<p>设备向空缓冲区输入数据和满缓冲区向工作区传数据同步进行，当然了，后者进行完后CPU会接力完成数据处理；</p>
<p>我们知道，由于<strong>限制1</strong>的约束，有可能做不到2T = 2M + C，也就是说，一个缓冲区是满的，另一个还有点参与数据没取完，就必须等待另一个M的进行。</p>
</li>
</ul>
<p>处理一块数据的平均用时为 C + M</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204163508555.png" alt="image-20201204163508555"></p>
<p>综合来说：采用双缓冲策略，处理一个数据块的平均耗时为Max (T, C+M)</p>
<h4 id="使用单-双缓冲在通信时的区别"><a href="#使用单-双缓冲在通信时的区别" class="headerlink" title="使用单/双缓冲在通信时的区别"></a>使用单/双缓冲在通信时的区别</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204164935982.png" alt="image-20201204164935982"></p>
<h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165050655.png" alt="image-20201204165050655"></p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：</p>
<ul>
<li>用于收容输入数据的<mark>工作缓冲区（hin）</mark></li>
<li>用于提取输入数据的<mark>工作缓冲区（sin）</mark></li>
<li>用于收容输出数据的<mark>工作缓冲区（hout）</mark></li>
<li>用于提取输出数据的<mark>工作缓冲区（sout）</mark></li>
</ul>
<p>操作系统根据不同的进程请求，将不同队列中的缓冲区提取一块出来 作为上述四种工作缓冲区的一种；</p>
<p>然后将其交付给程用于执行，缓冲区的状态将会进行一定的改变，之后会挂回到对应状态的队列队尾；</p>
<p><img src="https://gitee.com/UesugiEr11/pictures/raw/master/img/image-20201204165820255.png" alt="image-20201204165820255"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://uesugier11.github.io/2020/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckppikufa004kp0wi58msgmo3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/UesugiEr11.github.io/">&amp;laquo; 上一页</a><a class="page-number" href="/UesugiEr11.github.io/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/">JVM概述</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">内存结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">GC垃圾回收</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/">类加载与字节码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JVM%E6%A6%82%E8%BF%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/">OS基础</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">处理机调度与死锁</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/">内存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/OS%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/">Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/">IOC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/">DI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/">Bean</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/Spring/IOC/DI/Bean/AOP/">AOP</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/">与Servlet</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/">HelloSpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/">RequestMapping注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/">请求参数的绑定</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">常用注解</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/">响应数据与结果视图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">SpringMVC异常处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E4%B8%8EServlet/HelloSpringMVC/RequestMapping%E6%B3%A8%E8%A7%A3/%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/">关于Spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/">关于SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/">HelloSpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/">SpringBoot特点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/">容器组件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%85%B3%E4%BA%8ESpring/%E5%85%B3%E4%BA%8ESpringBoot/HelloSpringBoot/SpringBoot%E7%89%B9%E7%82%B9/%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">自动配置</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/">前言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/">搭建整合环境</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/">Spring搭建</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/">Spring整合SpringMVC</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/">Spring整合Mybatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E5%89%8D%E8%A8%80/%E6%90%AD%E5%BB%BA%E6%95%B4%E5%90%88%E7%8E%AF%E5%A2%83/Spring%E6%90%AD%E5%BB%BA/Spring%E6%95%B4%E5%90%88SpringMVC/Spring%E6%95%B4%E5%90%88Mybatis/%E4%B8%80%E4%BA%9B%E5%9D%91/">一些坑</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/">接口式编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/">CRUD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/">联表查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/">分步查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/">延迟查询</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/">参数处理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/">缓存</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/">Mybatis运行原理(源码)</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%BC%8F%E7%BC%96%E7%A8%8B/CRUD/%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2/%E5%BB%B6%E8%BF%9F%E6%9F%A5%E8%AF%A2/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/%E7%BC%93%E5%AD%98/Mybatis%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81/%E6%8F%92%E4%BB%B6/">插件</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/">核心理论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/">并发机制底层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/">Lock体系</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82/%E9%94%81%E6%9C%BA%E5%88%B6/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Lock%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">并发容器</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">数据链路层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BD%91%E7%BB%9C%E5%B1%82/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/">递归 分治</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/">二分</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/">贪心</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86/%E8%B4%AA%E5%BF%83/DP/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/">异常</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/">注解反射</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/">代理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/UesugiEr11.github.io/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%BC%82%E5%B8%B8/%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%BB%A3%E7%90%86/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Http/" rel="tag">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Listener/" rel="tag">Listener</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Mavan/" rel="tag">Mavan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/UesugiEr11.github.io/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/UesugiEr11.github.io/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/UesugiEr11.github.io/tags/Http/" style="font-size: 10px;">Http</a> <a href="/UesugiEr11.github.io/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/UesugiEr11.github.io/tags/Java/" style="font-size: 10px;">Java</a> <a href="/UesugiEr11.github.io/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/UesugiEr11.github.io/tags/Mavan/" style="font-size: 10px;">Mavan</a> <a href="/UesugiEr11.github.io/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/UesugiEr11.github.io/tags/Session/" style="font-size: 10px;">Session</a> <a href="/UesugiEr11.github.io/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/UesugiEr11.github.io/tags/Web/" style="font-size: 10px;">Web</a> <a href="/UesugiEr11.github.io/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/UesugiEr11.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/UesugiEr11.github.io/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/UesugiEr11.github.io/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/UesugiEr11.github.io/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/UesugiEr11.github.io/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/UesugiEr11.github.io/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/06/02/Mysql%E8%BF%9B%E9%98%B6/">Mysql进阶</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/04/22/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/29/JVM/">JVM</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/21/SpringBoot/">SpringBoot</a>
          </li>
        
          <li>
            <a href="/UesugiEr11.github.io/2021/03/18/SSM%E6%95%B4%E5%90%88/">SSM整合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Erii<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/UesugiEr11.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/UesugiEr11.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/UesugiEr11.github.io/fancybox/jquery.fancybox.css">

  
<script src="/UesugiEr11.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/UesugiEr11.github.io/js/script.js"></script>




  </div>
</body>
</html>